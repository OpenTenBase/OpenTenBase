\set ECHO all
SET client_min_messages = warning;
SET datestyle TO ISO;
SET client_encoding = utf8;
DROP DATABASE IF EXISTS regression_sort;
CREATE DATABASE regression_sort WITH TEMPLATE = template0_ora ENCODING='SQL_ASCII' LC_COLLATE='C' LC_CTYPE='C';
\c regression_ora
-- test opentenbase_ora namespace
select oid, nspname, nspowner 
    from pg_namespace 
    where nspname = 'opentenbase_ora';
 OID  |  NSPNAME  | NSPOWNER 
------+-----------+----------
 8012 | opentenbase_ora |       10
(1 row)

set search_path = foo, public, not_there_initially;
select current_schemas(true);
        CURRENT_SCHEMAS        
-------------------------------
 {pg_catalog,public,opentenbase_ora}
(1 row)

create schema not_there_initially;
select current_schemas(true);
                  CURRENT_SCHEMAS                  
---------------------------------------------------
 {pg_catalog,public,NOT_THERE_INITIALLY,opentenbase_ora}
(1 row)

drop schema not_there_initially;
select current_schemas(true);
        CURRENT_SCHEMAS        
-------------------------------
 {pg_catalog,public,opentenbase_ora}
(1 row)

reset search_path;
select current_schemas(true);
        CURRENT_SCHEMAS        
-------------------------------
 {pg_catalog,public,opentenbase_ora}
(1 row)

reset search_path;
select current_schemas(true);
        CURRENT_SCHEMAS        
-------------------------------
 {pg_catalog,public,opentenbase_ora}
(1 row)

-- test Alias
select * from (VALUES(1,2,3)) as v0;
 COLUMN1 | COLUMN2 | COLUMN3 
---------+---------+---------
       1 |       2 |       3
(1 row)

select * from (VALUES(1,2,3));
 COLUMN1 | COLUMN2 | COLUMN3 
---------+---------+---------
       1 |       2 |       3
(1 row)

drop table if exists test1;
NOTICE:  table "TEST1" does not exist, skipping
create table test1(tc1 int2, tc2 int4, tc3 int8, tc4 float4, tc5 float8);
drop table if exists test2;
NOTICE:  table "TEST2" does not exist, skipping
create table test2(tc1 int2, tc2 int4, tc3 int8, tc4 float4, tc5 float8);
insert into test1 values(1,2,3,4,5);
insert into test1 values(6,7,8,9,0);
insert into test2 values(1,2,3,4,5);
insert into test2 values(6,7,8,9,0);
select * 
    from (select * from test1 order by tc1, tc2, tc3, tc4, tc5),
         (select * from test2 order by tc5, tc4, tc3, tc2, tc1);
 TC1 | TC2 | TC3 | TC4 | TC5 | TC1 | TC2 | TC3 | TC4 | TC5 
-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |   0
   1 |   2 |   3 |   4 |   5 |   1 |   2 |   3 |   4 |   5
   6 |   7 |   8 |   9 |   0 |   6 |   7 |   8 |   9 |   0
   6 |   7 |   8 |   9 |   0 |   1 |   2 |   3 |   4 |   5
(4 rows)

drop table test1;
drop table test2;
-- test number/binary_float/binary_double
drop table if exists test1;
NOTICE:  table "TEST1" does not exist, skipping
create table test1(tc1 binary_float, tc2 binary_double, tc3 number, tc4 float4, tc5 float8, tc6 numeric);
create index idx_test1_tc1 on test1(tc1);
create index idx_test1_tc2 on test1(tc2);
create index idx_test1_tc3 on test1(tc3);
create index idx_test1_tc4 on test1(tc4);
create index idx_test1_tc5 on test1(tc5);
create index idx_test1_tc6 on test1(tc6);
\d+ test1
                                       Table "public.TEST1"
 Column |       Type       | Collation | Nullable | Default | Storage | Stats target | Description 
--------+------------------+-----------+----------+---------+---------+--------------+-------------
 TC1    | NUMERIC(-1009,0) |           |          |         | main    |              | 
 TC2    | NUMERIC(-1017,0) |           |          |         | main    |              | 
 TC3    | NUMERIC          |           |          |         | main    |              | 
 TC4    | REAL             |           |          |         | plain   |              | 
 TC5    | DOUBLE PRECISION |           |          |         | plain   |              | 
 TC6    | NUMERIC          |           |          |         | main    |              | 
Indexes:
    "IDX_TEST1_TC1" btree (TC1) WITH (checksum='on')
    "IDX_TEST1_TC2" btree (TC2) WITH (checksum='on')
    "IDX_TEST1_TC3" btree (TC3) WITH (checksum='on')
    "IDX_TEST1_TC4" btree (TC4) WITH (checksum='on')
    "IDX_TEST1_TC5" btree (TC5) WITH (checksum='on')
    "IDX_TEST1_TC6" btree (TC6) WITH (checksum='on')
Distribute By: HASH(TC1)
Location Nodes: ALL DATANODES

insert into test1 values(10.0123456789, 11.0123456789, 12.0123456789, 13.0123456789, 14.0123456789, 15.0123456789);
insert into test1 values(20.0123456789, 22.0123456789, 22.0123456789, 23.0123456789, 24.0123456789, 25.0123456789);
insert into test1 values(30.0123456789, 33.0123456789, 32.0123456789, 33.0123456789, 34.0123456789, 35.0123456789);
insert into test1 values(40.0123456789, 44.0123456789, 42.0123456789, 43.0123456789, 44.0123456789, 45.0123456789);
insert into test1 values(50.0123456789, 55.0123456789, 52.0123456789, 53.0123456789, 54.0123456789, 55.0123456789);
insert into test1 values(60.0123456789, 66.0123456789, 62.0123456789, 63.0123456789, 64.0123456789, 65.0123456789);
insert into test1 values(70.0123456789, 77.0123456789, 72.0123456789, 73.0123456789, 74.0123456789, 75.0123456789);
insert into test1 values(80.0123456789, 88.0123456789, 82.0123456789, 83.0123456789, 84.0123456789, 85.0123456789);
insert into test1 values(90.0123456789, 99.0123456789, 92.0123456789, 93.0123456789, 94.0123456789, 95.0123456789);
-- explain select * from test1 where tc1 > 20.0123456789 and tc1 < 70.0123456789 order by tc1;
-- explain select * from test1 where tc2 > 20.0123456789 and tc2 < 70.0123456789 order by tc2;
-- explain select * from test1 where tc3 > 20.0123456789 and tc3 < 70.0123456789 order by tc3;
-- explain select * from test1 where tc4 > 20.0123456789 and tc4 < 70.0123456789 order by tc4;
-- explain select * from test1 where tc5 > 20.0123456789 and tc5 < 70.0123456789 order by tc5;
-- explain select * from test1 where tc6 > 20.0123456789 and tc6 < 70.0123456789 order by tc6;
select * from test1 where tc1 > 20.0123456789 and tc1 < 70.0123456789 order by tc1;
    TC1     |      TC2      |      TC3      |    TC4    |      TC5      |      TC6      
------------+---------------+---------------+-----------+---------------+---------------
 20.0123457 | 22.0123456789 | 22.0123456789 | 23.012346 | 24.0123456789 | 25.0123456789
 30.0123457 | 33.0123456789 | 32.0123456789 | 33.012344 | 34.0123456789 | 35.0123456789
 40.0123457 | 44.0123456789 | 42.0123456789 | 43.012344 | 44.0123456789 | 45.0123456789
 50.0123457 | 55.0123456789 | 52.0123456789 | 53.012344 | 54.0123456789 | 55.0123456789
 60.0123457 | 66.0123456789 | 62.0123456789 | 63.012344 | 64.0123456789 | 65.0123456789
(5 rows)

select * from test1 where tc2 > 20.0123456789 and tc2 < 70.0123456789 order by tc2;
    TC1     |      TC2      |      TC3      |    TC4    |      TC5      |      TC6      
------------+---------------+---------------+-----------+---------------+---------------
 20.0123457 | 22.0123456789 | 22.0123456789 | 23.012346 | 24.0123456789 | 25.0123456789
 30.0123457 | 33.0123456789 | 32.0123456789 | 33.012344 | 34.0123456789 | 35.0123456789
 40.0123457 | 44.0123456789 | 42.0123456789 | 43.012344 | 44.0123456789 | 45.0123456789
 50.0123457 | 55.0123456789 | 52.0123456789 | 53.012344 | 54.0123456789 | 55.0123456789
 60.0123457 | 66.0123456789 | 62.0123456789 | 63.012344 | 64.0123456789 | 65.0123456789
(5 rows)

select * from test1 where tc3 > 20.0123456789 and tc3 < 70.0123456789 order by tc3;
    TC1     |      TC2      |      TC3      |    TC4    |      TC5      |      TC6      
------------+---------------+---------------+-----------+---------------+---------------
 20.0123457 | 22.0123456789 | 22.0123456789 | 23.012346 | 24.0123456789 | 25.0123456789
 30.0123457 | 33.0123456789 | 32.0123456789 | 33.012344 | 34.0123456789 | 35.0123456789
 40.0123457 | 44.0123456789 | 42.0123456789 | 43.012344 | 44.0123456789 | 45.0123456789
 50.0123457 | 55.0123456789 | 52.0123456789 | 53.012344 | 54.0123456789 | 55.0123456789
 60.0123457 | 66.0123456789 | 62.0123456789 | 63.012344 | 64.0123456789 | 65.0123456789
(5 rows)

select * from test1 where tc4 > 20.0123456789 and tc4 < 70.0123456789 order by tc4;
    TC1     |      TC2      |      TC3      |    TC4    |      TC5      |      TC6      
------------+---------------+---------------+-----------+---------------+---------------
 20.0123457 | 22.0123456789 | 22.0123456789 | 23.012346 | 24.0123456789 | 25.0123456789
 30.0123457 | 33.0123456789 | 32.0123456789 | 33.012344 | 34.0123456789 | 35.0123456789
 40.0123457 | 44.0123456789 | 42.0123456789 | 43.012344 | 44.0123456789 | 45.0123456789
 50.0123457 | 55.0123456789 | 52.0123456789 | 53.012344 | 54.0123456789 | 55.0123456789
 60.0123457 | 66.0123456789 | 62.0123456789 | 63.012344 | 64.0123456789 | 65.0123456789
(5 rows)

select * from test1 where tc5 > 20.0123456789 and tc5 < 70.0123456789 order by tc5;
    TC1     |      TC2      |      TC3      |    TC4    |      TC5      |      TC6      
------------+---------------+---------------+-----------+---------------+---------------
 20.0123457 | 22.0123456789 | 22.0123456789 | 23.012346 | 24.0123456789 | 25.0123456789
 30.0123457 | 33.0123456789 | 32.0123456789 | 33.012344 | 34.0123456789 | 35.0123456789
 40.0123457 | 44.0123456789 | 42.0123456789 | 43.012344 | 44.0123456789 | 45.0123456789
 50.0123457 | 55.0123456789 | 52.0123456789 | 53.012344 | 54.0123456789 | 55.0123456789
 60.0123457 | 66.0123456789 | 62.0123456789 | 63.012344 | 64.0123456789 | 65.0123456789
(5 rows)

select * from test1 where tc6 > 20.0123456789 and tc6 < 70.0123456789 order by tc6;
    TC1     |      TC2      |      TC3      |    TC4    |      TC5      |      TC6      
------------+---------------+---------------+-----------+---------------+---------------
 20.0123457 | 22.0123456789 | 22.0123456789 | 23.012346 | 24.0123456789 | 25.0123456789
 30.0123457 | 33.0123456789 | 32.0123456789 | 33.012344 | 34.0123456789 | 35.0123456789
 40.0123457 | 44.0123456789 | 42.0123456789 | 43.012344 | 44.0123456789 | 45.0123456789
 50.0123457 | 55.0123456789 | 52.0123456789 | 53.012344 | 54.0123456789 | 55.0123456789
 60.0123457 | 66.0123456789 | 62.0123456789 | 63.012344 | 64.0123456789 | 65.0123456789
(5 rows)

drop table test1;
--test number(*,0)
create table t_number_38(id number(38,5));
\d+ t_number_38
                                   Table "public.T_NUMBER_38"
 Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------------+-----------+----------+---------+---------+--------------+-------------
 ID     | NUMERIC(38,5) |           |          |         | main    |              | 
Distribute By: HASH(ID)
Location Nodes: ALL DATANODES

insert into t_number_38 values (12345678901234567890123456789012345678.123456789);
ERROR:  numeric field overflow
DETAIL:  A field with precision 38, scale 5 must round to an absolute value less than 10^33.
insert into t_number_38 values (123456789012345678901234567890123.123456789);
select * from t_number_38;
                   ID                    
-----------------------------------------
 123456789012345678901234567890123.12346
(1 row)

create table t_number_star(id number(*));
\d+ t_number_star
                               Table "public.T_NUMBER_STAR"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 ID     | NUMERIC |           |          |         | main    |              | 
Distribute By: HASH(ID)
Location Nodes: ALL DATANODES

insert into t_number_star values (1234567890123456789012345678901234567890.123456789);
insert into t_number_star values (123456789012345678901234567890123.123456789);
select * from t_number_star;
                    ID                    
------------------------------------------
 1234567890123456789012345678901234567890
 123456789012345678901234567890123.123457
(2 rows)

create table t_number_star_5(id number(*,5));
\d+ t_number_star_5
                                  Table "public.T_NUMBER_STAR_5"
 Column |      Type       | Collation | Nullable | Default | Storage | Stats target | Description 
--------+-----------------+-----------+----------+---------+---------+--------------+-------------
 ID     | NUMERIC(1000,5) |           |          |         | main    |              | 
Distribute By: HASH(ID)
Location Nodes: ALL DATANODES

insert into t_number_star_5 values (12345678901234567890123456789012345678.123456789);
insert into t_number_star_5 values (123456789012345678901234567890123.123456789);
select * from t_number_star_5;
                    ID                     
-------------------------------------------
 12345678901234567890123456789012345678.12
   123456789012345678901234567890123.12346
(2 rows)

drop table t_number_38;
drop table t_number_star;
drop table t_number_star_5;
-- test int4div
select 1/2 as div;
 DIV 
-----
  .5
(1 row)

select 1/2::int2 as div;
 DIV 
-----
   0
(1 row)

select 1/2::int8 as div;
 DIV 
-----
   0
(1 row)

select 1/2 as div;
 DIV 
-----
  .5
(1 row)

select 1/2::int2 as div;
 DIV 
-----
   0
(1 row)

select 1/2::int8 as div;
 DIV 
-----
   0
(1 row)

-- test sysdate
select sysdate - sysdate as mi;
 MI 
----
  0
(1 row)

-- test dual;
select * from dual;
 DUMMY 
-------
 X
(1 row)

select 1 as t from dual;
 T 
---
 1
(1 row)

select sysdate - sysdate AS now from dual;
 NOW 
-----
   0
(1 row)

drop table if exists test;
NOTICE:  table "TEST" does not exist, skipping
create table test(tc1 int4, tc2 int4);
insert into test values(1,2);
insert into test values(1,3);
insert into test values(1,4);
insert into test values(2,2);
insert into test values(3,2);
insert into test values(4,2);
insert into test values(5,2);
insert into test values(null, null);
insert into test values(null, 1);
insert into test values(1, null);
\d+ test
                                   Table "public.TEST"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 TC1    | INTEGER |           |          |         | plain   |              | 
 TC2    | INTEGER |           |          |         | plain   |              | 
Distribute By: HASH(TC1)
Location Nodes: ALL DATANODES

select tc1 / tc2 as div1,
        tc2 / tc1 as div2,
        (tc1 + tc2) / (tc1) as div3,
        (tc1::int2 + tc2::int2) / (tc1::int2) as div4, 
        tc1::int4 / tc2::int8 as div5,
        tc2::int2 / tc1::int2 as div6
    from test 
    order by div1, div2, div3, div4, div5, div6;
                   DIV1                    |                   DIV2                    |                   DIV3                   | DIV4 | DIV5 | DIV6 
-------------------------------------------+-------------------------------------------+------------------------------------------+------+------+------
                                       .25 |                                         4 |                                        5 |    5 |    0 |    4
 .3333333333333333333333333333333333333333 |                                         3 |                                        4 |    4 |    0 |    3
                                        .5 |                                         2 |                                        3 |    3 |    0 |    2
                                         1 |                                         1 |                                        2 |    2 |    1 |    1
                                       1.5 | .6666666666666666666666666666666666666667 | 1.66666666666666666666666666666666666667 |    1 |    1 |    0
                                         2 |                                        .5 |                                      1.5 |    1 |    2 |    0
                                       2.5 |                                        .4 |                                      1.4 |    1 |    2 |    0
                                           |                                           |                                          |      |      |     
                                           |                                           |                                          |      |      |     
                                           |                                           |                                          |      |      |     
(10 rows)

select tc1 / tc2 as div1,
        tc2 / tc1 as div2,
        (tc1 + tc2) / (tc1) as div3,
        (tc1::int2 + tc2::int2) / (tc1::int2) as div4, 
        tc1::int4 / tc2::int8 as div5,
        tc2::int2 / tc1::int2 as div6
    from test 
    order by div1, div2, div3, div4, div5, div6;
                   DIV1                    |                   DIV2                    |                   DIV3                   | DIV4 | DIV5 | DIV6 
-------------------------------------------+-------------------------------------------+------------------------------------------+------+------+------
                                       .25 |                                         4 |                                        5 |    5 |    0 |    4
 .3333333333333333333333333333333333333333 |                                         3 |                                        4 |    4 |    0 |    3
                                        .5 |                                         2 |                                        3 |    3 |    0 |    2
                                         1 |                                         1 |                                        2 |    2 |    1 |    1
                                       1.5 | .6666666666666666666666666666666666666667 | 1.66666666666666666666666666666666666667 |    1 |    1 |    0
                                         2 |                                        .5 |                                      1.5 |    1 |    2 |    0
                                       2.5 |                                        .4 |                                      1.4 |    1 |    2 |    0
                                           |                                           |                                          |      |      |     
                                           |                                           |                                          |      |      |     
                                           |                                           |                                          |      |      |     
(10 rows)

drop table test;
--test sequence
create sequence public.my_serial start 11;
select nextval('public.my_serial');
 NEXTVAL 
---------
      11
(1 row)

select currval('public.my_serial');
 CURRVAL 
---------
      11
(1 row)

select lastval();
 LASTVAL 
---------
      11
(1 row)

select setval('public.my_serial', 12);
 SETVAL 
--------
     12
(1 row)

select currval('public.my_serial');
 CURRVAL 
---------
      12
(1 row)

select nextval('public.my_serial');
 NEXTVAL 
---------
      13
(1 row)

select lastval();
 LASTVAL 
---------
      13
(1 row)

select setval('public.my_serial', 22, true);
 SETVAL 
--------
     22
(1 row)

select currval('public.my_serial');
 CURRVAL 
---------
      22
(1 row)

select nextval('public.my_serial');
 NEXTVAL 
---------
      23
(1 row)

select lastval();
 LASTVAL 
---------
      23
(1 row)

select setval('public.my_serial', 33, false);
 SETVAL 
--------
     33
(1 row)

select currval('public.my_serial');
 CURRVAL 
---------
      23
(1 row)

select nextval('public.my_serial');
 NEXTVAL 
---------
      33
(1 row)

select lastval();
 LASTVAL 
---------
      33
(1 row)

select currval('postgres.public.my_serial');
ERROR:  cross-database references are not implemented: "POSTGRES.PUBLIC.MY_SERIAL"
LINE 1: select currval('postgres.public.my_serial');
                       ^
select nextval('postgres.public.my_serial');
ERROR:  cross-database references are not implemented: "POSTGRES.PUBLIC.MY_SERIAL"
LINE 1: select nextval('postgres.public.my_serial');
                       ^
select lastval();
 LASTVAL 
---------
      33
(1 row)

select currval('my_serial');
 CURRVAL 
---------
      33
(1 row)

select nextval('my_serial');
 NEXTVAL 
---------
      34
(1 row)

select lastval();
 LASTVAL 
---------
      34
(1 row)

drop sequence public.my_serial;
create sequence public.my_serial start 11;
select public.my_serial.nextval;
 NEXTVAL 
---------
      11
(1 row)

select public.my_serial.currval;
 CURRVAL 
---------
      11
(1 row)

select lastval();
 LASTVAL 
---------
      11
(1 row)

select setval('public.my_serial', 12);
 SETVAL 
--------
     12
(1 row)

select public.my_serial.currval;
 CURRVAL 
---------
      12
(1 row)

select public.my_serial.nextval;
 NEXTVAL 
---------
      13
(1 row)

select lastval();
 LASTVAL 
---------
      13
(1 row)

select setval('public.my_serial', 22, true);
 SETVAL 
--------
     22
(1 row)

select public.my_serial.currval;
 CURRVAL 
---------
      22
(1 row)

select public.my_serial.nextval;
 NEXTVAL 
---------
      23
(1 row)

select lastval();
 LASTVAL 
---------
      23
(1 row)

select setval('public.my_serial', 33, false);
 SETVAL 
--------
     33
(1 row)

select public.my_serial.currval;
 CURRVAL 
---------
      23
(1 row)

select public.my_serial.nextval;
 NEXTVAL 
---------
      33
(1 row)

select lastval();
 LASTVAL 
---------
      33
(1 row)

select postgres.public.my_serial.currval;
ERROR:  cross-database references are not implemented: POSTGRES.PUBLIC.MY_SERIAL.CURRVAL
LINE 1: select postgres.public.my_serial.currval;
               ^
select postgres.public.my_serial.nextval;
ERROR:  cross-database references are not implemented: POSTGRES.PUBLIC.MY_SERIAL.NEXTVAL
LINE 1: select postgres.public.my_serial.nextval;
               ^
select lastval();
 LASTVAL 
---------
      33
(1 row)

select my_serial.currval;
 CURRVAL 
---------
      33
(1 row)

select my_serial.nextval;
 NEXTVAL 
---------
      34
(1 row)

select lastval();
 LASTVAL 
---------
      34
(1 row)

drop sequence public.my_serial;
-- test using index
drop table if exists t cascade;
NOTICE:  table "T" does not exist, skipping
create table t (f1 integer not null,nc text);
alter table t add constraint t_f1_PK primary key (f1) using index;
drop table t cascade;
drop table if exists t;
NOTICE:  table "T" does not exist, skipping
create table t (f1 integer not null,nc text);
alter table t add constraint t_f1_PK primary key (f1);
drop table t cascade;
drop table if exists t;
NOTICE:  table "T" does not exist, skipping
create table t (f1 integer not null primary key using index,nc text);
drop table t cascade;
drop table if exists t;
NOTICE:  table "T" does not exist, skipping
create table t (f1 integer not null primary key,nc text);
drop table t cascade;
-- test varchar2
    -- ERROR (typmod >= 1)
    CREATE TABLE foo (a VARCHAR2(0));
ERROR:  length for type varchar2 must be at least 1
LINE 1: CREATE TABLE foo (a VARCHAR2(0));
                            ^
    -- ERROR (number of typmods = 1)
    CREATE TABLE foo (a VARCHAR2(10, 1));
ERROR:  invalid type modifier
LINE 1: CREATE TABLE foo (a VARCHAR2(10, 1));
                            ^
    -- OK
    CREATE TABLE foo (a VARCHAR(5000));
    -- cleanup
    DROP TABLE foo;
    -- OK
    CREATE TABLE foo (a VARCHAR2(5));
    CREATE INDEX ON foo(a);
    --
    -- test that no value longer than maxlen is allowed
    --
    -- ERROR (length > 5)
    INSERT INTO foo VALUES ('abcdef');
ERROR:  input value length is 6; too long for type varchar2(5)
    -- ERROR (length > 5);
    -- VARCHAR2 does not truncate blank spaces on implicit coercion
    INSERT INTO foo VALUES ('abcde  ');
ERROR:  input value length is 7; too long for type varchar2(5)
    -- OK
    INSERT INTO foo VALUES ('abcde');
    -- OK
    INSERT INTO foo VALUES ('abcdef'::VARCHAR2(5));
    -- OK
    INSERT INTO foo VALUES ('abcde  '::VARCHAR2(5));
    --OK
    INSERT INTO foo VALUES ('abc'::VARCHAR2(5));
    --
    -- test whitespace semantics on comparison
    --
    -- equal
    SELECT 'abcde   '::VARCHAR2(10) = 'abcde   '::VARCHAR2(10);
 ?column? 
----------
 t
(1 row)

    -- not equal
    SELECT 'abcde  '::VARCHAR2(10) = 'abcde   '::VARCHAR2(10);
 ?column? 
----------
 f
(1 row)

    -- cleanup
    DROP TABLE foo;
-- test string
set client_min_messages = 'NOTICE'; 
--  1. test string in anonymous block
declare
  var_string string(15);
begin
  var_string := 'testString';
  raise notice '%',var_string;
end;
/
NOTICE:  testString
--  2. test function param using string
create or replace function f_test_string_20221018(a string)
return integer
is
  res integer;
  b   string;
begin
  res := 0;
  raise notice 'look:%',a;
  return res;
end;
/
declare
  res number;
  var_string STRING(20);
begin
  var_string := 'testString';
  res := f_test_string_20221018(var_string);
end;
/
NOTICE:  look:testString
select proargtypes,prosrc from pg_proc where proname='f_test_string_20221018';
 PROARGTYPES | PROSRC 
-------------+--------
(0 rows)

drop function if exists f_test_string_20221018;
--  3. test string typecast
declare
  a text;
  b string(20);
  c integer;
begin
  a := '12345';
  b := a;
  c := b;
  raise notice '%',b;
  raise notice '%',c;
end;
/
NOTICE:  12345
NOTICE:  12345
--  4. test string%type
declare
  a string(20);
  b a%type;
begin
  b := 'test %type';
  raise notice '%',b;
end;
/
NOTICE:  test %type
--5.test function return type
create or replace function f_test_string_20221018(a string)
return string
is
  res string;
  b   string;
begin
  res := a;
  raise notice 'look:%',a;
  return res;
end;
/
declare
  res string(20);
  var_string STRING(20);
begin
  var_string := 'testString';
  res := f_test_string_20221018(var_string);
  raise notice 'res:%',var_string;
end;
/
NOTICE:  look:testString
NOTICE:  res:testString
drop function if exists f_test_string_20221018;
--6. test string(2) as function param
create or replace function f_test_string_20221018(a string(2))
return string
is
  res string;
  b   string;
begin
  res := a;
  raise notice 'look:%',a;
  return res;
end;
/
declare
  res string(20);
  var_string STRING(20);
begin
  var_string := 'testString';
  res := f_test_string_20221018(var_string);
  raise notice 'res:%',var_string;
end;
/
NOTICE:  look:testString
NOTICE:  res:testString
drop function if exists f_test_string_20221018;
--7. test ddl/dml
create table t_test_string_20221018(id int,name string(20));
insert into t_test_string_20221018 values(1,'haha');
drop table t_test_string_20221018;
create table t_test_string_20221018(id int,name string(20));
insert into t_test_string_20221018 values(1,'haha'::string);
insert into t_test_string_20221018 values(2,CAST('haha' as string));
drop table t_test_string_20221018;
create table t_test_string_20221018(id int, name string);
insert into t_test_string_20221018 values(1,'haha');
drop table t_test_string_20221018;
create table t_test_string_20221018(id int, name string(32767));
insert into t_test_string_20221018 values(1,'haha');
drop table t_test_string_20221018;
create table t_test_string_20221018(id int, name string(10485760));
insert into t_test_string_20221018 values(1,'haha');
drop table t_test_string_20221018;
set client_min_messages = warning; 
    -- varchar2 specified unit is a character or byte (default is byte)
    create table test_varchar2_1(c1 varchar(5), c2 varchar2(5), c3 varchar2(5 char), c4 varchar2(5 byte));
    create table test_varchar2_2(c1 varchar(5), c2 varchar2(5), c3 varchar2(5 CHAR), c4 varchar2(5 BYTE));
    create table test_varchar2_3(c1 varchar(5), c2 varchar2(5), c3 varchar2(5 CHARACTER), c4 varchar2(5 byte));
    create table test_varchar2_4(c1 varchar(5), c2 varchar2(5), c3 varchar2(5 character), c4 varchar2(5 BYTE));
    insert into test_varchar2_1 values('中国中国中', '中', '中国中国中', '中');   -- should OK (c3 maxlen is 5 char)
    insert into test_varchar2_2 values('中国中国中', '中国中国中', '中国中国中', '中');   -- should failed (c2 byte longer than maxlen 5)
ERROR:  input value length is 15; too long for type varchar2(5)
    insert into test_varchar2_3 values('中国中国中', '中', '中国中国中', '中国中国中');   -- should failed (c4 byte longer than maxlen 5)
ERROR:  input value length is 15; too long for type varchar2(5)
    insert into test_varchar2_4 values('中国中国中', '中', '中国中国中', 'abcde');    -- should OK (c3 maxlen is 5 char, c2/c4 maxlen is 5 byte)
    drop table test_varchar2_1, test_varchar2_2, test_varchar2_3, test_varchar2_4;
-- test nvarchar2
    --
    -- test type modifier related rules
    --
    -- ERROR (typmod >= 1)
    CREATE TABLE bar (a NVARCHAR2(0));
ERROR:  length for type nvarchar2 must be at least 1
LINE 1: CREATE TABLE bar (a NVARCHAR2(0));
                            ^
    -- ERROR (number of typmods = 1)
    CREATE TABLE bar (a NVARCHAR2(10, 1));
ERROR:  invalid type modifier
LINE 1: CREATE TABLE bar (a NVARCHAR2(10, 1));
                            ^
    -- OK
    CREATE TABLE bar (a VARCHAR(5000));
    CREATE INDEX ON bar(a);
    -- cleanup
    DROP TABLE bar;
    -- OK
    CREATE TABLE bar (a NVARCHAR2(5));
    --
    -- test that no value longer than maxlen is allowed
    --
    -- ERROR (length > 5)
    INSERT INTO bar VALUES ('abcdef');
ERROR:  input value too long for type nvarchar2(5)
    -- ERROR (length > 5);
    -- NVARCHAR2 does not truncate blank spaces on implicit coercion
    INSERT INTO bar VALUES ('abcde  ');
ERROR:  input value too long for type nvarchar2(5)
    -- OK
    INSERT INTO bar VALUES ('abcde');
    -- OK
    INSERT INTO bar VALUES ('abcdef'::NVARCHAR2(5));
    -- OK
    INSERT INTO bar VALUES ('abcde  '::NVARCHAR2(5));
    --OK
    INSERT INTO bar VALUES ('abc'::NVARCHAR2(5));
    --
    -- test whitespace semantics on comparison
    --
    -- equal
    SELECT 'abcde   '::NVARCHAR2(10) = 'abcde   '::NVARCHAR2(10);
 ?column? 
----------
 t
(1 row)

    -- not equal
    SELECT 'abcde  '::NVARCHAR2(10) = 'abcde   '::NVARCHAR2(10);
 ?column? 
----------
 f
(1 row)

    -- cleanup
    DROP TABLE bar;
-- test cast string to numeric
drop table if exists test_t;
create table test_t(id varchar2(20));
insert into test_t values('1'); 
insert into test_t values(23);
insert into test_t values(24);
insert into test_t values(25);
select * from test_t where id = 1 order by id asc;
 ID 
----
 1
(1 row)

select * from test_t where id = '1' order by id asc;
 ID 
----
 1
(1 row)

select * from test_t where id=1::text order by id asc;
 ID 
----
 1
(1 row)

select * from test_t where id = 'xxx' order by id asc;
 ID 
----
(0 rows)

insert into test_t values('xxx');
select * from test_t where id = 1 order by id asc;
ERROR:  invalid input syntax for type numeric: "xxx"
select * from test_t where id = '1' order by id asc;
 ID 
----
 1
(1 row)

select * from test_t where id=1::text order by id asc;
 ID 
----
 1
(1 row)

select * from test_t where id = 'xxx' order by id asc;
 ID  
-----
 xxx
(1 row)

select * from test_t where id = 1 order by id asc;
ERROR:  invalid input syntax for type numeric: "xxx"
select * from test_t where id = '1' order by id asc;
 ID 
----
 1
(1 row)

select * from test_t where id=1::text order by id asc;
 ID 
----
 1
(1 row)

select * from test_t where id = 'xxx' order by id asc;
 ID  
-----
 xxx
(1 row)

select * from test_t where id = 1 order by id asc;
ERROR:  invalid input syntax for type numeric: "xxx"
select * from test_t where id = '1' order by id asc;
 ID 
----
 1
(1 row)

select * from test_t where id=1::text order by id asc;
 ID 
----
 1
(1 row)

select * from test_t where id = 'xxx' order by id asc;
 ID  
-----
 xxx
(1 row)

select * from test_t where id = 1 order by id asc;
ERROR:  invalid input syntax for type numeric: "xxx"
select * from test_t where id = '1' order by id asc;
 ID 
----
 1
(1 row)

select * from test_t where id=1::text order by id asc;
 ID 
----
 1
(1 row)

select * from test_t where id = 'xxx' order by id asc;
 ID  
-----
 xxx
(1 row)

drop table if exists test_t;
select 'xxx' || 1 as r;
  R   
------
 xxx1
(1 row)

select 1 || 'xxxx' as r;
   R   
-------
 1xxxx
(1 row)

drop table if exists test_t;
create table test_t (n int);
insert into test_t values(1);
insert into test_t values(2);
insert into test_t values(3);
insert into test_t values(4);
insert into test_t values(5);
insert into test_t values(6);
insert into test_t values(7);
insert into test_t values(8);
insert into test_t values(9);
select r from (SELECT '7' as r from dual UNION ALL SELECT n+1 as r FROM test_t WHERE n < 7 ) order by r;
 R 
---
 2
 3
 4
 5
 6
 7
 7
(7 rows)

drop table if exists test_t;
-- test nlssort
\c regression_sort
DROP TABLE IF EXISTS test_sort;
NOTICE:  table "TEST_SORT" does not exist, skipping
CREATE TABLE test_sort (name TEXT);
INSERT INTO test_sort VALUES ('red'), ('brown'), ('yellow'), ('Purple');
INSERT INTO test_sort VALUES ('guangdong'), ('shenzhen'), ('Tencent'), ('OpenTenBase');
SELECT * FROM test_sort ORDER BY NLSSORT(name, 'en_US.utf8');
   NAME    
-----------
 brown
 guangdong
 Purple
 red
 shenzhen
 OpenTenBase
 Tencent
 yellow
(8 rows)

SELECT * FROM test_sort ORDER BY NLSSORT(name, '');
   NAME    
-----------
 Purple
 OpenTenBase
 Tencent
 brown
 guangdong
 red
 shenzhen
 yellow
(8 rows)

SELECT set_nls_sort('invalid');
 SET_NLS_SORT 
--------------
 
(1 row)

SELECT * FROM test_sort ORDER BY NLSSORT(name);
ERROR:  failed to set the requested LC_COLLATE value [invalid]
SELECT set_nls_sort('');
 SET_NLS_SORT 
--------------
 
(1 row)

SELECT * FROM test_sort ORDER BY NLSSORT(name);
ERROR:  failed to set the requested LC_COLLATE value [invalid]
SELECT set_nls_sort('en_US.utf8');
 SET_NLS_SORT 
--------------
 
(1 row)

SELECT * FROM test_sort ORDER BY NLSSORT(name);
   NAME    
-----------
 brown
 guangdong
 Purple
 red
 shenzhen
 OpenTenBase
 Tencent
 yellow
(8 rows)

INSERT INTO test_sort VALUES(NULL);
SELECT * FROM test_sort ORDER BY NLSSORT(name);
   NAME    
-----------
 brown
 guangdong
 Purple
 red
 shenzhen
 OpenTenBase
 Tencent
 yellow
 
(9 rows)

SELECT set_nls_sort('nls_sort = russian');
 SET_NLS_SORT 
--------------
 
(1 row)

SELECT * FROM test_sort ORDER BY NLSSORT(name);
   NAME    
-----------
 brown
 guangdong
 Purple
 red
 shenzhen
 OpenTenBase
 Tencent
 yellow
 
(9 rows)

SELECT set_nls_sort('nls_sortr = pt_PT.iso885915@euro');
 SET_NLS_SORT 
--------------
 
(1 row)

SELECT * FROM test_sort ORDER BY NLSSORT(name);
ERROR:  failed to set the requested LC_COLLATE value [nls_sortr = pt_PT.iso885915@euro]
SELECT set_nls_sort('nls_sortr = en_US.iso885915');
 SET_NLS_SORT 
--------------
 
(1 row)

SELECT * FROM test_sort ORDER BY NLSSORT(name, 'Nls_sort =   ');
   NAME    
-----------
 Purple
 OpenTenBase
 Tencent
 brown
 guangdong
 red
 shenzhen
 yellow
 
(9 rows)

SELECT * FROM test_sort ORDER BY NLSSORT(name, 'Nls_sort =  zh_CN.gb18030 ');
   NAME    
-----------
 brown
 guangdong
 Purple
 red
 shenzhen
 OpenTenBase
 Tencent
 yellow
 
(9 rows)

SELECT * FROM test_sort ORDER BY NLSSORT(name, 'Nls_sort =  wa_BE.iso885915@euro ');
   NAME    
-----------
 brown
 guangdong
 Purple
 red
 shenzhen
 OpenTenBase
 Tencent
 yellow
 
(9 rows)

SELECT * FROM test_sort ORDER BY NLSSORT(name, 'NLS_SORT =  tt_RU.utf8@iqtelif ');
   NAME    
-----------
 brown
 guangdong
 Purple
 red
 shenzhen
 OpenTenBase
 Tencent
 yellow
 
(9 rows)

SELECT * FROM test_sort ORDER BY NLSSORT(name, 'Nls_sortR =  tt_RU.utf8@iqtelif ');
ERROR:  failed to set the requested LC_COLLATE value [Nls_sortR =  tt_RU.utf8@iqtelif]
SELECT * FROM test_sort ORDER BY NLSSORT(name,'NLS_SORT = SCHINESE_PINYIN_M');
   NAME    
-----------
 brown
 guangdong
 Purple
 red
 shenzhen
 OpenTenBase
 Tencent
 yellow
 
(9 rows)

SELECT * FROM test_sort ORDER BY NLSSORT(name,'NLS_SORT = SCHINESE_STROKE_M');
   NAME    
-----------
 brown
 guangdong
 Purple
 red
 shenzhen
 OpenTenBase
 Tencent
 yellow
 
(9 rows)

SELECT * FROM test_sort ORDER BY NLSSORT(name,'NLS_SORT = SCHINESE_RADICAL_M');
   NAME    
-----------
 brown
 guangdong
 Purple
 red
 shenzhen
 OpenTenBase
 Tencent
 yellow
 
(9 rows)

DROP TABLE test_sort;
\c regression_ora
SET client_encoding to default;
-- test !=- operator
drop table if exists test cascade;
NOTICE:  table "TEST" does not exist, skipping
create table test(tc1 int);
insert into test values(1),(-1),(null);
insert into test values(2),(-2),(null);
select * from test where tc1 != -1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 !=-1  order by tc1 asc;  -- error
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 <> -1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 <>-1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 != -1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 !=-1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 <> -1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 <>-1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

CREATE OPERATOR opentenbase_ora.!=- (
  LEFTARG   = INTEGER,
  RIGHTARG  = INTEGER,
  PROCEDURE = pg_catalog.int4div
);
ERROR:  syntax error at or near "-"
LINE 1: CREATE OPERATOR opentenbase_ora.!=- (
                                    ^
select * from test where tc1 != -1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 !=-1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 <> -1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 <>-1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 != -1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 !=-1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 <> -1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

select * from test where tc1 <>-1  order by tc1 asc;
 TC1 
-----
  -2
   1
   2
(3 rows)

drop operator opentenbase_ora.!=-(integer, integer);
ERROR:  syntax error at or near "-"
LINE 1: drop operator opentenbase_ora.!=-(integer, integer);
                                  ^
drop operator opentenbase_ora.!=-(integer, integer);
ERROR:  syntax error at or near "-"
LINE 1: drop operator opentenbase_ora.!=-(integer, integer);
                                  ^
CREATE OPERATOR opentenbase_ora.!=- (
  LEFTARG   = INTEGER,
  RIGHTARG  = INTEGER,
  PROCEDURE = pg_catalog.int4div
);
ERROR:  syntax error at or near "-"
LINE 1: CREATE OPERATOR opentenbase_ora.!=- (
                                    ^
drop table if exists test cascade;
\c regression
SELECT add_months ('2008-01-31', -80640);
           add_months            
---------------------------------
 Sat Jan 31 00:00:00 4713 PST BC
(1 row)

SELECT add_months ('2008-01-31 11:32:12', -80640);
           add_months            
---------------------------------
 Sat Jan 31 11:32:12 4713 PST BC
(1 row)

\c regression_ora
select instr('Tech on the net', 'e') = 2;
 ?column? 
----------
 t
(1 row)

select instr('Tech on the net', 'e', 1, 1) = 2;
 ?column? 
----------
 t
(1 row)

select instr('Tech on the net', 'e', 1, 2) = 11;
 ?column? 
----------
 t
(1 row)

select instr('Tech on the net', 'e', 1, 3) = 14;
 ?column? 
----------
 t
(1 row)

select instr('Tech on the net', 'e', -3, 2) = 2;
 ?column? 
----------
 t
(1 row)

select instr('abc', NULL) IS NULL;
 ?column? 
----------
 t
(1 row)

select instr('abc', '') IS NULL;
 ?column? 
----------
 t
(1 row)

select instr('', 'a') IS NULL;
 ?column? 
----------
 t
(1 row)

select 1 = instr('abc', 'a');
 ?column? 
----------
 t
(1 row)

select 3 = instr('abc', 'c');
 ?column? 
----------
 t
(1 row)

select 0 = instr('abc', 'z');
 ?column? 
----------
 t
(1 row)

select 1 = instr('abcabcabc', 'abca', 1);
 ?column? 
----------
 t
(1 row)

select 4 = instr('abcabcabc', 'abca', 2);
 ?column? 
----------
 t
(1 row)

select 0 = instr('abcabcabc', 'abca', 7);
 ?column? 
----------
 t
(1 row)

select 0 = instr('abcabcabc', 'abca', 9);
 ?column? 
----------
 t
(1 row)

select 4 = instr('abcabcabc', 'abca', -1);
 ?column? 
----------
 t
(1 row)

select 1 = instr('abcabcabc', 'abca', -8);
 ?column? 
----------
 t
(1 row)

select 1 = instr('abcabcabc', 'abca', -9);
 ?column? 
----------
 t
(1 row)

select 0 = instr('abcabcabc', 'abca', -10);
 ?column? 
----------
 t
(1 row)

select 1 = instr('abcabcabc', 'abca', 1, 1);
 ?column? 
----------
 t
(1 row)

select 4 = instr('abcabcabc', 'abca', 1, 2);
 ?column? 
----------
 t
(1 row)

select 0 = instr('abcabcabc', 'abca', 1, 3);
 ?column? 
----------
 t
(1 row)

select 2 = instr('张三','三') from dual;
 ?column? 
----------
 t
(1 row)

select 0 = instr('张三',' ') from dual;
 ?column? 
----------
 t
(1 row)

select instr('张三','') is NULL from dual;
 ?column? 
----------
 t
(1 row)

select instr('','三') is NULL from dual;
 ?column? 
----------
 t
(1 row)

--test to_char
select to_char(22);
 TO_CHAR 
---------
 22
(1 row)

select to_char(99::smallint);
 TO_CHAR 
---------
 99
(1 row)

select to_char(-44444);
 TO_CHAR 
---------
 -44444
(1 row)

select to_char(1234567890123456::bigint);
     TO_CHAR      
------------------
 1234567890123456
(1 row)

select to_char(123.456::real);
 TO_CHAR 
---------
 123.456
(1 row)

select to_char(1234.5678::double precision);
  TO_CHAR  
-----------
 1234.5678
(1 row)

select to_char(12345678901234567890::numeric);
       TO_CHAR        
----------------------
 12345678901234567890
(1 row)

select to_char(1234567890.12345);
     TO_CHAR      
------------------
 1234567890.12345
(1 row)

select to_char('4.00'::numeric);
 TO_CHAR 
---------
 4
(1 row)

select to_char('4.0010'::numeric);
 TO_CHAR 
---------
 4.001
(1 row)

-- test special case of '$' in int_to_char fmt
select TO_CHAR(123,'$99,999.9') from dual;
  TO_CHAR   
------------
     $123.0
(1 row)

select length(TO_CHAR(123,'$99,999.9')) from dual;
 LENGTH 
--------
     10
(1 row)

select TO_CHAR(123,'$99,9,999.9') from dual;
   TO_CHAR    
--------------
       $123.0
(1 row)

select length(TO_CHAR(123,'$99,9,999.9')) from dual;
 LENGTH 
--------
     12
(1 row)

select TO_CHAR(123,'99,9,9$99.9') from dual;
   TO_CHAR    
--------------
       $123.0
(1 row)

select length(TO_CHAR(123,'99,9,9$99.9')) from dual;
 LENGTH 
--------
     12
(1 row)

select TO_CHAR(123,'99,9,999.9$') from dual;
   TO_CHAR    
--------------
       $123.0
(1 row)

select length(TO_CHAR(123,'99,9,999.9$')) from dual;
 LENGTH 
--------
     12
(1 row)

-- with sign
select TO_CHAR(+123,'$99,999.9') from dual;
  TO_CHAR   
------------
     $123.0
(1 row)

select length(TO_CHAR(+123,'$99,999.9')) from dual;
 LENGTH 
--------
     10
(1 row)

select TO_CHAR(-123,'$99,999.9') from dual;
  TO_CHAR   
------------
    -$123.0
(1 row)

select length(TO_CHAR(-123,'$99,999.9')) from dual;
 LENGTH 
--------
     10
(1 row)

-- numeric_to_char
select TO_CHAR(123.99,'$99,999.9') from dual;
  TO_CHAR   
------------
     $124.0
(1 row)

select length(TO_CHAR(123.99,'$99,999.9')) from dual;
 LENGTH 
--------
     10
(1 row)

select TO_CHAR(123.99,'$99,9,999.9') from dual;
   TO_CHAR    
--------------
       $124.0
(1 row)

select length(TO_CHAR(123.99,'$99,9,999.9')) from dual;
 LENGTH 
--------
     12
(1 row)

select TO_CHAR(123.99,'99,9,9$99.9') from dual;
   TO_CHAR    
--------------
       $124.0
(1 row)

select length(TO_CHAR(123.99,'99,9,9$99.9')) from dual;
 LENGTH 
--------
     12
(1 row)

select TO_CHAR(123.99,'99,9,999.9$') from dual;
   TO_CHAR    
--------------
       $124.0
(1 row)

select length(TO_CHAR(123.99,'99,9,999.9$')) from dual;
 LENGTH 
--------
     12
(1 row)

-- with sign
select TO_CHAR(-123.99,'$99,999.9') from dual;
  TO_CHAR   
------------
    -$124.0
(1 row)

select length(TO_CHAR(-123.99,'$99,999.9')) from dual;
 LENGTH 
--------
     10
(1 row)

select TO_CHAR(+123.99,'$99,999.9') from dual;
  TO_CHAR   
------------
     $124.0
(1 row)

select length(TO_CHAR(+123.99,'$99,999.9')) from dual;
 LENGTH 
--------
     10
(1 row)

---------------------------------------------------------------------------------------------------------------------------------------
--add to_char to convert the integer, float, numeric to hex digit string 
select to_char(20, 'aa') from dual;
ERROR:  Invalid number format model
select to_char(22221., 'xxxxxxx') from dual;
 TO_CHAR  
----------
     56cd
(1 row)

select to_char(22221., 'XXXXXXX') from dual;
 TO_CHAR  
----------
     56CD
(1 row)

select to_char(22221.4, 'xxxxxxx') from dual;
 TO_CHAR  
----------
     56cd
(1 row)

select to_char(22221.5, 'xxxxxxx') from dual;
 TO_CHAR  
----------
     56ce
(1 row)

select to_char(-22221.4, 'xxxxxxx') from dual;
 TO_CHAR  
----------
 ########
(1 row)

select to_char(912222, 'xxxxx') from dual;
 TO_CHAR 
---------
  deb5e
(1 row)

select to_char(912222, 'XXXXX') from dual;
 TO_CHAR 
---------
  DEB5E
(1 row)

select to_char(912222, 'xxxx') from dual;
 TO_CHAR 
---------
 #####
(1 row)

select to_char(-912222, 'xxxxxxx') from dual;
 TO_CHAR  
----------
 ########
(1 row)

select to_char(2e4, 'XXXx') from dual;
 TO_CHAR 
---------
  4e20
(1 row)

select to_char(2e-4, 'XXXx') from dual;
 TO_CHAR 
---------
     0
(1 row)

select to_char(2e0, 'XXXx') from dual;
 TO_CHAR 
---------
     2
(1 row)

select to_char(-2e0, 'XXXx') from dual;
 TO_CHAR 
---------
 #####
(1 row)

select to_char(912222, 'XxxxxxxxxxxxxxxxxxxxxxxxxxXxxxxxxxxxxxxxXxxxxxxxxxxxxxxxxxxxxxX') from dual;
                             TO_CHAR                              
------------------------------------------------------------------
                                                            deb5e
(1 row)

select to_char(912222, 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') from dual;
                             TO_CHAR                              
------------------------------------------------------------------
                                                            deb5e
(1 row)

select to_char(912222, 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') from dual;
ERROR:  invalid number format model
create table tr_tbl_to_char(f1 integer, f2 float, f3 double precision, f4 numeric(10,2));
insert into tr_tbl_to_char values(255, 255.4, 65535.9999999, -32765.89);
insert into tr_tbl_to_char values(254, 253.4, 65534.9999999, 32765.89);
insert into tr_tbl_to_char values(-254, 253.4, 65534.9999999, 32765.89);
select to_char(f1, 'XXXX'), to_char(f2, 'xxxx'), to_char(f3, 'xxxX'), to_char(f4, 'XXXXX') from tr_tbl_to_char order by f1;
 TO_CHAR | TO_CHAR | TO_CHAR | TO_CHAR 
---------+---------+---------+---------
 #####   |    fd   |  ffff   |   7FFE
    FE   |    fd   |  ffff   |   7FFE
    FF   |    ff   | #####   | ######
(3 rows)

------------------------------------------------------------------------------------------------------------------------------
--test to_number
SELECT to_number('-34,338,492', '99G999G999') from dual;
 TO_NUMBER 
-----------
 -34338492
(1 row)

SELECT to_number('-34,338,492.654,878', '99G999G999D999G999') from dual;
ERROR:  Invalid number format model
SELECT to_number('<564646.654564>', '999999.999999PR') from dual;
   TO_NUMBER    
----------------
 -564646.654564
(1 row)

SELECT to_number('0.00001-', '9.999999S') from dual;
 TO_NUMBER 
-----------
   -.00001
(1 row)

SELECT to_number('5.01-', 'FM9.999999S') from dual;
 TO_NUMBER 
-----------
     -5.01
(1 row)

SELECT to_number('5.01-', 'FM9.999999MI') from dual;
 TO_NUMBER 
-----------
     -5.01
(1 row)

SELECT to_number('5 4 4 4 4 8 . 7 8', '9 9 9 9 9 9 . 9 9') from dual;
ERROR:  Invalid number format model
SELECT to_number('.01', 'FM9.99') from dual;
 TO_NUMBER 
-----------
       .01
(1 row)

SELECT to_number('.0', '99999999.99999999') from dual;
 TO_NUMBER 
-----------
         0
(1 row)

SELECT to_number('0', '99.99') from dual;
 TO_NUMBER 
-----------
         0
(1 row)

SELECT to_number('.-01', 'S99.99') from dual;
ERROR:  invalid number
SELECT to_number('.01-', '99.99S') from dual;
 TO_NUMBER 
-----------
      -.01
(1 row)

SELECT to_number(' . 0 1-', ' 9 9 . 9 9 S') from dual;
ERROR:  Invalid number format model
SELECT to_number('-34338492') from dual;
 TO_NUMBER 
-----------
 -34338492
(1 row)

SELECT to_number('-34338492.654878') from dual;
    TO_NUMBER     
------------------
 -34338492.654878
(1 row)

SELECT to_number('564646.654564') from dual;
   TO_NUMBER   
---------------
 564646.654564
(1 row)

SELECT to_number('0.00001') from dual;
 TO_NUMBER 
-----------
    .00001
(1 row)

SELECT to_number('5.01') from dual;
 TO_NUMBER 
-----------
      5.01
(1 row)

SELECT to_number('.01') from dual;
 TO_NUMBER 
-----------
       .01
(1 row)

SELECT to_number('.0') from dual;
 TO_NUMBER 
-----------
         0
(1 row)

SELECT to_number('0') from dual;
 TO_NUMBER 
-----------
         0
(1 row)

SELECT to_number('01') from dual;
 TO_NUMBER 
-----------
         1
(1 row)

select to_number(123.09e34::float4) from dual;
               TO_NUMBER               
---------------------------------------
 1230900000000000000000000000000000000
(1 row)

select to_number(1234.094e23::float8) from dual;
          TO_NUMBER          
-----------------------------
 123409400000000000000000000
(1 row)

SELECT to_number('123'::text);
 TO_NUMBER 
-----------
       123
(1 row)

SELECT to_number('123.456'::text);
 TO_NUMBER 
-----------
   123.456
(1 row)

SELECT to_number(123);
 TO_NUMBER 
-----------
       123
(1 row)

SELECT to_number(123::smallint);
 TO_NUMBER 
-----------
       123
(1 row)

SELECT to_number(123::int);
 TO_NUMBER 
-----------
       123
(1 row)

SELECT to_number(123::bigint);
 TO_NUMBER 
-----------
       123
(1 row)

SELECT to_number(123::numeric);
 TO_NUMBER 
-----------
       123
(1 row)

SELECT to_number(123.456);
 TO_NUMBER 
-----------
   123.456
(1 row)

-- test to_multi_byte
-- SELECT to_multi_byte('123$test') from dual;
-- SELECT octet_length('abc') from dual;
-- SELECT octet_length(to_multi_byte('abc')) from dual;
-- testto_single_byte
-- SELECT to_single_byte('123$test') from dual;
-- SELECT to_single_byte('１２３＄ｔｅｓｔ') from dual;
-- SELECT octet_length('ａｂｃ');
-- SELECT octet_length(to_single_byte('ａｂｃ')) from dual;
-- test sinh cosh tanh
SELECT sinh(1.570796), cosh(1.570796), tanh(4);
                   SINH                   |                   COSH                   |        TANH        
------------------------------------------+------------------------------------------+--------------------
 2.30129808232069622468685235162699418596 | 2.50917772660545389627160678510875500621 | 0.9993292997390669
(1 row)

SELECT sinh(1.570796::numeric), cosh(1.570796::numeric), tanh(4::numeric);
                   SINH                   |                   COSH                   |                   TANH                    
------------------------------------------+------------------------------------------+-------------------------------------------
 2.30129808232069622468685235162699418596 | 2.50917772660545389627160678510875500621 | .9993292997390670437922433443417249620054
(1 row)

-- Test nanvl
SELECT nanvl(12345, 1), nanvl('NaN', 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(12345::float4, 1), nanvl('NaN'::float4, 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(12345::float8, 1), nanvl('NaN'::float8, 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(12345::numeric, 1), nanvl('NaN'::numeric, 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(12345, '1'::varchar), nanvl('NaN', 1::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(12345::float4, '1'::varchar), nanvl('NaN'::float4, '1'::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(12345::float8, '1'::varchar), nanvl('NaN'::float8, '1'::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(12345::numeric, '1'::varchar), nanvl('NaN'::numeric, '1'::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(12345, '1'::char), nanvl('NaN', 1::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(12345::float4, '1'::char), nanvl('NaN'::float4, '1'::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(12345::float8, '1'::char), nanvl('NaN'::float8, '1'::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(12345::numeric, '1'::char), nanvl('NaN'::numeric, '1'::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
 12345 |     1
(1 row)

SELECT nanvl(binary_float_nan, 1), nanvl('NaN', 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_float_nan, 1), nanvl('NaN'::float4, 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_float_nan, 1), nanvl('NaN'::float8, 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_float_nan, 1), nanvl('NaN'::numeric, 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_float_nan, '1'::varchar), nanvl('NaN', 1::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_float_nan, '1'::varchar), nanvl('NaN'::float4, '1'::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_float_nan, '1'::varchar), nanvl('NaN'::float8, '1'::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_float_nan, '1'::varchar), nanvl('NaN'::numeric, '1'::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_float_nan, '1'::char), nanvl('NaN', 1::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_float_nan, '1'::char), nanvl('NaN'::float4, '1'::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_float_nan, '1'::char), nanvl('NaN'::float8, '1'::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_float_nan, '1'::char), nanvl('NaN'::numeric, '1'::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, 1), nanvl('NaN', 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, 1), nanvl('NaN'::float4, 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, 1), nanvl('NaN'::float8, 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, 1), nanvl('NaN'::numeric, 1) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, '1'::varchar), nanvl('NaN', 1::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, '1'::varchar), nanvl('NaN'::float4, '1'::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, '1'::varchar), nanvl('NaN'::float8, '1'::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, '1'::varchar), nanvl('NaN'::numeric, '1'::varchar) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, '1'::char), nanvl('NaN', 1::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, '1'::char), nanvl('NaN'::float4, '1'::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, '1'::char), nanvl('NaN'::float8, '1'::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(binary_double_nan, '1'::char), nanvl('NaN'::numeric, '1'::char) FROM DUAL;
 NANVL | NANVL 
-------+-------
     1 |     1
(1 row)

SELECT nanvl(NULL, NULL) from dual;
 NANVL 
-------
      
(1 row)

SELECT nanvl(NULL, 1), nanvl(binary_double_nan, NULL) from dual;
 NANVL | NANVL 
-------+-------
       |      
(1 row)

-- Test sign
select sign(binary_float_nan), sign(binary_double_nan) from dual;
 SIGN | SIGN 
------+------
    1 |    1
(1 row)

-- Test atan2
select atan2(-0, -0) from dual;
ERROR:  numeric overflow
-- Test nvl
SELECT nvl('A'::text, 'B') FROM DUAL;
 NVL 
-----
 A
(1 row)

SELECT nvl(NULL::text, 'B') FROM DUAL;
 NVL 
-----
 B
(1 row)

SELECT nvl(NULL::text, NULL) FROM DUAL;
 NVL 
-----
 
(1 row)

SELECT nvl(1, 2) FROM DUAL;
 NVL 
-----
   1
(1 row)

SELECT nvl(NULL, 2) FROM DUAL;
 NVL 
-----
 2
(1 row)

-- Test nvl2
SELECT nvl2('A'::text, 'B', 'C') FROM DUAL;
 NVL2 
------
 B
(1 row)

SELECT nvl2(NULL::text, 'B', 'C') FROM DUAL;
 NVL2 
------
 C
(1 row)

SELECT nvl2('A'::text, NULL, 'C') FROM DUAL;
 NVL2 
------
 
(1 row)

SELECT nvl2(NULL::text, 'B', NULL) FROM DUAL;
 NVL2 
------
 
(1 row)

SELECT nvl2(1, 2, 3) FROM DUAL;
 NVL2 
------
    2
(1 row)

SELECT nvl2(NULL, 2, 3) FROM DUAL;
 NVL2 
------
    3
(1 row)

SELECT nvl2(' ', 1, 2) FROM DUAL;
 NVL2 
------
    1
(1 row)

SELECT nvl2('', 1, 2) FROM DUAL;
 NVL2 
------
    2
(1 row)

-- Test lnnvl
SELECT lnnvl(true) FROM DUAL;
ERROR:  invalid relational operator
SELECT lnnvl(false) FROM DUAL;
ERROR:  invalid relational operator
SELECT lnnvl(NULL) FROM DUAL;
ERROR:  invalid relational operator
-- Test NULL
SELECT dump('') FROM DUAL;
 DUMP 
------
 NULL
(1 row)

SELECT nvl('',3) FROM DUAL;
 NVL 
-----
 3
(1 row)

SELECT nvl2('','1','2') FROM DUAL ;
 NVL2 
------
 2
(1 row)

SELECT 1 FROM DUAL WHERE '' is NULL;
 ?column? 
----------
        1
(1 row)

SELECT NULL||'opentenbase' FROM DUAL;
 ?column? 
----------
 opentenbase
(1 row)

SELECT NULL+1 FROM DUAL;
 ?column? 
----------
         
(1 row)

DROP TABLE IF EXISTS t_null;
NOTICE:  table "T_NULL" does not exist, skipping
CREATE TABLE t_null(f1 int,f2 varchar2(10));
INSERT INTO t_null VALUES(1,NULL);
INSERT INTO t_null VALUES(2,'');
SELECT * FROM t_null WHERE f2 is NULL;
 F1 | F2 
----+----
  1 | 
  2 | 
(2 rows)

SELECT * FROM t_null WHERE f2 ='' ;
 F1 | F2 
----+----
(0 rows)

INSERT INTO t_null VALUES(3,'1');
INSERT INTO t_null VALUES(4,'2');
SELECT * FROM t_null ORDER BY f2;
 F1 | F2 
----+----
  3 | 1
  4 | 2
  1 | 
  2 | 
(4 rows)

DROP TABLE t_null;
-- Test DUMP
SELECT DUMP('Yellow dog'::text) ~ E'^Typ=25 Len=(\\d+): \\d+(,\\d+)*$' AS t;
 T 
---
 t
(1 row)

SELECT DUMP('Yellow dog'::text, 10) ~ E'^Typ=25 Len=(\\d+): \\d+(,\\d+)*$' AS t;
 T 
---
 t
(1 row)

SELECT DUMP('Yellow dog'::text, 17) ~ E'^Typ=25 Len=(\\d+): .(,.)*$' AS t;
 T 
---
 t
(1 row)

SELECT DUMP(10::int2) ~ E'^Typ=21 Len=2: \\d+(,\\d+){1}$' AS t;
 T 
---
 t
(1 row)

SELECT DUMP(10::int4) ~ E'^Typ=23 Len=4: \\d+(,\\d+){3}$' AS t;
 T 
---
 t
(1 row)

SELECT DUMP(10::int8) ~ E'^Typ=20 Len=8: \\d+(,\\d+){7}$' AS t;
 T 
---
 t
(1 row)

SELECT DUMP(10.23::float4) ~ E'^Typ=700 Len=4: \\d+(,\\d+){3}$' AS t;
 T 
---
 t
(1 row)

SELECT DUMP(10.23::float8) ~ E'^Typ=701 Len=8: \\d+(,\\d+){7}$' AS t;
 T 
---
 t
(1 row)

SELECT DUMP(10.23::numeric) ~ E'^Typ=1700 Len=(\\d+): \\d+(,\\d+)*$' AS t;
 T 
---
 t
(1 row)

SELECT DUMP('2008-10-10'::date) ~ E'^Typ=8774 Len=8: \\d+(,\\d+){7}$' AS t;
 T 
---
 f
(1 row)

SELECT DUMP('2008-10-10'::timestamp) ~ E'^Typ=8776 Len=12: \\d+(,\\d+){11}$' AS t;
 T 
---
 f
(1 row)

SELECT DUMP('2009-10-10'::timestamp) ~ E'^Typ=8776 Len=12: \\d+(,\\d+){11}$' AS t;
 T 
---
 f
(1 row)

SELECT DUMP('Yellow dog'::text, 1010) ~ E'^Typ=25 Len=(\\d+) CharacterSet=(\\w+): \\d+(,\\d+)*$' AS t;
 T 
---
 t
(1 row)

SELECT DUMP('Yellow dog'::text, 1017) ~ E'^Typ=25 Len=(\\d+) CharacterSet=(\\w+): .(,.)*$' AS t;
 T 
---
 t
(1 row)

SELECT DUMP('2009-10-10'::timestamp, 10, 1, 5) ~ E'^Typ=8776 Len=12: \\d+(,\\d+){4}$' AS t;
 T 
---
 f
(1 row)

SELECT DUMP('2009-10-10'::timestamp, 10, 0, 0) ~ E'^Typ=8776 Len=12: \\d+(,\\d+){11}$' AS t;
 T 
---
 f
(1 row)

SELECT DUMP('2009-10-10'::timestamp, 16, 1, 5) ~ E'^Typ=8776 Len=12: [0-9a-fA-F]+(,[0-9a-fA-F]+){4}$' AS t;
 T 
---
 f
(1 row)

SELECT DUMP('2009-10-10'::timestamp, 8, 1, 5) ~ E'^Typ=8776 Len=12: [0-7]+(,[0-7]+){4}$' AS t;
 T 
---
 f
(1 row)

-- test substr
select substr('This is a test', 6, 2) = 'is';
 ?column? 
----------
 t
(1 row)

select substr('This is a test', 6) =  'is a test';
 ?column? 
----------
 t
(1 row)

select substr('TechOnTheNet', 1, 4) =  'Tech';
 ?column? 
----------
 t
(1 row)

select substr('TechOnTheNet', -3, 3) =  'Net';
 ?column? 
----------
 t
(1 row)

select substr('TechOnTheNet', -6, 3) =  'The';
 ?column? 
----------
 t
(1 row)

select substr('TechOnTheNet', -8, 2) =  'On';
 ?column? 
----------
 t
(1 row)

select substr('TechOnTheNet', -8, 0) =  '';
 ?column? 
----------
 
(1 row)

select substr('TechOnTheNet', -8, -1) =  '';
 ?column? 
----------
 
(1 row)

select substr(1234567,3.6::smallint)='4567';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::int)='4567';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::bigint)='4567';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::numeric)='34567';
 ?column? 
----------
 t
(1 row)

select substr(1234567,-1)='7';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::smallint,2.6)='45';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::smallint,2.6::smallint)='456';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::smallint,2.6::int)='456';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::smallint,2.6::bigint)='456';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::smallint,2.6::numeric)='45';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::int,2.6::smallint)='456';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::int,2.6::int)='456';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::int,2.6::bigint)='456';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::int,2.6::numeric)='45';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::bigint,2.6::smallint)='456';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::bigint,2.6::int)='456';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::bigint,2.6::bigint)='456';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::bigint,2.6::numeric)='45';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::numeric,2.6::smallint)='345';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::numeric,2.6::int)='345';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::numeric,2.6::bigint)='345';
 ?column? 
----------
 t
(1 row)

select substr(1234567,3.6::numeric,2.6::numeric)='34';
 ?column? 
----------
 t
(1 row)

select substr('abcdef'::varchar,3.6::smallint)='def';
 ?column? 
----------
 t
(1 row)

select substr('abcdef'::varchar,3.6::int)='def';
 ?column? 
----------
 t
(1 row)

select substr('abcdef'::varchar,3.6::bigint)='def';
 ?column? 
----------
 t
(1 row)

select substr('abcdef'::varchar,3.6::numeric)='cdef';
 ?column? 
----------
 t
(1 row)

select substr('abcdef'::varchar,3.5::int,3.5::int)='def';
 ?column? 
----------
 t
(1 row)

select substr('abcdef'::varchar,3.5::numeric,3.5::numeric)='cde';
 ?column? 
----------
 t
(1 row)

select substr('abcdef'::varchar,3.5::numeric,3.5::int)='cdef';
 ?column? 
----------
 t
(1 row)

-- test lengthb
select length('opentenbase_ora'),lengthB('opentenbase_ora') from dual;
 LENGTH | LENGTHB 
--------+---------
      6 |       6
(1 row)

-- test strposb
select strposb('abc', '') from dual;
 STRPOSB 
---------
        
(1 row)

select strposb('abc', 'a') from dual;
 STRPOSB 
---------
       1
(1 row)

select strposb('abc', 'c') from dual;
 STRPOSB 
---------
       3
(1 row)

select strposb('abc', 'z') from dual;
 STRPOSB 
---------
       0
(1 row)

select strposb('abcabcabc', 'abca') from dual;
 STRPOSB 
---------
       1
(1 row)

--test decode
select decode(1, 1, 100, 2, 200);
 DECODE 
--------
    100
(1 row)

select decode(2, 1, 100, 2, 200);
 DECODE 
--------
    200
(1 row)

select decode(3, 1, 100, 2, 200);
 DECODE 
--------
       
(1 row)

select decode(3, 1, 100, 2, 200, 300);
 DECODE 
--------
    300
(1 row)

select decode(NULL, 1, 100, NULL, 200, 300);
 DECODE 
--------
    200
(1 row)

select decode('1'::text, '1', 100, '2', 200);
 DECODE 
--------
    100
(1 row)

select decode(2, 1, 'ABC', 2, 'DEF');
 DECODE 
--------
 DEF
(1 row)

-- Test sysdate - (column)::sysdate
CREATE TABLE eh_etl_log_main (
      schedule_id character varying(20) not null,
      execute_period character varying(8)  ,
      start_time timestamp(0) without time zone,
      end_time  timestamp(0) without time zone,
      time_consuming numeric(14,2),
      execute_status character varying(10));
create or replace procedure insert_into_tableA_prococedure ( )as
$$
DECLARE  
v_schedule_id text;
begin 
v_schedule_id := to_char(sysdate,'yyyymmddhh24miss');
insert into eh_etl_log_main values (
                v_schedule_id,
                20211031,
                sysdate,
                sysdate,
                0,
                'NONE');
update eh_etl_log_main SET end_time = sysdate,time_consuming = (((sysdate - start_time::date)*24*60)::numeric),execute_status = 'ERROR' where schedule_id= v_schedule_id;
end;
$$language default_plsql;
call insert_into_tableA_prococedure();
call insert_into_tableA_prococedure();
call insert_into_tableA_prococedure();
call insert_into_tableA_prococedure();
call insert_into_tableA_prococedure();
drop table eh_etl_log_main;
drop procedure insert_into_tableA_prococedure;
-- For type 'bpchar'
select DECODE('a'::bpchar, 'a'::bpchar,'postgres'::bpchar);
  DECODE  
----------
 postgres
(1 row)

select DECODE('c'::bpchar, 'a'::bpchar,'postgres'::bpchar);
 DECODE 
--------
 
(1 row)

select DECODE('a'::bpchar, 'a'::bpchar,'postgres'::bpchar,'default value'::bpchar);
  DECODE  
----------
 postgres
(1 row)

select DECODE('c', 'a'::bpchar,'postgres'::bpchar,'default value'::bpchar);
    DECODE     
---------------
 default value
(1 row)

select DECODE('a'::bpchar, 'a'::bpchar,'postgres'::bpchar,'b'::bpchar,'database'::bpchar);
  DECODE  
----------
 postgres
(1 row)

select DECODE('d'::bpchar, 'a'::bpchar,'postgres'::bpchar,'b'::bpchar,'database'::bpchar);
 DECODE 
--------
 
(1 row)

select DECODE('a'::bpchar, 'a'::bpchar,'postgres'::bpchar,'b'::bpchar,'database'::bpchar,'default value'::bpchar);
  DECODE  
----------
 postgres
(1 row)

select DECODE('d'::bpchar, 'a'::bpchar,'postgres'::bpchar,'b'::bpchar,'database'::bpchar,'default value'::bpchar);
    DECODE     
---------------
 default value
(1 row)

select DECODE('a'::bpchar, 'a'::bpchar,'postgres'::bpchar,'b'::bpchar,'database'::bpchar, 'c'::bpchar, 'system'::bpchar);
  DECODE  
----------
 postgres
(1 row)

select DECODE('d'::bpchar, 'a'::bpchar,'postgres'::bpchar,'b'::bpchar,'database'::bpchar, 'c'::bpchar, 'system'::bpchar);
 DECODE 
--------
 
(1 row)

select DECODE('a'::bpchar, 'a'::bpchar,'postgres'::bpchar,'b'::bpchar,'database'::bpchar, 'c'::bpchar, 'system'::bpchar,'default value'::bpchar);
  DECODE  
----------
 postgres
(1 row)

select DECODE('d'::bpchar, 'a'::bpchar,'postgres'::bpchar,'b'::bpchar,'database'::bpchar, 'c'::bpchar, 'system'::bpchar,'default value'::bpchar);
    DECODE     
---------------
 default value
(1 row)

select DECODE(NULL, 'a'::bpchar, 'postgres'::bpchar, NULL,'database'::bpchar);
  DECODE  
----------
 database
(1 row)

select DECODE(NULL, 'a'::bpchar, 'postgres'::bpchar, 'b'::bpchar,'database'::bpchar);
 DECODE 
--------
 
(1 row)

select DECODE(NULL, 'a'::bpchar, 'postgres'::bpchar, NULL,'database'::bpchar,'default value'::bpchar);
  DECODE  
----------
 database
(1 row)

select DECODE(NULL, 'a'::bpchar, 'postgres'::bpchar, 'b'::bpchar,'database'::bpchar,'default value'::bpchar);
    DECODE     
---------------
 default value
(1 row)

-- For type 'bigint'
select DECODE(2147483651::bigint, 2147483650::bigint,2147483650::bigint);
 DECODE 
--------
       
(1 row)

select DECODE(2147483653::bigint, 2147483651::bigint,2147483650::bigint);
 DECODE 
--------
       
(1 row)

select DECODE(2147483653::bigint, 2147483651::bigint,2147483650::bigint,9999999999::bigint);
   DECODE   
------------
 9999999999
(1 row)

select DECODE(2147483653::bigint, 2147483651::bigint,2147483650::bigint,9999999999::bigint);
   DECODE   
------------
 9999999999
(1 row)

select DECODE(2147483651::bigint, 2147483651::bigint,2147483650::bigint,2147483652::bigint,2147483651::bigint);
   DECODE   
------------
 2147483650
(1 row)

select DECODE(2147483654::bigint, 2147483651::bigint,2147483650::bigint,2147483652::bigint,2147483651::bigint);
 DECODE 
--------
       
(1 row)

select DECODE(2147483651::bigint, 2147483651::bigint,2147483650::bigint,2147483652::bigint,2147483651::bigint,9999999999::bigint);
   DECODE   
------------
 2147483650
(1 row)

select DECODE(2147483654::bigint, 2147483651::bigint,2147483650::bigint,2147483652::bigint,2147483651::bigint,9999999999::bigint);
   DECODE   
------------
 9999999999
(1 row)

select DECODE(2147483651::bigint, 2147483651::bigint,2147483650::bigint, 2147483652::bigint,2147483651::bigint, 2147483653::bigint, 2147483652::bigint);
   DECODE   
------------
 2147483650
(1 row)

select DECODE(2147483654::bigint, 2147483651::bigint,2147483650::bigint, 2147483652::bigint,2147483651::bigint, 2147483653::bigint, 2147483652::bigint);
 DECODE 
--------
       
(1 row)

select DECODE(2147483651::bigint, 2147483651::bigint,2147483650::bigint, 2147483652::bigint,2147483651::bigint, 2147483653::bigint, 2147483652::bigint,9999999999::bigint);
   DECODE   
------------
 2147483650
(1 row)

select DECODE(2147483654::bigint, 2147483651::bigint,2147483650::bigint, 2147483652::bigint,2147483651::bigint, 2147483653::bigint, 2147483652::bigint,9999999999::bigint);
   DECODE   
------------
 9999999999
(1 row)

select DECODE(NULL, 2147483651::bigint, 2147483650::bigint, NULL,2147483651::bigint);
   DECODE   
------------
 2147483651
(1 row)

select DECODE(NULL, 2147483651::bigint, 2147483650::bigint, 2147483652::bigint,2147483651::bigint);
 DECODE 
--------
       
(1 row)

select DECODE(NULL, 2147483651::bigint, 2147483650::bigint, NULL,2147483651::bigint,9999999999::bigint);
   DECODE   
------------
 2147483651
(1 row)

select DECODE(NULL, 2147483651::bigint, 2147483650::bigint, 2147483652::bigint,2147483651::bigint,9999999999::bigint);
   DECODE   
------------
 9999999999
(1 row)

-- For type 'numeric'
select DECODE(12.001::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4));
   DECODE   
------------
 214748.365
(1 row)

select DECODE(12.003::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4));
 DECODE 
--------
       
(1 row)

select DECODE(12.001::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4),999999.9999::numeric(10,4));
   DECODE   
------------
 214748.365
(1 row)

select DECODE(12.003::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4),999999.9999::numeric(10,4));
   DECODE    
-------------
 999999.9999
(1 row)

select DECODE(12.001::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4),12.002::numeric(5,3),214748.3651::numeric(10,4));
   DECODE   
------------
 214748.365
(1 row)

select DECODE(12.004::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4),12.002::numeric(5,3),214748.3651::numeric(10,4));
 DECODE 
--------
       
(1 row)

select DECODE(12.001::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4),12.002::numeric(5,3),214748.3651::numeric(10,4),999999.9999::numeric(10,4));
   DECODE   
------------
 214748.365
(1 row)

select DECODE(12.004::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4),12.002::numeric(5,3),214748.3651::numeric(10,4),999999.9999::numeric(10,4));
   DECODE    
-------------
 999999.9999
(1 row)

select DECODE(12.001::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4),12.002::numeric(5,3),214748.3651::numeric(10,4), 12.003::numeric(5,3), 214748.3652::numeric(10,4));
   DECODE   
------------
 214748.365
(1 row)

select DECODE(12.004::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4),12.002::numeric(5,3),214748.3651::numeric(10,4), 12.003::numeric(5,3), 214748.3652::numeric(10,4));
 DECODE 
--------
       
(1 row)

select DECODE(12.001::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4),12.002::numeric(5,3),214748.3651::numeric(10,4), 12.003::numeric(5,3), 214748.3652::numeric(10,4),999999.9999::numeric(10,4));
   DECODE   
------------
 214748.365
(1 row)

select DECODE(12.004::numeric(5,3), 12.001::numeric(5,3),214748.3650::numeric(10,4),12.002::numeric(5,3),214748.3651::numeric(10,4), 12.003::numeric(5,3), 214748.3652::numeric(10,4),999999.9999::numeric(10,4));
   DECODE    
-------------
 999999.9999
(1 row)

select DECODE(NULL, 12.001::numeric(5,3), 214748.3650::numeric(10,4), NULL,214748.3651::numeric(10,4));
   DECODE    
-------------
 214748.3651
(1 row)

select DECODE(NULL, 12.001::numeric(5,3), 214748.3650::numeric(10,4), 12.002::numeric(5,3),214748.3651::numeric(10,4));
 DECODE 
--------
       
(1 row)

select DECODE(NULL, 12.001::numeric(5,3), 214748.3650::numeric(10,4), NULL,214748.3651::numeric(10,4),999999.9999::numeric(10,4));
   DECODE    
-------------
 214748.3651
(1 row)

select DECODE(NULL, 12.001::numeric(5,3), 214748.3650::numeric(10,4), 12.002::numeric(5,3),214748.3651::numeric(10,4),999999.9999::numeric(10,4));
   DECODE    
-------------
 999999.9999
(1 row)

--For type 'date'
select DECODE('2020-01-01'::date, '2020-01-01'::date,'2012-12-20'::date);
   DECODE   
------------
 12-20-2012
(1 row)

select DECODE('2020-01-03'::date, '2020-01-01'::date,'2012-12-20'::date);
 DECODE 
--------
 
(1 row)

select DECODE('2020-01-01'::date, '2020-01-01'::date,'2012-12-20'::date,'2012-12-21'::date);
   DECODE   
------------
 12-20-2012
(1 row)

select DECODE('2020-01-03'::date, '2020-01-01'::date,'2012-12-20'::date,'2012-12-21'::date);
   DECODE   
------------
 12-21-2012
(1 row)

select DECODE('2020-01-01'::date, '2020-01-01'::date,'2012-12-20'::date,'2020-01-02'::date,'2012-12-21'::date);
   DECODE   
------------
 12-20-2012
(1 row)

select DECODE('2020-01-04'::date, '2020-01-01'::date,'2012-12-20'::date,'2020-01-02'::date,'2012-12-21'::date);
 DECODE 
--------
 
(1 row)

select DECODE('2020-01-01'::date, '2020-01-01'::date,'2012-12-20'::date,'2020-01-02'::date,'2012-12-21'::date,'2012-12-31'::date);
   DECODE   
------------
 12-20-2012
(1 row)

select DECODE('2020-01-04'::date, '2020-01-01'::date,'2012-12-20'::date,'2020-01-02'::date,'2012-12-21'::date,'2012-12-31'::date);
   DECODE   
------------
 12-31-2012
(1 row)

select DECODE('2020-01-01'::date, '2020-01-01'::date,'2012-12-20'::date,'2020-01-02'::date,'2012-12-21'::date, '2020-01-03'::date, '2012-12-31'::date);
   DECODE   
------------
 12-20-2012
(1 row)

select DECODE('2020-01-04'::date, '2020-01-01'::date,'2012-12-20'::date,'2020-01-02'::date,'2012-12-21'::date, '2020-01-03'::date, '2012-12-31'::date);
 DECODE 
--------
 
(1 row)

select DECODE('2020-01-01'::date, '2020-01-01'::date,'2012-12-20'::date,'2020-01-02'::date,'2012-12-21'::date, '2020-01-03'::date, '2012-12-31'::date,'2013-01-01'::date);
   DECODE   
------------
 12-20-2012
(1 row)

select DECODE('2020-01-04'::date, '2020-01-01'::date,'2012-12-20'::date,'2020-01-02'::date,'2012-12-21'::date, '2020-01-03'::date, '2012-12-31'::date,'2013-01-01'::date);
   DECODE   
------------
 01-01-2013
(1 row)

select DECODE(NULL, '2020-01-01'::date, '2012-12-20'::date, NULL,'2012-12-21'::date);
   DECODE   
------------
 12-21-2012
(1 row)

select DECODE(NULL, '2020-01-01'::date, '2012-12-20'::date, '2020-01-02'::date,'2012-12-21'::date);
 DECODE 
--------
 
(1 row)

select DECODE(NULL, '2020-01-01'::date, '2012-12-20'::date, NULL,'2012-12-21'::date,'2012-12-31'::date);
   DECODE   
------------
 12-21-2012
(1 row)

select DECODE(NULL, '2020-01-01'::date, '2012-12-20'::date, '2020-01-02'::date,'2012-12-21'::date,'2012-12-31'::date);
   DECODE   
------------
 12-31-2012
(1 row)

-- For type 'time'
select DECODE('01:00:01'::time, '01:00:01'::time,'09:00:00'::time);
  DECODE  
----------
 09:00:00
(1 row)

select DECODE('01:00:03'::time, '01:00:01'::time,'09:00:00'::time);
 DECODE 
--------
 
(1 row)

select DECODE('01:00:01'::time, '01:00:01'::time,'09:00:00'::time,'00:00:00'::time);
  DECODE  
----------
 09:00:00
(1 row)

select DECODE('01:00:03'::time, '01:00:01'::time,'09:00:00'::time,'00:00:00'::time);
  DECODE  
----------
 00:00:00
(1 row)

select DECODE('01:00:01'::time, '01:00:01'::time,'09:00:00'::time,'01:00:02'::time,'12:00:00'::time);
  DECODE  
----------
 09:00:00
(1 row)

select DECODE('01:00:04'::time, '01:00:01'::time,'09:00:00'::time,'01:00:02'::time,'12:00:00'::time);
 DECODE 
--------
 
(1 row)

select DECODE('01:00:01'::time, '01:00:01'::time,'09:00:00'::time,'01:00:02'::time,'12:00:00'::time,'00:00:00'::time);
  DECODE  
----------
 09:00:00
(1 row)

select DECODE('01:00:04'::time, '01:00:01'::time,'09:00:00'::time,'01:00:01'::time,'12:00:00'::time,'00:00:00'::time);
  DECODE  
----------
 00:00:00
(1 row)

select DECODE('01:00:01'::time, '01:00:01'::time,'09:00:00'::time,'01:00:02'::time,'12:00:00'::time, '01:00:03'::time, '15:00:00'::time);
  DECODE  
----------
 09:00:00
(1 row)

select DECODE('01:00:04'::time, '01:00:01'::time,'09:00:00'::time,'01:00:02'::time,'12:00:00'::time, '01:00:03'::time, '15:00:00'::time);
 DECODE 
--------
 
(1 row)

select DECODE('01:00:01'::time, '01:00:01'::time,'09:00:00'::time,'01:00:02'::time,'12:00:00'::time, '01:00:03'::time, '15:00:00'::time,'00:00:00'::time);
  DECODE  
----------
 09:00:00
(1 row)

select DECODE('01:00:04'::time, '01:00:01'::time,'09:00:00'::time,'01:00:02'::time,'12:00:00'::time, '01:00:03'::time, '15:00:00'::time,'00:00:00'::time);
  DECODE  
----------
 00:00:00
(1 row)

select DECODE(NULL, '01:00:01'::time, '09:00:00'::time, NULL,'12:00:00'::time);
  DECODE  
----------
 12:00:00
(1 row)

select DECODE(NULL, '01:00:01'::time, '09:00:00'::time, '01:00:02'::time,'12:00:00'::time);
 DECODE 
--------
 
(1 row)

select DECODE(NULL, '01:00:01'::time, '09:00:00'::time, NULL,'12:00:00'::time,'00:00:00'::time);
  DECODE  
----------
 12:00:00
(1 row)

select DECODE(NULL, '01:00:01'::time, '09:00:00'::time, '01:00:02'::time,'12:00:00'::time,'00:00:00'::time);
  DECODE  
----------
 00:00:00
(1 row)

-- For type 'timestamp'
select DECODE('2020-01-01 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 09:00:00 2012
(1 row)

select DECODE('2020-01-03 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp);
 DECODE 
--------
 
(1 row)

select DECODE('2020-01-01 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp,'2012-12-20 00:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 09:00:00 2012
(1 row)

select DECODE('2020-01-03 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp,'2012-12-20 00:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 00:00:00 2012
(1 row)

select DECODE('2020-01-01 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp,'2020-01-02 01:00:01'::timestamp,'2012-12-20 12:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 09:00:00 2012
(1 row)

select DECODE('2020-01-04 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp,'2020-01-02 01:00:01'::timestamp,'2012-12-20 12:00:00'::timestamp);
 DECODE 
--------
 
(1 row)

select DECODE('2020-01-01 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp,'2020-01-02 01:00:01'::timestamp,'2012-12-20 12:00:00'::timestamp,'2012-12-20 00:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 09:00:00 2012
(1 row)

select DECODE('2020-01-04 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp,'2020-01-02 01:00:01'::timestamp,'2012-12-20 12:00:00'::timestamp,'2012-12-20 00:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 00:00:00 2012
(1 row)

select DECODE('2020-01-01 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp,'2020-01-02 01:00:01'::timestamp,'2012-12-20 12:00:00'::timestamp, '2020-01-03 01:00:01'::timestamp, '2012-12-20 15:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 09:00:00 2012
(1 row)

select DECODE('2020-01-04 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp,'2020-01-02 01:00:01'::timestamp,'2012-12-20 12:00:00'::timestamp, '2020-01-03 01:00:01'::timestamp, '2012-12-20 15:00:00'::timestamp);
 DECODE 
--------
 
(1 row)

select DECODE('2020-01-01 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp,'2020-01-02 01:00:01'::timestamp,'2012-12-20 12:00:00'::timestamp, '2020-01-03 01:00:01'::timestamp, '2012-12-20 15:00:00'::timestamp,'2012-12-20 00:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 09:00:00 2012
(1 row)

select DECODE('2020-01-04 01:00:01'::timestamp, '2020-01-01 01:00:01'::timestamp,'2012-12-20 09:00:00'::timestamp,'2020-01-02 01:00:01'::timestamp,'2012-12-20 12:00:00'::timestamp, '2020-01-03 01:00:01'::timestamp, '2012-12-20 15:00:00'::timestamp,'2012-12-20 00:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 00:00:00 2012
(1 row)

select DECODE(NULL, '2020-01-01 01:00:01'::timestamp, '2012-12-20 09:00:00'::timestamp, NULL,'2012-12-20 12:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 12:00:00 2012
(1 row)

select DECODE(NULL, '2020-01-01 01:00:01'::timestamp, '2012-12-20 09:00:00'::timestamp, '2020-01-02 01:00:01'::timestamp,'2012-12-20 12:00:00'::timestamp);
 DECODE 
--------
 
(1 row)

select DECODE(NULL, '2020-01-01 01:00:01'::timestamp, '2012-12-20 09:00:00'::timestamp, NULL,'2012-12-20 12:00:00'::timestamp,'2012-12-20 00:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 12:00:00 2012
(1 row)

select DECODE(NULL, '2020-01-01 01:00:01'::timestamp, '2012-12-20 09:00:00'::timestamp, '2020-01-02 01:00:01'::timestamp,'2012-12-20 12:00:00'::timestamp,'2012-12-20 00:00:00'::timestamp);
          DECODE          
--------------------------
 Thu Dec 20 00:00:00 2012
(1 row)

-- For type 'timestamptz'
select DECODE('2020-01-01 01:00:01-08'::timestamptz, '2020-01-01 01:00:01-08'::timestamptz,'2012-12-20 09:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 09:00:00 2012 PST
(1 row)

select DECODE('2020-01-03 01:00:01-08'::timestamptz, '2020-01-01 01:00:01-08'::timestamptz,'2012-12-20 09:00:00-08'::timestamptz);
 DECODE 
--------
 
(1 row)

select DECODE('2020-01-01 01:00:01-08'::timestamptz, '2020-01-01 01:00:01-08'::timestamptz,'2012-12-20 09:00:00-08'::timestamptz,'2012-12-20 00:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 09:00:00 2012 PST
(1 row)

select DECODE('2020-01-03 01:00:01-08'::timestamptz, '2020-01-01 01:00:01-08'::timestamptz,'2012-12-20 09:00:00-08'::timestamptz,'2012-12-20 00:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 00:00:00 2012 PST
(1 row)

select DECODE('2020-01-01 01:00:01-08'::timestamptz, '2020-01-01 01:00:01-08'::timestamptz,'2012-12-20 09:00:00-08'::timestamptz,'2020-01-02 01:00:01-08'::timestamptz,'2012-12-20 12:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 09:00:00 2012 PST
(1 row)

select DECODE('2020-01-04 01:00:01-08'::timestamptz, '2020-01-01 01:00:01-08'::timestamptz,'2012-12-20 09:00:00-08'::timestamptz,'2020-01-02 01:00:01-08'::timestamptz,'2012-12-20 12:00:00-08'::timestamptz);
 DECODE 
--------
 
(1 row)

select DECODE('2020-01-01 01:00:01-08'::timestamptz, '2020-01-01 01:00:01-08'::timestamptz,'2012-12-20 09:00:00-08'::timestamptz,'2020-01-02 01:00:01-08'::timestamptz,'2012-12-20 12:00:00-08'::timestamptz,'2012-12-20 00:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 09:00:00 2012 PST
(1 row)

select DECODE('2020-01-04 01:00:01-08'::timestamptz, '2020-01-01 01:00:01-08'::timestamptz,'2012-12-20 09:00:00-08'::timestamptz,'2020-01-02 01:00:01-08'::timestamptz,'2012-12-20 12:00:00-08'::timestamptz,'2012-12-20 00:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 00:00:00 2012 PST
(1 row)

select DECODE('2020-01-01 01:00:01-08'::timestamptz, '2020-01-01 01:00:01-08'::timestamptz,'2012-12-20 09:00:00-08'::timestamptz,'2020-01-02 01:00:01-08'::timestamptz,'2012-12-20 12:00:00-08'::timestamptz, '2020-01-03 01:00:01-08'::timestamptz, '2012-12-20 15:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 09:00:00 2012 PST
(1 row)

select DECODE('2020-01-04 01:00:01-08'::timestamptz, '2020-01-01 01:00:01-08'::timestamptz,'2012-12-20 09:00:00-08'::timestamptz,'2020-01-02 01:00:01-08'::timestamptz,'2012-12-20 12:00:00-08'::timestamptz, '2020-01-03 01:00:01-08'::timestamptz, '2012-12-20 15:00:00-08'::timestamptz);
 DECODE 
--------
 
(1 row)

select DECODE('2020-01-01 01:00:01-08'::timestamptz, '2020-01-01 01:00:01-08'::timestamptz,'2012-12-20 09:00:00-08'::timestamptz,'2020-01-02 01:00:01-08'::timestamptz,'2012-12-20 12:00:00-08'::timestamptz, '2020-01-03 01:00:01-08'::timestamptz, '2012-12-20 15:00:00-08'::timestamptz,'2012-12-20 00:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 09:00:00 2012 PST
(1 row)

select DECODE(4, 1,'2012-12-20 09:00:00-08'::timestamptz,2,'2012-12-20 12:00:00-08'::timestamptz, 3, '2012-12-20 15:00:00-08'::timestamptz,'2012-12-20 00:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 00:00:00 2012 PST
(1 row)

select DECODE(NULL, '2020-01-01 01:00:01-08'::timestamptz, '2012-12-20 09:00:00-08'::timestamptz, NULL,'2012-12-20 12:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 12:00:00 2012 PST
(1 row)

select DECODE(NULL, '2020-01-01 01:00:01-08'::timestamptz, '2012-12-20 09:00:00-08'::timestamptz, '2020-01-02 01:00:01-08'::timestamptz,'2012-12-20 12:00:00-08'::timestamptz);
 DECODE 
--------
 
(1 row)

select DECODE(NULL, '2020-01-01 01:00:01-08'::timestamptz, '2012-12-20 09:00:00-08'::timestamptz, NULL,'2012-12-20 12:00:00-08'::timestamptz,'2012-12-20 00:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 12:00:00 2012 PST
(1 row)

select DECODE(NULL, '2020-01-01 01:00:01-08'::timestamptz, '2012-12-20 09:00:00-08'::timestamptz, '2020-01-02 01:00:01-08'::timestamptz,'2012-12-20 12:00:00-08'::timestamptz,'2012-12-20 00:00:00-08'::timestamptz);
            DECODE            
------------------------------
 Thu Dec 20 00:00:00 2012 PST
(1 row)

select DECODE(1, 1,'2011-12-20 09:00:00-08',2,'2012-12-20 12:00:00-08', 3, '2013-12-20 15:00:00-08', 4, '2014-12-20 00:00:00-08', 5,'2015-12-20 00:00:00-08',6 ,'2016-12-20 00:00:00-08', 7 ,'2017-12-20 00:00:00-08', 8 ,'2012-18-20 00:00:00-08', 9 ,'2019-12-20 00:00:00-08',  10 ,'2020-12-20 00:00:00-08',  11 ,'2021-12-20 00:00:00-08',  12 ,'2022-12-20 00:00:00-08',  13 ,'20123-12-20 00:00:00-08',  14 ,'2024-12-20 00:00:00-08',  15 ,'2025-12-20 00:00:00-08', 16,'2026-12-20 00:00:00-08', 17,'2027-12-20 00:00:00-08', 18,'2028-12-20 00:00:00-08', 19,'2029-12-20 00:00:00-08', 'default');
         DECODE         
------------------------
 2011-12-20 09:00:00-08
(1 row)

select DECODE(2, 1,'2011-12-20 09:00:00-08',2,'2012-12-20 12:00:00-08', 3, '2013-12-20 15:00:00-08', 4, '2014-12-20 00:00:00-08', 5,'2015-12-20 00:00:00-08',6 ,'2016-12-20 00:00:00-08', 7 ,'2017-12-20 00:00:00-08', 8 ,'2012-18-20 00:00:00-08', 9 ,'2019-12-20 00:00:00-08',  10 ,'2020-12-20 00:00:00-08',  11 ,'2021-12-20 00:00:00-08',  12 ,'2022-12-20 00:00:00-08',  13 ,'20123-12-20 00:00:00-08',  14 ,'2024-12-20 00:00:00-08',  15 ,'2025-12-20 00:00:00-08', 16,'2026-12-20 00:00:00-08', 17,'2027-12-20 00:00:00-08', 18,'2028-12-20 00:00:00-08', 19,'2029-12-20 00:00:00-08', 'default');
         DECODE         
------------------------
 2012-12-20 12:00:00-08
(1 row)

select DECODE(19, 1,'2011-12-20 09:00:00-08',2,'2012-12-20 12:00:00-08', 3, '2013-12-20 15:00:00-08', 4, '2014-12-20 00:00:00-08', 5,'2015-12-20 00:00:00-08',6 ,'2016-12-20 00:00:00-08', 7 ,'2017-12-20 00:00:00-08', 8 ,'2012-18-20 00:00:00-08', 9 ,'2019-12-20 00:00:00-08',  10 ,'2020-12-20 00:00:00-08',  11 ,'2021-12-20 00:00:00-08',  12 ,'2022-12-20 00:00:00-08',  13 ,'20123-12-20 00:00:00-08',  14 ,'2024-12-20 00:00:00-08',  15 ,'2025-12-20 00:00:00-08', 16,'2026-12-20 00:00:00-08', 17,'2027-12-20 00:00:00-08', 18,'2028-12-20 00:00:00-08', 19,'2029-12-20 00:00:00-08', 'default');
         DECODE         
------------------------
 2029-12-20 00:00:00-08
(1 row)

select DECODE(20, 1,'2011-12-20 09:00:00-08',2,'2012-12-20 12:00:00-08', 3, '2013-12-20 15:00:00-08', 4, '2014-12-20 00:00:00-08', 5,'2015-12-20 00:00:00-08',6 ,'2016-12-20 00:00:00-08', 7 ,'2017-12-20 00:00:00-08', 8 ,'2012-18-20 00:00:00-08', 9 ,'2019-12-20 00:00:00-08',  10 ,'2020-12-20 00:00:00-08',  11 ,'2021-12-20 00:00:00-08',  12 ,'2022-12-20 00:00:00-08',  13 ,'20123-12-20 00:00:00-08',  14 ,'2024-12-20 00:00:00-08',  15 ,'2025-12-20 00:00:00-08', 16,'2026-12-20 00:00:00-08', 17,'2027-12-20 00:00:00-08', 18,'2028-12-20 00:00:00-08', 19,'2029-12-20 00:00:00-08', 'default');
 DECODE  
---------
 default
(1 row)

select DECODE(21, 1,'2011-12-20 09:00:00-08',2,'2012-12-20 12:00:00-08', 3, '2013-12-20 15:00:00-08', 4, '2014-12-20 00:00:00-08', 5,'2015-12-20 00:00:00-08',6 ,'2016-12-20 00:00:00-08', 7 ,'2017-12-20 00:00:00-08', 8 ,'2012-18-20 00:00:00-08', 9 ,'2019-12-20 00:00:00-08',  10 ,'2020-12-20 00:00:00-08',  11 ,'2021-12-20 00:00:00-08',  12 ,'2022-12-20 00:00:00-08',  13 ,'20123-12-20 00:00:00-08',  14 ,'2024-12-20 00:00:00-08',  15 ,'2025-12-20 00:00:00-08', 16,'2026-12-20 00:00:00-08', 17,'2027-12-20 00:00:00-08', 18,'2028-12-20 00:00:00-08', 19,'2029-12-20 00:00:00-08', 'default');
 DECODE  
---------
 default
(1 row)

select DECODE(22, 1,'2011-12-20 09:00:00-08',2,'2012-12-20 12:00:00-08', 3, '2013-12-20 15:00:00-08', 4, '2014-12-20 00:00:00-08', 5,'2015-12-20 00:00:00-08',6 ,'2016-12-20 00:00:00-08', 7 ,'2017-12-20 00:00:00-08', 8 ,'2012-18-20 00:00:00-08', 9 ,'2019-12-20 00:00:00-08',  10 ,'2020-12-20 00:00:00-08',  11 ,'2021-12-20 00:00:00-08',  12 ,'2022-12-20 00:00:00-08',  13 ,'20123-12-20 00:00:00-08',  14 ,'2024-12-20 00:00:00-08',  15 ,'2025-12-20 00:00:00-08', 16,'2026-12-20 00:00:00-08', 17,'2027-12-20 00:00:00-08', 18,'2028-12-20 00:00:00-08', 19,'2029-12-20 00:00:00-08', 'default');
 DECODE  
---------
 default
(1 row)

select DECODE(23, 1,'2011-12-20 09:00:00-08',2,'2012-12-20 12:00:00-08', 3, '2013-12-20 15:00:00-08', 4, '2014-12-20 00:00:00-08', 5,'2015-12-20 00:00:00-08',6 ,'2016-12-20 00:00:00-08', 7 ,'2017-12-20 00:00:00-08', 8 ,'2012-18-20 00:00:00-08', 9 ,'2019-12-20 00:00:00-08',  10 ,'2020-12-20 00:00:00-08',  11 ,'2021-12-20 00:00:00-08',  12 ,'2022-12-20 00:00:00-08',  13 ,'20123-12-20 00:00:00-08',  14 ,'2024-12-20 00:00:00-08',  15 ,'2025-12-20 00:00:00-08', 16,'2026-12-20 00:00:00-08', 17,'2027-12-20 00:00:00-08', 18,'2028-12-20 00:00:00-08', 19,'2029-12-20 00:00:00-08', 'default');
 DECODE  
---------
 default
(1 row)

select DECODE(20, 1,'2011-12-20 09:00:00-08',2,'2012-12-20 12:00:00-08', 3, '2013-12-20 15:00:00-08', 4, '2014-12-20 00:00:00-08', 5,'2015-12-20 00:00:00-08',6 ,'2016-12-20 00:00:00-08', 7 ,'2017-12-20 00:00:00-08', 8 ,'2012-18-20 00:00:00-08', 9 ,'2019-12-20 00:00:00-08',  10 ,'2020-12-20 00:00:00-08',  11 ,'2021-12-20 00:00:00-08',  12 ,'2022-12-20 00:00:00-08',  13 ,'20123-12-20 00:00:00-08',  14 ,'2024-12-20 00:00:00-08',  15 ,'2025-12-20 00:00:00-08', 16,'2026-12-20 00:00:00-08', 17,'2027-12-20 00:00:00-08', 18,'2028-12-20 00:00:00-08', 19,'2029-12-20 00:00:00-08');
 DECODE 
--------
 
(1 row)

select DECODE(21, 1,'2011-12-20 09:00:00-08',2,'2012-12-20 12:00:00-08', 3, '2013-12-20 15:00:00-08', 4, '2014-12-20 00:00:00-08', 5,'2015-12-20 00:00:00-08',6 ,'2016-12-20 00:00:00-08', 7 ,'2017-12-20 00:00:00-08', 8 ,'2012-18-20 00:00:00-08', 9 ,'2019-12-20 00:00:00-08',  10 ,'2020-12-20 00:00:00-08',  11 ,'2021-12-20 00:00:00-08',  12 ,'2022-12-20 00:00:00-08',  13 ,'20123-12-20 00:00:00-08',  14 ,'2024-12-20 00:00:00-08',  15 ,'2025-12-20 00:00:00-08', 16,'2026-12-20 00:00:00-08', 17,'2027-12-20 00:00:00-08', 18,'2028-12-20 00:00:00-08', 19,'2029-12-20 00:00:00-08');
 DECODE 
--------
 
(1 row)

select DECODE(22, 1,'2011-12-20 09:00:00-08',2,'2012-12-20 12:00:00-08', 3, '2013-12-20 15:00:00-08', 4, '2014-12-20 00:00:00-08', 5,'2015-12-20 00:00:00-08',6 ,'2016-12-20 00:00:00-08', 7 ,'2017-12-20 00:00:00-08', 8 ,'2012-18-20 00:00:00-08', 9 ,'2019-12-20 00:00:00-08',  10 ,'2020-12-20 00:00:00-08',  11 ,'2021-12-20 00:00:00-08',  12 ,'2022-12-20 00:00:00-08',  13 ,'20123-12-20 00:00:00-08',  14 ,'2024-12-20 00:00:00-08',  15 ,'2025-12-20 00:00:00-08', 16,'2026-12-20 00:00:00-08', 17,'2027-12-20 00:00:00-08', 18,'2028-12-20 00:00:00-08', 19,'2029-12-20 00:00:00-08');
 DECODE 
--------
 
(1 row)

select DECODE(23, 1,'2011-12-20 09:00:00-08',2,'2012-12-20 12:00:00-08', 3, '2013-12-20 15:00:00-08', 4, '2014-12-20 00:00:00-08', 5,'2015-12-20 00:00:00-08',6 ,'2016-12-20 00:00:00-08', 7 ,'2017-12-20 00:00:00-08', 8 ,'2012-18-20 00:00:00-08', 9 ,'2019-12-20 00:00:00-08',  10 ,'2020-12-20 00:00:00-08',  11 ,'2021-12-20 00:00:00-08',  12 ,'2022-12-20 00:00:00-08',  13 ,'20123-12-20 00:00:00-08',  14 ,'2024-12-20 00:00:00-08',  15 ,'2025-12-20 00:00:00-08', 16,'2026-12-20 00:00:00-08', 17,'2027-12-20 00:00:00-08', 18,'2028-12-20 00:00:00-08', 19,'2029-12-20 00:00:00-08');
 DECODE 
--------
 
(1 row)

select DECODE(1.0::numeric,2::bigint,3::bigint,10::numeric);
 DECODE 
--------
     10
(1 row)

select DECODE(1.0::numeric,2::bigint,3::bigint,4::bigint,5::bigint,1::bigint,10::bigint);
 DECODE 
--------
     10
(1 row)

select DECODE(1.0::numeric,2::bigint,'3'::text,1::bigint,'10'::text);
 DECODE 
--------
 10
(1 row)

select DECODE(1::bigint,2::integer,3::integer,10.0::double precision);
 DECODE 
--------
     10
(1 row)

select DECODE(1::bigint,2::bigint,3::bigint,10.0::double precision);
 DECODE 
--------
     10
(1 row)

select DECODE(1::bigint,2::integer,3::integer,1::integer,10.0::integer);
 DECODE 
--------
     10
(1 row)

select DECODE(1::bigint,2::integer,3::integer,10::integer);
 DECODE 
--------
     10
(1 row)

select DECODE(1.0::numeric,2::integer,'3'::text,10::numeric);
 DECODE 
--------
 10
(1 row)

SELECT DECODE(null::text, 1, 'a', null, 'b', 'default');
 DECODE 
--------
 b
(1 row)

SELECT DECODE(1, null::text, 'a', 2, 'b', 1, 'c', 'default');
 DECODE 
--------
 c
(1 row)

WITH v_tmp AS
         (SELECT NULL col1, 'x' col2 FROM dual)
SELECT DECODE(tan(null),col1, 'a', 'default')
FROM v_tmp;
 DECODE 
--------
 a
(1 row)

WITH v_tmp AS
         (SELECT NULL col1, 'x' col2 FROM dual)
SELECT DECODE(col1,'null', 'a', 'b')
FROM v_tmp;
 DECODE 
--------
 b
(1 row)

WITH v_tmp AS
         (SELECT NULL col1, 'x' col2 FROM dual)
SELECT DECODE(null,col1, 'a', 'default')
FROM v_tmp;
 DECODE 
--------
 a
(1 row)

WITH v_tmp AS
         (SELECT NULL col1, 'x' col2 FROM dual)
SELECT DECODE(1, col1,'a', 'default')
FROM v_tmp;
 DECODE  
---------
 default
(1 row)

-- pre-process constant expression.
drop table if exists t2;
NOTICE:  table "T2" does not exist, skipping
create table t2(f1 int,f2 int);
insert into t2 values(1,0);
select DECODE(f2,0,0,12/f2*100) from t2;
 DECODE 
--------
      0
(1 row)

select DECODE(f2,0,0,12/0*100) from t2;
 DECODE 
--------
      0
(1 row)

select DECODE(f2,0,0,12/f2*100,0) from t2;
 DECODE 
--------
      0
(1 row)

select DECODE(f2,0,0,12/0*100,0) from t2;
 DECODE 
--------
      0
(1 row)

drop table if exists t2;
-- complicate case
drop table if exists t_student;
NOTICE:  table "T_STUDENT" does not exist, skipping
create table t_student(id int, name varchar2(20), age int, sex int);
insert into t_student values(1, '张三', 15, 1);
insert into t_student values(2, '李四', 20, 3);
insert into t_student values(3, '王五', 19, 2);
insert into t_student values(4, '李六', 30, 1);
select count(*) from t_student order by 1;    --should pass
 COUNT 
-------
     4
(1 row)

select count(*) from t_student order by 2;    --should error
ERROR:  ORDER BY position 2 is not in select list
LINE 1: select count(*) from t_student order by 2;
                                                ^
select count(*) from t_student order by id1;  --should error
ERROR:  column "ID1" does not exist
LINE 1: select count(*) from t_student order by id1;
                                                ^
HINT:  Perhaps you meant to reference the column "T_STUDENT.ID".
insert into t_student select * from t_student where id < 3;
select distinct count(1) over(partition by name) from t_student order by 1;
 COUNT 
-------
     1
     2
(2 rows)

select distinct count(1) over(partition by name) from t_student order by 1 desc;
 COUNT 
-------
     2
     1
(2 rows)

drop table t_student;
\c regression
drop table if exists t_student;
NOTICE:  table "t_student" does not exist, skipping
create table t_student(id int, name varchar(20), age int, sex int);
insert into t_student values(1, '张三', 15, 1);
insert into t_student values(2, '李四', 20, 3);
insert into t_student values(3, '王五', 19, 2);
insert into t_student values(4, '李六', 30, 1);
create or replace function errorout() returns int as
$$
begin
    return 1/0;
end; 
$$ language default_plsql;
select count(*) from t_student order by errorout(); --function should not be executed
ERROR:  division by zero
CONTEXT:  SQL statement "SELECT 1/0"
PL/pgSQL function errorout() line 3 at RETURN
drop function errorout;
drop table t_student;
\c regression_ora
-- test lpad
SELECT '|' || lpad('X123bcd'::char(8), 10) || '|';
   ?column?   
--------------
 |  X123bcd |
(1 row)

SELECT '|' || lpad('X123bcd'::char(8),  5) || '|';
 ?column? 
----------
 |X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::char(8), 1) || '|';
 ?column? 
----------
 |X|
(1 row)

SELECT '|' || lpad('X123bcd'::char(5), 10, '321X'::char(3)) || '|';
   ?column?   
--------------
 |32132X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::char(5),  5, '321X'::char(3)) || '|';
 ?column? 
----------
 |X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::char(5), 10, '321X'::text) || '|';
   ?column?   
--------------
 |321X3X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::char(5), 10, '321X'::varchar2(5)) || '|';
   ?column?   
--------------
 |321X3X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::char(5), 10, '321X'::nvarchar2(3)) || '|';
   ?column?   
--------------
 |32132X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::text, 10, '321X'::char(3)) || '|';
   ?column?   
--------------
 |321X123bcd|
(1 row)

SELECT '|' || lpad('X123bcd'::text,  5, '321X'::char(3)) || '|';
 ?column? 
----------
 |X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::varchar2(5), 10, '321X'::char(3)) || '|';
   ?column?   
--------------
 |32132X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::varchar2(5),  5, '321X'::char(3)) || '|';
 ?column? 
----------
 |X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::nvarchar2(5), 10, '321X'::char(3)) || '|';
   ?column?   
--------------
 |32132X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::nvarchar2(5),  5, '321X'::char(3)) || '|';
 ?column? 
----------
 |X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::text, 10) || '|';
   ?column?   
--------------
 |   X123bcd|
(1 row)

SELECT '|' || lpad('X123bcd'::text,  5) || '|';
 ?column? 
----------
 |X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::varchar2(10), 10) || '|';
   ?column?   
--------------
 |   X123bcd|
(1 row)

SELECT '|' || lpad('X123bcd'::varchar2(10), 5) || '|';
 ?column? 
----------
 |X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::nvarchar2(10), 10) || '|';
   ?column?   
--------------
 |   X123bcd|
(1 row)

SELECT '|' || lpad('X123bcd'::nvarchar2(10), 5) || '|';
 ?column? 
----------
 |X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::text, 10, '321X'::text) || '|';
   ?column?   
--------------
 |321X123bcd|
(1 row)

SELECT '|' || lpad('X123bcd'::text, 10, '321X'::varchar2(5)) || '|';
   ?column?   
--------------
 |321X123bcd|
(1 row)

SELECT '|' || lpad('X123bcd'::text, 10, '321X'::nvarchar2(3)) || '|';
   ?column?   
--------------
 |321X123bcd|
(1 row)

SELECT '|' || lpad('X123bcd'::varchar2(5), 10, '321X'::text) || '|';
   ?column?   
--------------
 |321X3X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::varchar2(5), 10, '321X'::varchar2(5)) || '|';
   ?column?   
--------------
 |321X3X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::varchar2(5), 10, '321X'::nvarchar2(5)) || '|';
   ?column?   
--------------
 |321X3X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::nvarchar2(5), 10, '321X'::text) || '|';
   ?column?   
--------------
 |321X3X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::nvarchar2(5), 10, '321X'::varchar2(5)) || '|';
   ?column?   
--------------
 |321X3X123b|
(1 row)

SELECT '|' || lpad('X123bcd'::nvarchar2(5), 10, '321X'::nvarchar2(5)) || '|';
   ?column?   
--------------
 |321X3X123b|
(1 row)

-- test lpad/rpad for multibyte character.
SELECT '甲骨文' ORA_STR, LENGTHB('甲骨文') ORA_STR_LENGTH,
       LPAD('甲骨文', 10, '$') ORA_LPAD_STR,
       LENGTHB(LPAD('甲骨文', 10, '$')) ORA_LPAD_STR_LENGTH
FROM dual;
 ORA_STR | ORA_STR_LENGTH | ORA_LPAD_STR | ORA_LPAD_STR_LENGTH 
---------+----------------+--------------+---------------------
 甲骨文  |              9 | $$$$甲骨文   |                  13
(1 row)

SELECT '甲骨文' ORA_STR, LENGTHB('甲骨文') ORA_STR_LENGTH,
       RPAD('甲骨文', 10, '$') ORA_RPAD_STR,
       LENGTHB(RPAD('甲骨文', 10, '$')) ORA_RPAD_STR_LENGTH
FROM dual;
 ORA_STR | ORA_STR_LENGTH | ORA_RPAD_STR | ORA_RPAD_STR_LENGTH 
---------+----------------+--------------+---------------------
 甲骨文  |              9 | 甲骨文$$$$   |                  13
(1 row)

-- test lpad/rpad data type
SELECT lpad('0ab', 10, '1cd') from dual;
    LPAD    
------------
 1cd1cd10ab
(1 row)

SELECT lpad(0, 10, 1) from dual;
    LPAD    
------------
 1111111110
(1 row)

SELECT lpad(0, 10, '1') from dual;
    LPAD    
------------
 1111111110
(1 row)

SELECT lpad('0', 10, 1) from dual;
    LPAD    
------------
 1111111110
(1 row)

SELECT lpad('1', 10) from dual;
    LPAD    
------------
          1
(1 row)

SELECT lpad(1, 10) from dual;
    LPAD    
------------
          1
(1 row)

-- test lpad/rpad/instr. string/numeric input fot int4 params.
SELECT lpad('hi', '5'::text, 'xy');
 LPAD  
-------
 xyxhi
(1 row)

SELECT lpad('hi', '5'::varchar, 'xy');
 LPAD  
-------
 xyxhi
(1 row)

SELECT lpad('hi', 5.12, 'xy') from dual;
 LPAD  
-------
 xyxhi
(1 row)

SELECT lpad('hi', 5.89, 'xy') from dual;
 LPAD  
-------
 xyxhi
(1 row)

SELECT lpad('hi', '-5a', 'xy');
ERROR:  invalid input syntax for type numeric: "-5a"
LINE 1: SELECT lpad('hi', '-5a', 'xy');
                          ^
SELECT rpad('hi', '5'::text, 'xy');
 RPAD  
-------
 hixyx
(1 row)

SELECT rpad('hi', '5'::varchar, 'xy');
 RPAD  
-------
 hixyx
(1 row)

SELECT rpad('hi', 5.12, 'xy');
 RPAD  
-------
 hixyx
(1 row)

SELECT rpad('hi', 5.89, 'xy') from dual;
 RPAD  
-------
 hixyx
(1 row)

SELECT rpad('hi', '-5a', 'xy');
ERROR:  invalid input syntax for type numeric: "-5a"
LINE 1: SELECT rpad('hi', '-5a', 'xy');
                          ^
select instr('Tech on the net', 'e', '1', '1') = 2;
 ?column? 
----------
 t
(1 row)

select instr('Tech on the net', 'e', '1'::text, '2'::text) = 11;
 ?column? 
----------
 t
(1 row)

select instr('Tech on the net', 'e', 1.12, 2.65) = 11;
 ?column? 
----------
 t
(1 row)

select instr('Tech on the net', 'e', 1.12, 3.12) = 14;
 ?column? 
----------
 t
(1 row)

select instr('Tech on the net', 'e', '-3'::varchar, '2'::varchar) = 2;
 ?column? 
----------
 t
(1 row)

select instr('Tech on the net', 'e', '1', '4a') from dual;
ERROR:  invalid input syntax for type numeric: "4a"
LINE 1: select instr('Tech on the net', 'e', '1', '4a') from dual;
                                                  ^
--test lpad/rpad, parm2 <= 0
select nvl(rpad('你好,china', -1, 'acd'), '-1') from dual;
 NVL 
-----
 -1
(1 row)

select nvl(lpad('你好, china', -1, 'acd' ), '- 1') from dual;
 NVL 
-----
 - 1
(1 row)

--test regexp_replace function
SELECT regexp_replace('abc1def2', '[[:digit:]]','@',1,2) output  from dual;
  OUTPUT  
----------
 abc1def@
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',1,'1') output  from dual;
  OUTPUT  
----------
 abc@def2
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',1,to_number(2)::int) output  from dual;
  OUTPUT  
----------
 abc1def@
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',1,2.1::int) output  from dual;
  OUTPUT  
----------
 abc1def@
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',1,to_char(1)::int) output  from dual;
  OUTPUT  
----------
 abc@def2
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',1,to_char(1)::int) output  from dual;
  OUTPUT  
----------
 abc@def2
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',1,power(1,1)::int) output  from dual;
  OUTPUT  
----------
 abc@def2
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',4) output  from dual;
  OUTPUT  
----------
 abc@def@
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',5) output  from dual;
  OUTPUT  
----------
 abc1def@
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',1000000) output  from dual;
  OUTPUT  
----------
 abc1def2
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@','5') output  from dual;
  OUTPUT  
----------
 abc1def@
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',5.5::int) output  from dual;
  OUTPUT  
----------
 abc1def@
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',to_char(5)) output  from dual;
  OUTPUT  
----------
 abc1def@
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]','@',power(1,1)::int) output  from dual;
  OUTPUT  
----------
 abc@def@
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]D','@',1,1,'i') output  from dual;
 OUTPUT  
---------
 abc@ef2
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]]D','@',1,1,'c') output  from dual;
  OUTPUT  
----------
 abc1def2
(1 row)

SELECT regexp_replace('abc1
def2', '[[:digit:]].d','@',1,1,'n') output  from dual;
 OUTPUT  
---------
 abc@ef2
(1 row)

SELECT regexp_replace('abc1
def2', '[[:digit:]].d','#',1,1,'xic') output  from dual;
 OUTPUT 
--------
 abc1  +
 def2
(1 row)

SELECT regexp_replace('abc1def2', '[[:digit:]] d','@',1,1,'x') output  from dual;
 OUTPUT  
---------
 abc@ef2
(1 row)

select regexp_replace('abcxxx#%
adfbc','^a','@',1,2,'n') from dual;
 REGEXP_REPLACE 
----------------
 abcxxx#%      +
 adfbc
(1 row)

select regexp_replace('abcxxx#%
adfbc','^a','@',1,2,'c') from dual;
 REGEXP_REPLACE 
----------------
 abcxxx#%      +
 adfbc
(1 row)

SELECT regexp_replace('', '', '1', 1, 0)
regexp_replace FROM DUAL;
 REGEXP_REPLACE 
----------------
 
(1 row)

SELECT opentenbase_ora.regexp_replace('', '', '', 1, 0) regexp_replace FROM DUAL;
 REGEXP_REPLACE 
----------------
 
(1 row)

select opentenbase_ora.REGEXP_REPLACE('i,aaaaa,bbi,ccc', ',', '') from dual;
 REGEXP_REPLACE 
----------------
 iaaaaabbiccc
(1 row)

select opentenbase_ora.REGEXP_REPLACE('i,aaaaa,bbi,ccc', ',', null) from dual;
 REGEXP_REPLACE 
----------------
 iaaaaabbiccc
(1 row)

SELECT opentenbase_ora.regexp_replace('abc1def2', '[[:digit:]]D','@',1,1,'') output  from dual;
  OUTPUT  
----------
 abc1def2
(1 row)

SELECT opentenbase_ora.regexp_replace('abc1def2', '[[:digit:]]D','@',1,1,null) output  from dual;
  OUTPUT  
----------
 abc1def2
(1 row)

SELECT opentenbase_ora.regexp_replace('abc1def2', '[[:digit:]]','@',1,'') output  from dual;
 OUTPUT 
--------
 
(1 row)

SELECT opentenbase_ora.regexp_replace('abc1def2', '[[:digit:]]D','@', null, 1) output  from dual;
 OUTPUT 
--------
 
(1 row)

select opentenbase_ora.regexp_replace('abcxxx', 'xx') from dual;
 REGEXP_REPLACE 
----------------
 abcx
(1 row)

select opentenbase_ora.regexp_replace('abcxxx', '') from dual;
 REGEXP_REPLACE 
----------------
 abcxxx
(1 row)

SELECT opentenbase_ora.regexp_replace('abc1def2', '[[:digit:]]','@', '') output  from dual;
 OUTPUT 
--------
 
(1 row)

SELECT opentenbase_ora.regexp_replace('abc1def2', '[[:digit:]]D','@', null) output  from dual;
 OUTPUT 
--------
 
(1 row)

SELECT opentenbase_ora.regexp_replace('abc1def2', '[[:digit:]]D','@','', 1,'x') output  from dual;
 OUTPUT 
--------
 
(1 row)

SELECT opentenbase_ora.regexp_replace('abc1def2', '[[:digit:]]D','@',3, null,'x') output  from dual;
 OUTPUT 
--------
 
(1 row)

SELECT opentenbase_ora.regexp_replace('abc1def2', '[[:digit:]]D','@',3, '','x') output  from dual;
 OUTPUT 
--------
 
(1 row)

-- fix customer issue:877165291
\c regression
select regexp_replace('aaaaaaaaa', '[^0-9]',',') from dual;
 regexp_replace 
----------------
 ,aaaaaaaa
(1 row)

select regexp_replace('aaaaaaaaa', '[^0-9]','') from dual;
 regexp_replace 
----------------
 aaaaaaaa
(1 row)

select regexp_replace('aaaaaaaaa', null,',') from dual;
 regexp_replace 
----------------
 
(1 row)

select regexp_replace('aaaaaaaaa', null, null) from dual;
 regexp_replace 
----------------
 
(1 row)

select regexp_replace(null, null, null) from dual;
 regexp_replace 
----------------
 
(1 row)

select regexp_replace(null, 'a', null) from dual;
 regexp_replace 
----------------
 
(1 row)

select regexp_replace(null, 'a', 'a') from dual;
 regexp_replace 
----------------
 
(1 row)

\c regression_ora
select regexp_replace('aaaaaaaaa', '[^0-9]',',') from dual;
 REGEXP_REPLACE 
----------------
 ,,,,,,,,,
(1 row)

select regexp_replace('aaaaaaaaa', '[^0-9]','') from dual;
 REGEXP_REPLACE 
----------------
 
(1 row)

select regexp_replace('aaaaaaaaa', null,',') from dual;
 REGEXP_REPLACE 
----------------
 aaaaaaaaa
(1 row)

select regexp_replace('aaaaaaaaa', null, null) from dual;
 REGEXP_REPLACE 
----------------
 aaaaaaaaa
(1 row)

select regexp_replace(null, null, null) from dual;
 REGEXP_REPLACE 
----------------
 
(1 row)

select regexp_replace(null, 'a', null) from dual;
 REGEXP_REPLACE 
----------------
 
(1 row)

select regexp_replace(null, 'a', 'a') from dual;
 REGEXP_REPLACE 
----------------
 
(1 row)

--test regexp_count function
select regexp_count('abcdfbc','Bc',1,'i') from dual;
 REGEXP_COUNT 
--------------
            2
(1 row)

select regexp_count('abcdfBc','Bc',1,'c') from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count('ab
cdfbc','b.c',1,'n') from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count('ab
cdfbc','b.c',1,'i') from dual;
 REGEXP_COUNT 
--------------
            0
(1 row)

select regexp_count('abcxxx#%
adfbc','^a',1,'m') from dual;
 REGEXP_COUNT 
--------------
            2
(1 row)

select regexp_count('abcxxx#%
adfbc','^a',1,'i') from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count('abcxxx#%
adfbc','^a',1,'n') from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count('abcxxx#%
adfbc','^a',1,'x') from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count('abcxxx#%
adfbc','^a',1,'c') from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count('abcvvbcvvb c','b c',1,'x') from dual;
 REGEXP_COUNT 
--------------
            2
(1 row)

select regexp_count('abcvvbcvvb c','b c',1,'n') from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count('abcvvbcvvBC','bc',1,'ic') from dual;
 REGEXP_COUNT 
--------------
            2
(1 row)

select regexp_count('abcvvbcvvBC','bc',1,'ci') from dual;
 REGEXP_COUNT 
--------------
            3
(1 row)

select regexp_count('abcvvbcvvBC','b c',1,'ix') from dual;
 REGEXP_COUNT 
--------------
            3
(1 row)

select regexp_count('abcvvb
cvvB
C','b.c',1,'in') from dual;
 REGEXP_COUNT 
--------------
            2
(1 row)

select regexp_count('abcvvb cvvB C','b c') from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count('abacvvb
cvvB C','b.c') from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count('abc
abc','bc?') from dual;
 REGEXP_COUNT 
--------------
            2
(1 row)

select regexp_count('abcvvbcvvbc','bc',2.9::int,'c') from dual;
 REGEXP_COUNT 
--------------
            2
(1 row)

select regexp_count('abcvvbcvvbc','bc',exp(2)::int,'c') from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count('abcvvbcvvbc','bc','1','c') from dual;
 REGEXP_COUNT 
--------------
            3
(1 row)

select regexp_count('abcvvbcvvbc','bc',-1,'c') from dual;
ERROR:  Invalid "position" value (-1) for "regexp_count"
HINT:  "position" must be a positive integer
select regexp_count('abcvvbcvvbc','bc',1000000,'c') from dual;
 REGEXP_COUNT 
--------------
            0
(1 row)

select regexp_count('12345','123',1) from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

-- TODO: enable this case after opentenbase_ora datetime functions are merged
select regexp_count(to_date('2016-01-31', 'yyyy-mm-dd'), '31', 1) from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count(to_timestamp('2016-01-31', 'yyyy-mm-dd'), '31', 1) from dual;
 REGEXP_COUNT 
--------------
            1
(1 row)

select regexp_count('abcvvbcvvbc','bc',2.1::int,'c') from dual;
 REGEXP_COUNT 
--------------
            3
(1 row)

select regexp_count(null,'',1,'i') from dual;
 REGEXP_COUNT 
--------------
             
(1 row)

select regexp_count('','',1,'i') from dual;
 REGEXP_COUNT 
--------------
             
(1 row)

--test regexp_substr function
SELECT regexp_substr('abc1def2', '[[:digit:]]',1,2::bigint) output  from dual;
 OUTPUT 
--------
 2
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]',1::bigint,'1') output  from dual;
 OUTPUT 
--------
 1
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]',1,to_number(2)::bigint) output  from dual;
 OUTPUT 
--------
 2
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]',1,2.1::int) output  from dual;
 OUTPUT 
--------
 2
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]',1,to_char(1)::int) output  from dual;
 OUTPUT 
--------
 1
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]',1,power(2,1)::bigint) output  from dual;
 OUTPUT 
--------
 2
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]',4::int) output  from dual;
 OUTPUT 
--------
 1
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]',5::bigint) output  from dual;
 OUTPUT 
--------
 2
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]',1000000) output  from dual;
 OUTPUT 
--------
 
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]','5'::int) output  from dual;
 OUTPUT 
--------
 2
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]',5.5::bigint) output  from dual;
 OUTPUT 
--------
 2
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]',to_char(5)::int) output  from dual;
 OUTPUT 
--------
 2
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]',power(5,1)::int) output  from dual;
 OUTPUT 
--------
 2
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]D',1,1,'i') output  from dual;
 OUTPUT 
--------
 1d
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]]D',1,1,'c') output  from dual;
 OUTPUT 
--------
 
(1 row)

SELECT regexp_substr('abc1
def2', '[[:digit:]].d',1,1,'n') output  from dual;
 OUTPUT 
--------
 1     +
 d
(1 row)

SELECT regexp_substr('abc1
def2', '[[:digit:]].d',1,1,'i') output  from dual;
 OUTPUT 
--------
 
(1 row)

SELECT regexp_substr('abc1def2', '[[:digit:]] d',1,1,'x') output  from dual;
 OUTPUT 
--------
 1d
(1 row)

select regexp_substr('abcxxx#%
adfbc','^a',1,2,'m') from dual;
 REGEXP_SUBSTR 
---------------
 a
(1 row)

select regexp_substr('abcxxx#%
adfbc','^a',1,2,'n') from dual;
 REGEXP_SUBSTR 
---------------
 
(1 row)

select regexp_substr('abcxxx#%
adfbc','^a',1,2,'i') from dual;
 REGEXP_SUBSTR 
---------------
 
(1 row)

select regexp_substr('abcxxx#%
adfbc','^a',1,2,'x') from dual;
 REGEXP_SUBSTR 
---------------
 
(1 row)

select regexp_substr('abcxxx#%
adfbc','^a',1,2,'c') from dual;
 REGEXP_SUBSTR 
---------------
 
(1 row)

SELECT REGEXP_SUBSTR('123', '12', 1, 1)  FROM DUAL;
 REGEXP_SUBSTR 
---------------
 12
(1 row)

SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 4)  FROM DUAL;
 REGEXP_SUBSTR 
---------------
 78
(1 row)

SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 1)  FROM DUAL;
 REGEXP_SUBSTR 
---------------
 123
(1 row)

SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 9::bigint)  FROM DUAL;
 REGEXP_SUBSTR 
---------------
 
(1 row)

SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 0)  FROM DUAL;
 REGEXP_SUBSTR 
---------------
 12345678
(1 row)

SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 4.5::bigint) FROM DUAL;
 REGEXP_SUBSTR 
---------------
 
(1 row)

SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', to_char(4)::int)  FROM DUAL;
 REGEXP_SUBSTR 
---------------
 78
(1 row)

SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i',power(2,2)::bigint)  FROM DUAL;
 REGEXP_SUBSTR 
---------------
 78
(1 row)

SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', '4')  FROM DUAL;
 REGEXP_SUBSTR 
---------------
 78
(1 row)

SELECT REGEXP_SUBSTR('1234567890abcdefg', '(1)(2)(3)(4)(5)(6)(7)(8)(9)(0)(a)(b)', 1, 1, 'i', 10::bigint)  FROM DUAL;
ERROR:  Invalid "subexpr" value (10) for "regexp_substr"
HINT:  "subexpr" must be a nonnegative integer from 0 to 9
SELECT REGEXP_SUBSTR('', '', 1, 1, '0') FROM DUAL;
 REGEXP_SUBSTR 
---------------
 
(1 row)

SELECT REGEXP_SUBSTR(null, null, 1, 1, '0') FROM DUAL;
 REGEXP_SUBSTR 
---------------
 
(1 row)

\c regression_ora
--test nchr function
select nchr(256);
 NCHR 
------
 Ā
(1 row)

select nchr(257);
 NCHR 
------
 ā
(1 row)

select nchr(258);
 NCHR 
------
 Ă
(1 row)

select nchr(420);
 NCHR 
------
 Ƥ
(1 row)

select nchr(-1);
ERROR:  requested character too large for encoding: -1
select nchr(10241234);
ERROR:  requested character too large for encoding: 10241234
select nchr(1024123);
 NCHR 
------
 󺁻
(1 row)

select nchr('1234');
 NCHR 
------
 Ӓ
(1 row)

select nchr(to_char(97)::int);
 NCHR 
------
 a
(1 row)

-- test number like text
select 9999 like '9%' from dual;
 ?column? 
----------
 t
(1 row)

select 9999 like '09%' from dual;
 ?column? 
----------
 f
(1 row)

select 9999 ilike '9%' from dual;
 ?column? 
----------
 t
(1 row)

select 9999 ilike '09%' from dual;
 ?column? 
----------
 f
(1 row)

select 9999 not like '9%' from dual;
 ?column? 
----------
 f
(1 row)

select 9999 not like '09%' from dual;
 ?column? 
----------
 t
(1 row)

select 9999 not ilike '9%' from dual;
 ?column? 
----------
 f
(1 row)

select 9999 not ilike '09%' from dual;
 ?column? 
----------
 t
(1 row)

create table t_nlssort_regress (f1 integer,f2 varchar2(10),f3 varchar(255));
insert into t_nlssort_regress values(1,'深圳','深圳abcdefghijklmnopqrstuvwxyz');
insert into t_nlssort_regress values(2,'中国','中国ABCDEFGHIJKLMNOPQRSTUVWXYZ');
insert into t_nlssort_regress values(3,'PG','PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ');
insert into t_nlssort_regress values(4,'OpenTenBase','OpenTenBase_abcdefghijklmnopqrstuvwxyz');
insert into t_nlssort_regress values(5,'PG中国','PG中国_abcdefghijklmnopqrstuvwxyz');
--test function NLS_UPPER
SELECT nls_upper(f3) FROM t_nlssort_regress order by f1;
             NLS_UPPER             
-----------------------------------
 深圳ABCDEFGHIJKLMNOPQRSTUVWXYZ
 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
 PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
 OPENTENBASE_ABCDEFGHIJKLMNOPQRSTUVWXYZ
 PG中国_ABCDEFGHIJKLMNOPQRSTUVWXYZ
(5 rows)

SELECT nls_upper(f3,'NLS_SORT = zh_CN.gb2312') FROM t_nlssort_regress order by f1;
             NLS_UPPER             
-----------------------------------
 深圳ABCDEFGHIJKLMNOPQRSTUVWXYZ
 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
 PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
 OPENTENBASE_ABCDEFGHIJKLMNOPQRSTUVWXYZ
 PG中国_ABCDEFGHIJKLMNOPQRSTUVWXYZ
(5 rows)

SELECT nls_upper(f3,'NLS_SORT = zh_CN.UTF8') FROM t_nlssort_regress order by f1;
             NLS_UPPER             
-----------------------------------
 深圳ABCDEFGHIJKLMNOPQRSTUVWXYZ
 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
 PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
 OPENTENBASE_ABCDEFGHIJKLMNOPQRSTUVWXYZ
 PG中国_ABCDEFGHIJKLMNOPQRSTUVWXYZ
(5 rows)

SELECT * FROM t_nlssort_regress order by nls_upper(f3,'NLS_SORT = SCHINESE_PINYIN_M') ;
 F1 |   F2   |                F3                 
----+--------+-----------------------------------
  3 | PG     | PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
  5 | PG中国 | PG中国_abcdefghijklmnopqrstuvwxyz
  4 | OpenTenBase  | OpenTenBase_abcdefghijklmnopqrstuvwxyz
  2 | 中国   | 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
  1 | 深圳   | 深圳abcdefghijklmnopqrstuvwxyz
(5 rows)

SELECT * FROM t_nlssort_regress order by nls_upper(f3,'NLS_SORT = zh_CN.UTF8') ;
 F1 |   F2   |                F3                 
----+--------+-----------------------------------
  3 | PG     | PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
  5 | PG中国 | PG中国_abcdefghijklmnopqrstuvwxyz
  4 | OpenTenBase  | OpenTenBase_abcdefghijklmnopqrstuvwxyz
  2 | 中国   | 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
  1 | 深圳   | 深圳abcdefghijklmnopqrstuvwxyz
(5 rows)

SELECT * FROM t_nlssort_regress order by nls_upper(f3,'NLS_SORT = zh_CN.gb2312') ;
 F1 |   F2   |                F3                 
----+--------+-----------------------------------
  3 | PG     | PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
  5 | PG中国 | PG中国_abcdefghijklmnopqrstuvwxyz
  4 | OpenTenBase  | OpenTenBase_abcdefghijklmnopqrstuvwxyz
  2 | 中国   | 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
  1 | 深圳   | 深圳abcdefghijklmnopqrstuvwxyz
(5 rows)

SELECT * FROM t_nlssort_regress order by nls_upper(f3,'NLS_SORT = zh_CN.gb18030') ;
 F1 |   F2   |                F3                 
----+--------+-----------------------------------
  3 | PG     | PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
  5 | PG中国 | PG中国_abcdefghijklmnopqrstuvwxyz
  4 | OpenTenBase  | OpenTenBase_abcdefghijklmnopqrstuvwxyz
  2 | 中国   | 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
  1 | 深圳   | 深圳abcdefghijklmnopqrstuvwxyz
(5 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_upper(f3,'NLS_SORT = SCHINESE_PINYIN_M') ;
 COUNT 
-------
     1
     1
     1
     1
     1
(5 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_upper(f3,'NLS_SORT = SCHINESE_STROKE_M') ;
 COUNT 
-------
     1
     1
     1
     1
     1
(5 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_upper(f3,'NLS_SORT = SCHINESE_RADICAL_M') ;
 COUNT 
-------
     1
     1
     1
     1
     1
(5 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_upper(f3,'NLS_SORT = zh_CN.UTF8') ;
 COUNT 
-------
     1
     1
     1
     1
     1
(5 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_upper(f3,'NLS_SORT = zh_CN.gb2312') ;
 COUNT 
-------
     1
     1
     1
     1
     1
(5 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_upper(f3,'NLS_SORT = zh_CN.gb18030') ;
 COUNT 
-------
     1
     1
     1
     1
     1
(5 rows)

insert into t_nlssort_regress values (6,nls_upper('aBCCCaaaa'));
select * from t_nlssort_regress order by f1;
 F1 |    F2     |                F3                 
----+-----------+-----------------------------------
  1 | 深圳      | 深圳abcdefghijklmnopqrstuvwxyz
  2 | 中国      | 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
  3 | PG        | PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
  4 | OpenTenBase     | OpenTenBase_abcdefghijklmnopqrstuvwxyz
  5 | PG中国    | PG中国_abcdefghijklmnopqrstuvwxyz
  6 | ABCCCAAAA | 
(6 rows)

--test function NLS_LOWER
SELECT nls_lower(f3) FROM t_nlssort_regress order by f1;
             NLS_LOWER             
-----------------------------------
 深圳abcdefghijklmnopqrstuvwxyz
 中国abcdefghijklmnopqrstuvwxyz
 pg_abcdefghijklmnopqrstuvwxyz
 opentenbase_abcdefghijklmnopqrstuvwxyz
 pg中国_abcdefghijklmnopqrstuvwxyz
 
(6 rows)

SELECT nls_lower(f3,'zh_CN.gb2312') FROM t_nlssort_regress order by f1;;
             NLS_LOWER             
-----------------------------------
 深圳abcdefghijklmnopqrstuvwxyz
 中国abcdefghijklmnopqrstuvwxyz
 pg_abcdefghijklmnopqrstuvwxyz
 opentenbase_abcdefghijklmnopqrstuvwxyz
 pg中国_abcdefghijklmnopqrstuvwxyz
 
(6 rows)

SELECT nls_lower(f3,'zh_CN.UTF8') FROM t_nlssort_regress order by f1;
             NLS_LOWER             
-----------------------------------
 深圳abcdefghijklmnopqrstuvwxyz
 中国abcdefghijklmnopqrstuvwxyz
 pg_abcdefghijklmnopqrstuvwxyz
 opentenbase_abcdefghijklmnopqrstuvwxyz
 pg中国_abcdefghijklmnopqrstuvwxyz
 
(6 rows)

SELECT * FROM t_nlssort_regress order by nls_lower(f3,'NLS_SORT = SCHINESE_PINYIN_M') ;
 F1 |    F2     |                F3                 
----+-----------+-----------------------------------
  3 | PG        | PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
  5 | PG中国    | PG中国_abcdefghijklmnopqrstuvwxyz
  4 | OpenTenBase     | OpenTenBase_abcdefghijklmnopqrstuvwxyz
  2 | 中国      | 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
  1 | 深圳      | 深圳abcdefghijklmnopqrstuvwxyz
  6 | ABCCCAAAA | 
(6 rows)

SELECT * FROM t_nlssort_regress order by nls_lower(f3,'NLS_SORT = zh_CN.UTF8') ;
 F1 |    F2     |                F3                 
----+-----------+-----------------------------------
  3 | PG        | PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
  5 | PG中国    | PG中国_abcdefghijklmnopqrstuvwxyz
  4 | OpenTenBase     | OpenTenBase_abcdefghijklmnopqrstuvwxyz
  2 | 中国      | 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
  1 | 深圳      | 深圳abcdefghijklmnopqrstuvwxyz
  6 | ABCCCAAAA | 
(6 rows)

SELECT * FROM t_nlssort_regress order by nls_lower(f3,'NLS_SORT = zh_CN.gb2312') ;
 F1 |    F2     |                F3                 
----+-----------+-----------------------------------
  3 | PG        | PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
  5 | PG中国    | PG中国_abcdefghijklmnopqrstuvwxyz
  4 | OpenTenBase     | OpenTenBase_abcdefghijklmnopqrstuvwxyz
  2 | 中国      | 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
  1 | 深圳      | 深圳abcdefghijklmnopqrstuvwxyz
  6 | ABCCCAAAA | 
(6 rows)

SELECT * FROM t_nlssort_regress order by nls_lower(f3,'NLS_SORT = zh_CN.gb18030') ;
 F1 |    F2     |                F3                 
----+-----------+-----------------------------------
  3 | PG        | PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
  5 | PG中国    | PG中国_abcdefghijklmnopqrstuvwxyz
  4 | OpenTenBase     | OpenTenBase_abcdefghijklmnopqrstuvwxyz
  2 | 中国      | 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
  1 | 深圳      | 深圳abcdefghijklmnopqrstuvwxyz
  6 | ABCCCAAAA | 
(6 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_lower(f3,'NLS_SORT = SCHINESE_PINYIN_M') ;
 COUNT 
-------
     1
     1
     1
     1
     1
     1
(6 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_lower(f3,'NLS_SORT = SCHINESE_STROKE_M') ;
 COUNT 
-------
     1
     1
     1
     1
     1
     1
(6 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_lower(f3,'NLS_SORT = SCHINESE_RADICAL_M') ;
 COUNT 
-------
     1
     1
     1
     1
     1
     1
(6 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_lower(f3,'NLS_SORT = zh_CN.UTF8') ;
 COUNT 
-------
     1
     1
     1
     1
     1
     1
(6 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_lower(f3,'NLS_SORT = zh_CN.gb2312') ;
 COUNT 
-------
     1
     1
     1
     1
     1
     1
(6 rows)

SELECT count(1) FROM t_nlssort_regress group by nls_lower(f3,'NLS_SORT = zh_CN.gb18030') ;
 COUNT 
-------
     1
     1
     1
     1
     1
     1
(6 rows)

insert into t_nlssort_regress values (7,nls_lower('aBCCCaaaa'));
select * from t_nlssort_regress order by f1;
 F1 |    F2     |                F3                 
----+-----------+-----------------------------------
  1 | 深圳      | 深圳abcdefghijklmnopqrstuvwxyz
  2 | 中国      | 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
  3 | PG        | PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
  4 | OpenTenBase     | OpenTenBase_abcdefghijklmnopqrstuvwxyz
  5 | PG中国    | PG中国_abcdefghijklmnopqrstuvwxyz
  6 | ABCCCAAAA | 
  7 | abcccaaaa | 
(7 rows)

--get correct encoding
SELECT * FROM t_nlssort_regress order by nls_upper(f3,'NLS_SORT = zh_CN.18030') ;
 F1 |    F2     |                F3                 
----+-----------+-----------------------------------
  3 | PG        | PG_ABCDEFGHIJKLMNOPQRSTUVWXYZ
  5 | PG中国    | PG中国_abcdefghijklmnopqrstuvwxyz
  4 | OpenTenBase     | OpenTenBase_abcdefghijklmnopqrstuvwxyz
  2 | 中国      | 中国ABCDEFGHIJKLMNOPQRSTUVWXYZ
  1 | 深圳      | 深圳abcdefghijklmnopqrstuvwxyz
  6 | ABCCCAAAA | 
  7 | abcccaaaa | 
(7 rows)

drop table t_nlssort_regress;
-- test offset n
SET client_min_messages = warning;
drop table if exists test_t;
create table test_t(id varchar2(20));
insert into test_t values('1');
insert into test_t values(23);
insert into test_t values(24);
insert into test_t values(25);
select * from test_t order by id;
 ID 
----
 1
 23
 24
 25
(4 rows)

select * from test_t order by id limit 4 offset 0;
 ID 
----
 1
 23
 24
 25
(4 rows)

select * from test_t order by id limit 4 offset 1;
 ID 
----
 23
 24
 25
(3 rows)

select * from test_t order by id limit 4 offset 2;
 ID 
----
 24
 25
(2 rows)

drop table test_t;
-- test order/group by non-int const
create table test_ord(a int, b int);
explain (costs off) select * from test_ord order by 'any char'; -- no order by
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Seq Scan on TEST_ORD
(3 rows)

explain (costs off) select a from test_ord group by 'any char', 1;
               QUERY PLAN               
----------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  HashAggregate
         Group Key: 'any char'::TEXT, A
         ->  Seq Scan on TEST_ORD
(5 rows)

explain (costs off) select * from test_ord order by 1;
                QUERY PLAN                 
-------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   Sort Key: A
   ->  Sort
         Sort Key: A
         ->  Seq Scan on TEST_ORD
(5 rows)

drop table test_ord;
--
select substring(ltrim(to_char(sysdate,'yyyy')), 1,2) FROM dual;
 SUBSTRING 
-----------
 20
(1 row)

select to_char('1234', 'xxxxx') from dual;
 TO_CHAR 
---------
    4d2
(1 row)

select to_char('1234.23', 'xxxxx') from dual;
 TO_CHAR 
---------
    4d2
(1 row)

select to_char(NULL, 'xxxxx') from dual;
 TO_CHAR 
---------
 
(1 row)

select to_char('1234.23', NULL) from dual;
 TO_CHAR 
---------
 
(1 row)

select to_char(NULL, NULL) from dual;
 TO_CHAR 
---------
 
(1 row)

-- test remainder
\c regression_ora
select mod(3, 0), remainder(3, 0) from dual;
ERROR:  division by zero
select mod(3, 1), remainder(3, 1) from dual;
 MOD | REMAINDER 
-----+-----------
   0 |         0
(1 row)

select mod(1, 3), remainder(1, 3) from dual;
 MOD | REMAINDER 
-----+-----------
   1 |         1
(1 row)

select mod(32767, 32767), remainder(32767, 32767) from dual;
 MOD | REMAINDER 
-----+-----------
   0 |         0
(1 row)

select mod(0.0, 1234.5678), remainder(0.0, 1234.5678) from dual;
 MOD | REMAINDER 
-----+-----------
   0 |         0
(1 row)

select mod(1234.5678, 0.0), remainder(1234.5678, 0.0) from dual;
ERROR:  division by zero
select mod(11234.5678, 9638.5632), remainder(11234.5678, 9638.5632) from dual;
    MOD    | REMAINDER 
-----------+-----------
 1596.0046 | 1596.0046
(1 row)

select mod(-0.0, 1234.5678), remainder(-0.0, 1234.5678) from dual;
 MOD | REMAINDER 
-----+-----------
   0 |         0
(1 row)

select mod(-1234.5678, 0.0), remainder(-1234.5678, 0.0) from dual;
ERROR:  division by zero
select mod(-11234.5678, 9638.5632), remainder(-11234.5678, 9638.5632) from dual;
    MOD     | REMAINDER  
------------+------------
 -1596.0046 | -1596.0046
(1 row)

select mod(1.5, 2), remainder(1.5, 2) from dual;
 MOD | REMAINDER 
-----+-----------
 1.5 |       -.5
(1 row)

select mod(1.522322, 2), remainder(1.522322, 2) from dual;
   MOD    | REMAINDER 
----------+-----------
 1.522322 |  -.477678
(1 row)

select mod(1.322322, 2), remainder(1.322322, 2) from dual;
   MOD    | REMAINDER 
----------+-----------
 1.322322 |  -.677678
(1 row)

select mod(-32768, 3), remainder(-32768, 3) from dual;
 MOD | REMAINDER 
-----+-----------
  -2 |         1
(1 row)

select mod(-5, 3), remainder(-5, 3) from dual;
 MOD | REMAINDER 
-----+-----------
  -2 |         1
(1 row)

select mod(-5, -3), remainder(-5, -3) from dual;
 MOD | REMAINDER 
-----+-----------
  -2 |         1
(1 row)

select mod(-6, 3), remainder(-6, 3) from dual;
 MOD | REMAINDER 
-----+-----------
   0 |         0
(1 row)

-- test remainder insert data
create table t_id(id int);
insert into t_id values(generate_series(1, 5));
create table t_data(a int, b int, c text , d text);
insert into t_data select mod(id,2), remainder(id,3), id, id from t_id;
select * from t_data order by d;
 A | B  | C | D 
---+----+---+---
 1 |  1 | 1 | 1
 0 | -1 | 2 | 2
 1 |  0 | 3 | 3
 0 |  1 | 4 | 4
 1 | -1 | 5 | 5
(5 rows)

drop table t_id;
drop table t_data;
-- remainder other combinations
select remainder(6.7, 2) from dual;
 REMAINDER 
-----------
        .7
(1 row)

select remainder(6.7, 2.3) from dual;
 REMAINDER 
-----------
       -.2
(1 row)

select remainder(6.7, 2.6) from dual;
 REMAINDER 
-----------
      -1.1
(1 row)

select remainder(6.7, 1.5) from dual;
 REMAINDER 
-----------
        .7
(1 row)

select remainder(6.7, 1.3) from dual;
 REMAINDER 
-----------
        .2
(1 row)

select remainder(6.7, 1.6) from dual;
 REMAINDER 
-----------
        .3
(1 row)

select remainder(6.7, -2) from dual;
 REMAINDER 
-----------
        .7
(1 row)

select remainder(6.7, -2.3) from dual;
 REMAINDER 
-----------
       -.2
(1 row)

select remainder(6.7, -2.6) from dual;
 REMAINDER 
-----------
      -1.1
(1 row)

select remainder(6.7, -1.5) from dual;
 REMAINDER 
-----------
        .7
(1 row)

select remainder(6.7, -1.3) from dual;
 REMAINDER 
-----------
        .2
(1 row)

select remainder(6.7, -1.6) from dual;
 REMAINDER 
-----------
        .3
(1 row)

select remainder(6.9, 3) from dual;
 REMAINDER 
-----------
        .9
(1 row)

select remainder(6.8, 2) from dual;
 REMAINDER 
-----------
        .8
(1 row)

select remainder(5.8, 2) from dual;
 REMAINDER 
-----------
       -.2
(1 row)

select remainder(4.8, 2) from dual;
 REMAINDER 
-----------
        .8
(1 row)

select remainder(67, 2) from dual;
 REMAINDER 
-----------
        -1
(1 row)

select remainder(57, 2) from dual;
 REMAINDER 
-----------
         1
(1 row)

select remainder(6.9, 3) from dual;
 REMAINDER 
-----------
        .9
(1 row)

select remainder(7, 2) from dual;
 REMAINDER 
-----------
        -1
(1 row)

select remainder(5, 2) from dual;
 REMAINDER 
-----------
         1
(1 row)

select remainder(7, -2) from dual;
 REMAINDER 
-----------
        -1
(1 row)

select remainder(5, -2) from dual;
 REMAINDER 
-----------
         1
(1 row)

select remainder(-7, 2) from dual;
 REMAINDER 
-----------
         1
(1 row)

select remainder(-5, 2) from dual;
 REMAINDER 
-----------
        -1
(1 row)

select remainder(-7, -2) from dual;
 REMAINDER 
-----------
         1
(1 row)

select remainder(-5, -2) from dual;
 REMAINDER 
-----------
        -1
(1 row)

-- test text_remainder
select remainder(7, 2) from dual;
 REMAINDER 
-----------
        -1
(1 row)

select remainder('7', 2) from dual;
 REMAINDER 
-----------
        -1
(1 row)

select remainder('7', '2') from dual;
 REMAINDER 
-----------
        -1
(1 row)

select remainder(7, '2') from dual;
 REMAINDER 
-----------
        -1
(1 row)

--support BINARY_DOUBLE/BINARY_FLOAT
drop table if exists float_point_demo;
NOTICE:  table "FLOAT_POINT_DEMO" does not exist, skipping
CREATE TABLE float_point_demo(dec_num NUMBER(10,2), bin_double BINARY_DOUBLE, bin_float BINARY_FLOAT);
INSERT INTO float_point_demo VALUES (12345,12345,12345);
INSERT INTO float_point_demo VALUES (1.235E+003,1.235E+003,1.235E+003);
SELECT bin_float, bin_double, REMAINDER(bin_float, bin_double) FROM float_point_demo order by 1;;
 BIN_FLOAT | BIN_DOUBLE | REMAINDER 
-----------+------------+-----------
      1235 |       1235 |         0
     12345 |      12345 |         0
(2 rows)

drop table float_point_demo;
\c regression
select mod(3, 1), remainder(3, 1) from dual;
ERROR:  function remainder(integer, integer) does not exist
LINE 1: select mod(3, 1), remainder(3, 1) from dual;
                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- test order by with only agg functions in targetlist
\c regression_ora
create table test_agg_ord(a int, b int);
-- complicate case
\c regression
-- test trim
-- usage1
SELECT trim('    aaa  bbb  ccc     ') ltrim FROM dual;
     ltrim     
---------------
 aaa  bbb  ccc
(1 row)

SELECT ltrim('    aaa  bbb  ccc     ') ltrim FROM dual;
       ltrim        
--------------------
 aaa  bbb  ccc     
(1 row)

SELECT rtrim('    aaa  bbb  ccc     ') ltrim FROM dual;
       ltrim       
-------------------
     aaa  bbb  ccc
(1 row)

-- usage2:
SELECT trim(leading 'd' from 'dfssa') FROM dual; 
 ltrim 
-------
 fssa
(1 row)

SELECT trim(both '1' from '123sfd111') FROM dual;
 btrim 
-------
 23sfd
(1 row)

SELECT trim(trailing '2' from '213dsq12') FROM dual;
  rtrim  
---------
 213dsq1
(1 row)

-- usage3:
SELECT trim('    aaa  bbb  ccc     ') ltrim FROM dual;
     ltrim     
---------------
 aaa  bbb  ccc
(1 row)

SELECT ltrim('    aaa  bbb  ccc     ') ltrim FROM dual;
       ltrim        
--------------------
 aaa  bbb  ccc     
(1 row)

SELECT rtrim('    aaa  bbb  ccc     ') ltrim FROM dual;
       ltrim       
-------------------
     aaa  bbb  ccc
(1 row)

select ltrim('10900111000991110224323','109') from dual;
 ltrim  
--------
 224323
(1 row)

SELECT rtrim('aaaaminb','main') FROM dual;
  rtrim   
----------
 aaaaminb
(1 row)

SELECT rtrim('aaaaminb','mainb') FROM dual;
 rtrim 
-------
 
(1 row)

SELECT ltrim('ccbcminb','cb') FROM dual;
 ltrim 
-------
 minb
(1 row)

SELECT rtrim('abcdssscb','adscb') FROM dual;
 rtrim 
-------
 
(1 row)

SELECT rtrim('abcdssscb','badsc') FROM dual;
 rtrim 
-------
 
(1 row)

-- usage4
SELECT trim(leading 'df' from 'dfssa') FROM dual; 
 ltrim 
-------
 ssa
(1 row)

SELECT trim(both '13' from '123sfd111') FROM dual;
 btrim 
-------
 23sfd
(1 row)

SELECT trim(trailing '23' from '213dsq12') FROM dual;
  rtrim  
---------
 213dsq1
(1 row)

-- usage5
\c regression_ora
SELECT trim(leading 'df' from 'dfssa') FROM dual;
ERROR:  trim set should have only one character
SELECT trim(both '13' from '123sfd111') FROM dual;
ERROR:  trim set should have only one character
SELECT trim(trailing '23' from '213dsq12') FROM dual;
ERROR:  trim set should have only one character
-- trim(' ') is null
select 'abcd' col_name from dual where trim(' ') is null;
 COL_NAME 
----------
 abcd
(1 row)

select nvl(trim(both '' from ' '),'-1') from dual;
 NVL 
-----
 -1
(1 row)

\c regression
-- alias trim
SELECT ltrim(trim(both 'l' from lpad(SUBSTR('32.8,63.5',1,INSTR('32.8,63.5',',', 1, 1)+1), 123, 'lpad')), 'lpad') trim FROM DUAL;
ERROR:  syntax error at or near "trim"
LINE 1: ...'32.8,63.5',',', 1, 1)+1), 123, 'lpad')), 'lpad') trim FROM ...
                                                             ^
\c regression_ora
-- test char(n)
DROP TABLE IF EXISTS CHAR_TBL;
NOTICE:  table "CHAR_TBL" does not exist, skipping
CREATE TABLE CHAR_TBL(key int, f1 char(4));
INSERT INTO CHAR_TBL (key, f1) VALUES (1,'a');
INSERT INTO CHAR_TBL (key, f1) VALUES (2, 'ab');
INSERT INTO CHAR_TBL (key, f1) VALUES (3, 'abcd');
INSERT INTO CHAR_TBL (key, f1) VALUES (4, 'abcde');
ERROR:  value too long for type character(4), actual(5)
INSERT INTO CHAR_TBL (key, f1) VALUES (5, 'abcd    ');
ERROR:  value too long for type character(4), actual(8)
SELECT key, f1, length(f1) FROM CHAR_TBL ORDER BY f1;
 KEY |  F1  | LENGTH 
-----+------+--------
   1 | a    |      4
   2 | ab   |      4
   3 | abcd |      4
(3 rows)

DROP TABLE IF EXISTS VARCHAR_TBL;
NOTICE:  table "VARCHAR_TBL" does not exist, skipping
CREATE TABLE VARCHAR_TBL(key int, f1 varchar(4));
INSERT INTO VARCHAR_TBL (key, f1) VALUES (1, 'a');
INSERT INTO VARCHAR_TBL (key, f1) VALUES (2, 'ab');
INSERT INTO VARCHAR_TBL (key, f1) VALUES (3, 'abcd');
INSERT INTO VARCHAR_TBL (key, f1) VALUES (4, 'abcde');
ERROR:  value too long for type character(4), actual(5)
INSERT INTO VARCHAR_TBL (key, f1) VALUES (5, 'abcd    ');
ERROR:  value too long for type character(4), actual(8)
SELECT key, f1, length(f1) FROM VARCHAR_TBL ORDER BY f1;
 KEY |  F1  | LENGTH 
-----+------+--------
   1 | a    |      1
   2 | ab   |      2
   3 | abcd |      4
(3 rows)

-- cast char(n) to text
SELECT CAST(f1 AS text) AS c_text, length(CAST(f1 AS text)) len FROM CHAR_TBL ORDER BY f1;
 C_TEXT | LEN 
--------+-----
 a      |   4
 ab     |   4
 abcd   |   4
(3 rows)

-- cast char(n) to varchar
SELECT CAST(f1 AS varchar(4)) c_varchar, length(CAST(f1 AS varchar(4))) len FROM CHAR_TBL ORDER BY f1;
 C_VARCHAR | LEN 
-----------+-----
 a         |   4
 ab        |   4
 abcd      |   4
(3 rows)

DROP TABLE CHAR_TBL;
DROP TABLE VARCHAR_TBL;
SELECT CAST('characters' AS char(20)) || ' and text' AS "Concat char to unknown type";
  Concat char to unknown type  
-------------------------------
 characters           and text
(1 row)

SELECT CAST('text' AS text) || CAST(' and characters' AS char(20)) AS "Concat text to char";
   Concat text to char    
--------------------------
 text and characters     
(1 row)

SELECT '|' || lpad(cast('X123bcd' as char(8)), 10) || '|' from dual;
   ?column?   
--------------
 |  X123bcd |
(1 row)

\c regression_ora
drop table if exists t5;
NOTICE:  table "T5" does not exist, skipping
create table t5(f1 int,f2 text);
insert into t5 values(1,'opentenbase');
insert into t5 values(2,'opentenbase2');
insert into t5 values(3,'opentenbase3');
select * from t5 where f2 like'opentenbase%'and f1=1;
 F1 |  F2   
----+-------
  1 | opentenbase
(1 row)

PREPARE usrrptplan(text, int) AS  SELECT * FROM t5 WHERE f2 like$1and  f1=$2;
execute usrrptplan('opentenbase', 1);
 F1 |  F2   
----+-------
  1 | opentenbase
(1 row)

PREPARE usrrptplan2(int, int) as SELECT * FROM t5 WHERE f1 between$1and$2;
execute usrrptplan2(1,2);
 F1 |   F2   
----+--------
  1 | opentenbase
  2 | opentenbase2
(2 rows)

PREPARE usrrptplan3(int, int) as SELECT * FROM t5 WHERE f1 in($1,$2) order by f1;
execute usrrptplan3(1,2);
 F1 |   F2   
----+--------
  1 | opentenbase
  2 | opentenbase2
(2 rows)

drop table t5;
\c regression
reset client_min_messages;
reset datestyle;
reset intervalstyle;
reset client_encoding;
-- Test TZ_OFFSET
\c regression_ora
-- test raw
drop table if exists t1;
NOTICE:  table "T1" does not exist, skipping
create table t1 (id number, doc raw(2001));
ERROR:  specified length too long for its datatype.
LINE 1: create table t1 (id number, doc raw(2001));
                                        ^
drop table if exists t1;
NOTICE:  table "T1" does not exist, skipping
create table t1 (a int, b raw(3), c long raw);
\d t1
                 Table "public.T1"
 Column |   Type   | Collation | Nullable | Default 
--------+----------+-----------+----------+---------
 A      | INTEGER  |           |          | 
 B      | RAW(3)   |           |          | 
 C      | LONG RAW |           |          | 

insert into t1 values(1 ,'123', '123');
insert into t1 values(1 ,'1234', '123');
insert into t1 values(1 ,'123', '1234');
select * from t1;
ERROR:  inconsistent datatypes: expected CHAR got LONG BINARY
drop table if exists t1;
-- agg
drop table if exists tb4;
create table tb4(a raw(10), b raw(10), c int);
insert into tb4 values('123', '456', 1);
insert into tb4 values('123', '456', 1);
insert into tb4 values('123a', '456a', 1);
insert into tb4 values('123a', '456a', 2);
select max(a) from tb4;
 MAX  
------
 123A
(1 row)

select min(a) from tb4;
 MIN  
------
 0123
(1 row)

drop table tb4;
-- hash
drop table if exists raw_test2;
NOTICE:  table "RAW_TEST2" does not exist, skipping
create table raw_test2(a raw(10), b varchar(20), c int);
create index raw_test2_index on raw_test2 using btree (a);
create index raw_test2_index2 on raw_test2 using hash (a);
\d raw_test2
                    Table "public.RAW_TEST2"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 A      | RAW(10)               |           |          | 
 B      | CHARACTER VARYING(20) |           |          | 
 C      | INTEGER               |           |          | 
Indexes:
    "RAW_TEST2_INDEX" btree (A) WITH (checksum='on')
    "RAW_TEST2_INDEX2" hash (A) WITH (checksum='on')

drop table if exists raw_test2;
-- base type
create table test_raw (r raw(20));
insert into test_raw values ('a');
insert into test_raw values ('b');
insert into test_raw values ('s');
ERROR:  invalid hexadecimal digit: "s"
LINE 1: insert into test_raw values ('s');
                                     ^
insert into test_raw values ('as');
ERROR:  invalid hexadecimal digit: "s"
LINE 1: insert into test_raw values ('as');
                                     ^
insert into test_raw values ('c');
insert into test_raw values ('f');
insert into test_raw values ('dd');
insert into test_raw values ('d');
insert into test_raw values ('e');
insert into test_raw values ('12');
select r from test_raw order by r desc;
 R  
----
 DD
 12
 0F
 0E
 0D
 0C
 0B
 0A
(8 rows)

select r from test_raw order by r asc;
 R  
----
 0A
 0B
 0C
 0D
 0E
 0F
 12
 DD
(8 rows)

drop table test_raw;
create table test_raw (a raw(1), b raw(1));
insert into test_raw values ('a', 'a');
insert into test_raw values ('b', 'c');
insert into test_raw values ('d', '9');
insert into test_raw values ('6', '6');
insert into test_raw values ('5', 'f');
select * from test_raw where a < b order by a desc;
 A  | B  
----+----
 0B | 0C
 05 | 0F
(2 rows)

select * from test_raw where a > b order by b asc;
 A  | B  
----+----
 0D | 09
(1 row)

select * from test_raw where a < b or a > b order by a desc;
 A  | B  
----+----
 0D | 09
 0B | 0C
 05 | 0F
(3 rows)

select * from test_raw where a < b or a > b order by a asc;
 A  | B  
----+----
 05 | 0F
 0B | 0C
 0D | 09
(3 rows)

select * from test_raw where a = b order by a desc;
 A  | B  
----+----
 0A | 0A
 06 | 06
(2 rows)

select * from test_raw where a = b order by a asc;
 A  | B  
----+----
 06 | 06
 0A | 0A
(2 rows)

select * from test_raw where a >= b order by a desc;
 A  | B  
----+----
 0D | 09
 0A | 0A
 06 | 06
(3 rows)

select * from test_raw where a >= b order by a asc;
 A  | B  
----+----
 06 | 06
 0A | 0A
 0D | 09
(3 rows)

select * from test_raw where a <= b order by a desc;
 A  | B  
----+----
 0B | 0C
 0A | 0A
 06 | 06
 05 | 0F
(4 rows)

select * from test_raw where a <= b order by a asc;
 A  | B  
----+----
 05 | 0F
 06 | 06
 0A | 0A
 0B | 0C
(4 rows)

drop table test_raw;
create table test_raw1 (a raw(1), b raw(1));
create table test_raw2 (a raw(1), b raw(1));
insert into test_raw1 values ('a', 'a');
insert into test_raw1 values ('b', '4');
insert into test_raw1 values ('2', '9');
insert into test_raw1 values ('6', '6');
insert into test_raw1 values ('5', 'e');
insert into test_raw2 values ('a', 'a');
insert into test_raw2 values ('d', 'c');
insert into test_raw2 values ('d', '9');
insert into test_raw2 values ('2', '6');
insert into test_raw2 values ('1', 'f');
select * from test_raw1 where a like 'd';
 A | B 
---+---
(0 rows)

select * from test_raw1 test1 cross join test_raw2 test2 where test1.a = test2.b order by 1,2;
 A  | B  | A  | B  
----+----+----+----
 06 | 06 | 02 | 06
 0A | 0A | 0A | 0A
(2 rows)

select * from test_raw1 test1 join test_raw2 test2 using(a) order by 1;
 A  | B  | B  
----+----+----
 02 | 09 | 06
 0A | 0A | 0A
(2 rows)

select * from test_raw1 test1 full join test_raw2 test2 using(a) order by 1,2,3;
 A  | B  | B  
----+----+----
 01 |    | 0F
 02 | 09 | 06
 05 | 0E | 
 06 | 06 | 
 0A | 0A | 0A
 0B | 04 | 
 0D |    | 09
 0D |    | 0C
(8 rows)

select * from test_raw1 test1 left join test_raw2 test2 using(a) order by 1,2,3;
 A  | B  | B  
----+----+----
 02 | 09 | 06
 05 | 0E | 
 06 | 06 | 
 0A | 0A | 0A
 0B | 04 | 
(5 rows)

select * from test_raw1 test1 right join test_raw2 test2 using(a) order by 1,2,3;
 A  | B  | B  
----+----+----
 01 |    | 0F
 02 | 09 | 06
 0A | 0A | 0A
 0D |    | 09
 0D |    | 0C
(5 rows)

select * from test_raw1 test1 inner join test_raw2 test2 using(a) order by 1,2,3;
 A  | B  | B  
----+----+----
 02 | 09 | 06
 0A | 0A | 0A
(2 rows)

select * from test_raw1 test1 inner join test_raw2 test2 using(a) order by 1,2,3;
 A  | B  | B  
----+----+----
 02 | 09 | 06
 0A | 0A | 0A
(2 rows)

select * from test_raw1 test1 natural join test_raw2 test2;
 A  | B  
----+----
 0A | 0A
(1 row)

drop table test_raw1;
drop table test_raw2;
-- opentenbase_ora raw support '\\'
select rawtohex('\') from dual;
 RAWTOHEX 
----------
 5C
(1 row)

select rawtohex('\\') from dual;
 RAWTOHEX 
----------
 5C5C
(1 row)

select rawtohex('\-') from dual;
 RAWTOHEX 
----------
 5C2D
(1 row)

-- opentenbase_ora rawtohex support number/int
select rawtohex(0) from dual;
 RAWTOHEX 
----------
 80
(1 row)

select rawtohex(1) from dual;
 RAWTOHEX 
----------
 C102
(1 row)

select rawtohex(2) from dual;
 RAWTOHEX 
----------
 C103
(1 row)

select rawtohex(3) from dual;
 RAWTOHEX 
----------
 C104
(1 row)

select rawtohex(4) from dual;
 RAWTOHEX 
----------
 C105
(1 row)

select rawtohex(5) from dual;
 RAWTOHEX 
----------
 C106
(1 row)

select rawtohex(-1) from dual;
 RAWTOHEX 
----------
 3E6466
(1 row)

select rawtohex(-2) from dual;
 RAWTOHEX 
----------
 3E6366
(1 row)

select rawtohex(-3) from dual;
 RAWTOHEX 
----------
 3E6266
(1 row)

select rawtohex(-4) from dual;
 RAWTOHEX 
----------
 3E6166
(1 row)

select rawtohex(-5) from dual;
 RAWTOHEX 
----------
 3E6066
(1 row)

select rawtohex(1) from dual;
 RAWTOHEX 
----------
 C102
(1 row)

select rawtohex(11) from dual;
 RAWTOHEX 
----------
 C10C
(1 row)

select rawtohex(111) from dual;
 RAWTOHEX 
----------
 C2020C
(1 row)

select rawtohex(1111) from dual;
 RAWTOHEX 
----------
 C20C0C
(1 row)

select rawtohex(-1) from dual;
 RAWTOHEX 
----------
 3E6466
(1 row)

select rawtohex(-11) from dual;
 RAWTOHEX 
----------
 3E5A66
(1 row)

select rawtohex(-111) from dual;
 RAWTOHEX 
----------
 3D645A66
(1 row)

select rawtohex(-1111) from dual;
 RAWTOHEX 
----------
 3D5A5A66
(1 row)

select rawtohex(1) from dual;
 RAWTOHEX 
----------
 C102
(1 row)

select rawtohex(12) from dual;
 RAWTOHEX 
----------
 C10D
(1 row)

select rawtohex(123) from dual;
 RAWTOHEX 
----------
 C20218
(1 row)

select rawtohex(1234) from dual;
 RAWTOHEX 
----------
 C20D23
(1 row)

select rawtohex(12345) from dual;
 RAWTOHEX 
----------
 C302182E
(1 row)

select rawtohex(-1) from dual;
 RAWTOHEX 
----------
 3E6466
(1 row)

select rawtohex(-12) from dual;
 RAWTOHEX 
----------
 3E5966
(1 row)

select rawtohex(-123) from dual;
 RAWTOHEX 
----------
 3D644E66
(1 row)

select rawtohex(-1234) from dual;
 RAWTOHEX 
----------
 3D594366
(1 row)

select rawtohex(-12345) from dual;
  RAWTOHEX  
------------
 3C644E3866
(1 row)

select rawtohex(1.1) from dual;
 RAWTOHEX 
----------
 C1020B
(1 row)

select rawtohex(1.12) from dual;
 RAWTOHEX 
----------
 C1020D
(1 row)

select rawtohex(1.123) from dual;
 RAWTOHEX 
----------
 C1020D1F
(1 row)

select rawtohex(1.1234) from dual;
 RAWTOHEX 
----------
 C1020D23
(1 row)

select rawtohex(1.1) from dual;
 RAWTOHEX 
----------
 C1020B
(1 row)

select rawtohex(-1.1) from dual;
 RAWTOHEX 
----------
 3E645B66
(1 row)

select rawtohex(-1.12) from dual;
 RAWTOHEX 
----------
 3E645966
(1 row)

select rawtohex(-1.123) from dual;
  RAWTOHEX  
------------
 3E64594766
(1 row)

select rawtohex(-1.1234) from dual;
  RAWTOHEX  
------------
 3E64594366
(1 row)

select rawtohex(-1.1) from dual;
 RAWTOHEX 
----------
 3E645B66
(1 row)

select rawtohex(0.1) from dual;
 RAWTOHEX 
----------
 C00B
(1 row)

select rawtohex(0.12) from dual;
 RAWTOHEX 
----------
 C00D
(1 row)

select rawtohex(0.123) from dual;
 RAWTOHEX 
----------
 C00D1F
(1 row)

select rawtohex(0.1234) from dual;
 RAWTOHEX 
----------
 C00D23
(1 row)

select rawtohex(-0.1) from dual;
 RAWTOHEX 
----------
 3F5B66
(1 row)

select rawtohex(-0.12) from dual;
 RAWTOHEX 
----------
 3F5966
(1 row)

select rawtohex(-0.123) from dual;
 RAWTOHEX 
----------
 3F594766
(1 row)

select rawtohex(-0.1234) from dual;
 RAWTOHEX 
----------
 3F594366
(1 row)

select rawtohex(-0.1) from dual;
 RAWTOHEX 
----------
 3F5B66
(1 row)

reset timezone;
-- Only one long(long raw) type is allowed in a table
drop table if exists t_src;
NOTICE:  table "T_SRC" does not exist, skipping
drop table if exists t_dst;
NOTICE:  table "T_DST" does not exist, skipping
create table t_src(a int, b raw);
ERROR:  missing left parenthesis.
create table t_src(a int, b long raw, c long raw);
ERROR:  Only one "long" type is allowed in a table
create table t_src(a int, b raw(100));
create table t_dst as select * from t_src;
alter table t_dst add column c raw;
ERROR:  missing left parenthesis.
alter table t_dst add column d long raw;
alter table t_dst add column e long raw;
ERROR:  Only one "long" type is allowed in a table
drop table t_src;
drop table t_dst;
-- type long raw no support op '||'
drop table if exists test_raw;
NOTICE:  table "TEST_RAW" does not exist, skipping
create table test_raw(f1 int,f2 long raw);
insert into test_raw values(1,'1');
select count(f2) from test_raw;
ERROR:  illegal use of LONG datatype
select f2 || 'opentenbase' from test_raw;
ERROR:  inconsistent datatypes: expected CHAR got LRAW
select f2 || f2 from test_raw;
ERROR:  inconsistent datatypes: expected CHAR got LRAW
select * from test_raw;
ERROR:  inconsistent datatypes: expected CHAR got LONG BINARY
select f1 from test_raw;
 F1 
----
  1
(1 row)

drop table test_raw;
drop table if exists t_test;
NOTICE:  table "T_TEST" does not exist, skipping
create table t_test(c1 INTERVAL YEAR TO MONTH, c2 interval day to second, c3 blob, c4 LONG RAW, c5 raw(20));
insert into t_test values(7||'-'||8||' ', 5||' '||4||':'||3||':'||2.246601||' ', ''||'10', 'AC'||'b', 'AC'||'b');
drop table t_test;
drop table if exists emp cascade;
NOTICE:  drop cascades to table STUD_EMP
CREATE TABLE emp (  
empno    NUMBER(4) CONSTRAINT pk_emp PRIMARY KEY,  
ename    VARCHAR2(10),  
job      VARCHAR2(9),  
mgr      NUMBER(4),  
hiredate DATE,  
sal      NUMBER(7,2),  
comm     NUMBER(7,2),  
deptno   NUMBER(2)
);
INSERT INTO emp VALUES (7369,'SMITH','CLERK',7902,to_date('17-12-1980','dd-mm-yyyy'),800,NULL,20);
INSERT INTO emp VALUES (7499,'ALLEN','SALESMAN',7698,to_date('20-2-1981','dd-mm-yyyy'),1600,300,30);
INSERT INTO emp VALUES (7521,'WARD','SALESMAN',7698,to_date('22-2-1981','dd-mm-yyyy'),1250,500,30);
INSERT INTO emp VALUES (7566,'JONES','MANAGER',7839,to_date('2-4-1981','dd-mm-yyyy'),2975,NULL,20);
INSERT INTO emp VALUES (7654,'MARTIN','SALESMAN',7698,to_date('28-9-1981','dd-mm-yyyy'),1250,1400,30);
INSERT INTO emp VALUES (7698,'BLAKE','MANAGER',7839,to_date('1-5-1981','dd-mm-yyyy'),2850,NULL,30);
INSERT INTO emp VALUES (7782,'CLARK','MANAGER',7839,to_date('9-6-1981','dd-mm-yyyy'),2450,NULL,10);
INSERT INTO emp VALUES (7788,'SCOTT','ANALYST',7566,to_date('13-12-1987','dd-mm-rr')-85,3000,NULL,20);
INSERT INTO emp VALUES (7839,'KING','PRESIDENT',NULL,to_date('17-11-1981','dd-mm-yyyy'),5000,NULL,10);
INSERT INTO emp VALUES (7844,'TURNER','SALESMAN',7698,to_date('8-9-1981','dd-mm-yyyy'),1500,0,30);
INSERT INTO emp VALUES (7876,'ADAMS','CLERK',7788,to_date('13-5-1987', 'dd-mm-rr')-51,1100,NULL,20);
INSERT INTO emp VALUES (7900,'JAMES','CLERK',7698,to_date('3-12-1981','dd-mm-yyyy'),950,NULL,30);
INSERT INTO emp VALUES (7902,'FORD','ANALYST',7566,to_date('3-12-1981','dd-mm-yyyy'),3000,NULL,20);
INSERT INTO emp VALUES (7934,'MILLER','CLERK',7782,to_date('23-1-1982','dd-mm-yyyy'),1300,NULL,10);
-- test RATIO_TO_REPORT
select EMPNO,ENAME,sal,RATIO_TO_REPORT(sal) OVER() as rr from emp where JOB='CLERK' order by 1;
 EMPNO | ENAME  | SAL  |                    RR                     
-------+--------+------+-------------------------------------------
  7369 | SMITH  |  800 | .1927710843373493975903614457831325301205
  7876 | ADAMS  | 1100 | .2650602409638554216867469879518072289157
  7900 | JAMES  |  950 | .2289156626506024096385542168674698795181
  7934 | MILLER | 1300 | .3132530120481927710843373493975903614458
(4 rows)

select EMPNO,ENAME,
RATIO_TO_REPORT(sal) OVER() as rsal,
RATIO_TO_REPORT(comm) OVER() as rcomm,
RATIO_TO_REPORT(deptno) OVER() as rdeptno
from emp order by 1;
 EMPNO | ENAME  |                   RSAL                    |                   RCOMM                   |                  RDEPTNO                  
-------+--------+-------------------------------------------+-------------------------------------------+-------------------------------------------
  7369 | SMITH  | .0275624461670973298880275624461670973299 |                                           |  .064516129032258064516129032258064516129
  7499 | ALLEN  | .0551248923341946597760551248923341946598 | .1363636363636363636363636363636363636364 | .0967741935483870967741935483870967741935
  7521 | WARD   |  .043066322136089577950043066322136089578 | .2272727272727272727272727272727272727273 | .0967741935483870967741935483870967741935
  7566 | JONES  | .1024978466838931955211024978466838931955 |                                           |  .064516129032258064516129032258064516129
  7654 | MARTIN |  .043066322136089577950043066322136089578 | .6363636363636363636363636363636363636364 | .0967741935483870967741935483870967741935
  7698 | BLAKE  | .0981912144702842377260981912144702842377 |                                           | .0967741935483870967741935483870967741935
  7782 | CLARK  | .0844099913867355727820844099913867355728 |                                           | .0322580645161290322580645161290322580645
  7788 | SCOTT  | .1033591731266149870801033591731266149871 |                                           |  .064516129032258064516129032258064516129
  7839 | KING   | .1722652885443583118001722652885443583118 |                                           | .0322580645161290322580645161290322580645
  7844 | TURNER | .0516795865633074935400516795865633074935 |                                         0 | .0967741935483870967741935483870967741935
  7876 | ADAMS  | .0378983634797588285960378983634797588286 |                                           |  .064516129032258064516129032258064516129
  7900 | JAMES  | .0327304048234280792420327304048234280792 |                                           | .0967741935483870967741935483870967741935
  7902 | FORD   | .1033591731266149870801033591731266149871 |                                           |  .064516129032258064516129032258064516129
  7934 | MILLER | .0447889750215331610680447889750215331611 |                                           | .0322580645161290322580645161290322580645
(14 rows)

select ratio_to_report(1) over() from dual;
 RATIO_TO_REPORT 
-----------------
               1
(1 row)

-- should fail
select RATIO_TO_REPORT(sal) from emp;
ERROR:  window function RATIO_TO_REPORT requires an OVER clause
LINE 1: select RATIO_TO_REPORT(sal) from emp;
               ^
select ratio_to_report() over() from dual;
ERROR:  function RATIO_TO_REPORT() does not exist
LINE 1: select ratio_to_report() over() from dual;
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select ratio_to_report(1,2) over() from dual;
ERROR:  function RATIO_TO_REPORT(NUMERIC, NUMERIC) does not exist
LINE 1: select ratio_to_report(1,2) over() from dual;
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- test vsize
select vsize(NULL);
 VSIZE 
-------
      
(1 row)

select ename, vsize(ename) from emp order by 1;
 ENAME  | VSIZE 
--------+-------
 ADAMS  |     5
 ALLEN  |     5
 BLAKE  |     5
 CLARK  |     5
 FORD   |     4
 JAMES  |     5
 JONES  |     5
 KING   |     4
 MARTIN |     6
 MILLER |     6
 SCOTT  |     5
 SMITH  |     5
 TURNER |     6
 WARD   |     4
(14 rows)

select vsize('opentenbase'::text);
 VSIZE 
-------
     5
(1 row)

select vsize('opentenbase'::cstring);
 VSIZE 
-------
     5
(1 row)

select vsize('opentenbase'::varchar(20));
 VSIZE 
-------
     5
(1 row)

select vsize('opentenbase'::char(20));
 VSIZE 
-------
    20
(1 row)

-- test approx_count_distinct
select approx_count_distinct(deptno) from emp;
 COUNT 
-------
     3
(1 row)

drop table emp;
-- [BUGFIX] Partitioning tables support expression partitioning pruning
\c regression_ora
Drop table if exists t_time;
NOTICE:  table "T_TIME" does not exist, skipping
create table t_time
(f1 int, f2 timestamp) 
partition by range (f2) -- begin (timestamp without time zone '2021-06-01 0:0:0')     
-- step (interval '5 day') 
--partitions (5)
distribute by shard(f1) 
to group default_group;
create table t_time_part_1 partition of t_time for values from ('2021-06-01 0:0:0') to ('2021-06-06 0:0:0');
create table t_time_part_2 partition of t_time for values from ('2021-06-06 0:0:0') to ('2021-06-11 0:0:0');
create table t_time_part_3 partition of t_time for values from ('2021-06-11 0:0:0') to ('2021-06-16 0:0:0');
create table t_time_part_4 partition of t_time for values from ('2021-06-16 0:0:0') to ('2021-06-21 0:0:0');
create table t_time_part_5 partition of t_time for values from ('2021-06-21 0:0:0') to ('2021-06-26 0:0:0');
insert into t_time values(1, '2021-06-01 0:0:0'::timestamp without time zone);
insert into t_time values(1, '2021-06-05 0:0:0'::timestamp without time zone);
insert into t_time values(2, '2021-06-06 0:0:0'::timestamp without time zone);
insert into t_time values(2, '2021-06-10 0:0:0'::timestamp without time zone);
insert into t_time values(3, '2021-06-11 0:0:0'::timestamp without time zone);
insert into t_time values(3, '2021-06-15 0:0:0'::timestamp without time zone);
insert into t_time values(4, '2021-06-16 0:0:0'::timestamp without time zone);
insert into t_time values(4, '2021-06-20 0:0:0'::timestamp without time zone);
insert into t_time values(5, '2021-06-21 0:0:0'::timestamp without time zone);
insert into t_time values(5, '2021-06-25 0:0:0'::timestamp without time zone);
Drop table t_time;
-- test long type
create table t1(v int, w long, f long);
ERROR:  Only one "long" type is allowed in a table
create table t1 (v int, w int, f long);
alter table t1 add column k long;
ERROR:  Only one "long" type is allowed in a table
alter table t1 alter column w type long;
ERROR:  Only one "long" type is allowed in a table
alter table t1 alter column f set default 'test';
ERROR:  "long" type can not have default constraint
create table t2 (v int, w long default 'test');
drop table if exists t2;
create table t2 (v int, w long unique);
ERROR:  data type LONG has no default operator class for access method "btree"
HINT:  You must specify an operator class for the index or define a default operator class for the data type.
create table t2 (v int, w long not null);
select * from t1 where f = 'test';
ERROR:  illegal use of LONG datatype
create index longidx on t1(f);
ERROR:  data type LONG has no default operator class for access method "btree"
HINT:  You must specify an operator class for the index or define a default operator class for the data type.
select * from t1 where f ~ 'test';
ERROR:  inconsistent datatypes: expected CHAR got LONG
select * from t1 group by f;
ERROR:  could not identify an equality operator for type LONG
LINE 1: select * from t1 group by f;
                                  ^
select * from t1 order by f;
ERROR:  could not identify an ordering operator for type LONG
LINE 1: select * from t1 order by f;
                                  ^
HINT:  Use an explicit ordering operator or modify the query.
select distinct f from t1;
ERROR:  could not identify an equality operator for type LONG
LINE 1: select distinct f from t1;
                        ^
create materialized view mview as select v, f from t1;
ERROR:  "long" type can't in materialized view
create table t3 as select v, f from t1;
ERROR:  "long" type can't in select list of create as/insert grammer
insert into t2 (select v, f from t1);
ERROR:  "long" type can't in select list of create as/insert grammer
drop table t1;
drop table t2;
create table test_long(f1 int, f2 long);
insert into test_long values(1,'long1');
select f2,lpad(f2,10,'long') from test_long;
ERROR:  Do not support long to text
select f2,rpad(f2,10,'long') from test_long;
ERROR:  Do not support long to text
select f2,trim(f2||' ') from test_long;
ERROR:  inconsistent datatypes: expected CHAR got LONG
select f2||'opentenbase' from test_long;
ERROR:  inconsistent datatypes: expected CHAR got LONG
drop table test_long;
CREATE TABLE test_long
   (f1    NUMBER  CONSTRAINT test_long_c1
              CHECK (f1 BETWEEN 10 AND 99),
    f2    long  CONSTRAINT test_long_c2
              CHECK (f2 is not null));
drop table test_long;
CREATE or replace function test_long_fun(acc_no IN NUMBER)
   RETURN int
   IS acc_bal long :='test_long';
   BEGIN
   raise notice '%',acc_bal;
   return acc_no;
    END;
/
drop function test_long_fun(acc_no IN NUMBER);
CREATE or replace PROCEDURE test_long_pro AS
   tot_emps long;
   BEGIN
   tot_emps := 'test_long';
   raise notice '%',tot_emps;
   END;
/
drop procedure test_long_pro;
-- test nclob type
create table test_nclob(f1 int primary key not null,f2 nclob);
create index test_nclob_idx on test_nclob(f2);
ERROR:  data type NCLOB has no default operator class for access method "btree"
HINT:  You must specify an operator class for the index or define a default operator class for the data type.
insert into test_nclob values (1,'nclob1'),(2,'nclob2');
create table test_nclob1(f1 int primary key not null,f2 nclob);
insert into test_nclob1 values (1,'nclob1'),(4,'nclob2');
select * from test_nclob union select f1,f2 from test_nclob1;
ERROR:  inconsistent datatypes: expected - got NCLOB
LINE 1: select * from test_nclob union select f1,f2 from test_nclob1...
               ^
select * from test_nclob intersect select f1,f2 from test_nclob1;
ERROR:  inconsistent datatypes: expected - got NCLOB
LINE 1: select * from test_nclob intersect select f1,f2 from test_nc...
               ^
select * from test_nclob except select f1,f2 from test_nclob1;
ERROR:  inconsistent datatypes: expected - got NCLOB
LINE 1: select * from test_nclob except select f1,f2 from test_nclob...
               ^
select * from test_nclob right join test_nclob1 on test_nclob.f2=test_nclob1.f2;
ERROR:  NCLOB do not support join
select * from test_nclob inner join test_nclob1 on test_nclob.f2=test_nclob1.f2;
ERROR:  NCLOB do not support join
select * from test_nclob left join test_nclob1 on test_nclob.f2=test_nclob1.f2;
ERROR:  NCLOB do not support join
select * from test_nclob full join test_nclob1 on test_nclob.f2=test_nclob1.f2;
ERROR:  NCLOB do not support join
drop table test_nclob;
drop table test_nclob1;
-- Expand fun/pro named arguments and defaults args in the parsing phase
Drop table if exists tb1;
NOTICE:  table "TB1" does not exist, skipping
Drop procedure if exists p60(_errno int, _debug bool);
NOTICE:  procedure P60(pg_catalog.INT4,BOOL) does not exist, skipping
Drop function if exists f30(a int);
NOTICE:  function F30(pg_catalog.INT4) does not exist, skipping
Create table tb1(a int);
Insert into tb1 select generate_series(1,10);
create or replace procedure p60(_errno int, _debug bool  default false)
as
$$
begin
    select * from tb1 where a = _errno;
end;
$$ language default_plsql;
CREATE OR REPLACE function f30(a int) returns void
    language default_plsql
    as $$
BEGIN
    call p60(-20344);
END;
$$;
select f30(1);
ERROR:  query has no destination for result data
HINT:  If you want to discard the results of a SELECT, use PERFORM instead.
CONTEXT:  PL/pgSQL function P60(INTEGER,BOOLEAN) line 3 at SQL statement
SQL statement "CALL p60(-20344)"
PL/pgSQL function F30(INTEGER) line 3 at CALL
select f30(1);
ERROR:  query has no destination for result data
HINT:  If you want to discard the results of a SELECT, use PERFORM instead.
CONTEXT:  PL/pgSQL function P60(INTEGER,BOOLEAN) line 3 at SQL statement
SQL statement "CALL p60(-20344)"
PL/pgSQL function F30(INTEGER) line 3 at CALL
Drop table tb1;
Drop procedure  p60(_errno int, _debug bool);
Drop function f30(a int);
-- insert into from dual, the verification for dual is ignored
drop table if exists tb1;
NOTICE:  table "TB1" does not exist, skipping
create table tb1(a date);
insert into tb1 select sysdate from dual;
drop table tb1;
-- Subtransaction commits should not reset session information
drop table if exists t_cif_organ_info;
NOTICE:  table "T_CIF_ORGAN_INFO" does not exist, skipping
drop table if exists t_client_info_pre;
NOTICE:  table "T_CLIENT_INFO_PRE" does not exist, skipping
drop FUNCTION if exists get_age(i_birth_date character varying, i_busi_date character varying);
NOTICE:  function GET_AGE(VARCHAR,VARCHAR) does not exist, skipping
CREATE TABLE t_cif_organ_info
(
    ds_date               character(8)          NOT NULL,
    unique_id             character varying(64) NOT NULL,
    branch_no             character varying(10) NOT NULL
) DISTRIBUTE BY SHARD (branch_no) to GROUP default_group;
insert into t_cif_organ_info(ds_date, branch_no, unique_id)
values ('20210803', '@', '45123135'),
       ('20210804', '123', '45123136'),
       ('20210805', '@', '45123132'),
       ('20210806', '125', '45123134'),
       ('20210802', '128', '45123133');
CREATE TABLE t_client_info_pre
(
    unique_id       character varying(64) NOT NULL,
	id_no           character varying(8),
    benefit_person  varchar2(10),
    zipcode         varchar2(10),
    open_type       varchar(10),
    is_idcard       char(1)
) DISTRIBUTE BY SHARD (unique_id) to GROUP default_group;
insert into t_client_info_pre
values ('45123135', '20210803', '1', 'dasda', 'asI~KasJs', '0');
insert into t_client_info_pre
values ('45123134', '20210804', '2', 'dasdaa', 'asGsasJs', '1');
insert into t_client_info_pre
values ('45123136', '20210805', '3', 'dasda', 'asI~KasJs', '0');
insert into t_client_info_pre
values ('45123134', '20210806', '4', 'dasda', 'asGsasJs', '2');
insert into t_client_info_pre
values ('45123132', '20210802', '5', 'ddasda', 'asI~KasJs', '0');
CREATE OR REPLACE FUNCTION get_age(i_birth_date character varying, i_busi_date character varying) RETURNS integer
    LANGUAGE default_plsql
AS
$$
declare
    out_age integer;
begin
    select 10
    into out_age
    from dual;

    return out_age;
exception
    when others then
        out_age := null;
        return out_age;
end;
$$;
SELECT
  a.benefit_person,
  get_age(a.id_no, ('20210806') :: character varying) AS age,
  a.zipcode
FROM
  (
    t_client_info_pre a
    LEFT JOIN t_cif_organ_info c ON (((a.unique_id) :: text = (c.unique_id) :: text))
  )
order by a.benefit_person;
 BENEFIT_PERSON | AGE | ZIPCODE 
----------------+-----+---------
 1              |  10 | dasda
 2              |  10 | dasdaa
 3              |  10 | dasda
 4              |  10 | dasda
 5              |  10 | ddasda
(5 rows)

drop table t_cif_organ_info;
drop table t_client_info_pre;
drop FUNCTION if exists get_age(i_birth_date character varying, i_busi_date character varying);
-- Procedure checks the validity of a word when it records the previous word.
\c regression_ora
Drop table if exists t_core;
NOTICE:  table "T_CORE" does not exist, skipping
Drop function if exists f6();
NOTICE:  function F6() does not exist, skipping
Create table t_core(a int);
create or replace function f6() returns void
    language default_plsql
    as $$
declare
v1 int;
cur_ref REFCURSOR;
v_sql char(200);
begin
     v_sql='select sal from t_core';
     OPEN cur_ref FOR  EXECUTE v_sql;
     LOOP
        FETCH cur_ref INTO v1;
        EXIT WHEN cur_ref % notfound;
        if v1 >= 1200 then
            res:='exception';
        end if;
     end loop;
end;
$$;
ERROR:  "RES" is not a known variable
LINE 15:             res:='exception';
                     ^
Drop table t_core;
Drop function if exists f6();
NOTICE:  function F6() does not exist, skipping
-- trigger support subtransaction
drop table if exists tb1 cascade;
NOTICE:  table "TB1" does not exist, skipping
drop table if exists tb3 cascade;
NOTICE:  table "TB3" does not exist, skipping
drop function if exists fun_fbjfyj();
NOTICE:  function FUN_FBJFYJ() does not exist, skipping
create table tb1(a int, b int, c1 varchar(50), c2 varchar(50) COLLATE "pg_catalog"."default", primary key(c1));
create table tb3(
    a int,
    d1 varchar(18) COLLATE "pg_catalog"."default",
    d2 varchar(600) COLLATE "pg_catalog"."default"
);
CREATE OR REPLACE FUNCTION fun_fbjfyj()
  RETURNS trigger AS $BODY$
    DECLARE
        TF              integer :=0;
    BEGIN
        begin
            select NVL2(MAX(a), '1', '0') INTO TF from tb1 where a = 7;
            IF TF = '1' THEN RETURN new; END IF;
            new.d1 := '11';
            new.d2 := '111';
            insert into tb1 values(12, 12, new.d1, new.d2);
        end;
        RETURN new;
exception
    when others then
    return new;
    END
$BODY$
LANGUAGE default_plsql VOLATILE
COST 100;
create trigger tb3_insert after insert on tb3
FOR EACH ROW
EXECUTE PROCEDURE fun_fbjfyj();
ERROR:  Postgres-XL does not support TRIGGER yet
DETAIL:  The feature is not currently supported
insert into tb3 values(1, '11', '111'), (2, '22', '222'), (3,'33','333');
insert into tb3 values(1, '11', '111'), (2, '22', '222'), (3,'33','333');
select count(*) from tb3;
 COUNT 
-------
     6
(1 row)

drop table tb1 cascade;
drop table tb3 cascade;
drop function fun_fbjfyj();
-- 1020421696091652701
create table tbl_a(a int) distribute by shard(a);
insert into tbl_a values(1);
create view v_a as select * from tbl_a;
insert into tbl_a select * from v_a;
select * from tbl_a;
 A 
---
 1
 1
(2 rows)

drop table tbl_a cascade;
NOTICE:  drop cascades to view V_A
-- user case
 
drop table cib_form_fee_adj_tbl cascade;
ERROR:  table "CIB_FORM_FEE_ADJ_TBL" does not exist
drop table ps_rc_case cascade;
ERROR:  table "PS_RC_CASE" does not exist
drop table ps_cib_bo_name_vw cascade;
ERROR:  table "PS_CIB_BO_NAME_VW" does not exist
drop table ps_cib_case_more cascade;
ERROR:  table "PS_CIB_CASE_MORE" does not exist
create table cib_form_fee_adj_tbl(case_id text,
         first_name text,
         atm_card_no text,
         cib_account_id text,
         cib_tzzklx text,
         cib_ori_tran_dt text,
         cib_ori_tran_no text,
         cib_adj_value text,
         cib_feemark text,
         row_added_oprid text,
         row_added_dttm text,
         closed_attm text,
         cib_tz_reason text,
         rc_status text,
         znjtzz text,
         dzfyzz text,
         cib_app1_id text,
         cib_approver text,
         cib_ori_tran_amt text,
         cib_flag text)distribute by shard(case_id);
create table ps_rc_case(case_id text, cib_app1_id text,
         cib_approver text,
         cib_ori_tan_amt text, closed_date text,
         rc_category text,
         rc_detail text,
         cib_cr_order_type text,
         cib_rc_case_flag text,
         bo_id_cust text)distribute by shard(case_id);
create view v_ps_rc_case as select * from ps_rc_case;
create table ps_cib_bo_name_vw(first_name text, bo_id text)distribute by shard(first_name);
create table ps_cib_case_more(
         cib_tzzklx text,
         cib_ori_tran_dt text,
         cib_ori_tran_no text,
         cib_adj_value text,
         cib_feemark text,
         cib_tz_reason text,
         cib_znjtzz text,
         cib_dxfytzz text,
         case_id text,
         rc_type text,
         atm_card_no text,
         cib text,
         row_added_oprid text,
                  row_added_dttm text,
         closed_dttm text,
          rc_status text
         )distribute by shard(cib_tzzklx);
create or replace procedure cib_set_date_mark(a varchar, c date, d varchar) is
begin
null;
end;
/
create or replace procedure cib_log_prc(a int, b varchar)
is
  begin
  null;
  end;
/
drop function if exists cib_get_datemark;
create or replace function cib_get_datemark (a varchar) return date
is
  begin
    return null;
  end;
/
drop procedure cib_log_prc;
drop procedure cib_set_date_mark;
drop function cib_get_datemark;
drop view v_ps_rc_case;
drop package cib_load_ps_pck;
ERROR:  package corresponding namespace "CIB_LOAD_PS_PCK" does not exist
HINT:  Please check catalog.
-- to_date returns null by default
drop table if exists t_date1;
NOTICE:  table "T_DATE1" does not exist, skipping
CREATE TABLE t_date1
       (EMPNO NUMBER(4) CONSTRAINT PK_EMP PRIMARY KEY,
        ENAME VARCHAR2(10),
        JOB VARCHAR2(9),
        MGR NUMBER(4),
        HIREDATE DATE,
        SAL NUMBER(7,2),
        COMM NUMBER(7,2),
        DEPTNO NUMBER(2));
INSERT INTO t_date1 VALUES
(7369,'SMITH','CLERK',7902,to_date('17-12-1980','dd-mm-yyyy'),800,NULL,20);
INSERT INTO t_date1 VALUES
(7499,'ALLEN','SALESMAN',7698,to_date('20-2-1981','dd-mm-yyyy'),1600,300,30);
INSERT INTO t_date1 VALUES
(7521,'WARD','SALESMAN',7698,to_date('22-2-1981','dd-mm-yyyy'),1250,500,30);
INSERT INTO t_date1 VALUES
(7566,'JONES','MANAGER',7839,to_date('2-4-1981','dd-mm-yyyy'),2975,NULL,20);
INSERT INTO t_date1 VALUES
(7654,'MARTIN','SALESMAN',7698,to_date('28-9-1981','dd-mm-yyyy'),1250,1400,30);
INSERT INTO t_date1 VALUES
(7698,'BLAKE','MANAGER',7839,to_date('1-5-1981','dd-mm-yyyy'),2850,NULL,30);
INSERT INTO t_date1 VALUES
(7782,'CLARK','MANAGER',7839,to_date('9-6-1981','dd-mm-yyyy'),2450,NULL,10);
INSERT INTO t_date1 VALUES
(7788,'SCOTT','ANALYST',7566,to_date('19-04-87','dd-mm-rr'),3000,NULL,20);
INSERT INTO t_date1 VALUES
(7839,'KING','PRESIDENT',NULL,to_date('17-11-1981','dd-mm-yyyy'),5000,NULL,10);
INSERT INTO t_date1 VALUES
(7844,'TURNER','SALESMAN',7698,to_date('8-9-1981','dd-mm-yyyy'),1500,0,30);
INSERT INTO t_date1 VALUES
(7876,'ADAMS','CLERK',7788,to_date('23-05-87', 'dd-mm-rr'),1100,NULL,20);
INSERT INTO t_date1 VALUES
(7900,'JAMES','CLERK',7698,to_date('3-12-1981','dd-mm-yyyy'),950,NULL,30);
INSERT INTO t_date1 VALUES
(7902,'FORD','ANALYST',7566,to_date('3-12-1981','dd-mm-yyyy'),3000,NULL,20);
INSERT INTO t_date1 VALUES
(7934,'MILLER','CLERK',7782,to_date('23-1-1982','dd-mm-yyyy'),1300,NULL,10);
drop table t_date1;
-- test varchar/varchar2 operator
DROP TABLE IF EXISTS char_t;
NOTICE:  table "CHAR_T" does not exist, skipping
CREATE TABLE char_t (id int, col1 varchar2(100), col2 varchar(100));
insert into char_t values (1, '12', '3');
insert into char_t values (2, '13', '3');
insert into char_t values (3, '1.2345678e-8', '1.2345678e-2');
select id, col1 + col1 varchar_add, col2 + col2 varchar2_add, col1 + col2 t_v_add,
       col1 - col1 varchar_sub, col2 - col2 varchar2_sub, col2 - col1 v_t_sub,
       col1 * col1 varchar_mul, col2 * col2 varchar2_mul, col1 + col2 t_v_mul,
       col1 / col1 varchar_div, col2 / col2 varchar2_div, col2 / col1 v_t_div from char_t order by id;
 ID |   VARCHAR_ADD    | VARCHAR2_ADD |     T_V_ADD      | VARCHAR_SUB | VARCHAR2_SUB |     V_T_SUB      |           VARCHAR_MUL           |    VARCHAR2_MUL     |     T_V_MUL      | VARCHAR_DIV | VARCHAR2_DIV |                  V_T_DIV                  
----+------------------+--------------+------------------+-------------+--------------+------------------+---------------------------------+---------------------+------------------+-------------+--------------+-------------------------------------------
  1 |               24 |            6 |               15 |           0 |            0 |               -9 |                             144 |                   9 |               15 |           1 |            1 |                                       .25
  2 |               26 |            6 |               16 |           0 |            0 |              -10 |                             169 |                   9 |               16 |           1 |            1 | .2307692307692307692307692307692307692308
  3 | .000000024691356 |   .024691356 | .012345690345678 |           0 |            0 | .012345665654322 | .000000000000000152415765279684 | .000152415765279684 | .012345690345678 |           1 |            1 |                                   1000000
(3 rows)

insert into char_t values (4, 'varchar', 'varchar2');
select id, col1 + col1 varchar_add, col2 + col2 varchar2_add, col1 + col2 t_v_add,
       col1 - col1 varchar_sub, col2 - col2 varchar2_sub, col2 - col1 v_t_sub,
       col1 * col1 varchar_mul, col2 * col2 varchar2_mul, col1 + col2 t_v_mul,
       col1 / col1 varchar_div, col2 / col2 varchar2_div, col2 / col1 v_t_div from char_t order by id;
ERROR:  invalid input syntax for type numeric: "varchar"
DROP TABLE IF EXISTS char_t;
-- test upper(numeric)
DROP TABLE IF EXISTS upper_numeric_t;
NOTICE:  table "UPPER_NUMERIC_T" does not exist, skipping
CREATE TABLE upper_numeric_t(v int, w numeric, f float8);
insert into upper_numeric_t values(1, 2.005, -4.33435545);
select upper(v) as f1, upper(w) as f2, upper(f) as f3 from upper_numeric_t;
 F1 |  F2   |     F3      
----+-------+-------------
 1  | 2.005 | -4.33435545
(1 row)

drop table upper_numeric_t;
select upper(2.1) as f1 from dual;
 F1  
-----
 2.1
(1 row)

-- test 'select unique xxx from table'
create table t_unique(f1 varchar(10),f2 int);
insert into t_unique values('test1',1);
insert into t_unique values('test2',1);
insert into t_unique values('test1',1);
insert into t_unique values('test3',1);
insert into t_unique values('test2',1);
select unique f1 from t_unique order by 1;
  F1   
-------
 test1
 test2
 test3
(3 rows)

select count(unique f1) from t_unique;
 COUNT 
-------
     3
(1 row)

drop table t_unique;
create table test_unique1(id int, c0 int, c1 number , c2 varchar(100), c3 varchar2(100));
insert into test_unique1(id, c0, c1, c2, c3) values(1,123, 123.123, 'abc', '123');
insert into test_unique1(id, c0, c1, c2, c3) values(2,234, 234.234, 'bcd', '234');
insert into test_unique1(id, c0, c1, c2, c3) values(3,345, 345.345, 'cde', '345');
insert into test_unique1(id, c0, c1, c2, c3) values(4,456, 234.234, 'def', '456');
insert into test_unique1(id, c0, c1, c2, c3) values(5,567, 567.567, 'efg', '567');
insert into test_unique1(id, c0, c1, c2, c3) values(6,567, 567.567, 'fgh', '567');
insert into test_unique1(id, c0, c1, c2, c3) values(7,678, 678.678, 'ghi', '789');
insert into test_unique1(id, c0, c1, c2, c3) values(8,678, 678.678, '', '789');
insert into test_unique1(id, c0, c1, c2, c3) values(9,678, 678678.8123, '', '8423');
insert into test_unique1(id, c0, c1, c2) values(10,789, 789.789, 'hij');
insert into test_unique1(id, c0, c1, c2) values(11,890, 123.123, 'ijk');
insert into test_unique1(id, c0, c1, c2) values(12,901, 901.901, 'abc');
create table test_unique2(id int, c0 int, c1 number , c2 varchar(100), c3 varchar2(100));
insert into test_unique2(id, c0, c1, c2, c3) values(1,123, 123.123, 'abc', '123');
insert into test_unique2(id, c0, c1, c2, c3) values(2,234, 234.234, 'bcd', '234');
insert into test_unique2(id, c0, c1, c2, c3) values(3,345, 345.345, 'cde', '345');
insert into test_unique2(id, c0, c1, c2, c3) values(4,456, 234.234, 'def', '456');
insert into test_unique2(id, c0, c1, c2, c3) values(5,567, 567.567, 'efg', '567');
insert into test_unique2(id, c0, c1, c2, c3) values(6,567, 567.567, 'fgh', '567');
insert into test_unique2(id, c0, c1, c2, c3) values(7,678, 678.678, 'ghi', '789');
insert into test_unique2(id, c0, c1, c2, c3) values(8,678, 678.678, '', '789');
insert into test_unique2(id, c0, c1, c2, c3) values(9,678, 678678.8123, '', '8423');
insert into test_unique2(id, c0, c1, c2) values(10,789, 789.789, 'hij');
insert into test_unique2(id, c0, c1, c2) values(11,890, 123.123, 'ijk');
insert into test_unique2(id, c0, c1, c2) values(12,901, 901.901, 'abc');
select * from test_unique2 where c3 in (select unique c3 from test_unique1) order by id;
 ID | C0  |     C1      | C2  |  C3  
----+-----+-------------+-----+------
  1 | 123 |     123.123 | abc | 123
  2 | 234 |     234.234 | bcd | 234
  3 | 345 |     345.345 | cde | 345
  4 | 456 |     234.234 | def | 456
  5 | 567 |     567.567 | efg | 567
  6 | 567 |     567.567 | fgh | 567
  7 | 678 |     678.678 | ghi | 789
  8 | 678 |     678.678 |     | 789
  9 | 678 | 678678.8123 |     | 8423
(9 rows)

select unique sin(c3) from (select unique c3 from test_unique1) order by 1;
         SIN          
----------------------
  -0.5439958173735323
 -0.45990349068959124
    -0.45205267588297
  -0.4441666848300092
 -0.38027695100780123
   0.9983488258124457
   0.9988166912028082
                     
(8 rows)

drop table test_unique1;
drop table test_unique2;
select chr(67)||chr(0)||chr(65)||chr(0)||chr(84) "dog" from dual;
  dog  
-------
 C A T
(1 row)

-- test pg_catalog.to_char()
-- opentenbase_ora compatible on
select pg_catalog.to_char(20, 'aa') from dual;
ERROR:  Invalid number format model
select pg_catalog.to_char(22221., 'xxxxxxx') from dual;
 TO_CHAR  
----------
     56cd
(1 row)

select pg_catalog.to_char(22221., 'XXXXXXX') from dual;
 TO_CHAR  
----------
     56CD
(1 row)

select pg_catalog.to_char(22221.4, 'xxxxxxx') from dual;
 TO_CHAR  
----------
     56cd
(1 row)

select pg_catalog.to_char(22221.5, 'xxxxxxx') from dual;
 TO_CHAR  
----------
     56ce
(1 row)

select pg_catalog.to_char(-22221.4, 'xxxxxxx') from dual;
 TO_CHAR  
----------
 ########
(1 row)

select pg_catalog.to_char(912222, 'xxxxx') from dual;
 TO_CHAR 
---------
  deb5e
(1 row)

select pg_catalog.to_char(912222, 'XXXXX') from dual;
 TO_CHAR 
---------
  DEB5E
(1 row)

select pg_catalog.to_char(912222, 'xxxx') from dual;
 TO_CHAR 
---------
 #####
(1 row)

select pg_catalog.to_char(-912222, 'xxxxxxx') from dual;
 TO_CHAR  
----------
 ########
(1 row)

select pg_catalog.to_char(2e4, 'XXXx') from dual;
 TO_CHAR 
---------
  4e20
(1 row)

select pg_catalog.to_char(2e-4, 'XXXx') from dual;
 TO_CHAR 
---------
     0
(1 row)

select pg_catalog.to_char(2e0, 'XXXx') from dual;
 TO_CHAR 
---------
     2
(1 row)

select pg_catalog.to_char(-2e0, 'XXXx') from dual;
 TO_CHAR 
---------
 #####
(1 row)

select pg_catalog.to_char(912222, 'XxxxxxxxxxxxxxxxxxxxxxxxxxXxxxxxxxxxxxxxXxxxxxxxxxxxxxxxxxxxxxX') from dual;
                             TO_CHAR                              
------------------------------------------------------------------
                                                            deb5e
(1 row)

select pg_catalog.to_char(912222, 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') from dual;
                             TO_CHAR                              
------------------------------------------------------------------
                                                            deb5e
(1 row)

select pg_catalog.to_char(912222, 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') from dual;
ERROR:  invalid number format model
drop table if exists tr_tbl_to_char;
create table tr_tbl_to_char(f1 integer, f2 float, f3 double precision, f4 numeric(10,2));
insert into tr_tbl_to_char values(255, 255.4, 65535.9999999, -32765.89);
insert into tr_tbl_to_char values(254, 253.4, 65534.9999999, 32765.89);
insert into tr_tbl_to_char values(-254, 253.4, 65534.9999999, 32765.89);
select pg_catalog.to_char(f1, 'XXXX'), pg_catalog.to_char(f2, 'xxxx'), pg_catalog.to_char(f3, 'xxxX'), pg_catalog.to_char(f4, 'XXXXX') from tr_tbl_to_char order by f1;
 TO_CHAR | TO_CHAR | TO_CHAR | TO_CHAR 
---------+---------+---------+---------
 #####   |    fd   |  ffff   |   7FFE
    FE   |    fd   |  ffff   |   7FFE
    FF   |    ff   | #####   | ######
(3 rows)

drop table if exists tr_tbl_to_char;
-- opentenbase_ora compatible off
\c regression
select pg_catalog.to_char(20, 'aa') from dual;
 to_char 
---------
 aa
(1 row)

select pg_catalog.to_char(22221., 'xxxxxxx') from dual;
 to_char 
---------
 xxxxxxx
(1 row)

select pg_catalog.to_char(22221., 'XXXXXXX') from dual;
 to_char 
---------
 XXXXXXX
(1 row)

select pg_catalog.to_char(22221.4, 'xxxxxxx') from dual;
 to_char 
---------
 xxxxxxx
(1 row)

select pg_catalog.to_char(22221.5, 'xxxxxxx') from dual;
 to_char 
---------
 xxxxxxx
(1 row)

select pg_catalog.to_char(-22221.4, 'xxxxxxx') from dual;
 to_char 
---------
 xxxxxxx
(1 row)

select pg_catalog.to_char(912222, 'xxxxx') from dual;
 to_char 
---------
 xxxxx
(1 row)

select pg_catalog.to_char(912222, 'XXXXX') from dual;
 to_char 
---------
 XXXXX
(1 row)

select pg_catalog.to_char(912222, 'xxxx') from dual;
 to_char 
---------
 xxxx
(1 row)

select pg_catalog.to_char(-912222, 'xxxxxxx') from dual;
 to_char 
---------
 xxxxxxx
(1 row)

select pg_catalog.to_char(2e4, 'XXXx') from dual;
 to_char 
---------
 XXXx
(1 row)

select pg_catalog.to_char(2e-4, 'XXXx') from dual;
 to_char 
---------
 XXXx
(1 row)

select pg_catalog.to_char(2e0, 'XXXx') from dual;
 to_char 
---------
 XXXx
(1 row)

select pg_catalog.to_char(-2e0, 'XXXx') from dual;
 to_char 
---------
 XXXx
(1 row)

select pg_catalog.to_char(912222, 'XxxxxxxxxxxxxxxxxxxxxxxxxxXxxxxxxxxxxxxxXxxxxxxxxxxxxxxxxxxxxxX') from dual;
                             to_char                             
-----------------------------------------------------------------
 XxxxxxxxxxxxxxxxxxxxxxxxxxXxxxxxxxxxxxxxXxxxxxxxxxxxxxxxxxxxxxX
(1 row)

select pg_catalog.to_char(912222, 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') from dual;
                             to_char                             
-----------------------------------------------------------------
 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(1 row)

select pg_catalog.to_char(912222, 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') from dual;
                             to_char                              
------------------------------------------------------------------
 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(1 row)

create table tr_tbl_to_char(f1 integer, f2 float, f3 double precision, f4 numeric(10,2));
insert into tr_tbl_to_char values(255, 255.4, 65535.9999999, -32765.89);
insert into tr_tbl_to_char values(254, 253.4, 65534.9999999, 32765.89);
insert into tr_tbl_to_char values(-254, 253.4, 65534.9999999, 32765.89);
select pg_catalog.to_char(f1, 'XXXX'), pg_catalog.to_char(f2, 'xxxx'), pg_catalog.to_char(f3, 'xxxX'), pg_catalog.to_char(f4, 'XXXXX') from tr_tbl_to_char order by f1;
 to_char | to_char | to_char | to_char 
---------+---------+---------+---------
 XXXX    | xxxx    | xxxX    | XXXXX
 XXXX    | xxxx    | xxxX    | XXXXX
 XXXX    | xxxx    | xxxX    | XXXXX
(3 rows)

drop table if exists tr_tbl_to_char;
-- opentenbase_ora treat '' as null
\c regression_ora
drop table if exists t1;
NOTICE:  table "T1" does not exist, skipping
create table t1(f1 int, f2 varchar(10), f3 text, f4 char(30), f5 nvarchar2);
insert into t1 values(1, '', '', '', ''), (2, null, null, null, null);
copy t1 from stdin;
select char_length(f2), char_length(f3), char_length(f4), char_length(f5), * from t1 order by f1;
 CHAR_LENGTH | CHAR_LENGTH | CHAR_LENGTH | CHAR_LENGTH | F1 | F2 | F3 | F4 | F5 
-------------+-------------+-------------+-------------+----+----+----+----+----
             |             |             |             |  1 |    |    |    | 
             |             |             |             |  2 |    |    |    | 
             |             |             |             |  3 |    |    |    | 
             |             |             |             |  4 |    |    |    | 
(4 rows)

truncate table t1;
drop table t1;
\c regression
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1(f1 int, f2 varchar(10), f3 text, f4 char(30), f5 varchar(100));
insert into t1 values(1, '', '', '', ''), (2, null, null, null, null);
copy t1 from stdin;
select char_length(f2), char_length(f3), char_length(f4), char_length(f5), * from t1 order by f1;
 char_length | char_length | char_length | char_length | f1 | f2 | f3 |               f4               | f5 
-------------+-------------+-------------+-------------+----+----+----+--------------------------------+----
           0 |           0 |           0 |           0 |  1 |    |    |                                | 
             |             |             |             |  2 |    |    |                                | 
           0 |           0 |           0 |           0 |  3 |    |    |                                | 
             |             |             |             |  4 |    |    |                                | 
(4 rows)

drop table t1;
-- test clob
\c regression_ora
create table lob_table(v int, c1 clob);
insert into lob_table values (1, 'clob');
select trim(trailing ' ' from c1) as clob from lob_table;
 CLOB 
------
 clob
(1 row)

select to_clob(c1) from lob_table;
 TO_CLOB 
---------
 clob
(1 row)

select to_char(c1) from lob_table;
 TO_CHAR 
---------
 clob
(1 row)

select ascii(c1) from lob_table;
 ASCII 
-------
    99
(1 row)

insert into lob_table values (2, '1');
insert into lob_table values (2, '2');
select avg(c1) from lob_table where v = 2;
 AVG 
-----
 1.5
(1 row)

select ratio_to_report(c1) over() from lob_table where v = 2;
              RATIO_TO_REPORT              
-------------------------------------------
 .3333333333333333333333333333333333333333
 .6666666666666666666666666666666666666667
(2 rows)

drop table lob_table;
set allow_limit_ident to on;
create temporary table limit(id int, limit CLOB);
insert into limit(id, limit) values(1,'abc'),(2,'dcb');
select * from limit order by limit,id;
ERROR:  There exists unexpected data type of CLOB for sort
drop table limit;
reset allow_limit_ident;
-- test left as column
drop table if exists left_t;
NOTICE:  table "LEFT_T" does not exist, skipping
create table left_t(v int, left int, w int);
insert into left_t values(1, 1, 1);
insert into left_t(v, left) values(2, 3);
select left from left_t order by v;
 LEFT 
------
    1
    3
(2 rows)

select left from left_t order by left;
 LEFT 
------
    1
    3
(2 rows)

select * from left_t order by left;
 V | LEFT | W 
---+------+---
 1 |    1 | 1
 2 |    3 |  
(2 rows)

drop table left_t;
-- test unique_column_name
set unique_column_name to on;
select '','' as alias_column,substr('opentenbase',5,2),substr('opentenbase',-3),null,null,'opentenbase' as alias_column;
 ?column? | ALIAS_COLUMN | SUBSTR | SUBSTR_1 | ?column?_1 | ?column?_2 | ALIAS_COLUMN 
----------+--------------+--------+----------+------------+------------+--------------
          |              | e      | ase      |            |            | opentenbase
(1 row)

create table t_unique_column_name (a int, a_1 int);
select a,a from t_unique_column_name;
 A | A_1 
---+-----
(0 rows)

select a,a,a_1,a from t_unique_column_name;
 A | A_1 | A_1_1 | A_2 
---+-----+-------+-----
(0 rows)

select a,a_1,a_1,a from t_unique_column_name;
 A | A_1 | A_1_1 | A_2 
---+-----+-------+-----
(0 rows)

select *,a as a from t_unique_column_name;
 A | A_1 | A 
---+-----+---
(0 rows)

drop table t_unique_column_name;
reset unique_column_name;
-- opentenbase_ora,to_data/to_timestamp/to_timestamp_tz relax delimiter checking in opentenbase_ora compatibility mode
\c regression_ora
-- 1020421696875393133
/*
 * test insert with table alias.
 * 1. INSERT INTO table t1(c1,c2, t1.c3)
 * 2. INSERT INTO table (test.c1)
 * 3. INSERT INTO table t1 VALUES
 * 4. INSERT INTO table t1 select
 * exception:
 * 1. INSERT INTO table t1(t1.t2.c1)
 * 2. INSERT INTO table t1(t1.*)
 */
create table table_102(c1 int, c2 int, c3 int, c4 int);
-- 1. INSERT INTO table t1(c1,c2, t1.c3)
insert into table_102 t(t.c1,t.c2) values(1, 2);
insert into table_102 t(t.c1,t.c2) select 1, 22;
select * from table_102 order by 1, 2;
 C1 | C2 | C3 | C4 
----+----+----+----
  1 |  2 |    |   
  1 | 22 |    |   
(2 rows)

delete from table_102;
-- 2. INSERT INTO table (test.c1)
insert into table_102(table_102.c1, table_102.c2) values(2, 3);
select * from table_102;
 C1 | C2 | C3 | C4 
----+----+----+----
  2 |  3 |    |   
(1 row)

delete from table_102;
-- 3. INSERT INTO table t1 VALUES
insert into table_102 t1 values(1,2 );
insert into table_102 t2 select 1,2 ;
select * from table_102;
 C1 | C2 | C3 | C4 
----+----+----+----
  1 |  2 |    |   
  1 |  2 |    |   
(2 rows)

delete from table_102;
--mixed
insert into table_102 t(t.c1,t.c2, c3) select 1, 2, 12;
select * from table_102;
 C1 | C2 | C3 | C4 
----+----+----+----
  1 |  2 | 12 |   
(1 row)

delete from table_102;
-- 4. INSERT INTO table t1 select
-- tested above
-- exception:
-- 1. INSERT INTO table t1(t1.t2.c1)
insert into table_102 t(t.t.c1,t.c2) select 1, 22;
ERROR:  column "T" of relation "TABLE_102" does not exist
LINE 1: insert into table_102 t(t.t.c1,t.c2) select 1, 22;
                                ^
insert into table_102 t(table_102.c1,t.c2) select 1, 22;
ERROR:  invalid relation name "TABLE_102"
LINE 1: insert into table_102 t(table_102.c1,t.c2) select 1, 22;
                                ^
-- 2. INSERT INTO table t1(t1.*)
insert into table_102 t(t.*) select 1;
ERROR:  column "T" of relation "TABLE_102" does not exist
LINE 1: insert into table_102 t(t.*) select 1;
                                ^
drop table table_102;
-- 1020421696095179659
/*
 * use 'link' as column identifier
 * use 'link' as table identifier
 * use 'link' as alias name
 */
create table table_103 (id int, link int);
create table link (id int, link int);
select id as link from table_103;
 LINK 
------
(0 rows)

drop table table_103;
drop table link;
-- 1020421696880130617
-- test nvl with diff length type
create table t_fix_nvl_ret_cut_20221201(id int,name varchar(6),name2 timestamp);
insert into t_fix_nvl_ret_cut_20221201 values (1,'202210','2022-12-04 23:48:35.636675');
insert into t_fix_nvl_ret_cut_20221201(id,name2) values (2,'2022-12-04 23:48:35.638837');
insert into t_fix_nvl_ret_cut_20221201(id,name2) values (3,'2022-12-04 23:48:35.640332');
insert into t_fix_nvl_ret_cut_20221201 values (4,'202012','2022-12-04 23:48:35.642297');
select * from t_fix_nvl_ret_cut_20221201 order by id;
 ID |  NAME  |              NAME2              
----+--------+---------------------------------
  1 | 202210 | Sun Dec 04 23:48:35.636675 2022
  2 |        | Sun Dec 04 23:48:35.638837 2022
  3 |        | Sun Dec 04 23:48:35.640332 2022
  4 | 202012 | Sun Dec 04 23:48:35.642297 2022
(4 rows)

select nvl(name,to_char(name2,'yyyy:mm:dd hh24:mi:ss')) from t_fix_nvl_ret_cut_20221201 order by id;
         NVL         
---------------------
 202210
 2022:12:04 23:48:35
 2022:12:04 23:48:35
 202012
(4 rows)

drop table t_fix_nvl_ret_cut_20221201;
select nvl(NULL::bfile, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::bpchar(1), 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::char(1), 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::information_schema.character_data, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::clob, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::long, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::name, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::nclob, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::varchar2(1), 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::pg_dependencies, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::pg_ndistinct, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::pg_node_tree, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::information_schema.sql_identifier, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::text, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::varchar(1), 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::varchar2(1), 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl(NULL::information_schema.yes_or_no, 111111111111111111111111111111111111);
                 NVL                  
--------------------------------------
 111111111111111111111111111111111111
(1 row)

-- test nvl2 with diff length type
select nvl2(NULL, NULL::bfile, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::bpchar(1), 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::char(1), 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::information_schema.character_data, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::clob, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::long, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::name, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::nclob, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::varchar2(1), 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::pg_dependencies, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::pg_ndistinct, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::pg_node_tree, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::information_schema.sql_identifier, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::text, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::varchar(1), 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::varchar2(1), 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

select nvl2(NULL, NULL::information_schema.yes_or_no, 111111111111111111111111111111111111);
                 NVL2                 
--------------------------------------
 111111111111111111111111111111111111
(1 row)

-- test update pull up
create table test1 (
                       c11 integer,
                       c12 integer,
                       c13 integer,
                       c14 integer,
                       c15 integer
);
create table test2 (
                       c21 integer,
                       c22 integer,
                       c23 integer,
                       c24 integer,
                       c25 integer
);
create table test3 (
                       c31 bigint,
                       c32 bigint,
                       c33 bigint,
                       c34 bigint,
                       c35 bigint
);
create table test4 (
                       c41 char(10),
                       c42 char(10),
                       c43 char(10),
                       c44 char(10),
                       c45 char(10)
);
insert into test1
select  i,i,i,i,i
from generate_series(1, 10) as i;
insert into test2
select  i,i,i+1,i,i
from generate_series(1, 10) as i;
insert into test3
select  i,i,i+1,i,i
from generate_series(1, 10) as i;
insert into test4
select  i,i,i+1,i,i
from generate_series(1, 10) as i;
explain (costs off) update test1 set c13=(select test2.c23 from test2 where test1.c12=test2.c22);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Update on TEST1
         ->  Hash Left Scalar Join
               Hash Cond: (TEST1.C12 = TEST2.C22)
               ->  Seq Scan on TEST1
               ->  Hash
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by R
                           ->  Seq Scan on TEST2
(9 rows)

update test1 set c13=(select test2.c23 from test2 where test1.c12=test2.c22);
select * from test1 order by c11;
 C11 | C12 | C13 | C14 | C15 
-----+-----+-----+-----+-----
   1 |   1 |   2 |   1 |   1
   2 |   2 |   3 |   2 |   2
   3 |   3 |   4 |   3 |   3
   4 |   4 |   5 |   4 |   4
   5 |   5 |   6 |   5 |   5
   6 |   6 |   7 |   6 |   6
   7 |   7 |   8 |   7 |   7
   8 |   8 |   9 |   8 |   8
   9 |   9 |  10 |   9 |   9
  10 |  10 |  11 |  10 |  10
(10 rows)

delete from test1;
insert into test1
select  i,i,i,i,i
from generate_series(1, 10) as i;
explain (costs off) update test1 set c13=(select test3.c33 from test3 where test1.c12=test3.c32);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Update on TEST1
         ->  Hash Left Scalar Join
               Hash Cond: (TEST1.C12 = TEST3.C32)
               ->  Seq Scan on TEST1
               ->  Hash
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by R
                           ->  Seq Scan on TEST3
(9 rows)

update test1 set c13=(select test3.c33 from test3 where test1.c12=test3.c32);
select * from test1 order by c11;
 C11 | C12 | C13 | C14 | C15 
-----+-----+-----+-----+-----
   1 |   1 |   2 |   1 |   1
   2 |   2 |   3 |   2 |   2
   3 |   3 |   4 |   3 |   3
   4 |   4 |   5 |   4 |   4
   5 |   5 |   6 |   5 |   5
   6 |   6 |   7 |   6 |   6
   7 |   7 |   8 |   7 |   7
   8 |   8 |   9 |   8 |   8
   9 |   9 |  10 |   9 |   9
  10 |  10 |  11 |  10 |  10
(10 rows)

delete from test1;
insert into test1
select  i,i,i,i,i
from generate_series(1, 10) as i;
explain (costs off) update test1 set c13=(select t.c43 from test4 as t where test1.c12=t.c42);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Update on TEST1
         ->  Seq Scan on TEST1
               SubPlan 1
                 ->  Remote Subquery Scan on all (datanodes 2)
                       Distribute results by R
                       ->  Seq Scan on TEST4 T
                             Filter: ((TEST1.C12)::NUMERIC = (C42)::NUMERIC)
(8 rows)

update test1 set c13=(select t.c43 from test4 as t where test1.c12=t.c42);
select * from test1 order by c11;
 C11 | C12 | C13 | C14 | C15 
-----+-----+-----+-----+-----
   1 |   1 |   2 |   1 |   1
   2 |   2 |   3 |   2 |   2
   3 |   3 |   4 |   3 |   3
   4 |   4 |   5 |   4 |   4
   5 |   5 |   6 |   5 |   5
   6 |   6 |   7 |   6 |   6
   7 |   7 |   8 |   7 |   7
   8 |   8 |   9 |   8 |   8
   9 |   9 |  10 |   9 |   9
  10 |  10 |  11 |  10 |  10
(10 rows)

drop table test1;
drop table test2;
drop table test3;
drop table test4;
reset client_min_messages;
reset datestyle;
reset intervalstyle;
reset client_encoding;
-- 1020421696882003165
-- test column name like opentenbase_ora
set enable_opentenbase_ora_column_name to on;
create table t_opentenbase_ora_colname_20230220("Id " int, "I D" int, num int[]);
insert into t_opentenbase_ora_colname_20230220 values (1, 2, array[1,2,3]), (2, 3, array[1,2,3]), (3, 4, array[1,2,3]);
-- test column name of node T_ColumnRef
select "Id " as id1, "I D" from t_opentenbase_ora_colname_20230220  order by "Id ";
 ID1 | I D 
-----+-----
   1 |   2
   2 |   3
   3 |   4
(3 rows)

-- test column name of node T_A_Indirection (opentenbase_ora doesn't support)
select num[2] from t_opentenbase_ora_colname_20230220  order by "Id ";
 NUM[] 
-------
     2
     2
     2
(3 rows)

-- test column name of node T_FuncCall
create or replace function f_opentenbase_ora_colname_20230220(id int)
return int AS
begin
return id;
end;
/
select f_opentenbase_ora_colname_20230220(num[1]) from t_opentenbase_ora_colname_20230220 order by "Id ";
 F_OPENTENBASE_ORA_COLNAME_20230220(NUM[1]) 
-----------------------------------
                                 1
                                 1
                                 1
(3 rows)

select sum("Id "), avg("I D") from t_opentenbase_ora_colname_20230220;
 SUM("ID") | AVG("ID") 
-----------+-----------
         6 |         3
(1 row)

-- test column name of node T_A_Expr
select sum("Id ") + 3, avg("I D") / 5 from t_opentenbase_ora_colname_20230220;
 SUM("ID")+3 | AVG("ID")/5 
-------------+-------------
           9 |          .6
(1 row)

select 1 + 1, 'a,' || 'b''' || 'c from' from dual;
 1+1 | 'A,'||'B'''||'CFROM' 
-----+----------------------
   2 | a,b'c from
(1 row)

-- test column name of node T_TypeCast (opentenbase_ora doesn't support)
select "Id "::text, "I D"::varchar(2) from t_opentenbase_ora_colname_20230220 order by "Id ";
 Id  | I D 
-----+-----
 1   | 2
 2   | 3
 3   | 4
(3 rows)

-- test column name of node T_collateClause (opentenbase_ora doesn't support)
select "Id "::text collate "C" from t_opentenbase_ora_colname_20230220 order by "Id ";
 Id  
-----
 1
 2
 3
(3 rows)

-- test column name of node T_GroupingFunc
select grouping("Id ") from t_opentenbase_ora_colname_20230220 group by "Id ";
 GROUPING("ID") 
----------------
              0
              0
              0
(3 rows)

select grouping_id("I D") from t_opentenbase_ora_colname_20230220 group by "I D";
 GROUPING_ID("ID") 
-------------------
                 0
                 0
                 0
(3 rows)

-- test column name of node T_SubLink (opentenbase_ora doesn't support exists, array, all, any)
select exists(select "Id " from t_opentenbase_ora_colname_20230220 order by "Id ") from t_opentenbase_ora_colname_20230220;
 exists 
--------
 t
 t
 t
(3 rows)

select array(select "I D" from t_opentenbase_ora_colname_20230220 order by "I D") from t_opentenbase_ora_colname_20230220;
  array  
---------
 {2,3,4}
 {2,3,4}
 {2,3,4}
(3 rows)

select (select "I D" from t_opentenbase_ora_colname_20230220 order by "I D" limit 1) from dual;
 (SELECT"ID"FROMT_OPENTENBASE_ORA_COLNAME_20230220ORDERBY"ID"LIMIT1) 
------------------------------------------------------------
                                                          2
(1 row)

select "Id " = all(select "Id " from t_opentenbase_ora_colname_20230220 order by "Id ") from t_opentenbase_ora_colname_20230220;
 ?column? 
----------
 f
 f
 f
(3 rows)

select "I D" > any(select "I D" from t_opentenbase_ora_colname_20230220 order by "I D",1) from t_opentenbase_ora_colname_20230220 order by 1;
 ?column? 
----------
 f
 t
 t
(3 rows)

-- test column name of node T_CaseExpr
select case when "Id " = 1 then 1 else 0 end from t_opentenbase_ora_colname_20230220;
 CASEWHEN"ID"=1THEN1ELSE0END 
-----------------------------
                           1
                           0
                           0
(3 rows)

-- test column name of node T_A_ArrayExpr (opentenbase_ora doesn't support)
select array['1', '2', '3'] from t_opentenbase_ora_colname_20230220;
  array  
---------
 {1,2,3}
 {1,2,3}
 {1,2,3}
(3 rows)

-- test column name of node T_RowExpr (opentenbase_ora doesn't support)
select row(1, 2, '3') from t_opentenbase_ora_colname_20230220;
   row   
---------
 (1,2,3)
 (1,2,3)
 (1,2,3)
(3 rows)

-- test column name of node T_CoalesceExpr
select coalesce(NULL, NULL, 3, 4, 5) FROM dual;
 COALESCE(NULL,NULL,3,4,5) 
---------------------------
                         3
(1 row)

select coalesce(3) FROM dual;
ERROR:  not enough arguments for function
-- test column name of node T_MinMaxExpr
select greatest(1, 2, 3, 4) from dual;
 GREATEST(1,2,3,4) 
-------------------
                 4
(1 row)

select least(1, 2, 3, 4) from dual;
 LEAST(1,2,3,4) 
----------------
              1
(1 row)

-- test column name of node T_SQLValueFunction
select current_date from dual where 1=0;
 CURRENT_DATE 
--------------
(0 rows)

select current_timestamp from dual where 1=0;
 CURRENT_TIMESTAMP 
-------------------
(0 rows)

select localtimestamp from dual where 1=0;
 LOCALTIMESTAMP 
----------------
(0 rows)

select localtimestamp(1) from dual where 1=0;
 LOCALTIMESTAMP 
----------------
(0 rows)

select uid from dual where 1=0;
 UID 
-----
(0 rows)

-- opentenbase_ora doesn't support the following T_SQLValueFunction
select current_time from dual where 1=0;
 current_time 
--------------
(0 rows)

select current_time(1) from dual where 1=0;
 current_time 
--------------
(0 rows)

select localtime from dual where 1=0;
 localtime 
-----------
(0 rows)

select localtime(1) from dual where 1=0;
 localtime 
-----------
(0 rows)

select current_role from dual where 1=0;
 current_role 
--------------
(0 rows)

select current_user from dual where 1=0;
 current_user 
--------------
(0 rows)

select user from dual where 1=0;
 USER 
------
(0 rows)

select session_user from dual where 1=0;
 session_user 
--------------
(0 rows)

select current_catalog from dual where 1=0;
 current_catalog 
-----------------
(0 rows)

select current_schema from dual where 1=0;
 current_schema 
----------------
(0 rows)

-- test column name of node T_XmlExpr (opentenbase_ora doesn't support is document)
SELECT xmlcomment('hello') from dual;
 XMLCOMMENT('HELLO') 
---------------------
 <!--hello-->
(1 row)

SELECT xmlconcat(xmlcomment('hello'), xmlcomment('world')) from dual;
 XMLCONCAT(XMLCOMMENT('HELLO'),XMLCOMMENT('WORLD')) 
----------------------------------------------------
 <!--hello--><!--world-->
(1 row)

SELECT xmlforest('abc' AS "FOO", 123 AS "BAR") from dual;
 XMLFOREST('ABC'AS"FOO",123AS"BAR") 
------------------------------------
 <FOO>abc</FOO><BAR>123</BAR>
(1 row)

SELECT xmlparse(content '<abc>x</abc>') from dual;
 XMLPARSE(CONTENT'<ABC>X</ABC>') 
---------------------------------
 <abc>x</abc>
(1 row)

SELECT xmlpi(name foo) from dual;
 XMLPI(NAMEFOO) 
----------------
 <?FOO?>
(1 row)

SELECT xmlroot( XMLType('<poid>143598</poid>'), VERSION '1.0', STANDALONE YES) from dual;
 XMLROOT(XMLTYPE('<POID>143598</POID>'),VERSION'1.0',STANDALONEY 
-----------------------------------------------------------------
 <?xml version="1.0" standalone="yes"?><poid>143598</poid>
(1 row)

SELECT xmlserialize(CONTENT xmlconcat(xmlcomment('hello'), xmlcomment('world')) as varchar2(30)) from dual;
 XMLSERIALIZE(CONTENTXMLCONCAT(XMLCOMMENT('HELLO'),XMLCOMMENT('W 
-----------------------------------------------------------------
 <!--hello--><!--world-->
(1 row)

SELECT xmlforest('abc' AS foo, 123 AS bar) is document from dual;
 ?column? 
----------
 f
(1 row)

-- test column name of node T_XmlSerialize
SELECT xmlserialize(CONTENT XMLTYPE('<Owner>Grandco</Owner>') as varchar2(30)) from dual;
 XMLSERIALIZE(CONTENTXMLTYPE('<OWNER>GRANDCO</OWNER>')ASVARCHAR2 
-----------------------------------------------------------------
 <Owner>Grandco</Owner>
(1 row)

select 1 from dual;
 1 
---
 1
(1 row)

select 1.2 from dual;
 1.2 
-----
 1.2
(1 row)

select ' 12 2 aaaa' from dual;
 '122AAAA'  
------------
  12 2 aaaa
(1 row)

select ' 1.3 nnn? 大' from dual;
 '1.3NNN?大'  
--------------
  1.3 nnn? 大
(1 row)

drop table t_opentenbase_ora_colname_20230220;
drop function f_opentenbase_ora_colname_20230220;
reset enable_opentenbase_ora_column_name;
-- save pg function for upgrade case in opentenbase_ora mode issue: ID884752731
\c regression
-- arg 3
SELECT regexp_replace('hello world', 'o', '0');
 regexp_replace 
----------------
 hell0 world
(1 row)

-- Output: 'hell0 world'
SELECT regexp_replace('123-456-789', '\d+', 'X');
 regexp_replace 
----------------
 X-456-789
(1 row)

-- Output: 'X-456-789'
-- arg 4
SELECT regexp_replace('hello world', 'o', '', 'g');
 regexp_replace 
----------------
 hell wrld
(1 row)

-- Output: 'hell wrld'
SELECT regexp_replace('hello world', 'o', 'O', 'g');
 regexp_replace 
----------------
 hellO wOrld
(1 row)

-- Output: 'hellO wOrld'
select regexp_replace('aaaaaaaaa', '[^0-9]',',') from dual;
 regexp_replace 
----------------
 ,aaaaaaaa
(1 row)

select regexp_replace('aaaaaaaaa', '[^0-9]','') from dual;
 regexp_replace 
----------------
 aaaaaaaa
(1 row)

select regexp_replace('aaaaaaaaa', null,',') from dual;
 regexp_replace 
----------------
 
(1 row)

select regexp_replace('aaaaaaaaa', null, null) from dual;
 regexp_replace 
----------------
 
(1 row)

select regexp_replace(null, null, null) from dual;
 regexp_replace 
----------------
 
(1 row)

select regexp_replace(null, 'a', null) from dual;
 regexp_replace 
----------------
 
(1 row)

select regexp_replace(null, 'a', 'a') from dual;
 regexp_replace 
----------------
 
(1 row)

\c regression_ora
-- arg 3
SELECT regexp_replace('hello world', 'o', '0') from dual;
 REGEXP_REPLACE 
----------------
 hell0 w0rld
(1 row)

-- Output: 'hell0 w0rld'
SELECT regexp_replace('123-456-789', '\d+', 'X') from dual;
 REGEXP_REPLACE 
----------------
 X-X-X
(1 row)

-- Output: 'X-X-X'
-- arg 4
SELECT regexp_replace('hello world', 'o', '', 'g') from dual;
ERROR:  invalid input syntax for type numeric: "g"
LINE 1: SELECT regexp_replace('hello world', 'o', '', 'g') from dual...
                                                      ^
-- ERROR: invalid number
SELECT regexp_replace('hello world', 'o', 'O', 'g') from dual;
ERROR:  invalid input syntax for type numeric: "g"
LINE 1: SELECT regexp_replace('hello world', 'o', 'O', 'g') from dua...
                                                       ^
-- ERROR: invalid number
select regexp_replace('abcd(def)','\(|\)','\1','g') from dual;
ERROR:  invalid input syntax for type numeric: "g"
LINE 1: select regexp_replace('abcd(def)','\(|\)','\1','g') from dua...
                                                       ^
-- ERROR: invalid number
-- const test
select regexp_replace('1g3fd6f8dyf', '[0-9]',',','1a') from dual;
ERROR:  invalid input syntax for type numeric: "1a"
LINE 1: select regexp_replace('1g3fd6f8dyf', '[0-9]',',','1a') from ...
                                                         ^
select regexp_replace('1g3fd6f8dyf', '[0-9]',',','gggg') from dual;
ERROR:  invalid input syntax for type numeric: "gggg"
LINE 1: select regexp_replace('1g3fd6f8dyf', '[0-9]',',','gggg') fro...
                                                         ^
select regexp_replace('1g3fd6f8dyf', '[0-9]',',','ggggiii') from dual;
ERROR:  invalid input syntax for type numeric: "ggggiii"
LINE 1: select regexp_replace('1g3fd6f8dyf', '[0-9]',',','ggggiii') ...
                                                         ^
select regexp_replace('1g3fd6f8dyf', '[0-9]',',','ggggiii12') from dual;
ERROR:  invalid input syntax for type numeric: "ggggiii12"
LINE 1: select regexp_replace('1g3fd6f8dyf', '[0-9]',',','ggggiii12'...
                                                         ^
select regexp_replace('1g3fd6f8dyf', '[0-9]',',','1g') from dual;
ERROR:  invalid input syntax for type numeric: "1g"
LINE 1: select regexp_replace('1g3fd6f8dyf', '[0-9]',',','1g') from ...
                                                         ^
select regexp_replace('1g3fd6f8dyf', '[0-9]',',','1') from dual;
 REGEXP_REPLACE 
----------------
 ,g,fd,f,dyf
(1 row)

select regexp_replace('1g3fd6f8dyf', null,',',1) from dual;
 REGEXP_REPLACE 
----------------
 1g3fd6f8dyf
(1 row)

select regexp_replace('1g3fd6f8dyf', null, null,'5') from dual;
 REGEXP_REPLACE 
----------------
 1g3fd6f8dyf
(1 row)

select regexp_replace('1g3fd6f8dyf', null, null,5) from dual;
 REGEXP_REPLACE 
----------------
 1g3fd6f8dyf
(1 row)

-- postion err
select regexp_replace('1g3fd6f8dyf', '[0-9]',',','-1') from dual;
ERROR:  Invalid "position" value (-1) for "regexp_replace"
HINT:  "position" must be a positive integer
select regexp_replace('1g3fd6f8dyf', null,',',-1) from dual;
 REGEXP_REPLACE 
----------------
 1g3fd6f8dyf
(1 row)

select regexp_replace('1g3fd6f8dyf', null, null,'0') from dual;
 REGEXP_REPLACE 
----------------
 1g3fd6f8dyf
(1 row)

select regexp_replace('1g3fd6f8dyf', null, null,0) from dual;
 REGEXP_REPLACE 
----------------
 1g3fd6f8dyf
(1 row)

select regexp_replace('1g3fd6f8dyf', '[0-9]',',','100000') from dual;
 REGEXP_REPLACE 
----------------
 1g3fd6f8dyf
(1 row)

select regexp_replace('1g3fd6f8dyf', null,',',100000) from dual;
 REGEXP_REPLACE 
----------------
 1g3fd6f8dyf
(1 row)

select regexp_replace('1g3fd6f8dyf', null, null,'100000') from dual;
 REGEXP_REPLACE 
----------------
 1g3fd6f8dyf
(1 row)

select regexp_replace('1g3fd6f8dyf', null, null,100000) from dual;
 REGEXP_REPLACE 
----------------
 1g3fd6f8dyf
(1 row)

-- opentenbase_ora create table with physical_attributes_clause
CREATE TABLE phy_attr_storage_test_table (a numeric)
    PCTFREE    10
    PCTUSED    90
    INITRANS   2
    MAXTRANS   255
    STORAGE (INITIAL 100K NEXT 100K MINEXTENTS 1 MAXEXTENTS 100 PCTINCREASE 0 FREELISTS 4 FREELIST GROUPS 1 OPTIMAL 10K BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT ENCRYPT)
;
ALTER TABLE phy_attr_storage_test_table
    ADD d int,
    ADD e int,
    PCTFREE    10
    PCTUSED    90
    INITRANS   2
    MAXTRANS   255
    STORAGE (INITIAL 100T NEXT 100K MINEXTENTS 1 MAXEXTENTS 100 PCTINCREASE 0 FREELISTS 4 FREELIST GROUPS 1 OPTIMAL 10K BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT ENCRYPT)
;
CREATE INDEX phy_attr_storage_test_index ON phy_attr_storage_test_table (a)
    PCTFREE    10
    PCTUSED    90
    INITRANS   2
    MAXTRANS   255
    STORAGE (INITIAL 100K NEXT 100K MINEXTENTS 1 MAXEXTENTS 100 PCTINCREASE 0 FREELISTS 4 FREELIST GROUPS 1 OPTIMAL 10K BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT ENCRYPT);
ALTER INDEX phy_attr_storage_test_index
    PCTFREE    10
    PCTUSED    0
    INITRANS   2
    MAXTRANS   255
    STORAGE (INITIAL 100K NEXT 100K MINEXTENTS 1 MAXEXTENTS 100 PCTINCREASE 0 FREELISTS 4 FREELIST GROUPS 1 OPTIMAL 10K BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT ENCRYPT);
CREATE MATERIALIZED VIEW phy_attr_storage_test_matview
    PCTFREE    10
    PCTUSED    90
    INITRANS   2
    MAXTRANS   255
    STORAGE (INITIAL 100K NEXT 100K MINEXTENTS 1 MAXEXTENTS 100 PCTINCREASE 0 FREELISTS 4 FREELIST GROUPS 1 OPTIMAL 10K BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT ENCRYPT)
AS SELECT * FROM phy_attr_storage_test_table;
alter MATERIALIZED VIEW phy_attr_storage_test_matview
    PCTFREE    10
    PCTUSED    90
    INITRANS   2
    MAXTRANS   255
    STORAGE (INITIAL 100K NEXT 100K MINEXTENTS 1 MAXEXTENTS 100 PCTINCREASE 0 FREELISTS 4 FREELIST GROUPS 1 OPTIMAL 10K BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT ENCRYPT)
;
drop table phy_attr_storage_test_table cascade;
NOTICE:  drop cascades to materialized view PHY_ATTR_STORAGE_TEST_MATVIEW
-- test unique_column_name
set unique_column_name to on;
select '','' as alias_column,substr('opentenbase',5,2),substr('opentenbase',-3),null,null,'opentenbase' as alias_column;
 ?column? | ALIAS_COLUMN | SUBSTR | SUBSTR_1 | ?column?_1 | ?column?_2 | ALIAS_COLUMN 
----------+--------------+--------+----------+------------+------------+--------------
          |              | e      | ase      |            |            | opentenbase
(1 row)

create table t_unique_column_name (a int, a_1 int);
select a,a from t_unique_column_name;
 A | A_1 
---+-----
(0 rows)

select a,a,a_1,a from t_unique_column_name;
 A | A_1 | A_1_1 | A_2 
---+-----+-------+-----
(0 rows)

select a,a_1,a_1,a from t_unique_column_name;
 A | A_1 | A_1_1 | A_2 
---+-----+-------+-----
(0 rows)

select *,a as a from t_unique_column_name;
 A | A_1 | A 
---+-----+---
(0 rows)

drop table t_unique_column_name;
reset unique_column_name;
-- Remove group by in EXISTS subquery
set enable_opentenbase_ora_compatible = on;
ERROR:  unrecognized configuration parameter "enable_opentenbase_ora_compatible"
create table hoo(o1 int, o2 int);
insert into hoo values(1,2);
insert into hoo values(1,3);
insert into hoo values(1,4);
create table hii(i1 int, i2 int);
insert into hii values(1,2);
insert into hii values(1,3);
insert into hii values(1,4);
create or replace function ftest(a int) return int
as
begin
  return a;
end;
/
select * from hoo where exists (select i2 from hii group by 1);
 O1 | O2 
----+----
  1 |  2
  1 |  3
  1 |  4
(3 rows)

select 1 from dual where exists (select i1, sum(i2) from hii group by i1);
 ?column? 
----------
        1
(1 row)

select 1 from hoo where exists (select i1, sum(i1) from hii group by i1);
 ?column? 
----------
        1
        1
        1
(3 rows)

select 1 from hoo where exists (select sum(i2) over() from hii group by i2);
 ?column? 
----------
        1
        1
        1
(3 rows)

select 1 from hoo where exists (select rank() over(order by i2) from hii group by i2);
 ?column? 
----------
        1
        1
        1
(3 rows)

update hoo set o1 = o2+10 where exists (select i1 from hii group by i1 having sum(i2)>1);
ERROR:  Distributed column "O1" can't be updated in current version
update hoo set o1 = o2+10 where exists (select i1 from hii group by cube(i1));
ERROR:  Distributed column "O1" can't be updated in current version
--  invalid cases
select 1 from hoo where exists (select i1, sum(i2) from hii group by i2);
ERROR:  column "HII.I1" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: select 1 from hoo where exists (select i1, sum(i2) from hii ...
                                               ^
select 1 from hoo where exists (select i1, sum(i2) from hii group by 'any char');
ERROR:  column "HII.I1" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: select 1 from hoo where exists (select i1, sum(i2) from hii ...
                                               ^
select 1 from hoo where exists (select sum(i1) over() from hii group by i2);
ERROR:  column "HII.I1" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: select 1 from hoo where exists (select sum(i1) over() from h...
                                                   ^
select 1 from hoo where exists (select rank() over(order by i1) from hii group by i2);
ERROR:  column "HII.I1" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: ...rom hoo where exists (select rank() over(order by i1) from h...
                                                             ^
update hoo set o1 = o2+10 where exists (select i2 from hii group by i1 having 1=1);
ERROR:  column "HII.I2" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: update hoo set o1 = o2+10 where exists (select i2 from hii g...
                                                       ^
update hoo set o1 = o2+10 where exists (select i2 from hii group by cube(i1));
ERROR:  column "HII.I2" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: update hoo set o1 = o2+10 where exists (select i2 from hii g...
                                                       ^
drop table hoo;
drop table hii;
drop function ftest;
-- Support the judge whether the PARAM is null in PREPARE stmt
create table ttest_20230607 (a int, b int);
insert into ttest_20230607 values(1,1);
insert into ttest_20230607 values('',1);
prepare s as select * from ttest_20230607 where $1 is null;
execute s('1');
 A | B 
---+---
(0 rows)

execute s(1);
 A | B 
---+---
(0 rows)

execute s('');
 A | B 
---+---
 1 | 1
   | 1
(2 rows)

execute s(NULL);
 A | B 
---+---
 1 | 1
   | 1
(2 rows)

deallocate s;
prepare s as
select $1 is null from ttest_20230607;
execute s(1);
 ?column? 
----------
 f
 f
(2 rows)

execute s('');
 ?column? 
----------
 t
 t
(2 rows)

execute s(NULL);
 ?column? 
----------
 t
 t
(2 rows)

deallocate s;
prepare s as select decode(a,$1,'first','default') from ttest_20230607;
execute s(1);
 DECODE  
---------
 first
 default
(2 rows)

execute s(2);
 DECODE  
---------
 default
 default
(2 rows)

execute s('');
 DECODE  
---------
 default
 first
(2 rows)

execute s(NULL);
 DECODE  
---------
 default
 first
(2 rows)

deallocate s;
prepare s as select decode(a,$1,'first',$2,'second') from ttest_20230607;
execute s(-1,2);
 DECODE 
--------
 
 
(2 rows)

execute s(2,1);
 DECODE 
--------
 second
 
(2 rows)

execute s('',2);
 DECODE 
--------
 
 first
(2 rows)

execute s(1,'');
 DECODE 
--------
 first
 second
(2 rows)

execute s('','');
 DECODE 
--------
 
 first
(2 rows)

execute s(NULL,NULL);
 DECODE 
--------
 
 first
(2 rows)

deallocate s;
prepare s as select decode(a,$1 + $2,'first','default') from ttest_20230607;
execute s(1,0);
 DECODE  
---------
 first
 default
(2 rows)

execute s(2,1);
 DECODE  
---------
 default
 default
(2 rows)

execute s(1+'',1);
 DECODE  
---------
 default
 first
(2 rows)

execute s('','');
 DECODE  
---------
 default
 first
(2 rows)

execute s(NULL,NULL);
 DECODE  
---------
 default
 first
(2 rows)

deallocate s;
prepare s as select decode(a,$1 + 2,'first','default') from ttest_20230607;
execute s(-1);
 DECODE  
---------
 first
 default
(2 rows)

execute s(0);
 DECODE  
---------
 default
 default
(2 rows)

execute s(1+'');
 DECODE  
---------
 default
 first
(2 rows)

execute s(1+NULL);
 DECODE  
---------
 default
 first
(2 rows)

execute s('');
 DECODE  
---------
 default
 first
(2 rows)

execute s(NULL);
 DECODE  
---------
 default
 first
(2 rows)

deallocate s;
prepare s as
select case when $1 is null then 'first' else 'else' end from ttest_20230607;
execute s('');
 case  
-------
 first
 first
(2 rows)

execute s(NULL);
 case  
-------
 first
 first
(2 rows)

execute s(1);
 case 
------
 else
 else
(2 rows)

deallocate s;
prepare s as
select case when $1 is null then 'first'
            when $2 is not null then 'second'
            else 'else' end from ttest_20230607;
execute s('',1);
 case  
-------
 first
 first
(2 rows)

execute s(1,1);
  case  
--------
 second
 second
(2 rows)

execute s(1,'');
 case 
------
 else
 else
(2 rows)

execute s('','');
 case  
-------
 first
 first
(2 rows)

execute s(NULL,1);
 case  
-------
 first
 first
(2 rows)

execute s(1,NULL);
 case 
------
 else
 else
(2 rows)

execute s(NULL,NULL);
 case  
-------
 first
 first
(2 rows)

deallocate s;
-- failed
prepare s as
select $1 is distinct from null as "not null" from ttest_20230607;
ERROR:  could not determine data type of parameter $1
drop table ttest_20230607;
-- inner COMMIT with output arguments
drop PROCEDURE if exists test_proc7cc(_x int);
NOTICE:  procedure TEST_PROC7CC(pg_catalog.INT4) does not exist, skipping
drop PROCEDURE if exists test_proc7c(x int, INOUT a int, INOUT b numeric);
NOTICE:  procedure TEST_PROC7C(pg_catalog.INT4,pg_catalog.INT4,pg_catalog.NUMERIC) does not exist, skipping
CREATE PROCEDURE test_proc7c(x int, INOUT a int, INOUT b numeric)
AS
BEGIN
  a := x / 10;
  b := x / 2;
  COMMIT;
END;
/
CREATE PROCEDURE test_proc7cc(_x int)
AS
DECLARE _a int; _b numeric;
BEGIN
  CALL test_proc7c(_x, _a, _b);
  RAISE NOTICE '_x: %,_a: %, _b: %', _x, _a, _b;
END;
/
CALL test_proc7cc(10);
NOTICE:  _x: 10,_a: 1, _b: 5
-- Fix error-cleanup mistakes in exec_stmt_call()
create or replace procedure test_proc7cc(_x int)
as
declare _a int; _b numeric;
begin
  call test_proc7c(_x, _a, 1);
  raise notice '_x: %,_a: %, _b: %', _x, _a, _b;
end;
/
call test_proc7cc(10);
ERROR:  procedure parameter "B" is an output parameter but corresponding argument is not writable
CONTEXT:  PL/pgSQL function TEST_PROC7CC(INTEGER) line 4 at CALL
create or replace procedure test_proc7cc(_x int)
language default_plsql
as $$
declare _a int; _b numeric;
begin
  call test_proc7c(_x, _a, 1);
  raise notice '_x: %,_a: %, _b: %', _x, _a, _b;
end
$$;
call test_proc7cc(10);
ERROR:  procedure parameter "B" is an output parameter but corresponding argument is not writable
CONTEXT:  PL/pgSQL function TEST_PROC7CC(INTEGER) line 4 at CALL
drop PROCEDURE test_proc7cc(_x int);
drop PROCEDURE test_proc7c(x int, INOUT a int, INOUT b numeric);
create or replace function ftype_str_88(v1 text, v2 varchar2, v3 char(10), v4 varchar)
return int is
begin
 raise notice '%, %,%,%', v1, v2, v3,v4;
 return 1;
end;
/
create or replace function ftype_num_88(v1 number, v2 int, v3 float, v4 bigint)
return int is
begin
 raise notice '%,%,%,%', v1, v2, v3, v4;
 return 1;
end;
/
declare
  vtxt text default 1;
  vvar2 varchar2 default 2;
  vvar varchar default 3;
  vcar char(20) default 44;
  vi int default 4;
  vf float default 10.0;
  vb bigint default 10;
  vnum number default 10.12;
  ret int;
begin
-- string -> number
-- text
  ret = ftype_num_88(vtxt,vtxt,vtxt,vtxt);
-- varchar2/varchar
  ret = ftype_num_88(vvar,vvar,vvar,vvar);
  ret = ftype_num_88(vvar2,vvar2,vvar2,vvar2);
-- char
  ret = ftype_num_88(vcar,vcar,vcar,vcar);
-- number -> string 
-- int
  ret = ftype_str_88(vi, vi, vi, vi);
-- float
  ret = ftype_str_88(vf, vf, vf, vf);
-- bigint
  ret = ftype_str_88(vb, vb, vb, vb);
-- number
  ret = ftype_str_88(vnum, vnum, vnum, vnum);
end;
/
NOTICE:  1,1,1,1
NOTICE:  3,3,3,3
NOTICE:  2,2,2,2
NOTICE:  44,44,44,44
NOTICE:  4, 4,4,4
NOTICE:  10, 10,10,10
NOTICE:  10, 10,10,10
NOTICE:  10.12, 10.12,10.12,10.12
drop function ftype_str_88;
drop function ftype_num_88;
-- test tapd:ID884788269
create table lbw_0101(c1 varchar2(10));
insert into lbw_0101 values (1);
select least(0,c1 ) from lbw_0101;
 least 
-------
     0
(1 row)

select greatest(0,c1 ) from lbw_0101;
 greatest 
----------
        1
(1 row)

drop table lbw_0101;
-- test string and numeric
create table test_20230904(c1 int,c2 bigint,c3 numeric,c4 char,c5 varchar(100),c6 varchar2(100),c7 text);
insert into test_20230904 values(100,200,300,'1','100','1000','10000');
select least(c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 least 
-------
     1
(1 row)

select greatest(c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 greatest 
----------
    10000
(1 row)

select least('0',c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 least 
-------
 0
(1 row)

select greatest(0,c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 greatest 
----------
    10000
(1 row)

select greatest('0',c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 greatest 
----------
 300
(1 row)

select least(0,c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 least 
-------
     0
(1 row)

delete from test_20230904;
-- test error
insert into test_20230904 values(100,200,300,'a','abc00','1000','10000');
select least(c1,c2,c3,c4,c5,c6,c7) from test_20230904;
ERROR:  invalid input syntax for type numeric: "a"
select greatest(c1,c2,c3,c4,c5,c6,c7) from test_20230904;
ERROR:  invalid input syntax for type numeric: "a"
select least('0',c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 least 
-------
 0
(1 row)

select greatest(0,c1,c2,c3,c4,c5,c6,c7) from test_20230904;
ERROR:  invalid input syntax for type numeric: "a"
select greatest('0',c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 greatest 
----------
 abc00
(1 row)

select least(0,c1,c2,c3,c4,c5,c6,c7) from test_20230904;
ERROR:  invalid input syntax for type numeric: "a"
select least(c4,c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 least 
-------
 100
(1 row)

select least(c5,c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 least 
-------
 100
(1 row)

select least(c6,c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 least 
-------
 100
(1 row)

select least(c7,c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 least 
-------
 100
(1 row)

drop table test_20230904;
-- test float
create table test_20230904 (c1 float,c2 float8,c3 numeric,c4 char,c5 varchar(100),c6 varchar2(100),c7 text);
insert into test_20230904 values(3.33,1.11,22.2,'1','9.9','2.3','4.4');
select least(c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 least 
-------
     1
(1 row)

select least('9',c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 least 
-------
 1
(1 row)

select greatest(c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 greatest 
----------
     22.2
(1 row)

select greatest('1',c1,c2,c3,c4,c5,c6,c7) from test_20230904;
 greatest 
----------
 9.9
(1 row)

drop table test_20230904;
-- test other type
create table test_20230904(c1 date,c2 varchar(200));
insert into test_20230904 values('2023-09-04 11:11:11','2023-09-04 11:11:12');
select least(c1,c2) from test_20230904;
   least    
------------
 2023-09-04
(1 row)

select least(c2,c1) from test_20230904;
   least    
------------
 2023-09-04
(1 row)

select least('0',c2,c1) from test_20230904;
 least 
-------
 0
(1 row)

drop table test_20230904;
create table test_cb_20220816_1(id varchar2(10),mc varchar2(50));
insert into test_cb_20220816_1 values('1','11111');
insert into test_cb_20220816_1 values('1','22222');
insert into test_cb_20220816_1 values('2','11111');
insert into test_cb_20220816_1 values('2','22222');
insert into test_cb_20220816_1 values('3','11111');
insert into test_cb_20220816_1 values('3','22222');
insert into test_cb_20220816_1 values('3','33333');
drop table test_cb_20220816_1;
set disable_empty_to_null to on;
create table test_null_20231213(c1 int,c2 varchar2(10) not null,c3 text not null,c4 varchar(10) not null);
insert into test_null_20231213 values(1,'','','');
select * from test_null_20231213;
 C1 | C2 | C3 | C4 
----+----+----+----
  1 |    |    | 
(1 row)

set disable_empty_to_null to off;
\copy test_null_20231213(c1,c2,c3,c4) from stdin;
ERROR:  null value in column "C2" violates not-null constraint
DETAIL:  Failing row contains (3, null, qq, qq).
set disable_empty_to_null to on;
\copy test_null_20231213(c1,c2,c3,c4) from stdin;
select * from test_null_20231213 where c2 is not null order by 1;
 C1 | C2 | C3 | C4 
----+----+----+----
  1 |    |    | 
  2 |    | qq | qq
  3 |    | qq | qq
  4 |    | qq | qq
(4 rows)

drop table test_null_20231213;
create table t_20231210(id int,eno int);
drop table t_20231210;
-- empty string as null
--
-- BUGID: 116117311 BEGIN
--
reset disable_empty_to_null;
CREATE TABLE tbl_orders_20230526 (
	  order_id int,
	  salesperson_id INTEGER NOT NULL,
	  customer_id INTEGER NOT NULL
);
ALTER TABLE tbl_orders_20230526 ENABLE ROW LEVEL SECURITY;
CREATE POLICY tbl_orders_20230526_policy ON tbl_orders_20230526
USING (salesperson_id = 10)
WITH CHECK (salesperson_id = 10);
select * from pg_policies where POLICYNAME='TBL_ORDERS_20230526_POLICY';
 SCHEMANAME |      TABLENAME      |         POLICYNAME         | PERMISSIVE |  ROLES   | CMD |         QUAL          |      WITH_CHECK       
------------+---------------------+----------------------------+------------+----------+-----+-----------------------+-----------------------
 public     | TBL_ORDERS_20230526 | TBL_ORDERS_20230526_POLICY | PERMISSIVE | {public} | ALL | (SALESPERSON_ID = 10) | (SALESPERSON_ID = 10)
(1 row)

drop policy tbl_orders_20230526_policy on tbl_orders_20230526;
drop table tbl_orders_20230526;
select string_to_array('public', '') from dual;
 STRING_TO_ARRAY 
-----------------
 {public}
(1 row)

select string_to_array('public', null) from dual;
 STRING_TO_ARRAY 
-----------------
 {p,u,b,l,i,c}
(1 row)

--
-- BUGID: 116117311 END 
--
--
-- Fixed the incompatibility issue with opentenbase_ora in text equality comparison.
--
--TestPoint:1.char
create table table_t4_20240601(name char(50));
insert into table_t4_20240601 values('Hello');
select * from table_t4_20240601 where upper(name)=upper('hello');
                        NAME                        
----------------------------------------------------
 Hello                                             
(1 row)

select * from table_t4_20240601 where lower(name)=lower('hello');
                        NAME                        
----------------------------------------------------
 Hello                                             
(1 row)

select * from table_t4_20240601 where nls_lower(name)=nls_lower('hello');
                        NAME                        
----------------------------------------------------
 Hello                                             
(1 row)

select * from table_t4_20240601 where nls_upper(name)=nls_upper('hello');
                        NAME                        
----------------------------------------------------
 Hello                                             
(1 row)

drop table table_t4_20240601;
--TestPoint:2.nchar
drop table table_t4_20240601;
ERROR:  table "TABLE_T4_20240601" does not exist
create table table_t4_20240601(name nchar(50));
insert into table_t4_20240601 values('Hello');
select * from table_t4_20240601 where upper(name)=upper('hello');
                        NAME                        
----------------------------------------------------
 Hello                                             
(1 row)

select * from table_t4_20240601 where lower(name)=lower('hello');
                        NAME                        
----------------------------------------------------
 Hello                                             
(1 row)

select * from table_t4_20240601 where nls_lower(name)=nls_lower('hello');
                        NAME                        
----------------------------------------------------
 Hello                                             
(1 row)

select * from table_t4_20240601 where nls_upper(name)=nls_upper('hello');
                        NAME                        
----------------------------------------------------
 Hello                                             
(1 row)

drop table table_t4_20240601;
/* Fix update syntax issue when updated column bracketed */
drop table if exists t_20240520_1;
NOTICE:  table "T_20240520_1" does not exist, skipping
drop table if exists t_20240520_2;
NOTICE:  table "T_20240520_2" does not exist, skipping
create table t_20240520_1(a int, b int);
update t_20240520_1 set (b) = 1;
update t_20240520_1 set (b) = '123';
create table t_20240520_2(x int, y int);
update t_20240520_1 set (b) = y from t_20240520_2 where a = x;
update t_20240520_1 set (b) = (y) from t_20240520_2 where a = x;
drop table t_20240520_1;
drop table t_20240520_2;
drop table if exists t_20240520;
NOTICE:  table "T_20240520" does not exist, skipping
create table t_20240520(a int, b int);
update t_20240520 x set x.x = 1;
ERROR:  column "X"."X" of relation "T_20240520" does not exist
LINE 1: update t_20240520 x set x.x = 1;
                                ^
update t_20240520 x set x.b = 1;
update t_20240520 x set x.y.z = 1;
ERROR:  column "X"."Y"."Z" of relation "T_20240520" does not exist
LINE 1: update t_20240520 x set x.y.z = 1;
                                ^
drop table t_20240520;
