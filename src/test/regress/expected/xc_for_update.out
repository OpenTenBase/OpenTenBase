--
-- XC_FOR_UPDATE
--
set enable_fast_query_shipping=true;
-- create some tables
create table t1(val int, val2 int);
create table t2(val int, val2 int);
create table t3(val int, val2 int);
create table p1(a int, b int);
create table c1(d int, e int) inherits (p1);
-- insert some rows in them
insert into t1 values(1,11),(2,11);
insert into t2 values(3,11),(4,11);
insert into t3 values(5,11),(6,11);
insert into p1 values(55,66),(77,88);
insert into c1 values(111,222,333,444),(123,345,567,789);
select * from t1 order by val;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

select * from t2 order by val;
 val | val2 
-----+------
   3 |   11
   4 |   11
(2 rows)

select * from t3 order by val;
 val | val2 
-----+------
   5 |   11
   6 |   11
(2 rows)

select * from p1 order by a;
  a  |  b  
-----+-----
  55 |  66
  77 |  88
 111 | 222
 123 | 345
(4 rows)

select * from c1 order by a;
  a  |  b  |  d  |  e  
-----+-----+-----+-----
 111 | 222 | 333 | 444
 123 | 345 | 567 | 789
(2 rows)

-- create a view too
create view v1 as select * from t1 for update;
-- test a few queries with row marks
select * from t1 order by 1 for update of t1 nowait;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

--select * from t1, t2, t3 order by 1 for update;
select * from v1 order by val;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

--WITH q1 AS (SELECT * from t1 order by 1 FOR UPDATE) SELECT * FROM q1,t2 order by 1 FOR UPDATE;
WITH q1 AS (SELECT * from t1 order by 1) SELECT * FROM q1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

WITH q1 AS (SELECT * from t1 order by 1) SELECT * FROM q1 FOR UPDATE;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

WITH q1 AS (SELECT * from t1 order by 1 FOR UPDATE) SELECT * FROM q1 FOR UPDATE;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

-- confirm that in various join scenarios for update gets to the remote query
-- single table case
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 for update of t1 nowait;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: t1.val, t1.val2, t1.ctid, t1.xc_node_id
   Remote query: SELECT val, val2 FROM public.t1 FOR UPDATE OF t1 NOWAIT
   ->  LockRows
         Output: val, val2, ctid, xc_node_id
         ->  Seq Scan on public.t1
               Output: val, val2, ctid, xc_node_id
(7 rows)

-- two table case
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2 where t1.val = t2.val for update nowait;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2 where t1.val = t2.val for update;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2 where t1.val = t2.val for share;
ERROR:  FOR SHARE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2 where t1.val = t2.val;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: t1.val, t1.val2, t2.val, t2.val2
   Remote query: SELECT t1.val, t1.val2, t2.val, t2.val2 FROM public.t1, public.t2 WHERE (t1.val = t2.val)
   ->  Merge Join
         Output: t1.val, t1.val2, t2.val, t2.val2
         Merge Cond: (t1.val = t2.val)
         ->  Sort
               Output: t1.val, t1.val2
               Sort Key: t1.val
               ->  Seq Scan on public.t1
                     Output: t1.val, t1.val2
         ->  Sort
               Output: t2.val, t2.val2
               Sort Key: t2.val
               ->  Seq Scan on public.t2
                     Output: t2.val, t2.val2
(16 rows)

explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2;
                        QUERY PLAN                        
----------------------------------------------------------
 Nested Loop
   Output: t1.val, t1.val2, t2.val, t2.val2
   ->  Remote Subquery Scan[1] on all (datanodes 2)
         Output: t1.val, t1.val2
         ->  Seq Scan on public.t1
               Output: t1.val, t1.val2
   ->  Materialize
         Output: t2.val, t2.val2
         ->  Remote Subquery Scan[2] on all (datanodes 2)
               Output: t2.val, t2.val2
               ->  Seq Scan on public.t2
                     Output: t2.val, t2.val2
(12 rows)

explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2 for update;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2 for update nowait;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2 for share nowait;
ERROR:  FOR SHARE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2 for share;
ERROR:  FOR SHARE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2 for share of t2;
ERROR:  FOR SHARE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 join t2 on (t1.val = t2.val) for share;
ERROR:  FOR SHARE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 left join t2 on (t1.val = t2.val) for share;
ERROR:  FOR SHARE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 right join t2 on (t1.val = t2.val) for share;
ERROR:  FOR SHARE is not allowed with joins
select * from t1 join t2 on (t1.val = t2.val) for share;
ERROR:  FOR SHARE is not allowed with joins
select * from t1 left join t2 on (t1.val = t2.val) for share;
ERROR:  FOR SHARE is not allowed with joins
select * from t1 right join t2 on (t1.val = t2.val) for share;
ERROR:  FOR SHARE is not allowed with joins
-- three table case
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2, t3;
                           QUERY PLAN                           
----------------------------------------------------------------
 Nested Loop
   Output: t1.val, t1.val2, t2.val, t2.val2, t3.val, t3.val2
   ->  Nested Loop
         Output: t1.val, t1.val2, t2.val, t2.val2
         ->  Remote Subquery Scan[1] on all (datanodes 2)
               Output: t1.val, t1.val2
               ->  Seq Scan on public.t1
                     Output: t1.val, t1.val2
         ->  Materialize
               Output: t2.val, t2.val2
               ->  Remote Subquery Scan[2] on all (datanodes 2)
                     Output: t2.val, t2.val2
                     ->  Seq Scan on public.t2
                           Output: t2.val, t2.val2
   ->  Materialize
         Output: t3.val, t3.val2
         ->  Remote Subquery Scan[3] on all (datanodes 2)
               Output: t3.val, t3.val2
               ->  Seq Scan on public.t3
                     Output: t3.val, t3.val2
(20 rows)

explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2, t3 for update;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2, t3 for update of t1;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2, t3 for update of t1,t3;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2, t3 for update of t1,t3 nowait;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2, t3 for share of t1,t2 nowait;
ERROR:  FOR SHARE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 join t2 on (t1.val2 = t2.val2) join t3 on (t1.val2 = t3.val2);
                              QUERY PLAN                              
----------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanodes 2)
   Output: t1.val, t1.val2, t2.val, t2.val2, t3.val, t3.val2
   ->  Merge Join
         Output: t1.val, t1.val2, t2.val, t2.val2, t3.val, t3.val2
         Merge Cond: (t1.val2 = t3.val2)
         ->  Merge Join
               Output: t1.val, t1.val2, t2.val, t2.val2
               Merge Cond: (t1.val2 = t2.val2)
               ->  Remote Subquery Scan[2] on all (datanodes 2)
                     Output: t1.val, t1.val2
                     Sort Key: t1.val2
                     Distribute results by S: val2
                     ->  Sort
                           Output: t1.val, t1.val2
                           Sort Key: t1.val2
                           ->  Seq Scan on public.t1
                                 Output: t1.val, t1.val2
               ->  Materialize
                     Output: t2.val, t2.val2
                     ->  Remote Subquery Scan[3] on all (datanodes 2)
                           Output: t2.val, t2.val2
                           Sort Key: t2.val2
                           Distribute results by S: val2
                           ->  Sort
                                 Output: t2.val, t2.val2
                                 Sort Key: t2.val2
                                 ->  Seq Scan on public.t2
                                       Output: t2.val, t2.val2
         ->  Materialize
               Output: t3.val, t3.val2
               ->  Remote Subquery Scan[4] on all (datanodes 2)
                     Output: t3.val, t3.val2
                     Sort Key: t3.val2
                     Distribute results by S: val2
                     ->  Sort
                           Output: t3.val, t3.val2
                           Sort Key: t3.val2
                           ->  Seq Scan on public.t3
                                 Output: t3.val, t3.val2
(39 rows)

explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 join t2 on (t1.val2 = t2.val2) join t3 on (t1.val2 = t3.val2) for update;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 join t2 on (t1.val2 = t2.val2) join t3 on (t1.val2 = t3.val2) for update of t1;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 join t2 on (t1.val2 = t2.val2) join t3 on (t1.val2 = t3.val2) for update of t1,t3;
ERROR:  FOR UPDATE is not allowed with joins
select * from t1 join t2 on (t1.val2 = t2.val2) join t3 on (t1.val2 = t3.val2);
 val | val2 | val | val2 | val | val2 
-----+------+-----+------+-----+------
   1 |   11 |   3 |   11 |   5 |   11
   1 |   11 |   3 |   11 |   6 |   11
   1 |   11 |   4 |   11 |   5 |   11
   1 |   11 |   4 |   11 |   6 |   11
   2 |   11 |   3 |   11 |   5 |   11
   2 |   11 |   3 |   11 |   6 |   11
   2 |   11 |   4 |   11 |   5 |   11
   2 |   11 |   4 |   11 |   6 |   11
(8 rows)

select * from t1 join t2 on (t1.val2 = t2.val2) join t3 on (t1.val2 = t3.val2) for update;
ERROR:  FOR UPDATE is not allowed with joins
select * from t1 join t2 on (t1.val2 = t2.val2) join t3 on (t1.val2 = t3.val2) for update of t1;
ERROR:  FOR UPDATE is not allowed with joins
select * from t1 join t2 on (t1.val2 = t2.val2) join t3 on (t1.val2 = t3.val2) for update of t1,t3;
ERROR:  FOR UPDATE is not allowed with joins
-- check a few subquery cases
explain (costs off, num_nodes off, nodes off, verbose on)  select * from (select * from t1 for update of t1 nowait) as foo;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanodes 2)
   Output: foo.val, foo.val2
   ->  Subquery Scan on foo
         Output: foo.val, foo.val2
         ->  LockRows
               Output: t1.val, t1.val2, t1.ctid, t1.xc_node_id
               ->  Seq Scan on public.t1
                     Output: t1.val, t1.val2, t1.ctid, t1.xc_node_id
(8 rows)

explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 where val in (select val from t2 for update of t2 nowait) for update;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 where val in (select val from t2 for update of t2 nowait);
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanodes 2)
   Output: t1.val, t1.val2
   ->  Hash Join
         Output: t1.val, t1.val2
         Inner Unique: true
         Hash Cond: (t1.val = any_subquery_1.val)
         ->  Seq Scan on public.t1
               Output: t1.val, t1.val2
         ->  Hash
               Output: any_subquery_1.val
               ->  HashAggregate
                     Output: any_subquery_1.val
                     Group Key: any_subquery_1.val
                     ->  Subquery Scan on any_subquery_1
                           Output: any_subquery_1.val
                           ->  LockRows
                                 Output: t2.val, t2.ctid, t2.xc_node_id
                                 ->  Seq Scan on public.t2
                                       Output: t2.val, t2.ctid, t2.xc_node_id
(19 rows)

-- test multiple row marks
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1, t2 for share of t2 for update of t1;
ERROR:  FOR SHARE is not allowed with joins
-- make sure FOR UPDATE takes prioriy over FOR SHARE when mentioned for the same table
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 for share of t1 for update of t1;
                            QUERY PLAN                            
------------------------------------------------------------------
 Remote Fast Query Execution
   Output: t1.val, t1.val2, t1.ctid, t1.xc_node_id
   Remote query: SELECT val, val2 FROM public.t1 FOR UPDATE OF t1
   ->  LockRows
         Output: val, val2, ctid, xc_node_id
         ->  Seq Scan on public.t1
               Output: val, val2, ctid, xc_node_id
(7 rows)

explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 for update of t1 for share of t1;
                            QUERY PLAN                            
------------------------------------------------------------------
 Remote Fast Query Execution
   Output: t1.val, t1.val2, t1.ctid, t1.xc_node_id
   Remote query: SELECT val, val2 FROM public.t1 FOR UPDATE OF t1
   ->  LockRows
         Output: val, val2, ctid, xc_node_id
         ->  Seq Scan on public.t1
               Output: val, val2, ctid, xc_node_id
(7 rows)

explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 for share of t1 for share of t1 for update of t1;
                            QUERY PLAN                            
------------------------------------------------------------------
 Remote Fast Query Execution
   Output: t1.val, t1.val2, t1.ctid, t1.xc_node_id
   Remote query: SELECT val, val2 FROM public.t1 FOR UPDATE OF t1
   ->  LockRows
         Output: val, val2, ctid, xc_node_id
         ->  Seq Scan on public.t1
               Output: val, val2, ctid, xc_node_id
(7 rows)

explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 for share of t1 for share of t1 for share of t1;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Remote Fast Query Execution
   Output: t1.val, t1.val2, t1.ctid, t1.xc_node_id
   Remote query: SELECT val, val2 FROM public.t1 FOR SHARE OF t1
   ->  LockRows
         Output: val, val2, ctid, xc_node_id
         ->  Seq Scan on public.t1
               Output: val, val2, ctid, xc_node_id
(7 rows)

-- make sure NOWAIT is used in remote query even if it is not mentioned with FOR UPDATE clause
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 for share of t1 for share of t1 nowait for update of t1;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: t1.val, t1.val2, t1.ctid, t1.xc_node_id
   Remote query: SELECT val, val2 FROM public.t1 FOR UPDATE OF t1 NOWAIT
   ->  LockRows
         Output: val, val2, ctid, xc_node_id
         ->  Seq Scan on public.t1
               Output: val, val2, ctid, xc_node_id
(7 rows)

-- same table , different aliases and different row marks for different aliases
explain (costs off, num_nodes off, nodes off, verbose on)  select * from t1 a,t1 b for share of a for update of b;
ERROR:  FOR SHARE is not allowed with joins
-- test WITH queries
-- join of a WITH table and a normal table
explain (costs off, num_nodes off, nodes off, verbose on)  WITH q1 AS (SELECT * from t1 FOR UPDATE) SELECT * FROM q1,t2 FOR UPDATE;
ERROR:  FOR UPDATE is not allowed with joins
explain (costs off, num_nodes off, nodes off, verbose on)  WITH q1 AS (SELECT * from t1) SELECT * FROM q1;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Output: q1.val, q1.val2
   Remote query: WITH q1 AS (SELECT t1.val, t1.val2 FROM public.t1) SELECT val, val2 FROM q1
   ->  Seq Scan on public.t1
         Output: t1.val, t1.val2
(5 rows)

-- make sure row marks are no ops for queries on WITH tables
explain (costs off, num_nodes off, nodes off, verbose on)  WITH q1 AS (SELECT * from t1) SELECT * FROM q1 FOR UPDATE;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Output: q1.val, q1.val2
   Remote query: WITH q1 AS (SELECT t1.val, t1.val2 FROM public.t1) SELECT val, val2 FROM q1
   ->  Seq Scan on public.t1
         Output: t1.val, t1.val2
(5 rows)

explain (costs off, num_nodes off, nodes off, verbose on)  WITH q1 AS (SELECT * from t1 FOR UPDATE) SELECT * FROM q1 FOR UPDATE;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 CTE Scan on q1
   Output: q1.val, q1.val2
   CTE q1
     ->  Remote Subquery Scan[1] on all (datanodes 2)
           Output: t1.val, t1.val2, t1.ctid, t1.xc_node_id
           ->  LockRows
                 Output: t1.val, t1.val2, t1.ctid, t1.xc_node_id
                 ->  Seq Scan on public.t1
                       Output: t1.val, t1.val2, t1.ctid, t1.xc_node_id
(9 rows)

-- test case of inheried tables
select * from p1 order by 1 for update;
  a  |  b  
-----+-----
  55 |  66
  77 |  88
 111 | 222
 123 | 345
(4 rows)

explain (costs off, num_nodes off, nodes off, verbose on)  select * from p1 for update;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanodes 2)
   Output: p1.a, p1.b, p1.ctid, p1.xc_node_id, p1.tableoid
   ->  LockRows
         Output: p1.a, p1.b, p1.ctid, p1.xc_node_id, p1.tableoid
         ->  Append
               ->  Seq Scan on public.p1
                     Output: p1.a, p1.b, p1.ctid, p1.xc_node_id, p1.tableoid
               ->  Seq Scan on public.c1
                     Output: c1.a, c1.b, c1.ctid, c1.xc_node_id, c1.tableoid
(9 rows)

select * from c1 order by 1 for update;
  a  |  b  |  d  |  e  
-----+-----+-----+-----
 111 | 222 | 333 | 444
 123 | 345 | 567 | 789
(2 rows)

explain (costs off, num_nodes off, nodes off, verbose on)  select * from c1 for update;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Remote Fast Query Execution
   Output: c1.a, c1.b, c1.d, c1.e, c1.ctid, c1.xc_node_id
   Remote query: SELECT a, b, d, e FROM public.c1 FOR UPDATE OF c1
   ->  LockRows
         Output: a, b, d, e, ctid, xc_node_id
         ->  Seq Scan on public.c1
               Output: a, b, d, e, ctid, xc_node_id
(7 rows)

-- confirm that in various join scenarios for update gets to the remote query
-- single table case
 select * from t1 for update of t1 nowait;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

-- two table case
 select * from t1, t2 where t1.val = t2.val for update nowait;
ERROR:  FOR UPDATE is not allowed with joins
 select * from t1, t2 where t1.val = t2.val for update;
ERROR:  FOR UPDATE is not allowed with joins
 select * from t1, t2 where t1.val = t2.val for share;
ERROR:  FOR SHARE is not allowed with joins
 select * from t1, t2 where t1.val = t2.val;
 val | val2 | val | val2 
-----+------+-----+------
(0 rows)

 select * from t1, t2;
 val | val2 | val | val2 
-----+------+-----+------
   1 |   11 |   3 |   11
   1 |   11 |   4 |   11
   2 |   11 |   3 |   11
   2 |   11 |   4 |   11
(4 rows)

 select * from t1, t2 for update;
ERROR:  FOR UPDATE is not allowed with joins
 select * from t1, t2 for update nowait;
ERROR:  FOR UPDATE is not allowed with joins
 select * from t1, t2 for share nowait;
ERROR:  FOR SHARE is not allowed with joins
 select * from t1, t2 for share;
ERROR:  FOR SHARE is not allowed with joins
 select * from t1, t2 for share of t2;
ERROR:  FOR SHARE is not allowed with joins
-- three table case
 select * from t1, t2, t3;
 val | val2 | val | val2 | val | val2 
-----+------+-----+------+-----+------
   1 |   11 |   3 |   11 |   5 |   11
   1 |   11 |   3 |   11 |   6 |   11
   1 |   11 |   4 |   11 |   5 |   11
   1 |   11 |   4 |   11 |   6 |   11
   2 |   11 |   3 |   11 |   5 |   11
   2 |   11 |   3 |   11 |   6 |   11
   2 |   11 |   4 |   11 |   5 |   11
   2 |   11 |   4 |   11 |   6 |   11
(8 rows)

 select * from t1, t2, t3 for update;
ERROR:  FOR UPDATE is not allowed with joins
 select * from t1, t2, t3 for update of t1;
ERROR:  FOR UPDATE is not allowed with joins
 select * from t1, t2, t3 for update of t1,t3;
ERROR:  FOR UPDATE is not allowed with joins
 select * from t1, t2, t3 for update of t1,t3 nowait;
ERROR:  FOR UPDATE is not allowed with joins
 select * from t1, t2, t3 for share of t1,t2 nowait;
ERROR:  FOR SHARE is not allowed with joins
-- check a few subquery cases
 select * from (select * from t1 for update of t1 nowait) as foo;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

 select * from t1 where val in (select val from t2 for update of t2 nowait) for update;
ERROR:  FOR UPDATE is not allowed with joins
 select * from t1 where val in (select val from t2 for update of t2 nowait);
 val | val2 
-----+------
(0 rows)

-- test multiple row marks
 select * from t1, t2 for share of t2 for update of t1;
ERROR:  FOR SHARE is not allowed with joins
-- make sure FOR UPDATE takes prioriy over FOR SHARE when mentioned for the same table
 select * from t1 for share of t1 for update of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

 select * from t1 for update of t1 for share of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

 select * from t1 for share of t1 for share of t1 for update of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

 select * from t1 for share of t1 for share of t1 for share of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

-- make sure NOWAIT is used in remote query even if it is not mentioned with FOR UPDATE clause
 select * from t1 for share of t1 for share of t1 nowait for update of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

-- same table , different aliases and different row marks for different aliases
 select * from t1 a,t1 b for share of a for update of b;
ERROR:  FOR SHARE is not allowed with joins
-- test WITH queries
-- join of a WITH table and a normal table
 WITH q1 AS (SELECT * from t1 FOR UPDATE) SELECT * FROM q1,t2 FOR UPDATE;
ERROR:  FOR UPDATE is not allowed with joins
 WITH q1 AS (SELECT * from t1) SELECT * FROM q1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

-- make sure row marks are no ops for queries on WITH tables
 WITH q1 AS (SELECT * from t1) SELECT * FROM q1 FOR UPDATE;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

 WITH q1 AS (SELECT * from t1 FOR UPDATE) SELECT * FROM q1 FOR UPDATE;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

-- drop objects created
drop table c1;
drop table p1;
drop view v1;
drop table t1;
drop table t2;
drop table t3;
-------------------------------------------
-- Tests for concurrent transactions
-------------------------------------------
-- create some tables
create table mytab1(val int, val2 int, val3 int);
create table mytab3(val int, val2 int);
create table mytab4(val int, val2 int);
-- create index,rule,trgger & view on one of the tables
CREATE UNIQUE INDEX test_idx ON mytab1 (val);
CREATE RULE test_rule AS ON INSERT TO mytab1 DO ALSO SELECT * FROM mytab3;
CREATE VIEW v1 as select * from mytab1 where val = 2;
-- insert some rows
insert into mytab1 values(1,11,1122),(2,11,3344);
 val | val2 
-----+------
(0 rows)

-------------------------------------------
-- Case 1 where we have a SELECT FOR UPDATE
-------------------------------------------
-- A transaction that holds ACCESS EXCLUSIVE lock on a table can later acquire ACCESS SHARE lock on the same table
begin;
declare c1 cursor for select * from mytab1 for update;
fetch 1 from c1;
 val | val2 | val3 
-----+------+------
   1 |   11 | 1122
(1 row)

declare c2 cursor for select * from mytab1 for share;
fetch 1 from c2;
 val | val2 | val3 
-----+------+------
   1 |   11 | 1122
(1 row)

end;
-- prepare a transaction that holds a ACCESS EXCLUSIVE (ROW SHARE) lock on a table
begin;
declare c1 cursor for select * from mytab1 for update;
fetch 1 from c1;
 val | val2 | val3 
-----+------+------
   1 |   11 | 1122
(1 row)

prepare transaction 'tbl_mytab1_locked';
set statement_timeout to 1000;
-- When a transaction holds a ACCESS EXCLUSIVE (ROW SHARE) lock on a table (Like a SELECT FOR UPDATE would do)
-- Can onther transaction do these to the same table
--  1. select some rows (Should pass)
       select * from mytab1 order by 1;
 val | val2 | val3 
-----+------+------
   1 |   11 | 1122
   2 |   11 | 3344
(2 rows)

--  2. insert a row (Should pass)
       insert into mytab1 values(123,456);
 val | val2 
-----+------
(0 rows)

--  3. update a row (Should fail)
       update mytab1 set val2=33 where val = 1;
ERROR:  canceling statement due to statement timeout
--  4. delete a row
--     Newly Inserted (Should pass)
       delete from mytab1 where val2=456;
--     Previously Inserted (Should fail)
       delete from mytab1 where val=1;
ERROR:  canceling statement due to statement timeout
--  5. inherit form it (Should pass)
       create table chld_mytab1(d int, e int) inherits (mytab1);
--  6. create a view on it (Should pass)
       create view v2 as select * from mytab1 where val = 1;
--  7. comment on it (Should pass)
       comment on table mytab1 is 'Hello table';
--  8. Alter it (Should fail)
       alter table mytab1 drop column val2;
ERROR:  canceling statement due to statement timeout
--  9. drop it (Should fail)
       drop table mytab1;
ERROR:  canceling statement due to statement timeout
-- 10. vacuum it (Should pass)
       vacuum mytab1;
-- 11. obtain any of these locks on it
--     ACCESS SHARE (Should pass)
       begin;
         lock table mytab1 in ACCESS SHARE mode nowait;
       end;
--     ROW SHARE (Should pass)
       begin;
         lock table mytab1 in ROW SHARE mode nowait;
       end;
--     ROW EXCLUSIVE (Should pass)
       begin;
         lock table mytab1 in ROW EXCLUSIVE mode nowait;
       end;
--     SHARE UPDATE EXCLUSIVE (Should pass)
       begin;
         lock table mytab1 in SHARE UPDATE EXCLUSIVE mode nowait;
       end;
--     SHARE (Should pass)
       begin;
         lock table mytab1 in SHARE mode nowait;
       end;
--     SHARE ROW EXCLUSIVE (Should pass)
       begin;
         lock table mytab1 in SHARE ROW EXCLUSIVE mode nowait;
       end;
--     EXCLUSIVE (Should fail)
       begin;
         lock table mytab1 in EXCLUSIVE mode nowait;
ERROR:  could not obtain lock on relation "mytab1"
       end;
--     ACCESS EXCLUSIVE (Should fail)
       begin;
         lock table mytab1 in ACCESS EXCLUSIVE mode nowait;
ERROR:  could not obtain lock on relation "mytab1"
       end;
-- 12. do a SELECT FOR SHARE on it (Should fail)
       begin;
         declare c1 cursor for select * from mytab1 for share nowait;
         fetch 1 from c1;
ERROR:  could not obtain lock on row in relation "mytab1"
       end;
-- 13. do a SELECT FOR UPDATE on it (Should fail)
       begin;
         declare c1 cursor for select * from mytab1 for update nowait;
         fetch 1 from c1;
ERROR:  could not obtain lock on row in relation "mytab1"
       end;
-- 14. alter already defined index on it (Should fail)
       ALTER INDEX test_idx RENAME TO mytab1_idx;
ERROR:  canceling statement due to statement timeout
-- 15. alter already defined view on it (Should pass)
       ALTER VIEW v1 RENAME TO vv1;
-- 16. drop already defined index on it (Should fail)
       drop index test_idx;
ERROR:  canceling statement due to statement timeout
-- 17. drop already defined rule on it (Should fail)
       drop rule test_rule on mytab1;
ERROR:  canceling statement due to statement timeout
-- 18. drop already defined view on it (Should pass)
       drop view vv1;
-- 19. reindex an alredy defined index on it (Should fail)
       reindex index test_idx;
ERROR:  canceling statement due to statement timeout
-- 20. truncate it (Should fail)
       truncate table mytab1;
ERROR:  canceling statement due to statement timeout
-- 21. create rule on it (Should fail)
       CREATE RULE test_rule2 AS ON INSERT TO mytab1 DO ALSO SELECT * FROM mytab1_insert_log;
ERROR:  canceling statement due to statement timeout
-- clean up
COMMIT PREPARED 'tbl_mytab1_locked';
drop table chld_mytab1;
drop view v2;
-- create the view again to carry out the next test case
CREATE VIEW v1 as select * from mytab1 where val = 2;
-------------------------------------------
-- Case 2 where we have a SELECT FOR SHARE
-------------------------------------------
-- A transaction that holds ACCESS SHARE lock on a table can later acquire ACCESS EXCLUSIVE lock on the same table
begin;
declare c1 cursor for select * from mytab1 for share;
fetch 1 from c1;
 val | val2 | val3 
-----+------+------
   1 |   11 | 1122
(1 row)

declare c2 cursor for select * from mytab1 for update;
fetch 1 from c2;
 val | val2 | val3 
-----+------+------
   1 |   11 | 1122
(1 row)

end;
-- prepare a transaction that holds a ACCESS SHARE (ROW SHARE) lock on a table
begin;
declare c1 cursor for select * from mytab1 for share;
fetch 1 from c1;
 val | val2 | val3 
-----+------+------
   1 |   11 | 1122
(1 row)

prepare transaction 'tbl_mytab1_locked';
set statement_timeout to 1000;
-- When a transaction holds a ACCESS SHARE (ROW SHARE) lock on a table (Like a SELECT FOR SHARE would do)
-- Can onther transaction do these to the same table
--  1. select some rows (Should pass)
       select * from mytab1 order by 1 ;
 val | val2 | val3 
-----+------+------
   1 |   11 | 1122
   2 |   11 | 3344
(2 rows)

--  2. insert a row (Should pass)
       insert into mytab1 values(123,456);
 val | val2 
-----+------
(0 rows)

--  3. update a row (Should fail)
       update mytab1 set val2=33 where val = 1;
ERROR:  canceling statement due to statement timeout
--  4. delete a row
--     Newly Inserted (Should pass)
       delete from mytab1 where val2=456;
--     Previously Inserted (Should fail)
       delete from mytab1 where val=1;
ERROR:  canceling statement due to statement timeout
--  5. inherit form it (Should pass)
       create table chld_mytab1(d int, e int) inherits (mytab1);
--  6. create a view on it (Should pass)
       create view v2 as select * from mytab1 where val = 1;
--  7. comment on it (Should pass)
       comment on table mytab1 is 'Hello table';
--  8. Alter it (Should fail)
       alter table mytab1 drop column val2;
ERROR:  canceling statement due to statement timeout
--  9. drop it (Should fail)
       drop table mytab1;
ERROR:  canceling statement due to statement timeout
-- 10. vacuum it (Should pass)
       vacuum mytab1;
-- 11. obtain any of these locks on it
--     ACCESS SHARE (Should pass)
       begin;
         lock table mytab1 in ACCESS SHARE mode nowait;
       end;
--     ROW SHARE (Should pass)
       begin;
         lock table mytab1 in ROW SHARE mode nowait;
       end;
--     ROW EXCLUSIVE (Should pass)
       begin;
         lock table mytab1 in ROW EXCLUSIVE mode nowait;
       end;
--     SHARE UPDATE EXCLUSIVE (Should pass)
       begin;
         lock table mytab1 in SHARE UPDATE EXCLUSIVE mode nowait;
       end;
--     SHARE (Should pass)
       begin;
         lock table mytab1 in SHARE mode nowait;
       end;
--     SHARE ROW EXCLUSIVE (Should pass)
       begin;
         lock table mytab1 in SHARE ROW EXCLUSIVE mode nowait;
       end;
--     EXCLUSIVE (Should fail)
       begin;
         lock table mytab1 in EXCLUSIVE mode nowait;
ERROR:  could not obtain lock on relation "mytab1"
       end;
--     ACCESS EXCLUSIVE (Should fail)
       begin;
         lock table mytab1 in ACCESS EXCLUSIVE mode nowait;
ERROR:  could not obtain lock on relation "mytab1"
       end;
-- 12. do a SELECT FOR SHARE on it (Should pass) 
--     This is the difference between FOR SHARE & FOR UPDATE, This test should pass in case of FOR SHARE, but fail in case of FOR UPDATE
       begin;
         declare c1 cursor for select * from mytab1 for share nowait;
         fetch 1 from c1;
 val | val2 | val3 
-----+------+------
   1 |   11 | 1122
(1 row)

       end;
-- 13. do a SELECT FOR UPDATE on it (Should fail)
       begin;
         declare c1 cursor for select * from mytab1 for update nowait;
         fetch 1 from c1;
ERROR:  could not obtain lock on row in relation "mytab1"
       end;
-- 14. alter already defined index on it (Should fail)
       ALTER INDEX test_idx RENAME TO mytab1_idx;
ERROR:  canceling statement due to statement timeout
-- 15. alter already defined view on it (Should pass)
       ALTER VIEW v1 RENAME TO vv1;
-- 16. drop already defined index on it (Should fail)
       drop index test_idx;
ERROR:  canceling statement due to statement timeout
-- 17. drop already defined rule on it (Should fail)
       drop rule test_rule on mytab1;
ERROR:  canceling statement due to statement timeout
-- 18. drop already defined view on it (Should pass)
       drop view vv1;
-- 19. reindex an alredy defined index on it (Should fail)
       reindex index test_idx;
ERROR:  canceling statement due to statement timeout
-- 20. truncate it (Should fail)
       truncate table mytab1;
ERROR:  canceling statement due to statement timeout
-- 21. create rule on it (Should fail)
       CREATE RULE test_rule2 AS ON INSERT TO mytab1 DO ALSO SELECT * FROM mytab1_insert_log;
ERROR:  canceling statement due to statement timeout
-- clean up
COMMIT PREPARED 'tbl_mytab1_locked';
drop table chld_mytab1;
drop view v2;
drop table mytab1 cascade;
drop table mytab4 cascade;
drop table mytab3 cascade;
-- Test to make sure prepared transactions are working as expected
-- If a transcation is preared and contains only a select with for share/update, it should be preapred on data nodes
-- create some tables
create table t1(val int, val2 int) DISTRIBUTE BY REPLICATION;
create table t2(val int, val2 int) DISTRIBUTE BY REPLICATION;
create table t3(val int, val2 int) DISTRIBUTE BY REPLICATION;
create table p1(a int, b int) DISTRIBUTE BY REPLICATION;
create table c1(d int, e int) inherits (p1) DISTRIBUTE BY REPLICATION;
WARNING:  Inherited/partition tables inherit distribution from the parent
DETAIL:  Explicitly specified distribution will be ignored
-- insert some rows in them
insert into t1 values(1,11),(2,11);
insert into t2 values(3,11),(4,11);
insert into t3 values(5,11),(6,11);
insert into p1 values(55,66),(77,88);
insert into c1 values(111,222,333,444),(123,345,567,789);
-- ****  
begin;
  select * from t1 order by 1 for update of t1 nowait;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1, t2, t3 order by 1 for update;
 val | val2 | val | val2 | val | val2 
-----+------+-----+------+-----+------
   1 |   11 |   3 |   11 |   5 |   11
   1 |   11 |   3 |   11 |   6 |   11
   1 |   11 |   4 |   11 |   5 |   11
   1 |   11 |   4 |   11 |   6 |   11
   2 |   11 |   3 |   11 |   5 |   11
   2 |   11 |   3 |   11 |   6 |   11
   2 |   11 |   4 |   11 |   5 |   11
   2 |   11 |   4 |   11 |   6 |   11
(8 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  --WITH q1 AS (SELECT * from t1 order by 1 FOR UPDATE) SELECT * FROM q1,t2 order by 1 FOR UPDATE;
prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 f
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  WITH q1 AS (SELECT * from t1 order by 1) SELECT * FROM q1 FOR UPDATE;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- false
 is_prepared_on_node 
---------------------
 f
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  WITH q1 AS (SELECT * from t1 order by 1 FOR UPDATE) SELECT * FROM q1 FOR UPDATE;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1, t2 where t1.val = t2.val for share;
 val | val2 | val | val2 
-----+------+-----+------
(0 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1, t2 for share of t2;
 val | val2 | val | val2 
-----+------+-----+------
   1 |   11 |   3 |   11
   1 |   11 |   4 |   11
   2 |   11 |   3 |   11
   2 |   11 |   4 |   11
(4 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from (select * from t1 for update of t1 nowait) as foo;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 where val in (select val from t2 for update of t2 nowait) for update;
 val | val2 
-----+------
(0 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 where val in (select val from t2 for update of t2 nowait);
 val | val2 
-----+------
(0 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1, t2 for share of t2 for update of t1;
 val | val2 | val | val2 
-----+------+-----+------
   1 |   11 |   3 |   11
   1 |   11 |   4 |   11
   2 |   11 |   3 |   11
   2 |   11 |   4 |   11
(4 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 for share of t1 for update of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 for update of t1 for share of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 for share of t1 for share of t1 for update of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 for share of t1 for share of t1 for share of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 for share of t1 for share of t1 nowait for update of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 a,t1 b for share of a for update of b;
 val | val2 | val | val2 
-----+------+-----+------
   1 |   11 |   1 |   11
   1 |   11 |   2 |   11
   2 |   11 |   1 |   11
   2 |   11 |   2 |   11
(4 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from p1 order by 1 for update;
  a  |  b  
-----+-----
  55 |  66
  77 |  88
 111 | 222
 123 | 345
(4 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from p1 for update;
  a  |  b  
-----+-----
  55 |  66
  77 |  88
 111 | 222
 123 | 345
(4 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); --true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from c1 order by 1 for update;
  a  |  b  |  d  |  e  
-----+-----+-----+-----
 111 | 222 | 333 | 444
 123 | 345 | 567 | 789
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from c1 for update;
  a  |  b  |  d  |  e  
-----+-----+-----+-----
 111 | 222 | 333 | 444
 123 | 345 | 567 | 789
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- **********************************
-- repeat all tests with FQS disabled
-- **********************************
set enable_fast_query_shipping=false;
-- ****  
begin;
  select * from t1 order by 1 for update of t1 nowait;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1, t2, t3 order by 1 for update;
 val | val2 | val | val2 | val | val2 
-----+------+-----+------+-----+------
   1 |   11 |   3 |   11 |   5 |   11
   1 |   11 |   3 |   11 |   6 |   11
   1 |   11 |   4 |   11 |   5 |   11
   1 |   11 |   4 |   11 |   6 |   11
   2 |   11 |   3 |   11 |   5 |   11
   2 |   11 |   3 |   11 |   6 |   11
   2 |   11 |   4 |   11 |   5 |   11
   2 |   11 |   4 |   11 |   6 |   11
(8 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  --WITH q1 AS (SELECT * from t1 order by 1 FOR UPDATE) SELECT * FROM q1,t2 order by 1 FOR UPDATE;
prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 f
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  WITH q1 AS (SELECT * from t1 order by 1) SELECT * FROM q1 FOR UPDATE;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- false
 is_prepared_on_node 
---------------------
 f
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  WITH q1 AS (SELECT * from t1 order by 1 FOR UPDATE) SELECT * FROM q1 FOR UPDATE;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1, t2 where t1.val = t2.val for share;
 val | val2 | val | val2 
-----+------+-----+------
(0 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1, t2 for share of t2;
 val | val2 | val | val2 
-----+------+-----+------
   1 |   11 |   3 |   11
   1 |   11 |   4 |   11
   2 |   11 |   3 |   11
   2 |   11 |   4 |   11
(4 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from (select * from t1 for update of t1 nowait) as foo;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 where val in (select val from t2 for update of t2 nowait) for update;
 val | val2 
-----+------
(0 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 where val in (select val from t2 for update of t2 nowait);
 val | val2 
-----+------
(0 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1, t2 for share of t2 for update of t1;
 val | val2 | val | val2 
-----+------+-----+------
   1 |   11 |   3 |   11
   1 |   11 |   4 |   11
   2 |   11 |   3 |   11
   2 |   11 |   4 |   11
(4 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 for share of t1 for update of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 for update of t1 for share of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 for share of t1 for share of t1 for update of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 for share of t1 for share of t1 for share of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 for share of t1 for share of t1 nowait for update of t1;
 val | val2 
-----+------
   1 |   11
   2 |   11
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from t1 a,t1 b for share of a for update of b;
 val | val2 | val | val2 
-----+------+-----+------
   1 |   11 |   1 |   11
   1 |   11 |   2 |   11
   2 |   11 |   1 |   11
   2 |   11 |   2 |   11
(4 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from p1 order by 1 for update;
  a  |  b  
-----+-----
  55 |  66
  77 |  88
 111 | 222
 123 | 345
(4 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from p1 for update;
  a  |  b  
-----+-----
  55 |  66
  77 |  88
 111 | 222
 123 | 345
(4 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); --true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from c1 order by 1 for update;
  a  |  b  |  d  |  e  
-----+-----+-----+-----
 111 | 222 | 333 | 444
 123 | 345 | 567 | 789
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
begin;
  select * from c1 for update;
  a  |  b  |  d  |  e  
-----+-----+-----+-----
 111 | 222 | 333 | 444
 123 | 345 | 567 | 789
(2 rows)

prepare transaction 'pt_1';
select gid from pg_prepared_xacts where gid = 'pt_1';
 gid  
------
 pt_1
(1 row)

select is_prepared_on_node('pt_1', 1); -- true
 is_prepared_on_node 
---------------------
 t
(1 row)

commit prepared 'pt_1';
-- ****  
set enable_fast_query_shipping=true;
-- ****  
delete from t3 where val != 5;
PREPARE my_plan(int) as select * from t3 for update;
execute my_plan(1);
 val | val2 
-----+------
   5 |   11
(1 row)

-- ****  
drop table if exists test_rr_for_update_share_shard_1 cascade;
NOTICE:  table "test_rr_for_update_share_shard_1" does not exist, skipping
create table test_rr_for_update_share_shard_1 (id int, ename varchar, address text, score float, dt date, pt timestamp, creation_date timestamp default current_timestamp, primary key(id, ename));
insert into test_rr_for_update_share_shard_1 select i, 'opentenbase'||i%2000, '深圳'||i%20, i, date'2020-01-01'+i*interval '1 hour', timestamp'2020-01-01 09:00:00'+i*interval '1 second' from generate_series(1, 10000) i;
drop table if exists test_rr_for_update_share_replication_1 cascade;
NOTICE:  table "test_rr_for_update_share_replication_1" does not exist, skipping
create table test_rr_for_update_share_replication_1(id int, ename varchar, address text, score float, dt date, pt timestamp, creation_date timestamp default current_timestamp) distribute by replication;
insert into test_rr_for_update_share_replication_1 select i, 'opentenbase'||i%2000, '深圳'||i%20, i, date'2020-01-01'+i*interval '1 hour', timestamp'2020-01-01 09:00:00'+i*interval '1 second' from generate_series(100, 5000) i;
drop table if exists test_rr_for_update_share_multi_shard_1 cascade;
NOTICE:  table "test_rr_for_update_share_multi_shard_1" does not exist, skipping
create table test_rr_for_update_share_multi_shard_1(id int, ename varchar, address text, score float, dt date, pt timestamp, creation_date timestamp default current_timestamp) distribute by shard(id,ename,pt);
insert into test_rr_for_update_share_multi_shard_1 select i, 'opentenbase'||i%2000, '深圳'||i%20, i, date'2020-01-01'+i*interval '1 hour', timestamp'2020-01-01 09:00:00'+i*interval '1 second' from generate_series(200, 20000) i;
drop table if exists test_rr_for_update_share_par_hash_1 cascade;
NOTICE:  table "test_rr_for_update_share_par_hash_1" does not exist, skipping
create table test_rr_for_update_share_par_hash_1(id int, ename varchar, address text, score float, dt date, pt timestamp, creation_date timestamp default current_timestamp) partition by hash(pt) distribute by shard(id,ename,pt);
create table test_rr_for_update_share_par_hash_1_part_0 partition of test_rr_for_update_share_par_hash_1 for values with (modulus 5, remainder 0);
create table test_rr_for_update_share_par_hash_1_part_1 partition of test_rr_for_update_share_par_hash_1 for values with (modulus 5, remainder 1);
create table test_rr_for_update_share_par_hash_1_part_2 partition of test_rr_for_update_share_par_hash_1 for values with (modulus 5, remainder 2);
create table test_rr_for_update_share_par_hash_1_part_3 partition of test_rr_for_update_share_par_hash_1 for values with (modulus 5, remainder 3);
create table test_rr_for_update_share_par_hash_1_part_4 partition of test_rr_for_update_share_par_hash_1 for values with (modulus 5, remainder 4);
insert into test_rr_for_update_share_par_hash_1 select i, 'opentenbase'||i%2000, '深圳'||i%20, i, date'2020-01-01'+i*interval '1 hour', timestamp'2020-01-01 09:00:00'+i*interval '1 second' from generate_series(100, 22000) i;
 -- error 2 for update
 with cte_sub1 as (
 select * from test_rr_for_update_share_multi_shard_1 where score <= 100 for update
 ), cte_sub2 as (
 select * from test_rr_for_update_share_par_hash_1 where id <= 500 for update
 ) select count(1) from cte_sub1, cte_sub2 where cte_sub1.id = cte_sub2.id;
ERROR:  There are multiple writable fragments
-- ok for update
 with cte_sub1 as (
 select * from test_rr_for_update_share_multi_shard_1 where score <= 100
 ), cte_sub2 as (
 select * from test_rr_for_update_share_par_hash_1 where id <= 500 for update
 ) select count(1) from cte_sub1, cte_sub2 where cte_sub1.id = cte_sub2.id;
 count 
-------
     0
(1 row)

-- ok update with for update
update test_rr_for_update_share_multi_shard_1 t1 set address=(select address from test_rr_for_update_share_par_hash_1 t2 where t1.id=t2.id for update) where id<=200;
ERROR:  There are multiple writable fragments
-- drop objects created
drop table if exists test_rr_for_update_share_shard_1 cascade;
drop table if exists test_rr_for_update_share_replication_1 cascade;
drop table if exists test_rr_for_update_share_multi_shard_1 cascade;
drop table if exists test_rr_for_update_share_par_hash_1 cascade;
drop table c1;
drop table p1;
drop table t1;
drop table t2;
drop table t3;
drop table if exists test_for_update_replication_1 cascade;
NOTICE:  table "test_for_update_replication_1" does not exist, skipping
create table test_for_update_replication_1(id int, ename varchar, address text, score float, dt date, pt timestamp, creation_date timestamp default current_timestamp) distribute by replication;
insert into test_for_update_replication_1 select i, 'opentenbase'||i%2000, '深圳'||i%20, i, date'2020-01-01'+i*interval '1 hour', timestamp'2020-01-01 09:00:00'+i*interval '1 second' from generate_series(100, 105) i;
-- expected send all dn
explain select id,ename from test_for_update_replication_1 where id=100 for update;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  LockRows  (cost=0.00..22.38 rows=550 width=46)
         ->  Seq Scan on test_for_update_replication_1  (cost=0.00..16.88 rows=550 width=46)
               Filter: (id = 100)
(5 rows)

select id,ename from test_for_update_replication_1 where id=100 for update;
 id  |     ename      
-----+----------------
 100 | opentenbase100
(1 row)

create table test_replication_2 (id int, ename varchar, address text, score float, dt date, pt timestamp, creation_date timestamp default current_timestamp) distribute by replication;
insert into test_replication_2 select i, 'opentenbase'||i%2000, '深圳'||i%20, i, date'2020-01-01'+i*interval '1 hour', timestamp'2020-01-01 09:00:00'+i*interval '1 second' from generate_series(100, 103) i;
select ename,sum(score) from test_replication_2 t1 where exists (select 1 from (select * from test_for_update_replication_1 for update) t2 where t1.id=t2.id) group by ename order by 1;
     ename      | sum 
----------------+-----
 opentenbase100 | 100
 opentenbase101 | 101
 opentenbase102 | 102
 opentenbase103 | 103
(4 rows)

create table test_shard_1(id int, ename varchar, address text, score float, dt date, pt timestamp, creation_date timestamp default current_timestamp) distribute by shard(id);
insert into test_shard_1 select i, 'opentenbase'||i%2000, '深圳'||i%20, i, date'2020-01-01'+i*interval '1 hour', timestamp'2020-01-01 09:00:00'+i*interval '1 second' from generate_series(100, 103) i;
select ename,sum(score) from test_shard_1 t1 where exists (select 1 from (select * from test_for_update_replication_1 for update) t2 where t1.id=t2.id) group by ename order by 1;
     ename      | sum 
----------------+-----
 opentenbase100 | 100
 opentenbase101 | 101
 opentenbase102 | 102
 opentenbase103 | 103
(4 rows)

drop table test_for_update_replication_1;
drop table test_replication_2;
drop table test_shard_1;
drop table if exists test_replication_union;
NOTICE:  table "test_replication_union" does not exist, skipping
create table test_replication_union(a int, b varchar(30)) distribute by replication;
insert into test_replication_union values(1, 'xxx');
insert into test_replication_union values(2, 'yyy');
select b from (select b from test_replication_union for update) union select b from test_replication_union order by 1;
  b  
-----
 xxx
 yyy
(2 rows)

select b from test_replication_union union select b from  (select b from test_replication_union for update) order by 1;
  b  
-----
 xxx
 yyy
(2 rows)

select b from (select b from test_replication_union for update) union all select b from test_replication_union order by 1;
  b  
-----
 xxx
 xxx
 yyy
 yyy
(4 rows)

select b from test_replication_union union all select b from  (select b from test_replication_union for update) order by 1;
  b  
-----
 xxx
 xxx
 yyy
 yyy
(4 rows)

select b from (select b from test_replication_union for update) intersect select b from test_replication_union order by 1;
  b  
-----
 xxx
 yyy
(2 rows)

select b from test_replication_union intersect select b from  (select b from test_replication_union for update) order by 1;
  b  
-----
 xxx
 yyy
(2 rows)

create table test_shard_union(a int, b varchar(30)) distribute by shard(a);
insert into test_shard_union values(1, 'aaa');
insert into test_shard_union values(2, 'bbb');
select b from (select b from test_shard_union for update) union select b from test_replication_union order by 1;
  b  
-----
 aaa
 bbb
 xxx
 yyy
(4 rows)

select b from test_shard_union union select b from  (select b from test_replication_union for update) order by 1;
  b  
-----
 aaa
 bbb
 xxx
 yyy
(4 rows)

select b from (select b from test_shard_union for update) union all select b from test_replication_union order by 1;
  b  
-----
 aaa
 bbb
 xxx
 yyy
(4 rows)

select b from test_shard_union union all select b from  (select b from test_replication_union for update) order by 1;
  b  
-----
 aaa
 bbb
 xxx
 yyy
(4 rows)

select b from (select b from test_shard_union for update) intersect select b from test_replication_union order by 1;
 b 
---
(0 rows)

select b from test_shard_union intersect select b from  (select b from test_replication_union for update) order by 1;
 b 
---
(0 rows)

drop table test_replication_union;
drop table test_shard_union;
drop table if exists t_student_20221113;
NOTICE:  table "t_student_20221113" does not exist, skipping
create table t_student_20221113(id int primary key, name varchar(20), age int, sex int, point int) distribute by replication;
insert into t_student_20221113 values(1, '张三', 15, 1, 93);
insert into t_student_20221113 values(2, '李四', 20, 2, 90);
insert into t_student_20221113 values(3, '王五', 19, 2, 85);
insert into t_student_20221113 values(4, '李六', 30, 1, 73);
insert into t_student_20221113 values(5, '李六', 20, 1, 88);
insert into t_student_20221113 values(6, '赵六', 19, 2, 63);
explain select * from t_student_20221113 order by id offset 2 rows fetch next 2 rows only for update;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Limit  (cost=0.35..0.55 rows=2 width=84)
         ->  LockRows  (cost=0.15..64.15 rows=640 width=84)
               ->  Index Scan using t_student_20221113_pkey on t_student_20221113  (cost=0.15..57.75 rows=640 width=84)
(5 rows)

select * from t_student_20221113 order by id offset 2 rows fetch next 2 rows only for update;
 id | name | age | sex | point 
----+------+-----+-----+-------
  3 | 王五 |  19 |   2 |    85
  4 | 李六 |  30 |   1 |    73
(2 rows)

drop table t_student_20221113;
drop table if exists subselect_tbl;
CREATE TABLE subselect_tbl (f1 integer,f2 integer,f3 float) distribute by replication;
INSERT INTO subselect_tbl VALUES (1, 2, 3);
INSERT INTO subselect_tbl VALUES (2, 3, 4);
INSERT INTO subselect_tbl VALUES (3, 4, 5);
INSERT INTO subselect_tbl VALUES (1, 1, 1);
INSERT INTO subselect_tbl VALUES (2, 2, 2);
INSERT INTO subselect_tbl VALUES (3, 3, 3);
INSERT INTO subselect_tbl VALUES (6, 7, 8);
INSERT INTO subselect_tbl VALUES (8, 9, NULL);
explain (verbose, costs off,nodes off)
with x as (select * from (select f1 from subselect_tbl for update) ss)
select * from x where f1 = 1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 CTE Scan on x
   Output: x.f1
   Filter: (x.f1 = 1)
   CTE x
     ->  Remote Subquery Scan[1] on all (datanodes 2)
           Output: ss.f1
           ->  Subquery Scan on ss
                 Output: ss.f1
                 ->  LockRows
                       Output: subselect_tbl.f1, subselect_tbl.ctid, subselect_tbl.xc_node_id
                       ->  Seq Scan on public.subselect_tbl
                             Output: subselect_tbl.f1, subselect_tbl.ctid, subselect_tbl.xc_node_id
(12 rows)

with x as (select * from (select f1 from subselect_tbl for update) ss)
select * from x where f1 = 1;
 f1 
----
  1
  1
(2 rows)

explain (verbose, costs off,nodes off)
with x as (select * from subselect_tbl order by 1,2) select * from x for update;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: x.f1, x.f2, x.f3
   Remote query: WITH x AS (SELECT subselect_tbl.f1, subselect_tbl.f2, subselect_tbl.f3 FROM public.subselect_tbl ORDER BY subselect_tbl.f1, subselect_tbl.f2) SELECT f1, f2, f3 FROM x
   ->  Sort
         Output: subselect_tbl.f1, subselect_tbl.f2, subselect_tbl.f3
         Sort Key: subselect_tbl.f1, subselect_tbl.f2
         ->  Seq Scan on public.subselect_tbl
               Output: subselect_tbl.f1, subselect_tbl.f2, subselect_tbl.f3
(8 rows)

with x as (select * from subselect_tbl order by 1,2) select * from x for update;
 f1 | f2 | f3 
----+----+----
  1 |  1 |  1
  1 |  2 |  3
  2 |  2 |  2
  2 |  3 |  4
  3 |  3 |  3
  3 |  4 |  5
  6 |  7 |  8
  8 |  9 |   
(8 rows)

drop table subselect_tbl;
