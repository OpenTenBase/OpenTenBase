CREATE TEMP TABLE x (
	a serial,
	b int,
	c text not null default 'stuff',
	d text,
	e text
) WITH OIDS;
CREATE FUNCTION fn_x_before () RETURNS TRIGGER AS '
  BEGIN
		NEW.e := ''before trigger fired''::text;
		return NEW;
	END;
' LANGUAGE plpgsql;
CREATE FUNCTION fn_x_after () RETURNS TRIGGER AS '
  BEGIN
		UPDATE x set e=''after trigger fired'' where c=''stuff'';
		return NULL;
	END;
' LANGUAGE plpgsql;
CREATE TRIGGER trg_x_after AFTER INSERT ON x
FOR EACH ROW EXECUTE PROCEDURE fn_x_after();
ERROR:  Postgres-XL does not support TRIGGER yet
DETAIL:  The feature is not currently supported
CREATE TRIGGER trg_x_before BEFORE INSERT ON x
FOR EACH ROW EXECUTE PROCEDURE fn_x_before();
ERROR:  Postgres-XL does not support TRIGGER yet
DETAIL:  The feature is not currently supported
COPY x (a, b, c, d, e) from stdin;
COPY x (b, d) from stdin;
COPY x (b, d) from stdin;
COPY x (a, b, c, d, e) from stdin;
-- non-existent column in column list: should fail
COPY x (xyz) from stdin;
ERROR:  column "xyz" of relation "x" does not exist
-- too many columns in column list: should fail
COPY x (a, b, c, d, e, d, c) from stdin;
ERROR:  column "d" specified more than once
-- missing data: should fail
COPY x from stdin;
ERROR:  invalid input syntax for integer: ""
CONTEXT:  COPY x, line 1, column a: "", nodetype:1(1:cn,0:dn)
COPY x from stdin;
ERROR:  missing data for column "e"
CONTEXT:  COPY x, line 1: "2000	230	23	23", nodetype:1(1:cn,0:dn)
COPY x from stdin;
ERROR:  missing data for column "e"
CONTEXT:  COPY x, line 1: "2001	231	\N	\N", nodetype:1(1:cn,0:dn)
-- extra data: should fail
COPY x from stdin;
ERROR:  extra data after last expected column
CONTEXT:  COPY x, line 1: "2002	232	40	50	60	70	80", nodetype:1(1:cn,0:dn)
-- various COPY options: delimiters, oids, NULL string, encoding
COPY x (b, c, d, e) from stdin with oids delimiter ',' null 'x';
COPY x from stdin WITH DELIMITER AS ';' NULL AS '';
COPY x from stdin WITH DELIMITER AS ':' NULL AS E'\\X' ENCODING 'sql_ascii';
-- check results of copy in
SELECT * FROM x ORDER BY a, b;
   a   | b  |     c      |   d    | e  
-------+----+------------+--------+----
     1 |  1 | stuff      | test_1 | 
     2 |  2 | stuff      | test_2 | 
     3 |  3 | stuff      | test_3 | 
     4 |  4 | stuff      | test_4 | 
     5 |  5 | stuff      | test_5 | 
     6 |    | 45         | 80     | 90
     7 |    | x          | \x     | \x
     8 |    | ,          | \,     | \
  3000 |    | c          |        | 
  4000 |    | C          |        | 
  4001 |  1 | empty      |        | 
  4002 |  2 | null       |        | 
  4003 |  3 | Backslash  | \      | \
  4004 |  4 | BackslashX | \X     | \X
  4005 |  5 | N          | N      | N
  4006 |  6 | BackslashN | \N     | \N
  4007 |  7 | XX         | XX     | XX
  4008 |  8 | Delimiter  | :      | :
  9999 |    | \N         | NN     | 
 10000 | 21 | 31         | 41     | 51
 10001 | 22 | 32         | 42     | 52
 10002 | 23 | 33         | 43     | 53
 10003 | 24 | 34         | 44     | 54
 10004 | 25 | 35         | 45     | 55
 10005 | 26 | 36         | 46     | 56
(25 rows)

-- COPY w/ oids on a table w/o oids should fail
CREATE TABLE no_oids (
	a	int,
	b	int
) WITHOUT OIDS;
INSERT INTO no_oids (a, b) VALUES (5, 10);
INSERT INTO no_oids (a, b) VALUES (20, 30);
-- should fail
COPY no_oids FROM stdin WITH OIDS;
ERROR:  table "no_oids" does not have OIDs
COPY no_oids TO stdout WITH OIDS;
ERROR:  table "no_oids" does not have OIDs
-- check copy out
COPY x TO stdout;
9999	\N	\\N	NN	\N
1	1	stuff	test_1	\N
2	2	stuff	test_2	\N
5	5	stuff	test_5	\N
10001	22	32	42	52
10002	23	33	43	53
10004	25	35	45	55
6	\N	45	80	90
8	\N	,	\\,	\\
4000	\N	C	\N	\N
4002	2	null	\N	\N
4003	3	Backslash	\\	\\
4005	5	N	N	N
4007	7	XX	XX	XX
4008	8	Delimiter	:	:
10000	21	31	41	51
3	3	stuff	test_3	\N
4	4	stuff	test_4	\N
10003	24	34	44	54
10005	26	36	46	56
7	\N	x	\\x	\\x
3000	\N	c	\N	\N
4001	1	empty		
4004	4	BackslashX	\\X	\\X
4006	6	BackslashN	\\N	\\N
COPY x (c, e) TO stdout;
\\N	\N
stuff	\N
stuff	\N
stuff	\N
32	52
33	53
35	55
45	90
,	\\
C	\N
null	\N
Backslash	\\
N	N
XX	XX
Delimiter	:
31	51
stuff	\N
stuff	\N
34	54
36	56
x	\\x
c	\N
empty	
BackslashX	\\X
BackslashN	\\N
COPY x (b, e) TO stdout WITH NULL 'I''m null';
I'm null	I'm null
1	I'm null
2	I'm null
5	I'm null
22	52
23	53
25	55
I'm null	90
I'm null	\\
I'm null	I'm null
2	I'm null
3	\\
5	N
7	XX
8	:
21	51
3	I'm null
4	I'm null
24	54
26	56
I'm null	\\x
I'm null	I'm null
1	
4	\\X
6	\\N
CREATE TEMP TABLE y (
	col1 text,
	col2 text
);
INSERT INTO y VALUES ('Jackson, Sam', E'\\h');
INSERT INTO y VALUES ('It is "perfect".',E'\t');
INSERT INTO y VALUES ('', NULL);
COPY y TO stdout WITH CSV;
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
COPY y TO stdout WITH CSV QUOTE '''' DELIMITER '|';
Jackson, Sam|\h
It is "perfect".|	
''|
COPY y TO stdout WITH CSV FORCE QUOTE col2 ESCAPE E'\\' ENCODING 'sql_ascii';
"Jackson, Sam","\\h"
"It is \"perfect\".","	"
"",
COPY y TO stdout WITH CSV FORCE QUOTE *;
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
-- Repeat above tests with new 9.0 option syntax
COPY y TO stdout (FORMAT CSV);
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
COPY y TO stdout (FORMAT CSV, QUOTE '''', DELIMITER '|');
Jackson, Sam|\h
It is "perfect".|	
''|
COPY y TO stdout (FORMAT CSV, FORCE_QUOTE (col2), ESCAPE E'\\');
"Jackson, Sam","\\h"
"It is \"perfect\".","	"
"",
COPY y TO stdout (FORMAT CSV, FORCE_QUOTE *);
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
\copy y TO stdout (FORMAT CSV)
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
\copy y TO stdout (FORMAT CSV, QUOTE '''', DELIMITER '|')
Jackson, Sam|\h
It is "perfect".|	
''|
\copy y TO stdout (FORMAT CSV, FORCE_QUOTE (col2), ESCAPE E'\\')
"Jackson, Sam","\\h"
"It is \"perfect\".","	"
"",
\copy y TO stdout (FORMAT CSV, FORCE_QUOTE *)
"Jackson, Sam",\h
"It is ""perfect"".",	
"",
--test that we read consecutive LFs properly
CREATE TEMP TABLE testnl (a int, b text, c int);
COPY testnl FROM stdin CSV;
-- test end of copy marker
CREATE TEMP TABLE testeoc (a text);
COPY testeoc FROM stdin CSV;
COPY testeoc TO stdout CSV;
"\."
a\.
\.b
c\.d
-- test handling of nonstandard null marker that violates escaping rules
CREATE TEMP TABLE testnull(a int, b text);
INSERT INTO testnull VALUES (1, E'\\0'), (NULL, NULL);
COPY testnull TO stdout WITH NULL AS E'\\0';
1	\\0
\0	\0
COPY testnull FROM stdin WITH NULL AS E'\\0';
SELECT * FROM testnull ORDER BY 1,2;
 a  | b  
----+----
  1 | \0
 42 | \0
    | 
    | 
(4 rows)

BEGIN;
CREATE TABLE vistest (LIKE testeoc);
ERROR:  relation "testeoc" does not exist
COPY vistest FROM stdin CSV;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
a0
b
\.
invalid command \.
COMMIT;
ERROR:  syntax error at or near "a0"
LINE 1: a0
        ^
SELECT * FROM vistest;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
BEGIN;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
TRUNCATE vistest;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COPY vistest FROM stdin CSV;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
a1
b
\.
invalid command \.
SELECT * FROM vistest;
ERROR:  syntax error at or near "a1"
LINE 1: a1
        ^
SAVEPOINT s1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
TRUNCATE vistest;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COPY vistest FROM stdin CSV;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
d1
e
\.
invalid command \.
SELECT * FROM vistest;
ERROR:  syntax error at or near "d1"
LINE 1: d1
        ^
COMMIT;
SELECT * FROM vistest;
ERROR:  relation "vistest" does not exist
LINE 1: SELECT * FROM vistest;
                      ^
BEGIN;
TRUNCATE vistest;
ERROR:  relation "vistest" does not exist
COPY vistest FROM stdin CSV FREEZE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
a2
b
\.
invalid command \.
SELECT * FROM vistest;
ERROR:  syntax error at or near "a2"
LINE 1: a2
        ^
SAVEPOINT s1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
TRUNCATE vistest;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COPY vistest FROM stdin CSV FREEZE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
d2
e
\.
invalid command \.
SELECT * FROM vistest;
ERROR:  syntax error at or near "d2"
LINE 1: d2
        ^
COMMIT;
SELECT * FROM vistest;
ERROR:  relation "vistest" does not exist
LINE 1: SELECT * FROM vistest;
                      ^
BEGIN;
TRUNCATE vistest;
ERROR:  relation "vistest" does not exist
COPY vistest FROM stdin CSV FREEZE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
x
y
\.
invalid command \.
SELECT * FROM vistest;
ERROR:  syntax error at or near "x"
LINE 1: x
        ^
COMMIT;
TRUNCATE vistest;
ERROR:  relation "vistest" does not exist
COPY vistest FROM stdin CSV FREEZE;
ERROR:  relation "vistest" does not exist
p
g
\.
invalid command \.
BEGIN;
ERROR:  syntax error at or near "p"
LINE 1: p
        ^
TRUNCATE vistest;
ERROR:  relation "vistest" does not exist
SAVEPOINT s1;
ERROR:  SAVEPOINT can only be used in transaction blocks
COPY vistest FROM stdin CSV FREEZE;
ERROR:  relation "vistest" does not exist
m
k
\.
invalid command \.
COMMIT;
ERROR:  syntax error at or near "m"
LINE 1: m
        ^
BEGIN;
INSERT INTO vistest VALUES ('z');
ERROR:  relation "vistest" does not exist
LINE 1: INSERT INTO vistest VALUES ('z');
                    ^
SAVEPOINT s1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
TRUNCATE vistest;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK TO SAVEPOINT s1;
ERROR:  no such savepoint
COPY vistest FROM stdin CSV FREEZE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
d3
e
\.
invalid command \.
COMMIT;
ERROR:  syntax error at or near "d3"
LINE 1: d3
        ^
CREATE FUNCTION truncate_in_subxact() RETURNS VOID AS
$$
BEGIN
	TRUNCATE vistest;
EXCEPTION
  WHEN OTHERS THEN
	INSERT INTO vistest VALUES ('subxact failure');
END;
$$ language plpgsql;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
BEGIN;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO vistest VALUES ('z');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT truncate_in_subxact();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COPY vistest FROM stdin CSV FREEZE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
d4
e
\.
invalid command \.
SELECT * FROM vistest;
ERROR:  syntax error at or near "d4"
LINE 1: d4
        ^
COMMIT;
SELECT * FROM vistest;
ERROR:  relation "vistest" does not exist
LINE 1: SELECT * FROM vistest;
                      ^
-- Test FORCE_NOT_NULL and FORCE_NULL options
CREATE TEMP TABLE forcetest (
    a INT NOT NULL,
    b TEXT NOT NULL,
    c TEXT,
    d TEXT,
    e TEXT
);
\pset null NULL
-- should succeed with no effect ("b" remains an empty string, "c" remains NULL)
BEGIN;
COPY forcetest (a, b, c) FROM STDIN WITH (FORMAT csv, FORCE_NOT_NULL(b), FORCE_NULL(c));
COMMIT;
SELECT b, c FROM forcetest WHERE a = 1;
 b | c 
---+---
   | 
(1 row)

-- should succeed, FORCE_NULL and FORCE_NOT_NULL can be both specified
BEGIN;
COPY forcetest (a, b, c, d) FROM STDIN WITH (FORMAT csv, FORCE_NOT_NULL(c,d), FORCE_NULL(c,d));
COMMIT;
SELECT c, d FROM forcetest WHERE a = 2;
 c | d 
---+---
   | 
(1 row)

-- should fail with not-null constraint violation
BEGIN;
COPY forcetest (a, b, c) FROM STDIN WITH (FORMAT csv, FORCE_NULL(b), FORCE_NOT_NULL(c));
ERROR:  null value in column "b" violates not-null constraint
DETAIL:  Failing row contains (3, null, , null, null).
ROLLBACK;
-- should fail with "not referenced by COPY" error
BEGIN;
COPY forcetest (d, e) FROM STDIN WITH (FORMAT csv, FORCE_NOT_NULL(b));
ERROR:  FORCE_NOT_NULL column "b" not referenced by COPY
ROLLBACK;
-- should fail with "not referenced by COPY" error
BEGIN;
COPY forcetest (d, e) FROM STDIN WITH (FORMAT csv, FORCE_NULL(b));
ERROR:  FORCE_NULL column "b" not referenced by COPY
ROLLBACK;
\pset null ''
-- test case with whole-row Var in a check constraint
create table check_con_tbl (f1 int);
create function check_con_function(check_con_tbl) returns bool as $$
begin
  raise notice 'input = %', row_to_json($1);
  return $1.f1 > 0;
end $$ language plpgsql immutable;
alter table check_con_tbl add check (check_con_function(check_con_tbl.*));
\d+ check_con_tbl
                               Table "public.check_con_tbl"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 f1     | integer |           |          |         | plain   |              | 
Check constraints:
    "check_con_tbl_check" CHECK (check_con_function(check_con_tbl.*))
Distribute By: HASH(f1)
Location Nodes: ALL DATANODES

copy check_con_tbl from stdin;
copy check_con_tbl from stdin;
ERROR:  new row for relation "check_con_tbl" violates check constraint "check_con_tbl_check"
DETAIL:  Failing row contains (0).
select * from check_con_tbl;
 f1 
----
  1
   
(2 rows)

-- test with RLS enabled.
CREATE ROLE regress_rls_copy_user;
CREATE ROLE regress_rls_copy_user_colperms;
CREATE TABLE rls_t1 (a int, b int, c int);
COPY rls_t1 (a, b, c) from stdin;
CREATE POLICY p1 ON rls_t1 FOR SELECT USING (a % 2 = 0);
ALTER TABLE rls_t1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE rls_t1 FORCE ROW LEVEL SECURITY;
GRANT SELECT ON TABLE rls_t1 TO regress_rls_copy_user;
GRANT SELECT (a, b) ON TABLE rls_t1 TO regress_rls_copy_user_colperms;
-- all columns
COPY rls_t1 TO stdout;
1	4	1
2	3	2
3	2	3
4	1	4
COPY rls_t1 (a, b, c) TO stdout;
1	4	1
2	3	2
3	2	3
4	1	4
-- subset of columns
COPY rls_t1 (a) TO stdout;
1
2
3
4
COPY rls_t1 (a, b) TO stdout;
1	4
2	3
3	2
4	1
-- column reordering
COPY rls_t1 (b, a) TO stdout;
4	1
3	2
2	3
1	4
SET SESSION AUTHORIZATION regress_rls_copy_user;
-- all columns
COPY rls_t1 TO stdout;
2	3	2
4	1	4
COPY rls_t1 (a, b, c) TO stdout;
2	3	2
4	1	4
-- subset of columns
COPY rls_t1 (a) TO stdout;
2
4
COPY rls_t1 (a, b) TO stdout;
2	3
4	1
-- column reordering
COPY rls_t1 (b, a) TO stdout;
3	2
1	4
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_rls_copy_user_colperms;
-- attempt all columns (should fail)
COPY rls_t1 TO stdout;
ERROR:  permission denied for relation rls_t1
COPY rls_t1 (a, b, c) TO stdout;
ERROR:  permission denied for relation rls_t1
-- try to copy column with no privileges (should fail)
COPY rls_t1 (c) TO stdout;
ERROR:  permission denied for relation rls_t1
-- subset of columns (should succeed)
COPY rls_t1 (a) TO stdout;
2
4
COPY rls_t1 (a, b) TO stdout;
2	3
4	1
RESET SESSION AUTHORIZATION;
-- test with INSTEAD OF INSERT trigger on a view
CREATE TABLE instead_of_insert_tbl(id serial, name text);
CREATE VIEW instead_of_insert_tbl_view AS SELECT ''::text AS str;
COPY instead_of_insert_tbl_view FROM stdin; -- fail
ERROR:  cannot copy to view "instead_of_insert_tbl_view"
HINT:  To enable copying to a view, provide an INSTEAD OF INSERT trigger.
CREATE FUNCTION fun_instead_of_insert_tbl() RETURNS trigger AS $$
BEGIN
  INSERT INTO instead_of_insert_tbl (name) VALUES (NEW.str);
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trig_instead_of_insert_tbl_view
  INSTEAD OF INSERT ON instead_of_insert_tbl_view
  FOR EACH ROW EXECUTE PROCEDURE fun_instead_of_insert_tbl();
ERROR:  Postgres-XL does not support TRIGGER yet
DETAIL:  The feature is not currently supported
COPY instead_of_insert_tbl_view FROM stdin;
ERROR:  cannot copy to view "instead_of_insert_tbl_view"
HINT:  To enable copying to a view, provide an INSTEAD OF INSERT trigger.
SELECT * FROM instead_of_insert_tbl;
 id | name 
----+------
(0 rows)

\c regression_ora
set transform_insert_to_copy TO on;
drop TABLE if exists ctv_data_20220713 cascade;
NOTICE:  table "CTV_DATA_20220713" does not exist, skipping
CREATE TABLE ctv_data_20220713 (v, h, c, i, d) AS
VALUES
   ('v1','h2','foo', 3, '2015-04-01'::date),
   ('v2','h1','bar', 3, '2015-01-02'),
   ('v1','h0','baz', NULL, '2015-07-12'),
   ('v0','h4','qux', 4, '2015-07-15'),
   ('v0','h4','dbl', -3, '2014-12-15'),
   ('v0',NULL,'qux', 5, '2014-07-15'),
   ('v1','h2','quux',7, '2015-04-04');
select * from ctv_data_20220713 order by 1,2;
 V  | H  |  C   | I  |          D          
----+----+------+----+---------------------
 v0 | h4 | qux  |  4 | 2015-07-15 00:00:00
 v0 | h4 | dbl  | -3 | 2014-12-15 00:00:00
 v0 |    | qux  |  5 | 2014-07-15 00:00:00
 v1 | h0 | baz  |    | 2015-07-12 00:00:00
 v1 | h2 | foo  |  3 | 2015-04-01 00:00:00
 v1 | h2 | quux |  7 | 2015-04-04 00:00:00
 v2 | h1 | bar  |  3 | 2015-01-02 00:00:00
(7 rows)

drop TABLE if exists ctv_data_20220713 cascade;
create table t_copy_type_convert(v varchar(3)) distribute by shard(v);
copy t_copy_type_convert(v position(1:6) trim($1)) from stdin encoding 'UTF8';
ERROR:  value too long for type character(3), actual(6)
CONTEXT:  COPY T_COPY_TYPE_CONVERT, line 1, column V: "qqqqqq", nodetype:1(1:cn,0:dn)
copy t_copy_type_convert(v position(1:6) cast(nullif(trim($1),'') as varchar)) from stdin encoding 'UTF8';
ERROR:  value too long for type character(3), actual(6)
CONTEXT:  COPY T_COPY_TYPE_CONVERT, line 1, column V: "qqqqqq", nodetype:1(1:cn,0:dn)
drop table t_copy_type_convert;
\c regression
reset transform_insert_to_copy;
set transform_insert_to_copy to on;
drop table if exists t4;
NOTICE:  table "t4" does not exist, skipping
create table t4(f1 int,f2 varchar,f3 int);
--expected error
insert into t4(f1,f2,f3) values(1,'xxxxx'),(2,'xxxxx');
ERROR:  INSERT has more target columns than expressions
LINE 1: insert into t4(f1,f2,f3) values(1,'xxxxx'),(2,'xxxxx');
                             ^
insert into t4(f1,f2) values(1,'xxxxx'),(2,'xxxxx');
insert into t4 values(1,'xxxxx',1),(2,'xxxxx',2);
-- Additional support for partial column insert to copy
insert into t4 values(1,'xxxxx'),(2,'xxxxx');
select * from t4 order by 1,2,3;
 f1 |  f2   | f3 
----+-------+----
  1 | xxxxx |  1
  1 | xxxxx |   
  1 | xxxxx |   
  2 | xxxxx |  2
  2 | xxxxx |   
  2 | xxxxx |   
(6 rows)

drop table t4;
drop table if exists rules_src;
drop table if exists rules_log;
create table rules_src(f1 int, f2 int);
create table rules_log(f1 int, f2 int, tag text);
insert into rules_src values(1,2), (11,12);
-- No error is reported when the execution is successful.
create rule r1 as on update to rules_src do also
insert into rules_log values(old.*, 'old'), (new.*, 'new');
update rules_src set f2 = f2 + 1;
-- No error 'ERROR:  INSERT has more target columns than expressions'
insert into rules_log values(1,2), (11, to_number('14', '999'));
select * from rules_log order by 1,2,3;
 f1 | f2 | tag 
----+----+-----
  1 |  2 | old
  1 |  2 | 
  1 |  3 | new
 11 | 12 | old
 11 | 13 | new
 11 | 14 | 
(6 rows)

drop table rules_src cascade;
drop table rules_log cascade;
-- The cast conversion supports the insert to copy statement.
SET datestyle = iso, ymd;
drop table if exists t_varchar;
NOTICE:  table "t_varchar" does not exist, skipping
create table t_varchar(a varchar(1), b varchar(30)) distribute by shard(a);
insert into t_varchar values('123'::varchar(1), '2023-01-02 11:31:22'::date);
insert into t_varchar values('123'::varchar(1), '2023-01-02 11:31:22'::date),('123'::varchar(1), '2023-01-02 11:31:22'::date);
insert into t_varchar values('456'::varchar(1), NULL::date);
insert into t_varchar values('456'::varchar(1), NULL::date),('456'::varchar(1), NULL::date);
select *, b is null from t_varchar order by 1,2;
 a |     b      | ?column? 
---+------------+----------
 1 | 2023-01-02 | f
 1 | 2023-01-02 | f
 1 | 2023-01-02 | f
 4 |            | t
 4 |            | t
 4 |            | t
(6 rows)

drop table t_varchar;
reset datestyle;
-- prepare insert
drop table if exists t_insert_success;
NOTICE:  table "t_insert_success" does not exist, skipping
CREATE TABLE t_insert_success (
    col1 integer,
    col2 integer,
    col3 char(3),
    col4 int,
    col5 date
) distribute by shard(col1);
delete from t_insert_success;
prepare p1_3(int)  as insert into t_insert_success  values(1,2,'a',1,'2011-01-01'),(2,2,2,3,'2020-11-01'),(3,3,3,3,'2022-11-01') ;
execute p1_3(1);
select * from t_insert_success order by 1,2,3,4,5;
 col1 | col2 | col3 | col4 |    col5    
------+------+------+------+------------
    1 |    2 | a    |    1 | 01-01-2011
    2 |    2 | 2    |    3 | 11-01-2020
    3 |    3 | 3    |    3 | 11-01-2022
(3 rows)

select count(*) from t_insert_success;
 count 
-------
     3
(1 row)

drop table if exists t_insert_success;
-- plpgsql support tocopy
drop table if exists bug_test_pro_multi_values_shard_1 cascade;
NOTICE:  table "bug_test_pro_multi_values_shard_1" does not exist, skipping
create table bug_test_pro_multi_values_shard_1(f1 int default 1,f2 int default 1, f3 float default 0.9, f4 date default '2023-01-12', f5 timestamp default '2023-01-12 15:50:00.424278', f6 time default '15:50:00', f7 interval default '1 day', f8 varchar default '你好', f9 varchar(8000) default repeat('深圳', 10), f10 text default '南山', f11 serial);
drop procedure if exists bug_test_pro_multi_values_shard_1_insert();
NOTICE:  procedure bug_test_pro_multi_values_shard_1_insert() does not exist, skipping
CREATE OR REPLACE PROCEDURE bug_test_pro_multi_values_shard_1_insert() AS
$$
BEGIN
    delete from bug_test_pro_multi_values_shard_1;
    insert into bug_test_pro_multi_values_shard_1 values(3,3),(4,4);
    insert into bug_test_pro_multi_values_shard_1 values(5,5,default),(6,6,default),(default,default,default);
    insert into bug_test_pro_multi_values_shard_1 values(7,7,default),(8,8,default),(default,default,default);
    insert into bug_test_pro_multi_values_shard_1 values(default,default,default,default,default,default,default),(default,default,default,default,default,default,default),(default,default,default,default,default,default,default);
    exception
     when others then
		raise notice '%',SQLERRM;
end;
$$
language plpgsql;
truncate table bug_test_pro_multi_values_shard_1;
call bug_test_pro_multi_values_shard_1_insert();
select * from bug_test_pro_multi_values_shard_1 order by f11;
 f1 | f2 | f3  |     f4     |               f5                |    f6    |   f7    |  f8  |                    f9                    | f10  | f11 
----+----+-----+------------+---------------------------------+----------+---------+------+------------------------------------------+------+-----
  3 |  3 | 0.9 | 01-12-2023 | Thu Jan 12 15:50:00.424278 2023 | 15:50:00 | @ 1 day | 你好 | 深圳深圳深圳深圳深圳深圳深圳深圳深圳深圳 | 南山 |   1
  4 |  4 | 0.9 | 01-12-2023 | Thu Jan 12 15:50:00.424278 2023 | 15:50:00 | @ 1 day | 你好 | 深圳深圳深圳深圳深圳深圳深圳深圳深圳深圳 | 南山 |   2
  5 |  5 | 0.9 | 01-12-2023 | Thu Jan 12 15:50:00.424278 2023 | 15:50:00 | @ 1 day | 你好 | 深圳深圳深圳深圳深圳深圳深圳深圳深圳深圳 | 南山 |   3
  6 |  6 | 0.9 | 01-12-2023 | Thu Jan 12 15:50:00.424278 2023 | 15:50:00 | @ 1 day | 你好 | 深圳深圳深圳深圳深圳深圳深圳深圳深圳深圳 | 南山 |   4
  1 |  1 | 0.9 | 01-12-2023 | Thu Jan 12 15:50:00.424278 2023 | 15:50:00 | @ 1 day | 你好 | 深圳深圳深圳深圳深圳深圳深圳深圳深圳深圳 | 南山 |   5
  7 |  7 | 0.9 | 01-12-2023 | Thu Jan 12 15:50:00.424278 2023 | 15:50:00 | @ 1 day | 你好 | 深圳深圳深圳深圳深圳深圳深圳深圳深圳深圳 | 南山 |   6
  8 |  8 | 0.9 | 01-12-2023 | Thu Jan 12 15:50:00.424278 2023 | 15:50:00 | @ 1 day | 你好 | 深圳深圳深圳深圳深圳深圳深圳深圳深圳深圳 | 南山 |   7
  1 |  1 | 0.9 | 01-12-2023 | Thu Jan 12 15:50:00.424278 2023 | 15:50:00 | @ 1 day | 你好 | 深圳深圳深圳深圳深圳深圳深圳深圳深圳深圳 | 南山 |   8
  1 |  1 | 0.9 | 01-12-2023 | Thu Jan 12 15:50:00.424278 2023 | 15:50:00 | @ 1 day | 你好 | 深圳深圳深圳深圳深圳深圳深圳深圳深圳深圳 | 南山 |   9
  1 |  1 | 0.9 | 01-12-2023 | Thu Jan 12 15:50:00.424278 2023 | 15:50:00 | @ 1 day | 你好 | 深圳深圳深圳深圳深圳深圳深圳深圳深圳深圳 | 南山 |  10
  1 |  1 | 0.9 | 01-12-2023 | Thu Jan 12 15:50:00.424278 2023 | 15:50:00 | @ 1 day | 你好 | 深圳深圳深圳深圳深圳深圳深圳深圳深圳深圳 | 南山 |  11
(11 rows)

drop table bug_test_pro_multi_values_shard_1 cascade;
reset transform_insert_to_copy;
-- clean up
DROP TABLE forcetest;
ERROR:  table "forcetest" does not exist
DROP TABLE vistest;
ERROR:  table "vistest" does not exist
DROP FUNCTION truncate_in_subxact();
ERROR:  function truncate_in_subxact() does not exist
DROP TABLE x, y;
ERROR:  table "x" does not exist
DROP TABLE rls_t1 CASCADE;
DROP ROLE regress_rls_copy_user;
DROP ROLE regress_rls_copy_user_colperms;
DROP FUNCTION fn_x_before();
DROP FUNCTION fn_x_after();
DROP TABLE instead_of_insert_tbl;
DROP VIEW instead_of_insert_tbl_view;
DROP FUNCTION fun_instead_of_insert_tbl();
\c regression_ora
create table t_copy_type_convert(v varchar(3)) distribute by shard(v);
copy t_copy_type_convert(v position(1:6) trim($1)) from stdin encoding 'UTF8';
ERROR:  value too long for type character(3), actual(6)
CONTEXT:  COPY T_COPY_TYPE_CONVERT, line 1, column V: "qqqqqq", nodetype:1(1:cn,0:dn)
copy t_copy_type_convert(v position(1:6) cast(nullif(trim($1),'') as varchar)) from stdin encoding 'UTF8';
ERROR:  value too long for type character(3), actual(6)
CONTEXT:  COPY T_COPY_TYPE_CONVERT, line 1, column V: "qqqqqq", nodetype:1(1:cn,0:dn)
drop table t_copy_type_convert;
-- test copy position
drop table if exists t_copy;
NOTICE:  table "T_COPY" does not exist, skipping
create table t_copy(v varchar(3)) distribute by shard(v);
-- ok
copy t_copy(v position(1:3)) from stdin encoding 'UTF8';
select * from t_copy;
  V  
-----
 qqq
(1 row)

drop table t_copy;
-- copy with fixed
create table test_cp(f1 smallint, f2 integer, f3 bigint, f4 decimal, f5 numeric, f6 numeric(10), f7 numeric(10,5), f8 real ,f9 double precision, f10 money, f11 varchar(10), f12 char(15), f13 text, f14 timestamp without time zone, f15 boolean, f16 varchar(15));
copy test_cp from stdin delimiter ',';
copy test_cp to stdout csv formatter(f1(10));
ERROR:  formatter only can be specified in FIXED mode
copy test_cp to stdout binary formatter(f1(10));
ERROR:  formatter only can be specified in FIXED mode
copy test_cp to stdout fixed;
ERROR:  formatter must be specified in FIXED mode
copy test_cp to stdout fixed formatter(f1(10));
ERROR:  Fixed length is not specified for column "F2"
copy test_cp to stdout fixed formatter(f1(5), f2(5), f3(5), f4(5), f5(6), f6(6), f7(6), f8(7), f9(7));
ERROR:  Fixed length is not specified for column "F10"
copy test_cp to stdout fixed formatter(f1(5), f2(5), f3(5), f4(5), f5(6), f6(6), f7(6), f8(7), f9(7), f13(2), f14(10), f15(1));
ERROR:  Fixed length is not specified for column "F10"
copy test_cp to stdout fixed formatter(f1(5), f2(5), f3(5), f4(5), f5(6), f6(6), f7(6), f8(7), f9(7), f10(8), f13(2), f14(10), f15(1));
ERROR:  Unexpected response from the data nodes when combining, request type 0
copy test_cp to stdout fixed formatter with truncate (f1(5), f2(5), f3(5), f4(5), f5(6), f6(6), f7(6), f8(7), f9(7), f10(8), f13(2), f14(10), f15(1));
0000100002000030000400000501234612345.12345.612345.6$12,345.abc       ccccc          dd2023-05-01teeeeeeee       
0001200022000320004200005101234612345.12345.612345.6$12,345.dfedfedfe ccc            dd2023-05-01teeeeeeee       
0001300023000330004300005101234612345.12345.612345.6$12,345.qwerqwerq ccc            dd2023-05-01teeeeeeee       
0001100021000310004100005101234612345.12345.612345.6$12,345.abcabcabc cccccccccccccccdd2023-05-01teeeeeeee       
copy test_cp to stdout fixed formatter(f1(5), f2(5), f3(5), f4(5), f5(6), f6(6), f7 with truncate(6), f8(9), f9 with truncate(7), f10 with truncate(8), f13 with truncate(2), f14 with truncate(10), f15(2));
0000100002000030000400000501234612345.12345.67912345.6$12,345.abc       ccccc          dd2023-05-010teeeeeeee       
0001200022000320004200005101234612345.12345.67912345.6$12,345.dfedfedfe ccc            dd2023-05-010teeeeeeee       
0001300023000330004300005101234612345.12345.67912345.6$12,345.qwerqwerq ccc            dd2023-05-010teeeeeeee       
0001100021000310004100005101234612345.12345.67912345.6$12,345.abcabcabc cccccccccccccccdd2023-05-010teeeeeeee       
copy test_cp to stdout fixed formatter(f1(5), f2(5), f3(5), f4(5), f5(6), f6(6), f7 with truncate(6), f8 with truncate(7), f9 with truncate(7), f10 with truncate(8), f13 with truncate(2), f14 with truncate(10), f15(8)) header;
F1   F2   F3   F4   F5    F6    F7    F8     F9     F10     F11       F12            F1F14       F15     F16            
0000100002000030000400000501234612345.12345.612345.6$12,345.abc       ccccc          dd2023-05-010000000teeeeeeee       
0001200022000320004200005101234612345.12345.612345.6$12,345.dfedfedfe ccc            dd2023-05-010000000teeeeeeee       
0001300023000330004300005101234612345.12345.612345.6$12,345.qwerqwerq ccc            dd2023-05-010000000teeeeeeee       
0001100021000310004100005101234612345.12345.612345.6$12,345.abcabcabc cccccccccccccccdd2023-05-010000000teeeeeeee       
select * from test_cp order by 1,2,3,4;
 F1 | F2 | F3 | F4 | F5 |  F6   |     F7     |    F8     |     F9     |    F10     |    F11    |       F12       |  F13   |            F14             | F15 |   F16    
----+----+----+----+----+-------+------------+-----------+------------+------------+-----------+-----------------+--------+----------------------------+-----+----------
  1 |  2 |  3 |  4 |  5 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | abc       | ccccc           | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
 11 | 21 | 31 | 41 | 51 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | abcabcabc | ccccccccccccccc | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
 12 | 22 | 32 | 42 | 51 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | dfedfedfe | ccc             | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
 13 | 23 | 33 | 43 | 51 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | qwerqwerq | ccc             | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
(4 rows)

copy test_cp to stdout fixed formatter(f1(5), f2(5), f3(5), f4(5), f5(6), f6(6), f7(15), f8(7), f9(10), f10(15), f13(12), f14(25), f15(8)) header;
f1   f2   f3   f4   f5    f6    f7             f8     f9        f10            f11       f12            f13         f14                      f15     f16            
00001000020000300004000005012346000012345.6789012345.712345.678900000$12,345.67abc       ccccc          dddddd      0Mon May 01 10:10:10 20230000000teeeeeeee       
00012000220003200042000051012346000012345.6789012345.712345.678900000$12,345.67dfedfedfe ccc            dddddd      0Mon May 01 10:10:10 20230000000teeeeeeee       
00013000230003300043000051012346000012345.6789012345.712345.678900000$12,345.67qwerqwerq ccc            dddddd      0Mon May 01 10:10:10 20230000000teeeeeeee       
00011000210003100041000051012346000012345.6789012345.712345.678900000$12,345.67abcabcabc cccccccccccccccdddddd      0Mon May 01 10:10:10 20230000000teeeeeeee       
copy (select f1, f11, f12, f14 from test_cp) to stdout fixed formatter(f1(5), f14(25)) header;
f1   f11       f12            f14                      
00001abc       ccccc          0Mon May 01 10:10:10 2023
00012dfedfedfe ccc            0Mon May 01 10:10:10 2023
00013qwerqwerq ccc            0Mon May 01 10:10:10 2023
00011abcabcabc ccccccccccccccc0Mon May 01 10:10:10 2023
copy test_cp(f1, f11, f12, f14) from stdin fixed formatter(f1(5), f14(20)) header;
select * from test_cp order by 1,2,3,4;
 F1 | F2 | F3 | F4 | F5 |  F6   |     F7     |    F8     |     F9     |    F10     |    F11    |       F12       |  F13   |            F14             | F15 |   F16    
----+----+----+----+----+-------+------------+-----------+------------+------------+-----------+-----------------+--------+----------------------------+-----+----------
  1 |  2 |  3 |  4 |  5 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | abc       | ccccc           | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
  1 |    |    |    |    |       |            |           |            |            | abc       | ccccc           |        | 2023-05-01 10:10:10.000000 |     | 
 11 | 21 | 31 | 41 | 51 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | abcabcabc | ccccccccccccccc | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
 11 |    |    |    |    |       |            |           |            |            | abcabcabc | ccccccccccccccc |        | 2023-05-01 10:10:10.000000 |     | 
 12 | 22 | 32 | 42 | 51 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | dfedfedfe | ccc             | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
 12 |    |    |    |    |       |            |           |            |            | dfedfedfe | ccc             |        | 2023-05-01 10:10:10.000000 |     | 
 13 | 23 | 33 | 43 | 51 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | qwerqwerq | ccc             | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
 13 |    |    |    |    |       |            |           |            |            | qwerqwerq | ccc             |        | 2023-05-01 10:10:10.000000 |     | 
(8 rows)

copy (select f1, f8, f11, f12, f14 from test_cp) to stdout fixed formatter(f1(5), f8(10), f11(20), f14(25)) header;
f1   f8        f11                 f12            f14                      
0000100012345.7abc                 ccccc          0Mon May 01 10:10:10 2023
0001200012345.7dfedfedfe           ccc            0Mon May 01 10:10:10 2023
0001300012345.7qwerqwerq           ccc            0Mon May 01 10:10:10 2023
0000100000000\Nabc                 ccccc          0Mon May 01 10:10:10 2023
0001200000000\Ndfedfedfe           ccc            0Mon May 01 10:10:10 2023
0001300000000\Nqwerqwerq           ccc            0Mon May 01 10:10:10 2023
0001100012345.7abcabcabc           ccccccccccccccc0Mon May 01 10:10:10 2023
0001100000000\Nabcabcabc           ccccccccccccccc0Mon May 01 10:10:10 2023
copy test_cp(f1, f8, f11, f12, f14) from stdin fixed formatter(f1(5), f8(10), f11(20), f14(20)) header;
select * from test_cp order by 1,2,3,4;
 F1 | F2 | F3 | F4 | F5 |  F6   |     F7     |    F8     |     F9     |    F10     |    F11    |       F12       |  F13   |            F14             | F15 |   F16    
----+----+----+----+----+-------+------------+-----------+------------+------------+-----------+-----------------+--------+----------------------------+-----+----------
  1 |  2 |  3 |  4 |  5 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | abc       | ccccc           | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
  1 |    |    |    |    |       |            |           |            |            | abc       | ccccc           |        | 2023-05-01 10:10:10.000000 |     | 
  1 |    |    |    |    |       |            |   12345.7 |            |            | abc       | ccccc           |        | 2023-05-01 10:10:10.000000 |     | 
  1 |    |    |    |    |       |            |           |            |            | abc       | ccccc           |        | 2023-05-01 10:10:10.000000 |     | 
 11 | 21 | 31 | 41 | 51 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | abcabcabc | ccccccccccccccc | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
 11 |    |    |    |    |       |            |           |            |            | abcabcabc | ccccccccccccccc |        | 2023-05-01 10:10:10.000000 |     | 
 11 |    |    |    |    |       |            |   12345.7 |            |            | abcabcabc | ccccccccccccccc |        | 2023-05-01 10:10:10.000000 |     | 
 11 |    |    |    |    |       |            |           |            |            | abcabcabc | ccccccccccccccc |        | 2023-05-01 10:10:10.000000 |     | 
 12 | 22 | 32 | 42 | 51 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | dfedfedfe | ccc             | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
 12 |    |    |    |    |       |            |           |            |            | dfedfedfe | ccc             |        | 2023-05-01 10:10:10.000000 |     | 
 12 |    |    |    |    |       |            |   12345.7 |            |            | dfedfedfe | ccc             |        | 2023-05-01 10:10:10.000000 |     | 
 12 |    |    |    |    |       |            |           |            |            | dfedfedfe | ccc             |        | 2023-05-01 10:10:10.000000 |     | 
 13 | 23 | 33 | 43 | 51 | 12346 | 12345.6789 | 12345.679 | 12345.6789 | $12,345.67 | qwerqwerq | ccc             | dddddd | 2023-05-01 10:10:10.000000 | t   | eeeeeeee
 13 |    |    |    |    |       |            |           |            |            | qwerqwerq | ccc             |        | 2023-05-01 10:10:10.000000 |     | 
 13 |    |    |    |    |       |            |   12345.7 |            |            | qwerqwerq | ccc             |        | 2023-05-01 10:10:10.000000 |     | 
 13 |    |    |    |    |       |            |           |            |            | qwerqwerq | ccc             |        | 2023-05-01 10:10:10.000000 |     | 
(16 rows)

truncate test_cp;
copy test_cp(f1, f8, f11, f12, f14) from stdin fixed formatter(f1(5), f8(10), f11(20), f14(20), fff(10)) header;
ERROR:  extra formatter after last expected column
copy test_cp(f1, f8, f11, f12, f14) from stdin fixed formatter(f1(5), f8(10), f11(20), f14(20), fff(10)) header IGNORE_EXTRA_DATA;
select * from test_cp order by 1,2,3,4;
 F1 | F2 | F3 | F4 | F5 | F6 | F7 |   F8    | F9 | F10 |    F11    |       F12       | F13 |            F14             | F15 | F16 
----+----+----+----+----+----+----+---------+----+-----+-----------+-----------------+-----+----------------------------+-----+-----
 11 |    |    |    |    |    |    | 12345.7 |    |     | abcabcabc | ccccccccccccccc |     | 2023-05-01 10:10:10.000000 |     | 
 11 |    |    |    |    |    |    |         |    |     | abcabcabc | ccccccccccccccc |     | 2023-05-01 10:10:10.000000 |     | 
 13 |    |    |    |    |    |    | 12345.7 |    |     | qwerqwerq | ccc             |     | 2023-05-01 10:10:10.000000 |     | 
(3 rows)

truncate test_cp;
copy test_cp(f1, f8, f11, f12, f14) from stdin fixed formatter(f1(5), f8(10), f11(20), f14(20), fff(10)) header IGNORE_EXTRA_DATA;
ERROR:  missing data for column "F14"
CONTEXT:  COPY TEST_CP, line 4: "0001100000000\Nabcabcabc           ccccccccccccccc", nodetype:1(1:cn,0:dn)
copy test_cp(f1, f8, f11, f12, f14) from stdin fixed formatter(f1(5), f8(10), f11(20), f14(20), fff(10)) header IGNORE_EXTRA_DATA FILL_MISSING_FIELDS;
select * from test_cp order by 1,2,3,4;
 F1 | F2 | F3 | F4 | F5 | F6 | F7 |   F8    | F9 | F10 |    F11    |       F12       | F13 |            F14             | F15 | F16 
----+----+----+----+----+----+----+---------+----+-----+-----------+-----------------+-----+----------------------------+-----+-----
 11 |    |    |    |    |    |    | 12345.7 |    |     | abcabcabc | ccccccccccccccc |     | 2023-05-01 10:10:10.000000 |     | 
 11 |    |    |    |    |    |    |         |    |     | abcabcabc | ccccccccccccccc |     |                            |     | 
 13 |    |    |    |    |    |    | 12345.7 |    |     | qwerqwerq | ccc             |     | 2023-05-01 10:10:10.000000 |     | 
(3 rows)

drop table t_copy_type_convert;
ERROR:  table "T_COPY_TYPE_CONVERT" does not exist
-----------------------------------------------
-- 定长字段：语法、基本功能
-----------------------------------------------
-- 先创建所需表
drop table if exists data_20230612_31 cascade ;
NOTICE:  table "DATA_20230612_31" does not exist, skipping
drop table if exists test_20230612_31 cascade ;
NOTICE:  table "TEST_20230612_31" does not exist, skipping
create table data_20230612_31(id int, f1 char(10), f2 varchar(10), f3 numeric(10,5));
create table test_20230612_31(id int, f1 char(10), f2 varchar(10), f3 numeric(10,5));
-- 语法不支持formatter在括号里面，所以下面语句报错
insert into data_20230612_31 values (1, 'f1', 'f2', 1);
copy data_20230612_31 to stdout with (FORMAT fixed, formatter(id(3)));
ERROR:  syntax error at or near "("
LINE 1: ...20230612_31 to stdout with (FORMAT fixed, formatter(id(3)));
                                                                 ^
copy data_20230612_31 to stdout( delimiter '$',encoding utf8, format csv);
1$f1        $f2$1.00000
copy data_20230612_31 to stdout( delimiter '$',encoding utf8, format fixed, formatter(id(3), f1(10), f2(10), f3 with truncate (10)));
ERROR:  syntax error at or near "("
LINE 1: ...iter '$',encoding utf8, format fixed, formatter(id(3), f1(10...
                                                             ^
-- 在定长模式下，需要指定输出列的长度，默认采用列定义长度
truncate  table data_20230612_31;
insert into data_20230612_31 values (1, 'f1', 'f2', 1);
insert into data_20230612_31 values (2, 'f1');
copy data_20230612_31 to stdout;
1	f1        	f2	1
2	f1        	\N	\N
copy data_20230612_31 to stdout fixed formatter(id(3)) delimiter '$';
001f1        f2        0001.00000
002f1        \N        00000000\N
copy data_20230612_31 to stdout fixed formatter(id(3), f1(10), f2(10), f3 with truncate (10)) delimiter '$';
001f1        f2        0001.00000
002f1        \N        00000000\N
copy data_20230612_31 to stdout with fixed formatter(id(3), f1(10), f2(10), f3 with truncate (10)) delimiter '$';
001f1        f2        0001.00000
002f1        \N        00000000\N
-- 在定长模式下，需要指定输出列的长度，默认采用列定义长度----导出
truncate  table data_20230612_31;
insert into data_20230612_31 values (1, 'f1', 'f2', 1);
copy data_20230612_31 to stdout;
1	f1        	f2	1
copy data_20230612_31 to stdout with fixed formatter(id(3)) ;
001f1        f2        0001.00000
truncate  table data_20230612_31;
insert into data_20230612_31 values (2, 'f1');
copy data_20230612_31 to stdout;
2	f1        	\N	\N
copy data_20230612_31 to stdout with fixed formatter(id(3)) ;
002f1        \N        00000000\N
-- 定长字段，不指定长度，长度超长：不带with cut会报错，带with cut后按照定义的长度导入导出
truncate  table data_20230612_31;
insert into data_20230612_31 values (2, 'hij', 'hijklmn', 22222);
copy data_20230612_31 to stdout;
2	hij       	hijklmn	22222
copy data_20230612_31 to stdout fixed formatter(id(3));
ERROR:  Unexpected response from the data nodes when combining, request type 4, errorMessage: length of field "f3" longer than limit of '10'
copy data_20230612_31 to stdout fixed formatter(id(3), f1(10), f2(10), f3 with truncate (10)) delimiter '$';
002hij       hijklmn   22222.0000
copy data_20230612_31 to stdout fixed formatter(id(3), f3 with truncate (10)) delimiter '$';
002hij       hijklmn   22222.0000
drop table if exists data_20230612_31 cascade ;
drop table if exists test_20230612_31 cascade ;
create table emptystr(c1 int, c2 text, c3 text);
set enable_lightweight_ora_syntax TO off;
COPY emptystr (c1, c2, c3) from stdin (format 'csv',delimiter ',', null '\N');
select * from emptystr where c2 is null;
 C1 | C2 | C3 
----+----+----
  1 |    | aa
  3 |    | cc
(2 rows)

truncate emptystr;
set enable_lightweight_ora_syntax TO on;
COPY emptystr (c1, c2, c3) from stdin (format 'csv',delimiter ',', null '\N');
select * from emptystr where c2 is null;
 C1 | C2 | C3 
----+----+----
  1 |    | aa
  3 |    | cc
(2 rows)

reset enable_lightweight_ora_syntax;
drop table emptystr;
create table tbquote(c1 int, c2 text, c3 text);
copy tbquote from stdin (format 'csv', delimiter '^C', encoding utf8, quote E'&', escape '\');
ERROR:  unterminated CSV quoted field
CONTEXT:  COPY TBQUOTE, line 2: "2^Cd^C&t2
3^Ce^Ct3
4^Cf^Ct4
", nodetype:1(1:cn,0:dn)
copy tbquote from stdin (format 'csv', delimiter '^C', encoding utf8, quote E'\b', escape '\');
select * from tbquote;
 C1 | C2 | C3  
----+----+-----
  1 | c  | t1
  2 | d  | &t2
  3 | e  | t3
  4 | f  | t4
(4 rows)

drop table tbquote;
-- reset conn
\c regression
