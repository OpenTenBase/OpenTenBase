--
-- JOIN
-- Test JOIN clauses
--
CREATE TABLE J1_TBL (
  i integer,
  j integer,
  t text
);
CREATE TABLE J2_TBL (
  i integer,
  k integer
);
INSERT INTO J1_TBL VALUES (1, 4, 'one');
INSERT INTO J1_TBL VALUES (2, 3, 'two');
INSERT INTO J1_TBL VALUES (3, 2, 'three');
INSERT INTO J1_TBL VALUES (4, 1, 'four');
INSERT INTO J1_TBL VALUES (5, 0, 'five');
INSERT INTO J1_TBL VALUES (6, 6, 'six');
INSERT INTO J1_TBL VALUES (7, 7, 'seven');
INSERT INTO J1_TBL VALUES (8, 8, 'eight');
INSERT INTO J1_TBL VALUES (0, NULL, 'zero');
INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');
INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');
INSERT INTO J2_TBL VALUES (1, -1);
INSERT INTO J2_TBL VALUES (2, 2);
INSERT INTO J2_TBL VALUES (3, -3);
INSERT INTO J2_TBL VALUES (2, 4);
INSERT INTO J2_TBL VALUES (5, -5);
INSERT INTO J2_TBL VALUES (5, -5);
INSERT INTO J2_TBL VALUES (0, NULL);
INSERT INTO J2_TBL VALUES (NULL, NULL);
INSERT INTO J2_TBL VALUES (NULL, 0);
analyze J1_TBL;
analyze J2_TBL;
--
-- CORRELATION NAMES
-- Make sure that table/column aliases are supported
-- before diving into more complex join syntax.
--
SELECT '' AS "xxx", *
  FROM J1_TBL AS tx 
  ORDER BY i, j, t;
 xxx | i | j |   t   
-----+---+---+-------
     | 0 |   | zero
     | 1 | 4 | one
     | 2 | 3 | two
     | 3 | 2 | three
     | 4 | 1 | four
     | 5 | 0 | five
     | 6 | 6 | six
     | 7 | 7 | seven
     | 8 | 8 | eight
     |   | 0 | zero
     |   |   | null
(11 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL tx 
  ORDER BY i, j, t;
 xxx | i | j |   t   
-----+---+---+-------
     | 0 |   | zero
     | 1 | 4 | one
     | 2 | 3 | two
     | 3 | 2 | three
     | 4 | 1 | four
     | 5 | 0 | five
     | 6 | 6 | six
     | 7 | 7 | seven
     | 8 | 8 | eight
     |   | 0 | zero
     |   |   | null
(11 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL AS t1 (a, b, c) 
  ORDER BY a, b, c;
 xxx | a | b |   c   
-----+---+---+-------
     | 0 |   | zero
     | 1 | 4 | one
     | 2 | 3 | two
     | 3 | 2 | three
     | 4 | 1 | four
     | 5 | 0 | five
     | 6 | 6 | six
     | 7 | 7 | seven
     | 8 | 8 | eight
     |   | 0 | zero
     |   |   | null
(11 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL t1 (a, b, c)
  ORDER BY a, b, c;
 xxx | a | b |   c   
-----+---+---+-------
     | 0 |   | zero
     | 1 | 4 | one
     | 2 | 3 | two
     | 3 | 2 | three
     | 4 | 1 | four
     | 5 | 0 | five
     | 6 | 6 | six
     | 7 | 7 | seven
     | 8 | 8 | eight
     |   | 0 | zero
     |   |   | null
(11 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e) 
  ORDER BY a, b, c, d, e;
 xxx | a | b |   c   | d | e  
-----+---+---+-------+---+----
     | 0 |   | zero  | 0 |   
     | 0 |   | zero  | 1 | -1
     | 0 |   | zero  | 2 |  2
     | 0 |   | zero  | 2 |  4
     | 0 |   | zero  | 3 | -3
     | 0 |   | zero  | 5 | -5
     | 0 |   | zero  | 5 | -5
     | 0 |   | zero  |   |  0
     | 0 |   | zero  |   |   
     | 1 | 4 | one   | 0 |   
     | 1 | 4 | one   | 1 | -1
     | 1 | 4 | one   | 2 |  2
     | 1 | 4 | one   | 2 |  4
     | 1 | 4 | one   | 3 | -3
     | 1 | 4 | one   | 5 | -5
     | 1 | 4 | one   | 5 | -5
     | 1 | 4 | one   |   |  0
     | 1 | 4 | one   |   |   
     | 2 | 3 | two   | 0 |   
     | 2 | 3 | two   | 1 | -1
     | 2 | 3 | two   | 2 |  2
     | 2 | 3 | two   | 2 |  4
     | 2 | 3 | two   | 3 | -3
     | 2 | 3 | two   | 5 | -5
     | 2 | 3 | two   | 5 | -5
     | 2 | 3 | two   |   |  0
     | 2 | 3 | two   |   |   
     | 3 | 2 | three | 0 |   
     | 3 | 2 | three | 1 | -1
     | 3 | 2 | three | 2 |  2
     | 3 | 2 | three | 2 |  4
     | 3 | 2 | three | 3 | -3
     | 3 | 2 | three | 5 | -5
     | 3 | 2 | three | 5 | -5
     | 3 | 2 | three |   |  0
     | 3 | 2 | three |   |   
     | 4 | 1 | four  | 0 |   
     | 4 | 1 | four  | 1 | -1
     | 4 | 1 | four  | 2 |  2
     | 4 | 1 | four  | 2 |  4
     | 4 | 1 | four  | 3 | -3
     | 4 | 1 | four  | 5 | -5
     | 4 | 1 | four  | 5 | -5
     | 4 | 1 | four  |   |  0
     | 4 | 1 | four  |   |   
     | 5 | 0 | five  | 0 |   
     | 5 | 0 | five  | 1 | -1
     | 5 | 0 | five  | 2 |  2
     | 5 | 0 | five  | 2 |  4
     | 5 | 0 | five  | 3 | -3
     | 5 | 0 | five  | 5 | -5
     | 5 | 0 | five  | 5 | -5
     | 5 | 0 | five  |   |  0
     | 5 | 0 | five  |   |   
     | 6 | 6 | six   | 0 |   
     | 6 | 6 | six   | 1 | -1
     | 6 | 6 | six   | 2 |  2
     | 6 | 6 | six   | 2 |  4
     | 6 | 6 | six   | 3 | -3
     | 6 | 6 | six   | 5 | -5
     | 6 | 6 | six   | 5 | -5
     | 6 | 6 | six   |   |  0
     | 6 | 6 | six   |   |   
     | 7 | 7 | seven | 0 |   
     | 7 | 7 | seven | 1 | -1
     | 7 | 7 | seven | 2 |  2
     | 7 | 7 | seven | 2 |  4
     | 7 | 7 | seven | 3 | -3
     | 7 | 7 | seven | 5 | -5
     | 7 | 7 | seven | 5 | -5
     | 7 | 7 | seven |   |  0
     | 7 | 7 | seven |   |   
     | 8 | 8 | eight | 0 |   
     | 8 | 8 | eight | 1 | -1
     | 8 | 8 | eight | 2 |  2
     | 8 | 8 | eight | 2 |  4
     | 8 | 8 | eight | 3 | -3
     | 8 | 8 | eight | 5 | -5
     | 8 | 8 | eight | 5 | -5
     | 8 | 8 | eight |   |  0
     | 8 | 8 | eight |   |   
     |   | 0 | zero  | 0 |   
     |   | 0 | zero  | 1 | -1
     |   | 0 | zero  | 2 |  2
     |   | 0 | zero  | 2 |  4
     |   | 0 | zero  | 3 | -3
     |   | 0 | zero  | 5 | -5
     |   | 0 | zero  | 5 | -5
     |   | 0 | zero  |   |  0
     |   | 0 | zero  |   |   
     |   |   | null  | 0 |   
     |   |   | null  | 1 | -1
     |   |   | null  | 2 |  2
     |   |   | null  | 2 |  4
     |   |   | null  | 3 | -3
     |   |   | null  | 5 | -5
     |   |   | null  | 5 | -5
     |   |   | null  |   |  0
     |   |   | null  |   |   
(99 rows)

SELECT '' AS "xxx", t1.a, t2.e
  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)
  WHERE t1.a = t2.d
  ORDER BY a, e;
 xxx | a | e  
-----+---+----
     | 0 |   
     | 1 | -1
     | 2 |  2
     | 2 |  4
     | 3 | -3
     | 5 | -5
     | 5 | -5
(7 rows)

--
-- CROSS JOIN
-- Qualifications are not allowed on cross joins,
-- which degenerate into a standard unqualified inner join.
--
SELECT '' AS "xxx", *
  FROM J1_TBL CROSS JOIN J2_TBL
  ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k;
 xxx | i | j |   t   | i | k  
-----+---+---+-------+---+----
     | 0 |   | zero  | 0 |   
     | 0 |   | zero  | 1 | -1
     | 0 |   | zero  | 2 |  2
     | 0 |   | zero  | 2 |  4
     | 0 |   | zero  | 3 | -3
     | 0 |   | zero  | 5 | -5
     | 0 |   | zero  | 5 | -5
     | 0 |   | zero  |   |  0
     | 0 |   | zero  |   |   
     | 1 | 4 | one   | 0 |   
     | 1 | 4 | one   | 1 | -1
     | 1 | 4 | one   | 2 |  2
     | 1 | 4 | one   | 2 |  4
     | 1 | 4 | one   | 3 | -3
     | 1 | 4 | one   | 5 | -5
     | 1 | 4 | one   | 5 | -5
     | 1 | 4 | one   |   |  0
     | 1 | 4 | one   |   |   
     | 2 | 3 | two   | 0 |   
     | 2 | 3 | two   | 1 | -1
     | 2 | 3 | two   | 2 |  2
     | 2 | 3 | two   | 2 |  4
     | 2 | 3 | two   | 3 | -3
     | 2 | 3 | two   | 5 | -5
     | 2 | 3 | two   | 5 | -5
     | 2 | 3 | two   |   |  0
     | 2 | 3 | two   |   |   
     | 3 | 2 | three | 0 |   
     | 3 | 2 | three | 1 | -1
     | 3 | 2 | three | 2 |  2
     | 3 | 2 | three | 2 |  4
     | 3 | 2 | three | 3 | -3
     | 3 | 2 | three | 5 | -5
     | 3 | 2 | three | 5 | -5
     | 3 | 2 | three |   |  0
     | 3 | 2 | three |   |   
     | 4 | 1 | four  | 0 |   
     | 4 | 1 | four  | 1 | -1
     | 4 | 1 | four  | 2 |  2
     | 4 | 1 | four  | 2 |  4
     | 4 | 1 | four  | 3 | -3
     | 4 | 1 | four  | 5 | -5
     | 4 | 1 | four  | 5 | -5
     | 4 | 1 | four  |   |  0
     | 4 | 1 | four  |   |   
     | 5 | 0 | five  | 0 |   
     | 5 | 0 | five  | 1 | -1
     | 5 | 0 | five  | 2 |  2
     | 5 | 0 | five  | 2 |  4
     | 5 | 0 | five  | 3 | -3
     | 5 | 0 | five  | 5 | -5
     | 5 | 0 | five  | 5 | -5
     | 5 | 0 | five  |   |  0
     | 5 | 0 | five  |   |   
     | 6 | 6 | six   | 0 |   
     | 6 | 6 | six   | 1 | -1
     | 6 | 6 | six   | 2 |  2
     | 6 | 6 | six   | 2 |  4
     | 6 | 6 | six   | 3 | -3
     | 6 | 6 | six   | 5 | -5
     | 6 | 6 | six   | 5 | -5
     | 6 | 6 | six   |   |  0
     | 6 | 6 | six   |   |   
     | 7 | 7 | seven | 0 |   
     | 7 | 7 | seven | 1 | -1
     | 7 | 7 | seven | 2 |  2
     | 7 | 7 | seven | 2 |  4
     | 7 | 7 | seven | 3 | -3
     | 7 | 7 | seven | 5 | -5
     | 7 | 7 | seven | 5 | -5
     | 7 | 7 | seven |   |  0
     | 7 | 7 | seven |   |   
     | 8 | 8 | eight | 0 |   
     | 8 | 8 | eight | 1 | -1
     | 8 | 8 | eight | 2 |  2
     | 8 | 8 | eight | 2 |  4
     | 8 | 8 | eight | 3 | -3
     | 8 | 8 | eight | 5 | -5
     | 8 | 8 | eight | 5 | -5
     | 8 | 8 | eight |   |  0
     | 8 | 8 | eight |   |   
     |   | 0 | zero  | 0 |   
     |   | 0 | zero  | 1 | -1
     |   | 0 | zero  | 2 |  2
     |   | 0 | zero  | 2 |  4
     |   | 0 | zero  | 3 | -3
     |   | 0 | zero  | 5 | -5
     |   | 0 | zero  | 5 | -5
     |   | 0 | zero  |   |  0
     |   | 0 | zero  |   |   
     |   |   | null  | 0 |   
     |   |   | null  | 1 | -1
     |   |   | null  | 2 |  2
     |   |   | null  | 2 |  4
     |   |   | null  | 3 | -3
     |   |   | null  | 5 | -5
     |   |   | null  | 5 | -5
     |   |   | null  |   |  0
     |   |   | null  |   |   
(99 rows)

-- ambiguous column
SELECT '' AS "xxx", i, k, t
  FROM J1_TBL CROSS JOIN J2_TBL;
ERROR:  column reference "i" is ambiguous
LINE 1: SELECT '' AS "xxx", i, k, t
                            ^
-- resolve previous ambiguity by specifying the table name
SELECT '' AS "xxx", t1.i, k, t
  FROM J1_TBL t1 CROSS JOIN J2_TBL t2
  ORDER BY i, k, t;
 xxx | i | k  |   t   
-----+---+----+-------
     | 0 | -5 | zero
     | 0 | -5 | zero
     | 0 | -3 | zero
     | 0 | -1 | zero
     | 0 |  0 | zero
     | 0 |  2 | zero
     | 0 |  4 | zero
     | 0 |    | zero
     | 0 |    | zero
     | 1 | -5 | one
     | 1 | -5 | one
     | 1 | -3 | one
     | 1 | -1 | one
     | 1 |  0 | one
     | 1 |  2 | one
     | 1 |  4 | one
     | 1 |    | one
     | 1 |    | one
     | 2 | -5 | two
     | 2 | -5 | two
     | 2 | -3 | two
     | 2 | -1 | two
     | 2 |  0 | two
     | 2 |  2 | two
     | 2 |  4 | two
     | 2 |    | two
     | 2 |    | two
     | 3 | -5 | three
     | 3 | -5 | three
     | 3 | -3 | three
     | 3 | -1 | three
     | 3 |  0 | three
     | 3 |  2 | three
     | 3 |  4 | three
     | 3 |    | three
     | 3 |    | three
     | 4 | -5 | four
     | 4 | -5 | four
     | 4 | -3 | four
     | 4 | -1 | four
     | 4 |  0 | four
     | 4 |  2 | four
     | 4 |  4 | four
     | 4 |    | four
     | 4 |    | four
     | 5 | -5 | five
     | 5 | -5 | five
     | 5 | -3 | five
     | 5 | -1 | five
     | 5 |  0 | five
     | 5 |  2 | five
     | 5 |  4 | five
     | 5 |    | five
     | 5 |    | five
     | 6 | -5 | six
     | 6 | -5 | six
     | 6 | -3 | six
     | 6 | -1 | six
     | 6 |  0 | six
     | 6 |  2 | six
     | 6 |  4 | six
     | 6 |    | six
     | 6 |    | six
     | 7 | -5 | seven
     | 7 | -5 | seven
     | 7 | -3 | seven
     | 7 | -1 | seven
     | 7 |  0 | seven
     | 7 |  2 | seven
     | 7 |  4 | seven
     | 7 |    | seven
     | 7 |    | seven
     | 8 | -5 | eight
     | 8 | -5 | eight
     | 8 | -3 | eight
     | 8 | -1 | eight
     | 8 |  0 | eight
     | 8 |  2 | eight
     | 8 |  4 | eight
     | 8 |    | eight
     | 8 |    | eight
     |   | -5 | null
     |   | -5 | null
     |   | -5 | zero
     |   | -5 | zero
     |   | -3 | null
     |   | -3 | zero
     |   | -1 | null
     |   | -1 | zero
     |   |  0 | null
     |   |  0 | zero
     |   |  2 | null
     |   |  2 | zero
     |   |  4 | null
     |   |  4 | zero
     |   |    | null
     |   |    | null
     |   |    | zero
     |   |    | zero
(99 rows)

SELECT '' AS "xxx", ii, tt, kk
  FROM (J1_TBL CROSS JOIN J2_TBL)
    AS tx (ii, jj, tt, ii2, kk)
    ORDER BY ii, tt, kk;
 xxx | ii |  tt   | kk 
-----+----+-------+----
     |  0 | zero  | -5
     |  0 | zero  | -5
     |  0 | zero  | -3
     |  0 | zero  | -1
     |  0 | zero  |  0
     |  0 | zero  |  2
     |  0 | zero  |  4
     |  0 | zero  |   
     |  0 | zero  |   
     |  1 | one   | -5
     |  1 | one   | -5
     |  1 | one   | -3
     |  1 | one   | -1
     |  1 | one   |  0
     |  1 | one   |  2
     |  1 | one   |  4
     |  1 | one   |   
     |  1 | one   |   
     |  2 | two   | -5
     |  2 | two   | -5
     |  2 | two   | -3
     |  2 | two   | -1
     |  2 | two   |  0
     |  2 | two   |  2
     |  2 | two   |  4
     |  2 | two   |   
     |  2 | two   |   
     |  3 | three | -5
     |  3 | three | -5
     |  3 | three | -3
     |  3 | three | -1
     |  3 | three |  0
     |  3 | three |  2
     |  3 | three |  4
     |  3 | three |   
     |  3 | three |   
     |  4 | four  | -5
     |  4 | four  | -5
     |  4 | four  | -3
     |  4 | four  | -1
     |  4 | four  |  0
     |  4 | four  |  2
     |  4 | four  |  4
     |  4 | four  |   
     |  4 | four  |   
     |  5 | five  | -5
     |  5 | five  | -5
     |  5 | five  | -3
     |  5 | five  | -1
     |  5 | five  |  0
     |  5 | five  |  2
     |  5 | five  |  4
     |  5 | five  |   
     |  5 | five  |   
     |  6 | six   | -5
     |  6 | six   | -5
     |  6 | six   | -3
     |  6 | six   | -1
     |  6 | six   |  0
     |  6 | six   |  2
     |  6 | six   |  4
     |  6 | six   |   
     |  6 | six   |   
     |  7 | seven | -5
     |  7 | seven | -5
     |  7 | seven | -3
     |  7 | seven | -1
     |  7 | seven |  0
     |  7 | seven |  2
     |  7 | seven |  4
     |  7 | seven |   
     |  7 | seven |   
     |  8 | eight | -5
     |  8 | eight | -5
     |  8 | eight | -3
     |  8 | eight | -1
     |  8 | eight |  0
     |  8 | eight |  2
     |  8 | eight |  4
     |  8 | eight |   
     |  8 | eight |   
     |    | null  | -5
     |    | null  | -5
     |    | null  | -3
     |    | null  | -1
     |    | null  |  0
     |    | null  |  2
     |    | null  |  4
     |    | null  |   
     |    | null  |   
     |    | zero  | -5
     |    | zero  | -5
     |    | zero  | -3
     |    | zero  | -1
     |    | zero  |  0
     |    | zero  |  2
     |    | zero  |  4
     |    | zero  |   
     |    | zero  |   
(99 rows)

SELECT '' AS "xxx", tx.ii, tx.jj, tx.kk
  FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))
    AS tx (ii, jj, tt, ii2, kk)
    ORDER BY ii, jj, kk;
 xxx | ii | jj | kk 
-----+----+----+----
     |  0 |    | -5
     |  0 |    | -5
     |  0 |    | -3
     |  0 |    | -1
     |  0 |    |  0
     |  0 |    |  2
     |  0 |    |  4
     |  0 |    |   
     |  0 |    |   
     |  1 |  4 | -5
     |  1 |  4 | -5
     |  1 |  4 | -3
     |  1 |  4 | -1
     |  1 |  4 |  0
     |  1 |  4 |  2
     |  1 |  4 |  4
     |  1 |  4 |   
     |  1 |  4 |   
     |  2 |  3 | -5
     |  2 |  3 | -5
     |  2 |  3 | -3
     |  2 |  3 | -1
     |  2 |  3 |  0
     |  2 |  3 |  2
     |  2 |  3 |  4
     |  2 |  3 |   
     |  2 |  3 |   
     |  3 |  2 | -5
     |  3 |  2 | -5
     |  3 |  2 | -3
     |  3 |  2 | -1
     |  3 |  2 |  0
     |  3 |  2 |  2
     |  3 |  2 |  4
     |  3 |  2 |   
     |  3 |  2 |   
     |  4 |  1 | -5
     |  4 |  1 | -5
     |  4 |  1 | -3
     |  4 |  1 | -1
     |  4 |  1 |  0
     |  4 |  1 |  2
     |  4 |  1 |  4
     |  4 |  1 |   
     |  4 |  1 |   
     |  5 |  0 | -5
     |  5 |  0 | -5
     |  5 |  0 | -3
     |  5 |  0 | -1
     |  5 |  0 |  0
     |  5 |  0 |  2
     |  5 |  0 |  4
     |  5 |  0 |   
     |  5 |  0 |   
     |  6 |  6 | -5
     |  6 |  6 | -5
     |  6 |  6 | -3
     |  6 |  6 | -1
     |  6 |  6 |  0
     |  6 |  6 |  2
     |  6 |  6 |  4
     |  6 |  6 |   
     |  6 |  6 |   
     |  7 |  7 | -5
     |  7 |  7 | -5
     |  7 |  7 | -3
     |  7 |  7 | -1
     |  7 |  7 |  0
     |  7 |  7 |  2
     |  7 |  7 |  4
     |  7 |  7 |   
     |  7 |  7 |   
     |  8 |  8 | -5
     |  8 |  8 | -5
     |  8 |  8 | -3
     |  8 |  8 | -1
     |  8 |  8 |  0
     |  8 |  8 |  2
     |  8 |  8 |  4
     |  8 |  8 |   
     |  8 |  8 |   
     |    |  0 | -5
     |    |  0 | -5
     |    |  0 | -3
     |    |  0 | -1
     |    |  0 |  0
     |    |  0 |  2
     |    |  0 |  4
     |    |  0 |   
     |    |  0 |   
     |    |    | -5
     |    |    | -5
     |    |    | -3
     |    |    | -1
     |    |    |  0
     |    |    |  2
     |    |    |  4
     |    |    |   
     |    |    |   
(99 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b
  ORDER BY J1_TBL.i,J1_TBL.j,J1_TBL.t,a.i,a.k,b.i,b.k;
 xxx | i | j |   t   | i | k  | i | k  
-----+---+---+-------+---+----+---+----
     | 0 |   | zero  | 0 |    | 0 |   
     | 0 |   | zero  | 0 |    | 1 | -1
     | 0 |   | zero  | 0 |    | 2 |  2
     | 0 |   | zero  | 0 |    | 2 |  4
     | 0 |   | zero  | 0 |    | 3 | -3
     | 0 |   | zero  | 0 |    | 5 | -5
     | 0 |   | zero  | 0 |    | 5 | -5
     | 0 |   | zero  | 0 |    |   |  0
     | 0 |   | zero  | 0 |    |   |   
     | 0 |   | zero  | 1 | -1 | 0 |   
     | 0 |   | zero  | 1 | -1 | 1 | -1
     | 0 |   | zero  | 1 | -1 | 2 |  2
     | 0 |   | zero  | 1 | -1 | 2 |  4
     | 0 |   | zero  | 1 | -1 | 3 | -3
     | 0 |   | zero  | 1 | -1 | 5 | -5
     | 0 |   | zero  | 1 | -1 | 5 | -5
     | 0 |   | zero  | 1 | -1 |   |  0
     | 0 |   | zero  | 1 | -1 |   |   
     | 0 |   | zero  | 2 |  2 | 0 |   
     | 0 |   | zero  | 2 |  2 | 1 | -1
     | 0 |   | zero  | 2 |  2 | 2 |  2
     | 0 |   | zero  | 2 |  2 | 2 |  4
     | 0 |   | zero  | 2 |  2 | 3 | -3
     | 0 |   | zero  | 2 |  2 | 5 | -5
     | 0 |   | zero  | 2 |  2 | 5 | -5
     | 0 |   | zero  | 2 |  2 |   |  0
     | 0 |   | zero  | 2 |  2 |   |   
     | 0 |   | zero  | 2 |  4 | 0 |   
     | 0 |   | zero  | 2 |  4 | 1 | -1
     | 0 |   | zero  | 2 |  4 | 2 |  2
     | 0 |   | zero  | 2 |  4 | 2 |  4
     | 0 |   | zero  | 2 |  4 | 3 | -3
     | 0 |   | zero  | 2 |  4 | 5 | -5
     | 0 |   | zero  | 2 |  4 | 5 | -5
     | 0 |   | zero  | 2 |  4 |   |  0
     | 0 |   | zero  | 2 |  4 |   |   
     | 0 |   | zero  | 3 | -3 | 0 |   
     | 0 |   | zero  | 3 | -3 | 1 | -1
     | 0 |   | zero  | 3 | -3 | 2 |  2
     | 0 |   | zero  | 3 | -3 | 2 |  4
     | 0 |   | zero  | 3 | -3 | 3 | -3
     | 0 |   | zero  | 3 | -3 | 5 | -5
     | 0 |   | zero  | 3 | -3 | 5 | -5
     | 0 |   | zero  | 3 | -3 |   |  0
     | 0 |   | zero  | 3 | -3 |   |   
     | 0 |   | zero  | 5 | -5 | 0 |   
     | 0 |   | zero  | 5 | -5 | 0 |   
     | 0 |   | zero  | 5 | -5 | 1 | -1
     | 0 |   | zero  | 5 | -5 | 1 | -1
     | 0 |   | zero  | 5 | -5 | 2 |  2
     | 0 |   | zero  | 5 | -5 | 2 |  2
     | 0 |   | zero  | 5 | -5 | 2 |  4
     | 0 |   | zero  | 5 | -5 | 2 |  4
     | 0 |   | zero  | 5 | -5 | 3 | -3
     | 0 |   | zero  | 5 | -5 | 3 | -3
     | 0 |   | zero  | 5 | -5 | 5 | -5
     | 0 |   | zero  | 5 | -5 | 5 | -5
     | 0 |   | zero  | 5 | -5 | 5 | -5
     | 0 |   | zero  | 5 | -5 | 5 | -5
     | 0 |   | zero  | 5 | -5 |   |  0
     | 0 |   | zero  | 5 | -5 |   |  0
     | 0 |   | zero  | 5 | -5 |   |   
     | 0 |   | zero  | 5 | -5 |   |   
     | 0 |   | zero  |   |  0 | 0 |   
     | 0 |   | zero  |   |  0 | 1 | -1
     | 0 |   | zero  |   |  0 | 2 |  2
     | 0 |   | zero  |   |  0 | 2 |  4
     | 0 |   | zero  |   |  0 | 3 | -3
     | 0 |   | zero  |   |  0 | 5 | -5
     | 0 |   | zero  |   |  0 | 5 | -5
     | 0 |   | zero  |   |  0 |   |  0
     | 0 |   | zero  |   |  0 |   |   
     | 0 |   | zero  |   |    | 0 |   
     | 0 |   | zero  |   |    | 1 | -1
     | 0 |   | zero  |   |    | 2 |  2
     | 0 |   | zero  |   |    | 2 |  4
     | 0 |   | zero  |   |    | 3 | -3
     | 0 |   | zero  |   |    | 5 | -5
     | 0 |   | zero  |   |    | 5 | -5
     | 0 |   | zero  |   |    |   |  0
     | 0 |   | zero  |   |    |   |   
     | 1 | 4 | one   | 0 |    | 0 |   
     | 1 | 4 | one   | 0 |    | 1 | -1
     | 1 | 4 | one   | 0 |    | 2 |  2
     | 1 | 4 | one   | 0 |    | 2 |  4
     | 1 | 4 | one   | 0 |    | 3 | -3
     | 1 | 4 | one   | 0 |    | 5 | -5
     | 1 | 4 | one   | 0 |    | 5 | -5
     | 1 | 4 | one   | 0 |    |   |  0
     | 1 | 4 | one   | 0 |    |   |   
     | 1 | 4 | one   | 1 | -1 | 0 |   
     | 1 | 4 | one   | 1 | -1 | 1 | -1
     | 1 | 4 | one   | 1 | -1 | 2 |  2
     | 1 | 4 | one   | 1 | -1 | 2 |  4
     | 1 | 4 | one   | 1 | -1 | 3 | -3
     | 1 | 4 | one   | 1 | -1 | 5 | -5
     | 1 | 4 | one   | 1 | -1 | 5 | -5
     | 1 | 4 | one   | 1 | -1 |   |  0
     | 1 | 4 | one   | 1 | -1 |   |   
     | 1 | 4 | one   | 2 |  2 | 0 |   
     | 1 | 4 | one   | 2 |  2 | 1 | -1
     | 1 | 4 | one   | 2 |  2 | 2 |  2
     | 1 | 4 | one   | 2 |  2 | 2 |  4
     | 1 | 4 | one   | 2 |  2 | 3 | -3
     | 1 | 4 | one   | 2 |  2 | 5 | -5
     | 1 | 4 | one   | 2 |  2 | 5 | -5
     | 1 | 4 | one   | 2 |  2 |   |  0
     | 1 | 4 | one   | 2 |  2 |   |   
     | 1 | 4 | one   | 2 |  4 | 0 |   
     | 1 | 4 | one   | 2 |  4 | 1 | -1
     | 1 | 4 | one   | 2 |  4 | 2 |  2
     | 1 | 4 | one   | 2 |  4 | 2 |  4
     | 1 | 4 | one   | 2 |  4 | 3 | -3
     | 1 | 4 | one   | 2 |  4 | 5 | -5
     | 1 | 4 | one   | 2 |  4 | 5 | -5
     | 1 | 4 | one   | 2 |  4 |   |  0
     | 1 | 4 | one   | 2 |  4 |   |   
     | 1 | 4 | one   | 3 | -3 | 0 |   
     | 1 | 4 | one   | 3 | -3 | 1 | -1
     | 1 | 4 | one   | 3 | -3 | 2 |  2
     | 1 | 4 | one   | 3 | -3 | 2 |  4
     | 1 | 4 | one   | 3 | -3 | 3 | -3
     | 1 | 4 | one   | 3 | -3 | 5 | -5
     | 1 | 4 | one   | 3 | -3 | 5 | -5
     | 1 | 4 | one   | 3 | -3 |   |  0
     | 1 | 4 | one   | 3 | -3 |   |   
     | 1 | 4 | one   | 5 | -5 | 0 |   
     | 1 | 4 | one   | 5 | -5 | 0 |   
     | 1 | 4 | one   | 5 | -5 | 1 | -1
     | 1 | 4 | one   | 5 | -5 | 1 | -1
     | 1 | 4 | one   | 5 | -5 | 2 |  2
     | 1 | 4 | one   | 5 | -5 | 2 |  2
     | 1 | 4 | one   | 5 | -5 | 2 |  4
     | 1 | 4 | one   | 5 | -5 | 2 |  4
     | 1 | 4 | one   | 5 | -5 | 3 | -3
     | 1 | 4 | one   | 5 | -5 | 3 | -3
     | 1 | 4 | one   | 5 | -5 | 5 | -5
     | 1 | 4 | one   | 5 | -5 | 5 | -5
     | 1 | 4 | one   | 5 | -5 | 5 | -5
     | 1 | 4 | one   | 5 | -5 | 5 | -5
     | 1 | 4 | one   | 5 | -5 |   |  0
     | 1 | 4 | one   | 5 | -5 |   |  0
     | 1 | 4 | one   | 5 | -5 |   |   
     | 1 | 4 | one   | 5 | -5 |   |   
     | 1 | 4 | one   |   |  0 | 0 |   
     | 1 | 4 | one   |   |  0 | 1 | -1
     | 1 | 4 | one   |   |  0 | 2 |  2
     | 1 | 4 | one   |   |  0 | 2 |  4
     | 1 | 4 | one   |   |  0 | 3 | -3
     | 1 | 4 | one   |   |  0 | 5 | -5
     | 1 | 4 | one   |   |  0 | 5 | -5
     | 1 | 4 | one   |   |  0 |   |  0
     | 1 | 4 | one   |   |  0 |   |   
     | 1 | 4 | one   |   |    | 0 |   
     | 1 | 4 | one   |   |    | 1 | -1
     | 1 | 4 | one   |   |    | 2 |  2
     | 1 | 4 | one   |   |    | 2 |  4
     | 1 | 4 | one   |   |    | 3 | -3
     | 1 | 4 | one   |   |    | 5 | -5
     | 1 | 4 | one   |   |    | 5 | -5
     | 1 | 4 | one   |   |    |   |  0
     | 1 | 4 | one   |   |    |   |   
     | 2 | 3 | two   | 0 |    | 0 |   
     | 2 | 3 | two   | 0 |    | 1 | -1
     | 2 | 3 | two   | 0 |    | 2 |  2
     | 2 | 3 | two   | 0 |    | 2 |  4
     | 2 | 3 | two   | 0 |    | 3 | -3
     | 2 | 3 | two   | 0 |    | 5 | -5
     | 2 | 3 | two   | 0 |    | 5 | -5
     | 2 | 3 | two   | 0 |    |   |  0
     | 2 | 3 | two   | 0 |    |   |   
     | 2 | 3 | two   | 1 | -1 | 0 |   
     | 2 | 3 | two   | 1 | -1 | 1 | -1
     | 2 | 3 | two   | 1 | -1 | 2 |  2
     | 2 | 3 | two   | 1 | -1 | 2 |  4
     | 2 | 3 | two   | 1 | -1 | 3 | -3
     | 2 | 3 | two   | 1 | -1 | 5 | -5
     | 2 | 3 | two   | 1 | -1 | 5 | -5
     | 2 | 3 | two   | 1 | -1 |   |  0
     | 2 | 3 | two   | 1 | -1 |   |   
     | 2 | 3 | two   | 2 |  2 | 0 |   
     | 2 | 3 | two   | 2 |  2 | 1 | -1
     | 2 | 3 | two   | 2 |  2 | 2 |  2
     | 2 | 3 | two   | 2 |  2 | 2 |  4
     | 2 | 3 | two   | 2 |  2 | 3 | -3
     | 2 | 3 | two   | 2 |  2 | 5 | -5
     | 2 | 3 | two   | 2 |  2 | 5 | -5
     | 2 | 3 | two   | 2 |  2 |   |  0
     | 2 | 3 | two   | 2 |  2 |   |   
     | 2 | 3 | two   | 2 |  4 | 0 |   
     | 2 | 3 | two   | 2 |  4 | 1 | -1
     | 2 | 3 | two   | 2 |  4 | 2 |  2
     | 2 | 3 | two   | 2 |  4 | 2 |  4
     | 2 | 3 | two   | 2 |  4 | 3 | -3
     | 2 | 3 | two   | 2 |  4 | 5 | -5
     | 2 | 3 | two   | 2 |  4 | 5 | -5
     | 2 | 3 | two   | 2 |  4 |   |  0
     | 2 | 3 | two   | 2 |  4 |   |   
     | 2 | 3 | two   | 3 | -3 | 0 |   
     | 2 | 3 | two   | 3 | -3 | 1 | -1
     | 2 | 3 | two   | 3 | -3 | 2 |  2
     | 2 | 3 | two   | 3 | -3 | 2 |  4
     | 2 | 3 | two   | 3 | -3 | 3 | -3
     | 2 | 3 | two   | 3 | -3 | 5 | -5
     | 2 | 3 | two   | 3 | -3 | 5 | -5
     | 2 | 3 | two   | 3 | -3 |   |  0
     | 2 | 3 | two   | 3 | -3 |   |   
     | 2 | 3 | two   | 5 | -5 | 0 |   
     | 2 | 3 | two   | 5 | -5 | 0 |   
     | 2 | 3 | two   | 5 | -5 | 1 | -1
     | 2 | 3 | two   | 5 | -5 | 1 | -1
     | 2 | 3 | two   | 5 | -5 | 2 |  2
     | 2 | 3 | two   | 5 | -5 | 2 |  2
     | 2 | 3 | two   | 5 | -5 | 2 |  4
     | 2 | 3 | two   | 5 | -5 | 2 |  4
     | 2 | 3 | two   | 5 | -5 | 3 | -3
     | 2 | 3 | two   | 5 | -5 | 3 | -3
     | 2 | 3 | two   | 5 | -5 | 5 | -5
     | 2 | 3 | two   | 5 | -5 | 5 | -5
     | 2 | 3 | two   | 5 | -5 | 5 | -5
     | 2 | 3 | two   | 5 | -5 | 5 | -5
     | 2 | 3 | two   | 5 | -5 |   |  0
     | 2 | 3 | two   | 5 | -5 |   |  0
     | 2 | 3 | two   | 5 | -5 |   |   
     | 2 | 3 | two   | 5 | -5 |   |   
     | 2 | 3 | two   |   |  0 | 0 |   
     | 2 | 3 | two   |   |  0 | 1 | -1
     | 2 | 3 | two   |   |  0 | 2 |  2
     | 2 | 3 | two   |   |  0 | 2 |  4
     | 2 | 3 | two   |   |  0 | 3 | -3
     | 2 | 3 | two   |   |  0 | 5 | -5
     | 2 | 3 | two   |   |  0 | 5 | -5
     | 2 | 3 | two   |   |  0 |   |  0
     | 2 | 3 | two   |   |  0 |   |   
     | 2 | 3 | two   |   |    | 0 |   
     | 2 | 3 | two   |   |    | 1 | -1
     | 2 | 3 | two   |   |    | 2 |  2
     | 2 | 3 | two   |   |    | 2 |  4
     | 2 | 3 | two   |   |    | 3 | -3
     | 2 | 3 | two   |   |    | 5 | -5
     | 2 | 3 | two   |   |    | 5 | -5
     | 2 | 3 | two   |   |    |   |  0
     | 2 | 3 | two   |   |    |   |   
     | 3 | 2 | three | 0 |    | 0 |   
     | 3 | 2 | three | 0 |    | 1 | -1
     | 3 | 2 | three | 0 |    | 2 |  2
     | 3 | 2 | three | 0 |    | 2 |  4
     | 3 | 2 | three | 0 |    | 3 | -3
     | 3 | 2 | three | 0 |    | 5 | -5
     | 3 | 2 | three | 0 |    | 5 | -5
     | 3 | 2 | three | 0 |    |   |  0
     | 3 | 2 | three | 0 |    |   |   
     | 3 | 2 | three | 1 | -1 | 0 |   
     | 3 | 2 | three | 1 | -1 | 1 | -1
     | 3 | 2 | three | 1 | -1 | 2 |  2
     | 3 | 2 | three | 1 | -1 | 2 |  4
     | 3 | 2 | three | 1 | -1 | 3 | -3
     | 3 | 2 | three | 1 | -1 | 5 | -5
     | 3 | 2 | three | 1 | -1 | 5 | -5
     | 3 | 2 | three | 1 | -1 |   |  0
     | 3 | 2 | three | 1 | -1 |   |   
     | 3 | 2 | three | 2 |  2 | 0 |   
     | 3 | 2 | three | 2 |  2 | 1 | -1
     | 3 | 2 | three | 2 |  2 | 2 |  2
     | 3 | 2 | three | 2 |  2 | 2 |  4
     | 3 | 2 | three | 2 |  2 | 3 | -3
     | 3 | 2 | three | 2 |  2 | 5 | -5
     | 3 | 2 | three | 2 |  2 | 5 | -5
     | 3 | 2 | three | 2 |  2 |   |  0
     | 3 | 2 | three | 2 |  2 |   |   
     | 3 | 2 | three | 2 |  4 | 0 |   
     | 3 | 2 | three | 2 |  4 | 1 | -1
     | 3 | 2 | three | 2 |  4 | 2 |  2
     | 3 | 2 | three | 2 |  4 | 2 |  4
     | 3 | 2 | three | 2 |  4 | 3 | -3
     | 3 | 2 | three | 2 |  4 | 5 | -5
     | 3 | 2 | three | 2 |  4 | 5 | -5
     | 3 | 2 | three | 2 |  4 |   |  0
     | 3 | 2 | three | 2 |  4 |   |   
     | 3 | 2 | three | 3 | -3 | 0 |   
     | 3 | 2 | three | 3 | -3 | 1 | -1
     | 3 | 2 | three | 3 | -3 | 2 |  2
     | 3 | 2 | three | 3 | -3 | 2 |  4
     | 3 | 2 | three | 3 | -3 | 3 | -3
     | 3 | 2 | three | 3 | -3 | 5 | -5
     | 3 | 2 | three | 3 | -3 | 5 | -5
     | 3 | 2 | three | 3 | -3 |   |  0
     | 3 | 2 | three | 3 | -3 |   |   
     | 3 | 2 | three | 5 | -5 | 0 |   
     | 3 | 2 | three | 5 | -5 | 0 |   
     | 3 | 2 | three | 5 | -5 | 1 | -1
     | 3 | 2 | three | 5 | -5 | 1 | -1
     | 3 | 2 | three | 5 | -5 | 2 |  2
     | 3 | 2 | three | 5 | -5 | 2 |  2
     | 3 | 2 | three | 5 | -5 | 2 |  4
     | 3 | 2 | three | 5 | -5 | 2 |  4
     | 3 | 2 | three | 5 | -5 | 3 | -3
     | 3 | 2 | three | 5 | -5 | 3 | -3
     | 3 | 2 | three | 5 | -5 | 5 | -5
     | 3 | 2 | three | 5 | -5 | 5 | -5
     | 3 | 2 | three | 5 | -5 | 5 | -5
     | 3 | 2 | three | 5 | -5 | 5 | -5
     | 3 | 2 | three | 5 | -5 |   |  0
     | 3 | 2 | three | 5 | -5 |   |  0
     | 3 | 2 | three | 5 | -5 |   |   
     | 3 | 2 | three | 5 | -5 |   |   
     | 3 | 2 | three |   |  0 | 0 |   
     | 3 | 2 | three |   |  0 | 1 | -1
     | 3 | 2 | three |   |  0 | 2 |  2
     | 3 | 2 | three |   |  0 | 2 |  4
     | 3 | 2 | three |   |  0 | 3 | -3
     | 3 | 2 | three |   |  0 | 5 | -5
     | 3 | 2 | three |   |  0 | 5 | -5
     | 3 | 2 | three |   |  0 |   |  0
     | 3 | 2 | three |   |  0 |   |   
     | 3 | 2 | three |   |    | 0 |   
     | 3 | 2 | three |   |    | 1 | -1
     | 3 | 2 | three |   |    | 2 |  2
     | 3 | 2 | three |   |    | 2 |  4
     | 3 | 2 | three |   |    | 3 | -3
     | 3 | 2 | three |   |    | 5 | -5
     | 3 | 2 | three |   |    | 5 | -5
     | 3 | 2 | three |   |    |   |  0
     | 3 | 2 | three |   |    |   |   
     | 4 | 1 | four  | 0 |    | 0 |   
     | 4 | 1 | four  | 0 |    | 1 | -1
     | 4 | 1 | four  | 0 |    | 2 |  2
     | 4 | 1 | four  | 0 |    | 2 |  4
     | 4 | 1 | four  | 0 |    | 3 | -3
     | 4 | 1 | four  | 0 |    | 5 | -5
     | 4 | 1 | four  | 0 |    | 5 | -5
     | 4 | 1 | four  | 0 |    |   |  0
     | 4 | 1 | four  | 0 |    |   |   
     | 4 | 1 | four  | 1 | -1 | 0 |   
     | 4 | 1 | four  | 1 | -1 | 1 | -1
     | 4 | 1 | four  | 1 | -1 | 2 |  2
     | 4 | 1 | four  | 1 | -1 | 2 |  4
     | 4 | 1 | four  | 1 | -1 | 3 | -3
     | 4 | 1 | four  | 1 | -1 | 5 | -5
     | 4 | 1 | four  | 1 | -1 | 5 | -5
     | 4 | 1 | four  | 1 | -1 |   |  0
     | 4 | 1 | four  | 1 | -1 |   |   
     | 4 | 1 | four  | 2 |  2 | 0 |   
     | 4 | 1 | four  | 2 |  2 | 1 | -1
     | 4 | 1 | four  | 2 |  2 | 2 |  2
     | 4 | 1 | four  | 2 |  2 | 2 |  4
     | 4 | 1 | four  | 2 |  2 | 3 | -3
     | 4 | 1 | four  | 2 |  2 | 5 | -5
     | 4 | 1 | four  | 2 |  2 | 5 | -5
     | 4 | 1 | four  | 2 |  2 |   |  0
     | 4 | 1 | four  | 2 |  2 |   |   
     | 4 | 1 | four  | 2 |  4 | 0 |   
     | 4 | 1 | four  | 2 |  4 | 1 | -1
     | 4 | 1 | four  | 2 |  4 | 2 |  2
     | 4 | 1 | four  | 2 |  4 | 2 |  4
     | 4 | 1 | four  | 2 |  4 | 3 | -3
     | 4 | 1 | four  | 2 |  4 | 5 | -5
     | 4 | 1 | four  | 2 |  4 | 5 | -5
     | 4 | 1 | four  | 2 |  4 |   |  0
     | 4 | 1 | four  | 2 |  4 |   |   
     | 4 | 1 | four  | 3 | -3 | 0 |   
     | 4 | 1 | four  | 3 | -3 | 1 | -1
     | 4 | 1 | four  | 3 | -3 | 2 |  2
     | 4 | 1 | four  | 3 | -3 | 2 |  4
     | 4 | 1 | four  | 3 | -3 | 3 | -3
     | 4 | 1 | four  | 3 | -3 | 5 | -5
     | 4 | 1 | four  | 3 | -3 | 5 | -5
     | 4 | 1 | four  | 3 | -3 |   |  0
     | 4 | 1 | four  | 3 | -3 |   |   
     | 4 | 1 | four  | 5 | -5 | 0 |   
     | 4 | 1 | four  | 5 | -5 | 0 |   
     | 4 | 1 | four  | 5 | -5 | 1 | -1
     | 4 | 1 | four  | 5 | -5 | 1 | -1
     | 4 | 1 | four  | 5 | -5 | 2 |  2
     | 4 | 1 | four  | 5 | -5 | 2 |  2
     | 4 | 1 | four  | 5 | -5 | 2 |  4
     | 4 | 1 | four  | 5 | -5 | 2 |  4
     | 4 | 1 | four  | 5 | -5 | 3 | -3
     | 4 | 1 | four  | 5 | -5 | 3 | -3
     | 4 | 1 | four  | 5 | -5 | 5 | -5
     | 4 | 1 | four  | 5 | -5 | 5 | -5
     | 4 | 1 | four  | 5 | -5 | 5 | -5
     | 4 | 1 | four  | 5 | -5 | 5 | -5
     | 4 | 1 | four  | 5 | -5 |   |  0
     | 4 | 1 | four  | 5 | -5 |   |  0
     | 4 | 1 | four  | 5 | -5 |   |   
     | 4 | 1 | four  | 5 | -5 |   |   
     | 4 | 1 | four  |   |  0 | 0 |   
     | 4 | 1 | four  |   |  0 | 1 | -1
     | 4 | 1 | four  |   |  0 | 2 |  2
     | 4 | 1 | four  |   |  0 | 2 |  4
     | 4 | 1 | four  |   |  0 | 3 | -3
     | 4 | 1 | four  |   |  0 | 5 | -5
     | 4 | 1 | four  |   |  0 | 5 | -5
     | 4 | 1 | four  |   |  0 |   |  0
     | 4 | 1 | four  |   |  0 |   |   
     | 4 | 1 | four  |   |    | 0 |   
     | 4 | 1 | four  |   |    | 1 | -1
     | 4 | 1 | four  |   |    | 2 |  2
     | 4 | 1 | four  |   |    | 2 |  4
     | 4 | 1 | four  |   |    | 3 | -3
     | 4 | 1 | four  |   |    | 5 | -5
     | 4 | 1 | four  |   |    | 5 | -5
     | 4 | 1 | four  |   |    |   |  0
     | 4 | 1 | four  |   |    |   |   
     | 5 | 0 | five  | 0 |    | 0 |   
     | 5 | 0 | five  | 0 |    | 1 | -1
     | 5 | 0 | five  | 0 |    | 2 |  2
     | 5 | 0 | five  | 0 |    | 2 |  4
     | 5 | 0 | five  | 0 |    | 3 | -3
     | 5 | 0 | five  | 0 |    | 5 | -5
     | 5 | 0 | five  | 0 |    | 5 | -5
     | 5 | 0 | five  | 0 |    |   |  0
     | 5 | 0 | five  | 0 |    |   |   
     | 5 | 0 | five  | 1 | -1 | 0 |   
     | 5 | 0 | five  | 1 | -1 | 1 | -1
     | 5 | 0 | five  | 1 | -1 | 2 |  2
     | 5 | 0 | five  | 1 | -1 | 2 |  4
     | 5 | 0 | five  | 1 | -1 | 3 | -3
     | 5 | 0 | five  | 1 | -1 | 5 | -5
     | 5 | 0 | five  | 1 | -1 | 5 | -5
     | 5 | 0 | five  | 1 | -1 |   |  0
     | 5 | 0 | five  | 1 | -1 |   |   
     | 5 | 0 | five  | 2 |  2 | 0 |   
     | 5 | 0 | five  | 2 |  2 | 1 | -1
     | 5 | 0 | five  | 2 |  2 | 2 |  2
     | 5 | 0 | five  | 2 |  2 | 2 |  4
     | 5 | 0 | five  | 2 |  2 | 3 | -3
     | 5 | 0 | five  | 2 |  2 | 5 | -5
     | 5 | 0 | five  | 2 |  2 | 5 | -5
     | 5 | 0 | five  | 2 |  2 |   |  0
     | 5 | 0 | five  | 2 |  2 |   |   
     | 5 | 0 | five  | 2 |  4 | 0 |   
     | 5 | 0 | five  | 2 |  4 | 1 | -1
     | 5 | 0 | five  | 2 |  4 | 2 |  2
     | 5 | 0 | five  | 2 |  4 | 2 |  4
     | 5 | 0 | five  | 2 |  4 | 3 | -3
     | 5 | 0 | five  | 2 |  4 | 5 | -5
     | 5 | 0 | five  | 2 |  4 | 5 | -5
     | 5 | 0 | five  | 2 |  4 |   |  0
     | 5 | 0 | five  | 2 |  4 |   |   
     | 5 | 0 | five  | 3 | -3 | 0 |   
     | 5 | 0 | five  | 3 | -3 | 1 | -1
     | 5 | 0 | five  | 3 | -3 | 2 |  2
     | 5 | 0 | five  | 3 | -3 | 2 |  4
     | 5 | 0 | five  | 3 | -3 | 3 | -3
     | 5 | 0 | five  | 3 | -3 | 5 | -5
     | 5 | 0 | five  | 3 | -3 | 5 | -5
     | 5 | 0 | five  | 3 | -3 |   |  0
     | 5 | 0 | five  | 3 | -3 |   |   
     | 5 | 0 | five  | 5 | -5 | 0 |   
     | 5 | 0 | five  | 5 | -5 | 0 |   
     | 5 | 0 | five  | 5 | -5 | 1 | -1
     | 5 | 0 | five  | 5 | -5 | 1 | -1
     | 5 | 0 | five  | 5 | -5 | 2 |  2
     | 5 | 0 | five  | 5 | -5 | 2 |  2
     | 5 | 0 | five  | 5 | -5 | 2 |  4
     | 5 | 0 | five  | 5 | -5 | 2 |  4
     | 5 | 0 | five  | 5 | -5 | 3 | -3
     | 5 | 0 | five  | 5 | -5 | 3 | -3
     | 5 | 0 | five  | 5 | -5 | 5 | -5
     | 5 | 0 | five  | 5 | -5 | 5 | -5
     | 5 | 0 | five  | 5 | -5 | 5 | -5
     | 5 | 0 | five  | 5 | -5 | 5 | -5
     | 5 | 0 | five  | 5 | -5 |   |  0
     | 5 | 0 | five  | 5 | -5 |   |  0
     | 5 | 0 | five  | 5 | -5 |   |   
     | 5 | 0 | five  | 5 | -5 |   |   
     | 5 | 0 | five  |   |  0 | 0 |   
     | 5 | 0 | five  |   |  0 | 1 | -1
     | 5 | 0 | five  |   |  0 | 2 |  2
     | 5 | 0 | five  |   |  0 | 2 |  4
     | 5 | 0 | five  |   |  0 | 3 | -3
     | 5 | 0 | five  |   |  0 | 5 | -5
     | 5 | 0 | five  |   |  0 | 5 | -5
     | 5 | 0 | five  |   |  0 |   |  0
     | 5 | 0 | five  |   |  0 |   |   
     | 5 | 0 | five  |   |    | 0 |   
     | 5 | 0 | five  |   |    | 1 | -1
     | 5 | 0 | five  |   |    | 2 |  2
     | 5 | 0 | five  |   |    | 2 |  4
     | 5 | 0 | five  |   |    | 3 | -3
     | 5 | 0 | five  |   |    | 5 | -5
     | 5 | 0 | five  |   |    | 5 | -5
     | 5 | 0 | five  |   |    |   |  0
     | 5 | 0 | five  |   |    |   |   
     | 6 | 6 | six   | 0 |    | 0 |   
     | 6 | 6 | six   | 0 |    | 1 | -1
     | 6 | 6 | six   | 0 |    | 2 |  2
     | 6 | 6 | six   | 0 |    | 2 |  4
     | 6 | 6 | six   | 0 |    | 3 | -3
     | 6 | 6 | six   | 0 |    | 5 | -5
     | 6 | 6 | six   | 0 |    | 5 | -5
     | 6 | 6 | six   | 0 |    |   |  0
     | 6 | 6 | six   | 0 |    |   |   
     | 6 | 6 | six   | 1 | -1 | 0 |   
     | 6 | 6 | six   | 1 | -1 | 1 | -1
     | 6 | 6 | six   | 1 | -1 | 2 |  2
     | 6 | 6 | six   | 1 | -1 | 2 |  4
     | 6 | 6 | six   | 1 | -1 | 3 | -3
     | 6 | 6 | six   | 1 | -1 | 5 | -5
     | 6 | 6 | six   | 1 | -1 | 5 | -5
     | 6 | 6 | six   | 1 | -1 |   |  0
     | 6 | 6 | six   | 1 | -1 |   |   
     | 6 | 6 | six   | 2 |  2 | 0 |   
     | 6 | 6 | six   | 2 |  2 | 1 | -1
     | 6 | 6 | six   | 2 |  2 | 2 |  2
     | 6 | 6 | six   | 2 |  2 | 2 |  4
     | 6 | 6 | six   | 2 |  2 | 3 | -3
     | 6 | 6 | six   | 2 |  2 | 5 | -5
     | 6 | 6 | six   | 2 |  2 | 5 | -5
     | 6 | 6 | six   | 2 |  2 |   |  0
     | 6 | 6 | six   | 2 |  2 |   |   
     | 6 | 6 | six   | 2 |  4 | 0 |   
     | 6 | 6 | six   | 2 |  4 | 1 | -1
     | 6 | 6 | six   | 2 |  4 | 2 |  2
     | 6 | 6 | six   | 2 |  4 | 2 |  4
     | 6 | 6 | six   | 2 |  4 | 3 | -3
     | 6 | 6 | six   | 2 |  4 | 5 | -5
     | 6 | 6 | six   | 2 |  4 | 5 | -5
     | 6 | 6 | six   | 2 |  4 |   |  0
     | 6 | 6 | six   | 2 |  4 |   |   
     | 6 | 6 | six   | 3 | -3 | 0 |   
     | 6 | 6 | six   | 3 | -3 | 1 | -1
     | 6 | 6 | six   | 3 | -3 | 2 |  2
     | 6 | 6 | six   | 3 | -3 | 2 |  4
     | 6 | 6 | six   | 3 | -3 | 3 | -3
     | 6 | 6 | six   | 3 | -3 | 5 | -5
     | 6 | 6 | six   | 3 | -3 | 5 | -5
     | 6 | 6 | six   | 3 | -3 |   |  0
     | 6 | 6 | six   | 3 | -3 |   |   
     | 6 | 6 | six   | 5 | -5 | 0 |   
     | 6 | 6 | six   | 5 | -5 | 0 |   
     | 6 | 6 | six   | 5 | -5 | 1 | -1
     | 6 | 6 | six   | 5 | -5 | 1 | -1
     | 6 | 6 | six   | 5 | -5 | 2 |  2
     | 6 | 6 | six   | 5 | -5 | 2 |  2
     | 6 | 6 | six   | 5 | -5 | 2 |  4
     | 6 | 6 | six   | 5 | -5 | 2 |  4
     | 6 | 6 | six   | 5 | -5 | 3 | -3
     | 6 | 6 | six   | 5 | -5 | 3 | -3
     | 6 | 6 | six   | 5 | -5 | 5 | -5
     | 6 | 6 | six   | 5 | -5 | 5 | -5
     | 6 | 6 | six   | 5 | -5 | 5 | -5
     | 6 | 6 | six   | 5 | -5 | 5 | -5
     | 6 | 6 | six   | 5 | -5 |   |  0
     | 6 | 6 | six   | 5 | -5 |   |  0
     | 6 | 6 | six   | 5 | -5 |   |   
     | 6 | 6 | six   | 5 | -5 |   |   
     | 6 | 6 | six   |   |  0 | 0 |   
     | 6 | 6 | six   |   |  0 | 1 | -1
     | 6 | 6 | six   |   |  0 | 2 |  2
     | 6 | 6 | six   |   |  0 | 2 |  4
     | 6 | 6 | six   |   |  0 | 3 | -3
     | 6 | 6 | six   |   |  0 | 5 | -5
     | 6 | 6 | six   |   |  0 | 5 | -5
     | 6 | 6 | six   |   |  0 |   |  0
     | 6 | 6 | six   |   |  0 |   |   
     | 6 | 6 | six   |   |    | 0 |   
     | 6 | 6 | six   |   |    | 1 | -1
     | 6 | 6 | six   |   |    | 2 |  2
     | 6 | 6 | six   |   |    | 2 |  4
     | 6 | 6 | six   |   |    | 3 | -3
     | 6 | 6 | six   |   |    | 5 | -5
     | 6 | 6 | six   |   |    | 5 | -5
     | 6 | 6 | six   |   |    |   |  0
     | 6 | 6 | six   |   |    |   |   
     | 7 | 7 | seven | 0 |    | 0 |   
     | 7 | 7 | seven | 0 |    | 1 | -1
     | 7 | 7 | seven | 0 |    | 2 |  2
     | 7 | 7 | seven | 0 |    | 2 |  4
     | 7 | 7 | seven | 0 |    | 3 | -3
     | 7 | 7 | seven | 0 |    | 5 | -5
     | 7 | 7 | seven | 0 |    | 5 | -5
     | 7 | 7 | seven | 0 |    |   |  0
     | 7 | 7 | seven | 0 |    |   |   
     | 7 | 7 | seven | 1 | -1 | 0 |   
     | 7 | 7 | seven | 1 | -1 | 1 | -1
     | 7 | 7 | seven | 1 | -1 | 2 |  2
     | 7 | 7 | seven | 1 | -1 | 2 |  4
     | 7 | 7 | seven | 1 | -1 | 3 | -3
     | 7 | 7 | seven | 1 | -1 | 5 | -5
     | 7 | 7 | seven | 1 | -1 | 5 | -5
     | 7 | 7 | seven | 1 | -1 |   |  0
     | 7 | 7 | seven | 1 | -1 |   |   
     | 7 | 7 | seven | 2 |  2 | 0 |   
     | 7 | 7 | seven | 2 |  2 | 1 | -1
     | 7 | 7 | seven | 2 |  2 | 2 |  2
     | 7 | 7 | seven | 2 |  2 | 2 |  4
     | 7 | 7 | seven | 2 |  2 | 3 | -3
     | 7 | 7 | seven | 2 |  2 | 5 | -5
     | 7 | 7 | seven | 2 |  2 | 5 | -5
     | 7 | 7 | seven | 2 |  2 |   |  0
     | 7 | 7 | seven | 2 |  2 |   |   
     | 7 | 7 | seven | 2 |  4 | 0 |   
     | 7 | 7 | seven | 2 |  4 | 1 | -1
     | 7 | 7 | seven | 2 |  4 | 2 |  2
     | 7 | 7 | seven | 2 |  4 | 2 |  4
     | 7 | 7 | seven | 2 |  4 | 3 | -3
     | 7 | 7 | seven | 2 |  4 | 5 | -5
     | 7 | 7 | seven | 2 |  4 | 5 | -5
     | 7 | 7 | seven | 2 |  4 |   |  0
     | 7 | 7 | seven | 2 |  4 |   |   
     | 7 | 7 | seven | 3 | -3 | 0 |   
     | 7 | 7 | seven | 3 | -3 | 1 | -1
     | 7 | 7 | seven | 3 | -3 | 2 |  2
     | 7 | 7 | seven | 3 | -3 | 2 |  4
     | 7 | 7 | seven | 3 | -3 | 3 | -3
     | 7 | 7 | seven | 3 | -3 | 5 | -5
     | 7 | 7 | seven | 3 | -3 | 5 | -5
     | 7 | 7 | seven | 3 | -3 |   |  0
     | 7 | 7 | seven | 3 | -3 |   |   
     | 7 | 7 | seven | 5 | -5 | 0 |   
     | 7 | 7 | seven | 5 | -5 | 0 |   
     | 7 | 7 | seven | 5 | -5 | 1 | -1
     | 7 | 7 | seven | 5 | -5 | 1 | -1
     | 7 | 7 | seven | 5 | -5 | 2 |  2
     | 7 | 7 | seven | 5 | -5 | 2 |  2
     | 7 | 7 | seven | 5 | -5 | 2 |  4
     | 7 | 7 | seven | 5 | -5 | 2 |  4
     | 7 | 7 | seven | 5 | -5 | 3 | -3
     | 7 | 7 | seven | 5 | -5 | 3 | -3
     | 7 | 7 | seven | 5 | -5 | 5 | -5
     | 7 | 7 | seven | 5 | -5 | 5 | -5
     | 7 | 7 | seven | 5 | -5 | 5 | -5
     | 7 | 7 | seven | 5 | -5 | 5 | -5
     | 7 | 7 | seven | 5 | -5 |   |  0
     | 7 | 7 | seven | 5 | -5 |   |  0
     | 7 | 7 | seven | 5 | -5 |   |   
     | 7 | 7 | seven | 5 | -5 |   |   
     | 7 | 7 | seven |   |  0 | 0 |   
     | 7 | 7 | seven |   |  0 | 1 | -1
     | 7 | 7 | seven |   |  0 | 2 |  2
     | 7 | 7 | seven |   |  0 | 2 |  4
     | 7 | 7 | seven |   |  0 | 3 | -3
     | 7 | 7 | seven |   |  0 | 5 | -5
     | 7 | 7 | seven |   |  0 | 5 | -5
     | 7 | 7 | seven |   |  0 |   |  0
     | 7 | 7 | seven |   |  0 |   |   
     | 7 | 7 | seven |   |    | 0 |   
     | 7 | 7 | seven |   |    | 1 | -1
     | 7 | 7 | seven |   |    | 2 |  2
     | 7 | 7 | seven |   |    | 2 |  4
     | 7 | 7 | seven |   |    | 3 | -3
     | 7 | 7 | seven |   |    | 5 | -5
     | 7 | 7 | seven |   |    | 5 | -5
     | 7 | 7 | seven |   |    |   |  0
     | 7 | 7 | seven |   |    |   |   
     | 8 | 8 | eight | 0 |    | 0 |   
     | 8 | 8 | eight | 0 |    | 1 | -1
     | 8 | 8 | eight | 0 |    | 2 |  2
     | 8 | 8 | eight | 0 |    | 2 |  4
     | 8 | 8 | eight | 0 |    | 3 | -3
     | 8 | 8 | eight | 0 |    | 5 | -5
     | 8 | 8 | eight | 0 |    | 5 | -5
     | 8 | 8 | eight | 0 |    |   |  0
     | 8 | 8 | eight | 0 |    |   |   
     | 8 | 8 | eight | 1 | -1 | 0 |   
     | 8 | 8 | eight | 1 | -1 | 1 | -1
     | 8 | 8 | eight | 1 | -1 | 2 |  2
     | 8 | 8 | eight | 1 | -1 | 2 |  4
     | 8 | 8 | eight | 1 | -1 | 3 | -3
     | 8 | 8 | eight | 1 | -1 | 5 | -5
     | 8 | 8 | eight | 1 | -1 | 5 | -5
     | 8 | 8 | eight | 1 | -1 |   |  0
     | 8 | 8 | eight | 1 | -1 |   |   
     | 8 | 8 | eight | 2 |  2 | 0 |   
     | 8 | 8 | eight | 2 |  2 | 1 | -1
     | 8 | 8 | eight | 2 |  2 | 2 |  2
     | 8 | 8 | eight | 2 |  2 | 2 |  4
     | 8 | 8 | eight | 2 |  2 | 3 | -3
     | 8 | 8 | eight | 2 |  2 | 5 | -5
     | 8 | 8 | eight | 2 |  2 | 5 | -5
     | 8 | 8 | eight | 2 |  2 |   |  0
     | 8 | 8 | eight | 2 |  2 |   |   
     | 8 | 8 | eight | 2 |  4 | 0 |   
     | 8 | 8 | eight | 2 |  4 | 1 | -1
     | 8 | 8 | eight | 2 |  4 | 2 |  2
     | 8 | 8 | eight | 2 |  4 | 2 |  4
     | 8 | 8 | eight | 2 |  4 | 3 | -3
     | 8 | 8 | eight | 2 |  4 | 5 | -5
     | 8 | 8 | eight | 2 |  4 | 5 | -5
     | 8 | 8 | eight | 2 |  4 |   |  0
     | 8 | 8 | eight | 2 |  4 |   |   
     | 8 | 8 | eight | 3 | -3 | 0 |   
     | 8 | 8 | eight | 3 | -3 | 1 | -1
     | 8 | 8 | eight | 3 | -3 | 2 |  2
     | 8 | 8 | eight | 3 | -3 | 2 |  4
     | 8 | 8 | eight | 3 | -3 | 3 | -3
     | 8 | 8 | eight | 3 | -3 | 5 | -5
     | 8 | 8 | eight | 3 | -3 | 5 | -5
     | 8 | 8 | eight | 3 | -3 |   |  0
     | 8 | 8 | eight | 3 | -3 |   |   
     | 8 | 8 | eight | 5 | -5 | 0 |   
     | 8 | 8 | eight | 5 | -5 | 0 |   
     | 8 | 8 | eight | 5 | -5 | 1 | -1
     | 8 | 8 | eight | 5 | -5 | 1 | -1
     | 8 | 8 | eight | 5 | -5 | 2 |  2
     | 8 | 8 | eight | 5 | -5 | 2 |  2
     | 8 | 8 | eight | 5 | -5 | 2 |  4
     | 8 | 8 | eight | 5 | -5 | 2 |  4
     | 8 | 8 | eight | 5 | -5 | 3 | -3
     | 8 | 8 | eight | 5 | -5 | 3 | -3
     | 8 | 8 | eight | 5 | -5 | 5 | -5
     | 8 | 8 | eight | 5 | -5 | 5 | -5
     | 8 | 8 | eight | 5 | -5 | 5 | -5
     | 8 | 8 | eight | 5 | -5 | 5 | -5
     | 8 | 8 | eight | 5 | -5 |   |  0
     | 8 | 8 | eight | 5 | -5 |   |  0
     | 8 | 8 | eight | 5 | -5 |   |   
     | 8 | 8 | eight | 5 | -5 |   |   
     | 8 | 8 | eight |   |  0 | 0 |   
     | 8 | 8 | eight |   |  0 | 1 | -1
     | 8 | 8 | eight |   |  0 | 2 |  2
     | 8 | 8 | eight |   |  0 | 2 |  4
     | 8 | 8 | eight |   |  0 | 3 | -3
     | 8 | 8 | eight |   |  0 | 5 | -5
     | 8 | 8 | eight |   |  0 | 5 | -5
     | 8 | 8 | eight |   |  0 |   |  0
     | 8 | 8 | eight |   |  0 |   |   
     | 8 | 8 | eight |   |    | 0 |   
     | 8 | 8 | eight |   |    | 1 | -1
     | 8 | 8 | eight |   |    | 2 |  2
     | 8 | 8 | eight |   |    | 2 |  4
     | 8 | 8 | eight |   |    | 3 | -3
     | 8 | 8 | eight |   |    | 5 | -5
     | 8 | 8 | eight |   |    | 5 | -5
     | 8 | 8 | eight |   |    |   |  0
     | 8 | 8 | eight |   |    |   |   
     |   | 0 | zero  | 0 |    | 0 |   
     |   | 0 | zero  | 0 |    | 1 | -1
     |   | 0 | zero  | 0 |    | 2 |  2
     |   | 0 | zero  | 0 |    | 2 |  4
     |   | 0 | zero  | 0 |    | 3 | -3
     |   | 0 | zero  | 0 |    | 5 | -5
     |   | 0 | zero  | 0 |    | 5 | -5
     |   | 0 | zero  | 0 |    |   |  0
     |   | 0 | zero  | 0 |    |   |   
     |   | 0 | zero  | 1 | -1 | 0 |   
     |   | 0 | zero  | 1 | -1 | 1 | -1
     |   | 0 | zero  | 1 | -1 | 2 |  2
     |   | 0 | zero  | 1 | -1 | 2 |  4
     |   | 0 | zero  | 1 | -1 | 3 | -3
     |   | 0 | zero  | 1 | -1 | 5 | -5
     |   | 0 | zero  | 1 | -1 | 5 | -5
     |   | 0 | zero  | 1 | -1 |   |  0
     |   | 0 | zero  | 1 | -1 |   |   
     |   | 0 | zero  | 2 |  2 | 0 |   
     |   | 0 | zero  | 2 |  2 | 1 | -1
     |   | 0 | zero  | 2 |  2 | 2 |  2
     |   | 0 | zero  | 2 |  2 | 2 |  4
     |   | 0 | zero  | 2 |  2 | 3 | -3
     |   | 0 | zero  | 2 |  2 | 5 | -5
     |   | 0 | zero  | 2 |  2 | 5 | -5
     |   | 0 | zero  | 2 |  2 |   |  0
     |   | 0 | zero  | 2 |  2 |   |   
     |   | 0 | zero  | 2 |  4 | 0 |   
     |   | 0 | zero  | 2 |  4 | 1 | -1
     |   | 0 | zero  | 2 |  4 | 2 |  2
     |   | 0 | zero  | 2 |  4 | 2 |  4
     |   | 0 | zero  | 2 |  4 | 3 | -3
     |   | 0 | zero  | 2 |  4 | 5 | -5
     |   | 0 | zero  | 2 |  4 | 5 | -5
     |   | 0 | zero  | 2 |  4 |   |  0
     |   | 0 | zero  | 2 |  4 |   |   
     |   | 0 | zero  | 3 | -3 | 0 |   
     |   | 0 | zero  | 3 | -3 | 1 | -1
     |   | 0 | zero  | 3 | -3 | 2 |  2
     |   | 0 | zero  | 3 | -3 | 2 |  4
     |   | 0 | zero  | 3 | -3 | 3 | -3
     |   | 0 | zero  | 3 | -3 | 5 | -5
     |   | 0 | zero  | 3 | -3 | 5 | -5
     |   | 0 | zero  | 3 | -3 |   |  0
     |   | 0 | zero  | 3 | -3 |   |   
     |   | 0 | zero  | 5 | -5 | 0 |   
     |   | 0 | zero  | 5 | -5 | 0 |   
     |   | 0 | zero  | 5 | -5 | 1 | -1
     |   | 0 | zero  | 5 | -5 | 1 | -1
     |   | 0 | zero  | 5 | -5 | 2 |  2
     |   | 0 | zero  | 5 | -5 | 2 |  2
     |   | 0 | zero  | 5 | -5 | 2 |  4
     |   | 0 | zero  | 5 | -5 | 2 |  4
     |   | 0 | zero  | 5 | -5 | 3 | -3
     |   | 0 | zero  | 5 | -5 | 3 | -3
     |   | 0 | zero  | 5 | -5 | 5 | -5
     |   | 0 | zero  | 5 | -5 | 5 | -5
     |   | 0 | zero  | 5 | -5 | 5 | -5
     |   | 0 | zero  | 5 | -5 | 5 | -5
     |   | 0 | zero  | 5 | -5 |   |  0
     |   | 0 | zero  | 5 | -5 |   |  0
     |   | 0 | zero  | 5 | -5 |   |   
     |   | 0 | zero  | 5 | -5 |   |   
     |   | 0 | zero  |   |  0 | 0 |   
     |   | 0 | zero  |   |  0 | 1 | -1
     |   | 0 | zero  |   |  0 | 2 |  2
     |   | 0 | zero  |   |  0 | 2 |  4
     |   | 0 | zero  |   |  0 | 3 | -3
     |   | 0 | zero  |   |  0 | 5 | -5
     |   | 0 | zero  |   |  0 | 5 | -5
     |   | 0 | zero  |   |  0 |   |  0
     |   | 0 | zero  |   |  0 |   |   
     |   | 0 | zero  |   |    | 0 |   
     |   | 0 | zero  |   |    | 1 | -1
     |   | 0 | zero  |   |    | 2 |  2
     |   | 0 | zero  |   |    | 2 |  4
     |   | 0 | zero  |   |    | 3 | -3
     |   | 0 | zero  |   |    | 5 | -5
     |   | 0 | zero  |   |    | 5 | -5
     |   | 0 | zero  |   |    |   |  0
     |   | 0 | zero  |   |    |   |   
     |   |   | null  | 0 |    | 0 |   
     |   |   | null  | 0 |    | 1 | -1
     |   |   | null  | 0 |    | 2 |  2
     |   |   | null  | 0 |    | 2 |  4
     |   |   | null  | 0 |    | 3 | -3
     |   |   | null  | 0 |    | 5 | -5
     |   |   | null  | 0 |    | 5 | -5
     |   |   | null  | 0 |    |   |  0
     |   |   | null  | 0 |    |   |   
     |   |   | null  | 1 | -1 | 0 |   
     |   |   | null  | 1 | -1 | 1 | -1
     |   |   | null  | 1 | -1 | 2 |  2
     |   |   | null  | 1 | -1 | 2 |  4
     |   |   | null  | 1 | -1 | 3 | -3
     |   |   | null  | 1 | -1 | 5 | -5
     |   |   | null  | 1 | -1 | 5 | -5
     |   |   | null  | 1 | -1 |   |  0
     |   |   | null  | 1 | -1 |   |   
     |   |   | null  | 2 |  2 | 0 |   
     |   |   | null  | 2 |  2 | 1 | -1
     |   |   | null  | 2 |  2 | 2 |  2
     |   |   | null  | 2 |  2 | 2 |  4
     |   |   | null  | 2 |  2 | 3 | -3
     |   |   | null  | 2 |  2 | 5 | -5
     |   |   | null  | 2 |  2 | 5 | -5
     |   |   | null  | 2 |  2 |   |  0
     |   |   | null  | 2 |  2 |   |   
     |   |   | null  | 2 |  4 | 0 |   
     |   |   | null  | 2 |  4 | 1 | -1
     |   |   | null  | 2 |  4 | 2 |  2
     |   |   | null  | 2 |  4 | 2 |  4
     |   |   | null  | 2 |  4 | 3 | -3
     |   |   | null  | 2 |  4 | 5 | -5
     |   |   | null  | 2 |  4 | 5 | -5
     |   |   | null  | 2 |  4 |   |  0
     |   |   | null  | 2 |  4 |   |   
     |   |   | null  | 3 | -3 | 0 |   
     |   |   | null  | 3 | -3 | 1 | -1
     |   |   | null  | 3 | -3 | 2 |  2
     |   |   | null  | 3 | -3 | 2 |  4
     |   |   | null  | 3 | -3 | 3 | -3
     |   |   | null  | 3 | -3 | 5 | -5
     |   |   | null  | 3 | -3 | 5 | -5
     |   |   | null  | 3 | -3 |   |  0
     |   |   | null  | 3 | -3 |   |   
     |   |   | null  | 5 | -5 | 0 |   
     |   |   | null  | 5 | -5 | 0 |   
     |   |   | null  | 5 | -5 | 1 | -1
     |   |   | null  | 5 | -5 | 1 | -1
     |   |   | null  | 5 | -5 | 2 |  2
     |   |   | null  | 5 | -5 | 2 |  2
     |   |   | null  | 5 | -5 | 2 |  4
     |   |   | null  | 5 | -5 | 2 |  4
     |   |   | null  | 5 | -5 | 3 | -3
     |   |   | null  | 5 | -5 | 3 | -3
     |   |   | null  | 5 | -5 | 5 | -5
     |   |   | null  | 5 | -5 | 5 | -5
     |   |   | null  | 5 | -5 | 5 | -5
     |   |   | null  | 5 | -5 | 5 | -5
     |   |   | null  | 5 | -5 |   |  0
     |   |   | null  | 5 | -5 |   |  0
     |   |   | null  | 5 | -5 |   |   
     |   |   | null  | 5 | -5 |   |   
     |   |   | null  |   |  0 | 0 |   
     |   |   | null  |   |  0 | 1 | -1
     |   |   | null  |   |  0 | 2 |  2
     |   |   | null  |   |  0 | 2 |  4
     |   |   | null  |   |  0 | 3 | -3
     |   |   | null  |   |  0 | 5 | -5
     |   |   | null  |   |  0 | 5 | -5
     |   |   | null  |   |  0 |   |  0
     |   |   | null  |   |  0 |   |   
     |   |   | null  |   |    | 0 |   
     |   |   | null  |   |    | 1 | -1
     |   |   | null  |   |    | 2 |  2
     |   |   | null  |   |    | 2 |  4
     |   |   | null  |   |    | 3 | -3
     |   |   | null  |   |    | 5 | -5
     |   |   | null  |   |    | 5 | -5
     |   |   | null  |   |    |   |  0
     |   |   | null  |   |    |   |   
(891 rows)

--
--
-- Inner joins (equi-joins)
--
--
--
-- Inner joins (equi-joins) with USING clause
-- The USING syntax changes the shape of the resulting table
-- by including a column in the USING clause only once in the result.
--
-- Inner equi-join on specified column
SELECT '' AS "xxx", *
  FROM J1_TBL INNER JOIN J2_TBL USING (i)
  ORDER BY i, j, k, t;
 xxx | i | j |   t   | k  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
(7 rows)

-- Same as above, slightly different syntax
SELECT '' AS "xxx", *
  FROM J1_TBL JOIN J2_TBL USING (i)
  ORDER BY i, j, k, t;
 xxx | i | j |   t   | k  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
(7 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)
  ORDER BY a, d;
 xxx | a | b |   c   | d  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
(7 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)
  ORDER BY b, t1.a;
 xxx | b | a |   c   | a 
-----+---+---+-------+---
     | 0 | 5 | five  |  
     | 0 |   | zero  |  
     | 2 | 3 | three | 2
     | 4 | 1 | one   | 2
(4 rows)

--
-- NATURAL JOIN
-- Inner equi-join on all columns with the same name
--
SELECT '' AS "xxx", *
  FROM J1_TBL NATURAL JOIN J2_TBL
  ORDER BY i, j, k, t;
 xxx | i | j |   t   | k  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
(7 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d)
  ORDER BY a, b, c, d;
 xxx | a | b |   c   | d  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
(7 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a)
  ORDER BY a, b, c, d;
 xxx | a | b |  c   | d 
-----+---+---+------+---
     | 0 |   | zero |  
     | 2 | 3 | two  | 2
     | 4 | 1 | four | 2
(3 rows)

-- mismatch number of columns
-- currently, Postgres will fill in with underlying names
SELECT '' AS "xxx", *
  FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a)
  ORDER BY a, b, t, k;
 xxx | a | b |   t   | k  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
(7 rows)

--
-- Inner joins (equi-joins)
--
SELECT '' AS "xxx", *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i)
  ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k;
 xxx | i | j |   t   | i | k  
-----+---+---+-------+---+----
     | 0 |   | zero  | 0 |   
     | 1 | 4 | one   | 1 | -1
     | 2 | 3 | two   | 2 |  2
     | 2 | 3 | two   | 2 |  4
     | 3 | 2 | three | 3 | -3
     | 5 | 0 | five  | 5 | -5
     | 5 | 0 | five  | 5 | -5
(7 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k)
  ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k;
 xxx | i | j |  t   | i | k 
-----+---+---+------+---+---
     | 0 |   | zero |   | 0
     | 2 | 3 | two  | 2 | 2
     | 4 | 1 | four | 2 | 4
(3 rows)

--
-- Non-equi-joins
--
SELECT '' AS "xxx", *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k)
  ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k;
 xxx | i | j |   t   | i | k 
-----+---+---+-------+---+---
     | 0 |   | zero  | 2 | 2
     | 0 |   | zero  | 2 | 4
     | 0 |   | zero  |   | 0
     | 1 | 4 | one   | 2 | 2
     | 1 | 4 | one   | 2 | 4
     | 2 | 3 | two   | 2 | 2
     | 2 | 3 | two   | 2 | 4
     | 3 | 2 | three | 2 | 4
     | 4 | 1 | four  | 2 | 4
(9 rows)

--
-- Outer joins
-- Note that OUTER is a noise word
--
SELECT '' AS "xxx", *
  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 xxx | i | j |   t   | k  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 4 | 1 | four  |   
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
     | 6 | 6 | six   |   
     | 7 | 7 | seven |   
     | 8 | 8 | eight |   
     |   |   | null  |   
     |   | 0 | zero  |   
(13 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 xxx | i | j |   t   | k  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 4 | 1 | four  |   
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
     | 6 | 6 | six   |   
     | 7 | 7 | seven |   
     | 8 | 8 | eight |   
     |   |   | null  |   
     |   | 0 | zero  |   
(13 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i)
  ORDER BY i, j, k, t;
 xxx | i | j |   t   | k  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
     |   |   |       |  0
     |   |   |       |   
(9 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL RIGHT JOIN J2_TBL USING (i)
  ORDER BY i, j, k, t;
 xxx | i | j |   t   | k  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
     |   |   |       |  0
     |   |   |       |   
(9 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 xxx | i | j |   t   | k  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 4 | 1 | four  |   
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
     | 6 | 6 | six   |   
     | 7 | 7 | seven |   
     | 8 | 8 | eight |   
     |   |   |       |  0
     |   |   | null  |   
     |   | 0 | zero  |   
     |   |   |       |   
(15 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL FULL JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 xxx | i | j |   t   | k  
-----+---+---+-------+----
     | 0 |   | zero  |   
     | 1 | 4 | one   | -1
     | 2 | 3 | two   |  2
     | 2 | 3 | two   |  4
     | 3 | 2 | three | -3
     | 4 | 1 | four  |   
     | 5 | 0 | five  | -5
     | 5 | 0 | five  | -5
     | 6 | 6 | six   |   
     | 7 | 7 | seven |   
     | 8 | 8 | eight |   
     |   |   |       |  0
     |   |   | null  |   
     |   | 0 | zero  |   
     |   |   |       |   
(15 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);
 xxx | i | j | t | k 
-----+---+---+---+---
(0 rows)

SELECT '' AS "xxx", *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);
 xxx | i | j |  t  | k  
-----+---+---+-----+----
     | 1 | 4 | one | -1
(1 row)

--
-- semijoin selectivity for <>
--
explain (costs off)
select * from int4_tbl i4, tenk1 a
where exists(select * from tenk1 b
             where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)
      and i4.f1 = a.tenthous;
                         QUERY PLAN                          
-------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Right Semi Join
         Hash Cond: (b.twothousand = a.twothousand)
         Join Filter: (a.fivethous <> b.fivethous)
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: twothousand
               ->  Seq Scan on tenk1 b
         ->  Hash
               ->  Remote Subquery Scan on all (datanodes 2)
                     Distribute results by S: twothousand
                     ->  Hash Join
                           Hash Cond: (a.tenthous = i4.f1)
                           ->  Seq Scan on tenk1 a
                           ->  Hash
                                 ->  Seq Scan on int4_tbl i4
(15 rows)

--
-- More complicated constructs
--
--
-- Multiway full join
--
CREATE TABLE join_20231120_t1 (name TEXT, n INTEGER);
CREATE TABLE join_20231120_t2 (name TEXT, n INTEGER);
CREATE TABLE join_20231120_t3 (name TEXT, n INTEGER);
INSERT INTO join_20231120_t1 VALUES ( 'bb', 11 );
INSERT INTO join_20231120_t2 VALUES ( 'bb', 12 );
INSERT INTO join_20231120_t2 VALUES ( 'cc', 22 );
INSERT INTO join_20231120_t2 VALUES ( 'ee', 42 );
INSERT INTO join_20231120_t3 VALUES ( 'bb', 13 );
INSERT INTO join_20231120_t3 VALUES ( 'cc', 23 );
INSERT INTO join_20231120_t3 VALUES ( 'dd', 33 );
SELECT * FROM join_20231120_t1 FULL JOIN join_20231120_t2 USING (name) FULL JOIN join_20231120_t3 USING (name)
ORDER BY name,join_20231120_t1.n, join_20231120_t2.n, join_20231120_t3.n;
 name | n  | n  | n  
------+----+----+----
 bb   | 11 | 12 | 13
 cc   |    | 22 | 23
 dd   |    |    | 33
 ee   |    | 42 |   
(4 rows)

--
-- Test interactions of join syntax and subqueries
--
-- Basic cases (we expect planner to pull up the subquery here)
SELECT * FROM
(SELECT * FROM join_20231120_t2) as s2
INNER JOIN
(SELECT * FROM join_20231120_t3) s3
USING (name)
ORDER BY name, s2.n, s3.n;
 name | n  | n  
------+----+----
 bb   | 12 | 13
 cc   | 22 | 23
(2 rows)

SELECT * FROM
(SELECT * FROM join_20231120_t2) as s2
LEFT JOIN
(SELECT * FROM join_20231120_t3) s3
USING (name)
ORDER BY name, s2.n, s3.n;
 name | n  | n  
------+----+----
 bb   | 12 | 13
 cc   | 22 | 23
 ee   | 42 |   
(3 rows)

SELECT * FROM
(SELECT * FROM join_20231120_t2) as s2
FULL JOIN
(SELECT * FROM join_20231120_t3) s3
USING (name)
ORDER BY name, s2.n, s3.n;
 name | n  | n  
------+----+----
 bb   | 12 | 13
 cc   | 22 | 23
 dd   |    | 33
 ee   | 42 |   
(4 rows)

-- Cases with non-nullable expressions in subquery results;
-- make sure these go to null as expected
SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM join_20231120_t2) as s2
NATURAL INNER JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM join_20231120_t3) s3
ORDER BY name, s2_n, s3_n;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 bb   |   12 |    2 |   13 |    3
 cc   |   22 |    2 |   23 |    3
(2 rows)

SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM join_20231120_t2) as s2
NATURAL LEFT JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM join_20231120_t3) s3
ORDER BY name, s2_n, s3_n;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 bb   |   12 |    2 |   13 |    3
 cc   |   22 |    2 |   23 |    3
 ee   |   42 |    2 |      |     
(3 rows)

SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM join_20231120_t2) as s2
NATURAL FULL JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM join_20231120_t3) s3
ORDER BY name, s2_n, s3_n;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 bb   |   12 |    2 |   13 |    3
 cc   |   22 |    2 |   23 |    3
 dd   |      |      |   33 |    3
 ee   |   42 |    2 |      |     
(4 rows)

SELECT * FROM
(SELECT name, n as s1_n, 1 as s1_1 FROM join_20231120_t1) as s1
NATURAL INNER JOIN
(SELECT name, n as s2_n, 2 as s2_2 FROM join_20231120_t2) as s2
NATURAL INNER JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM join_20231120_t3) s3
ORDER BY name, s1_n, s2_n, s3_n;
 name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------+------+------
 bb   |   11 |    1 |   12 |    2 |   13 |    3
(1 row)

SELECT * FROM
(SELECT name, n as s1_n, 1 as s1_1 FROM join_20231120_t1) as s1
NATURAL FULL JOIN
(SELECT name, n as s2_n, 2 as s2_2 FROM join_20231120_t2) as s2
NATURAL FULL JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM join_20231120_t3) s3
ORDER BY name, s1_n, s2_n, s3_n;
 name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------+------+------
 bb   |   11 |    1 |   12 |    2 |   13 |    3
 cc   |      |      |   22 |    2 |   23 |    3
 dd   |      |      |      |      |   33 |    3
 ee   |      |      |   42 |    2 |      |     
(4 rows)

SELECT * FROM
(SELECT name, n as s1_n FROM join_20231120_t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT name, n as s2_n FROM join_20231120_t2) as s2
    NATURAL FULL JOIN
    (SELECT name, n as s3_n FROM join_20231120_t3) as s3
  ) ss2
  ORDER BY name, s1_n, s2_n, s3_n;
 name | s1_n | s2_n | s3_n 
------+------+------+------
 bb   |   11 |   12 |   13
 cc   |      |   22 |   23
 dd   |      |      |   33
 ee   |      |   42 |     
(4 rows)

SELECT * FROM
(SELECT name, n as s1_n FROM join_20231120_t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT name, n as s2_n, 2 as s2_2 FROM join_20231120_t2) as s2
    NATURAL FULL JOIN
    (SELECT name, n as s3_n FROM join_20231120_t3) as s3
  ) ss2
  ORDER BY name, s1_n, s2_n, s3_n;
 name | s1_n | s2_n | s2_2 | s3_n 
------+------+------+------+------
 bb   |   11 |   12 |    2 |   13
 cc   |      |   22 |    2 |   23
 dd   |      |      |      |   33
 ee   |      |   42 |    2 |     
(4 rows)

-- Constants as join keys can also be problematic
SELECT * FROM
  (SELECT name, n as s1_n FROM join_20231120_t1) as s1
FULL JOIN
  (SELECT name, 2 as s2_n FROM join_20231120_t2) as s2
ON (s1_n = s2_n) ORDER BY 1,2,3,4;
 name | s1_n | name | s2_n 
------+------+------+------
 bb   |   11 |      |     
      |      | bb   |    2
      |      | cc   |    2
      |      | ee   |    2
(4 rows)

-- Test for propagation of nullability constraints into sub-joins
create temp table x (x1 int, x2 int);
insert into x values (1,11);
insert into x values (2,22);
insert into x values (3,null);
insert into x values (4,44);
insert into x values (5,null);
create temp table y (y1 int, y2 int);
insert into y values (1,111);
insert into y values (2,222);
insert into y values (3,333);
insert into y values (4,null);
select * from x ORDER BY x1;
 x1 | x2 
----+----
  1 | 11
  2 | 22
  3 |   
  4 | 44
  5 |   
(5 rows)

select * from y ORDER BY y1;
 y1 | y2  
----+-----
  1 | 111
  2 | 222
  3 | 333
  4 |    
(4 rows)

select * from x left join y on (x1 = y1 and x2 is not null) ORDER BY x1, x2, y1, y2;
 x1 | x2 | y1 | y2  
----+----+----+-----
  1 | 11 |  1 | 111
  2 | 22 |  2 | 222
  3 |    |    |    
  4 | 44 |  4 |    
  5 |    |    |    
(5 rows)

select * from x left join y on (x1 = y1 and y2 is not null) ORDER BY x1, x2, y1, y2;
 x1 | x2 | y1 | y2  
----+----+----+-----
  1 | 11 |  1 | 111
  2 | 22 |  2 | 222
  3 |    |  3 | 333
  4 | 44 |    |    
  5 |    |    |    
(5 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1) ORDER BY x1, x2, y1, y2;
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |   3 |    
  4 | 44 |  4 |     |   4 |  44
  5 |    |    |     |   5 |    
(5 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1 and x2 is not null) ORDER BY x1, x2, y1, y2;
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |     |    
  4 | 44 |  4 |     |   4 |  44
  5 |    |    |     |     |    
(5 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1 and y2 is not null) ORDER BY x1, x2, y1, y2;
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |   3 |    
  4 | 44 |  4 |     |     |    
  5 |    |    |     |     |    
(5 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1 and xx2 is not null) ORDER BY x1, x2, y1, y2;
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |     |    
  4 | 44 |  4 |     |   4 |  44
  5 |    |    |     |     |    
(5 rows)

-- these should NOT give the same answers as above
select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1) where (x2 is not null)
ORDER BY x1, x2, y1, y2;
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  4 | 44 |  4 |     |   4 |  44
(3 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1) where (y2 is not null)
ORDER BY x1, x2, y1, y2;
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  3 |    |  3 | 333 |   3 |    
(3 rows)

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1) where (xx2 is not null)
ORDER BY x1, x2, y1, y2;
 x1 | x2 | y1 | y2  | xx1 | xx2 
----+----+----+-----+-----+-----
  1 | 11 |  1 | 111 |   1 |  11
  2 | 22 |  2 | 222 |   2 |  22
  4 | 44 |  4 |     |   4 |  44
(3 rows)

--
-- regression test: check for bug with propagation of implied equality
-- to outside an IN
--
select count(*) from tenk1 a where unique1 in
  (select unique1 from tenk1 b join tenk1 c using (unique1)
   where b.unique2 = 42);
 count 
-------
     1
(1 row)

--
-- regression test: check for failure to generate a plan with multiple
-- degenerate IN clauses
--
select count(*) from tenk1 x where
  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
  x.unique1 = 0 and
  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
 count 
-------
     1
(1 row)

-- try that with GEQO too
begin;
set geqo = on;
set geqo_threshold = 2;
select count(*) from tenk1 x where
  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
  x.unique1 = 0 and
  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
 count 
-------
     1
(1 row)

rollback;
--
-- regression test: be sure we cope with proven-dummy append rels
--
explain (costs off)
select aa, bb, unique1, unique1
  from tenk1 right join b on aa = unique1
  where bb < bb and bb is null;
                QUERY PLAN                 
-------------------------------------------
 Remote Subquery Scan on all (datanodes 1)
   ->  Result
         One-Time Filter: false
(3 rows)

select aa, bb, unique1, unique1
  from tenk1 right join b on aa = unique1
  where bb < bb and bb is null;
 aa | bb | unique1 | unique1 
----+----+---------+---------
(0 rows)

--
-- regression test: check handling of empty-FROM subquery underneath outer join
--
explain (costs off)
select * from int8_tbl i1 left join (int8_tbl i2 join
  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
order by 1, 2;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Sort
   Sort Key: i1.q1, i1.q2
   ->  Hash Left Join
         Hash Cond: (i1.q2 = i2.q2)
         ->  Remote Subquery Scan on all (datanodes 1)
               ->  Seq Scan on int8_tbl i1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (i2.q1 = (123))
                     ->  Remote Subquery Scan on all (datanodes 1)
                           ->  Seq Scan on int8_tbl i2
                     ->  Hash
                           ->  Result
(13 rows)

select * from int8_tbl i1 left join (int8_tbl i2 join
  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
order by 1, 2;
        q1        |        q2         | q1  |        q2        |  x  
------------------+-------------------+-----+------------------+-----
              123 |               456 | 123 |              456 | 123
              123 |  4567890123456789 | 123 | 4567890123456789 | 123
 4567890123456789 | -4567890123456789 |     |                  |    
 4567890123456789 |               123 |     |                  |    
 4567890123456789 |  4567890123456789 | 123 | 4567890123456789 | 123
(5 rows)

--
-- regression test: check a case where join_clause_is_movable_into() gives
-- an imprecise result, causing an assertion failure
--
select count(*)
from
  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2
   from tenk1 t1
   left join tenk1 t2 on t1.unique1 = t2.unique1
   join tenk1 t3 on t1.unique2 = t3.unique2) ss,
  tenk1 t4,
  tenk1 t5
where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;
 count 
-------
  1000
(1 row)

--
-- regression test: check a case where we formerly missed including an EC
-- enforcement clause because it was expected to be handled at scan level
--
explain (costs off)
select a.f1, b.f1, t.thousand, t.tenthous from
  tenk1 t,
  (select sum(f1)+1 as f1 from int4_tbl i4a) a,
  (select sum(f1) as f1 from int4_tbl i4b) b
where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Nested Loop
         ->  Aggregate
               ->  Seq Scan on int4_tbl i4b
         ->  Nested Loop
               Join Filter: ((sum(i4b.f1)) = ((sum(i4a.f1) + 1)))
               ->  Aggregate
                     ->  Seq Scan on int4_tbl i4a
               ->  Index Only Scan using tenk1_thous_tenthous on tenk1 t
                     Index Cond: ((thousand = (sum(i4b.f1))) AND (tenthous = ((((sum(i4a.f1) + 1)) + (sum(i4b.f1))) + 999)))
(11 rows)

select a.f1, b.f1, t.thousand, t.tenthous from
  tenk1 t,
  (select sum(f1)+1 as f1 from int4_tbl i4a) a,
  (select sum(f1) as f1 from int4_tbl i4b) b
where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
 f1 | f1 | thousand | tenthous 
----+----+----------+----------
(0 rows)

--
-- Clean up
--
DROP TABLE join_20231120_t1;
DROP TABLE join_20231120_t2;
DROP TABLE join_20231120_t3;
DROP TABLE J1_TBL;
DROP TABLE J2_TBL;
-- Both DELETE and UPDATE allow the specification of additional tables
-- to "join" against to determine which rows should be modified.
CREATE TEMP TABLE t1 (a int, b int);
CREATE TEMP TABLE t2 (a int, b int);
CREATE TEMP TABLE t3 (x int, y int);
INSERT INTO t1 VALUES (5, 10);
INSERT INTO t1 VALUES (15, 20);
INSERT INTO t1 VALUES (100, 100);
INSERT INTO t1 VALUES (200, 1000);
INSERT INTO t2 VALUES (200, 2000);
INSERT INTO t3 VALUES (5, 20);
INSERT INTO t3 VALUES (6, 7);
INSERT INTO t3 VALUES (7, 8);
INSERT INTO t3 VALUES (500, 100);
DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;
SELECT * FROM t3 ORDER By x, y;
  x  |  y  
-----+-----
   6 |   7
   7 |   8
 500 | 100
(3 rows)

DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;
SELECT * FROM t3 ORDER By x, y;
 x | y 
---+---
 6 | 7
 7 | 8
(2 rows)

DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;
SELECT * FROM t3 ORDER By x, y;
 x | y 
---+---
(0 rows)

-- Test join against inheritance tree
create temp table t2a () inherits (t2);
insert into t2a values (200, 2001);
select * from t1 left join t2 on (t1.a = t2.a) order by 1,2,3,4;
  a  |  b   |  a  |  b   
-----+------+-----+------
   5 |   10 |     |     
  15 |   20 |     |     
 100 |  100 |     |     
 200 | 1000 | 200 | 2000
 200 | 1000 | 200 | 2001
(5 rows)

-- Test matching of column name with wrong alias
select t1.x from t1 join t3 on (t1.a = t3.x);
ERROR:  column t1.x does not exist
LINE 1: select t1.x from t1 join t3 on (t1.a = t3.x);
               ^
HINT:  Perhaps you meant to reference the column "t3.x".
--
-- regression test for 8.1 merge right join bug
--
CREATE TEMP TABLE tt1 ( tt1_id int4, joincol int4 );
INSERT INTO tt1 VALUES (1, 11);
INSERT INTO tt1 VALUES (2, NULL);
CREATE TEMP TABLE tt2 ( tt2_id int4, joincol int4 );
INSERT INTO tt2 VALUES (21, 11);
INSERT INTO tt2 VALUES (22, 11);
set enable_hashjoin to off;
set enable_nestloop to off;
-- these should give the same results
select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol 
      ORDER BY tt1_id, tt2_id; 
 tt1_id | joincol | tt2_id | joincol 
--------+---------+--------+---------
      1 |      11 |     21 |      11
      1 |      11 |     22 |      11
      2 |         |        |        
(3 rows)

select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol 
      ORDER BY tt1_id, tt2_id; 
 tt1_id | joincol | tt2_id | joincol 
--------+---------+--------+---------
      1 |      11 |     21 |      11
      1 |      11 |     22 |      11
      2 |         |        |        
(3 rows)

reset enable_hashjoin;
reset enable_nestloop;
--
-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)
--
set work_mem to '64kB';
set enable_mergejoin to off;
set enable_indexonlyscan to off;
explain (costs off)
select count(*) from tenk1 a, tenk1 b
  where a.hundred = b.thousand and (b.fivethous % 10) < 10;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (a.hundred = b.thousand)
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by S: hundred
                           ->  Seq Scan on tenk1 a
                     ->  Hash
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Distribute results by S: thousand
                                 ->  Seq Scan on tenk1 b
                                       Filter: ((fivethous % 10) < 10)
(13 rows)

select count(*) from tenk1 a, tenk1 b
  where a.hundred = b.thousand and (b.fivethous % 10) < 10;
 count  
--------
 100000
(1 row)

reset work_mem;
reset enable_mergejoin;
reset enable_indexonlyscan;
--
-- regression test for 8.2 bug with improper re-ordering of left joins
--
create temp table tt3(f1 int, f2 text);
insert into tt3 select x, repeat('xyzzy', 100) from generate_series(1,10000) x;
create index tt3i on tt3(f1);
analyze tt3;
create temp table tt4(f1 int);
insert into tt4 values (0),(1),(9999);
analyze tt4;
SELECT a.f1
FROM tt4 a
LEFT JOIN (
        SELECT b.f1
        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)
        WHERE c.f1 IS NULL
) AS d ON (a.f1 = d.f1)
WHERE d.f1 IS NULL ORDER BY f1;
  f1  
------
    0
    1
 9999
(3 rows)

--
-- regression test for proper handling of outer joins within antijoins
--
create temp table tt4x(c1 int, c2 int, c3 int);
explain (costs off)
select * from tt4x t1
where not exists (
  select 1 from tt4x t2
    left join tt4x t3 on t2.c3 = t3.c1
    left join ( select t5.c1 as c1
                from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1
              ) a1 on t3.c2 = a1.c1
  where t1.c1 = t2.c2
);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Anti Join
         Hash Cond: (t1.c1 = t2.c2)
         ->  Seq Scan on tt4x t1
         ->  Hash
               ->  Remote Subquery Scan on all (datanodes 2)
                     Distribute results by H: c2
                     ->  Merge Right Join
                           Merge Cond: (t5.c1 = t3.c2)
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Sort Key: t5.c1
                                 Distribute results by S: c1
                                 ->  Merge Join
                                       Merge Cond: (t4.c2 = t5.c1)
                                       ->  Remote Subquery Scan on all (datanodes 2)
                                             Sort Key: t4.c2
                                             Distribute results by H: c2
                                             ->  Sort
                                                   Sort Key: t4.c2
                                                   ->  Seq Scan on tt4x t4
                                       ->  Sort
                                             Sort Key: t5.c1
                                             ->  Seq Scan on tt4x t5
                           ->  Materialize
                                 ->  Remote Subquery Scan on all (datanodes 2)
                                       Sort Key: t3.c2
                                       Distribute results by S: c2
                                       ->  Sort
                                             Sort Key: t3.c2
                                             ->  Hash Left Join
                                                   Hash Cond: (t2.c3 = t3.c1)
                                                   ->  Remote Subquery Scan on all (datanodes 2)
                                                         Distribute results by H: c3
                                                         ->  Seq Scan on tt4x t2
                                                   ->  Hash
                                                         ->  Seq Scan on tt4x t3
(36 rows)

--
-- regression test for problems of the sort depicted in bug #3494
--
create temp table tt5(f1 int, f2 int);
create temp table tt6(f1 int, f2 int);
insert into tt5 values(1, 10);
insert into tt5 values(1, 11);
insert into tt6 values(1, 9);
insert into tt6 values(1, 2);
insert into tt6 values(2, 9);
select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2 
      ORDER BY tt5.f1, tt5.f2, tt6.f1, tt6.f2;
 f1 | f2 | f1 | f2 
----+----+----+----
  1 | 10 |  1 |  9
(1 row)

--
-- regression test for problems of the sort depicted in bug #3588
--
create temp table xx (pkxx int);
create temp table yy (pkyy int, pkxx int);
insert into xx values (1);
insert into xx values (2);
insert into xx values (3);
insert into yy values (101, 1);
insert into yy values (201, 2);
insert into yy values (301, NULL);
select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,
       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx
from yy
     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy
     left join xx xxa on yya.pkxx = xxa.pkxx
     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx 
     ORDER BY yy_pkyy, yy_pkxx, yya_pkyy, xxa_pkxx, xxb_pkxx;
 yy_pkyy | yy_pkxx | yya_pkyy | xxa_pkxx | xxb_pkxx 
---------+---------+----------+----------+----------
     101 |       1 |      101 |        1 |        1
     201 |       2 |          |          |        1
     301 |         |          |          |        1
(3 rows)

--
-- regression test for improper pushing of constants across outer-join clauses
-- (as seen in early 8.2.x releases)
--
create temp table zt1 (f1 int primary key);
create temp table zt2 (f2 int primary key);
create temp table zt3 (f3 int primary key);
insert into zt1 values(53);
insert into zt2 values(53);
select * from
  zt2 left join zt3 on (f2 = f3)
      left join zt1 on (f3 = f1)
where f2 = 53 
ORDER BY f1, f2, f3;
 f2 | f3 | f1 
----+----+----
 53 |    |   
(1 row)

create temp view zv1 as select *,'dummy'::text AS junk from zt1;
select * from
  zt2 left join zt3 on (f2 = f3)
      left join zv1 on (f3 = f1)
where f2 = 53 
ORDER BY f1, f2, f3;
 f2 | f3 | f1 | junk 
----+----+----+------
 53 |    |    | 
(1 row)

--
-- regression test for improper extraction of OR indexqual conditions
-- (as seen in early 8.3.x releases)
--
select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred
from tenk1 a left join tenk1 b on a.unique2 = b.tenthous
where a.unique1 = 42 and
      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);
 unique2 | ten | tenthous | unique2 | hundred 
---------+-----+----------+---------+---------
(0 rows)

--
-- test proper positioning of one-time quals in EXISTS (8.4devel bug)
--
prepare foo(bool) as
  select count(*) from tenk1 a left join tenk1 b
    on (a.unique2 = b.unique1 and exists
        (select 1 from tenk1 c where c.thousand = b.unique2 and $1));
execute foo(true);
 count 
-------
 10000
(1 row)

execute foo(false);
 count 
-------
 10000
(1 row)

--
-- test for sane behavior with noncanonical merge clauses, per bug #4926
--
begin;
set enable_mergejoin = 1;
set enable_hashjoin = 0;
set enable_nestloop = 0;
create temp table a (i integer);
create temp table b (x integer, y integer);
select * from a left join b on i = x and i = y and x = i;
 i | x | y 
---+---+---
(0 rows)

rollback;
--
-- test handling of merge clauses using record_ops
--
begin;
create type mycomptype as (id int, v bigint);
create temp table tidv (idv mycomptype);
create index on tidv (idv);
explain (costs off)
select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
                           QUERY PLAN                           
----------------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1
   ->  Merge Join
         Merge Cond: (a.idv = b.idv)
         ->  Index Only Scan using tidv_idv_idx on tidv a
         ->  Materialize
               ->  Index Only Scan using tidv_idv_idx on tidv b
(7 rows)

set enable_mergejoin = 0;
explain (costs off)
select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
                        QUERY PLAN                        
----------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1
   ->  Nested Loop
         ->  Seq Scan on tidv a
         ->  Index Only Scan using tidv_idv_idx on tidv b
               Index Cond: (idv = a.idv)
(6 rows)

rollback;
--
-- test NULL behavior of whole-row Vars, per bug #5025
--
select t1.q2, count(t2.*)
from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

select t1.q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

select t1.q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

select t1.q2, count(t2.*)
from int8_tbl t1 left join
  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2
  on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

--
-- test incorrect failure to NULL pulled-up subexpressions
--
begin;
create temp table a (
     code char not null,
     constraint a_pk primary key (code)
);
create temp table b (
     a char not null,
     num integer not null,
     constraint b_pk primary key (a, num)
);
create temp table c (
     name char not null,
     a char,
     constraint c_pk primary key (name)
);
insert into a (code) values ('p');
insert into a (code) values ('q');
insert into b (a, num) values ('p', 1);
insert into b (a, num) values ('p', 2);
insert into c (name, a) values ('A', 'p');
insert into c (name, a) values ('B', 'q');
insert into c (name, a) values ('C', null);
select c.name, ss.code, ss.b_cnt, ss.const
from c left join
  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const
   from a left join
     (select count(1) as cnt, b.a from b group by b.a) as b_grp
     on a.code = b_grp.a
  ) as ss
  on (c.a = ss.code)
order by c.name;
 name | code | b_cnt | const 
------+------+-------+-------
 A    | p    |     2 |    -1
 B    | q    |     0 |    -1
 C    |      |       |      
(3 rows)

rollback;
--
-- test incorrect handling of placeholders that only appear in targetlists,
-- per bug #6154
--
SELECT * FROM
( SELECT 1 as key1 ) sub1
LEFT JOIN
( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM
    ( SELECT 1 as key3 ) sub3
    LEFT JOIN
    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
        ( SELECT 1 as key5 ) sub5
        LEFT JOIN
        ( SELECT 2 as key6, 42 as value1 ) sub6
        ON sub5.key5 = sub6.key6
    ) sub4
    ON sub4.key5 = sub3.key3
) sub2
ON sub1.key1 = sub2.key3;
 key1 | key3 | value2 | value3 
------+------+--------+--------
    1 |    1 |      1 |      1
(1 row)

-- test the path using join aliases, too
SELECT * FROM
( SELECT 1 as key1 ) sub1
LEFT JOIN
( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM
    ( SELECT 1 as key3 ) sub3
    LEFT JOIN
    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
        ( SELECT 1 as key5 ) sub5
        LEFT JOIN
        ( SELECT 2 as key6, 42 as value1 ) sub6
        ON sub5.key5 = sub6.key6
    ) sub4
    ON sub4.key5 = sub3.key3
) sub2
ON sub1.key1 = sub2.key3;
 key1 | key3 | value2 | value3 
------+------+--------+--------
    1 |    1 |      1 |      1
(1 row)

--
-- test case where a PlaceHolderVar is used as a nestloop parameter
--
EXPLAIN (NUM_NODES OFF, NODES OFF, COSTS OFF)
SELECT qq, unique1
  FROM
  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
  FULL OUTER JOIN
  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
  USING (qq)
  INNER JOIN tenk1 c ON qq = unique2;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   ->  Nested Loop
         ->  Hash Full Join
               Hash Cond: ((COALESCE(a.q1, '0'::bigint)) = (COALESCE(b.q2, '-1'::bigint)))
               ->  Seq Scan on int8_tbl a
               ->  Hash
                     ->  Seq Scan on int8_tbl b
         ->  Index Scan using tenk1_unique2 on tenk1 c
               Index Cond: (unique2 = COALESCE((COALESCE(a.q1, '0'::bigint)), (COALESCE(b.q2, '-1'::bigint))))
(9 rows)

SELECT qq, unique1
  FROM
  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
  FULL OUTER JOIN
  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
  USING (qq)
  INNER JOIN tenk1 c ON qq = unique2;
 qq  | unique1 
-----+---------
 123 |    4596
 123 |    4596
 456 |    7318
(3 rows)

--
-- nested nestloops can require nested PlaceHolderVars
--
create temp table nt1 (
  id int primary key,
  a1 boolean,
  a2 boolean
);
create temp table nt2 (
  id int primary key,
  nt1_id int,
  b1 boolean,
  b2 boolean
);
create temp table nt3 (
  id int primary key,
  nt2_id int,
  c1 boolean
);
insert into nt1 values (1,true,true);
insert into nt1 values (2,true,false);
insert into nt1 values (3,false,false);
insert into nt2 values (1,1,true,true);
insert into nt2 values (2,2,true,false);
insert into nt2 values (3,3,false,false);
insert into nt3 values (1,1,true);
insert into nt3 values (2,2,false);
insert into nt3 values (3,3,true);
explain(num_nodes off, nodes off, costs off) 
select nt3.id
from nt3 as nt3
  left join
    (select nt2.*, (nt2.b1 and ss1.a3) AS b3
     from nt2 as nt2
       left join
         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
         on ss1.id = nt2.nt1_id
    ) as ss2
    on ss2.id = nt3.nt2_id
where nt3.id = 1 and ss2.b3;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Nested Loop
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by H: nt1_id
               ->  Nested Loop
                     ->  Remote Subquery Scan on all (datanodes 1)
                           Distribute results by H: nt2_id
                           ->  Index Scan using nt3_pkey on nt3
                                 Index Cond: (id = 1)
                     ->  Index Scan using nt2_pkey on nt2
                           Index Cond: (id = nt3.nt2_id)
         ->  Index Only Scan using nt1_pkey on nt1
               Index Cond: (id = nt2.nt1_id)
               Filter: (nt2.b1 AND (id IS NOT NULL))
(14 rows)

select nt3.id
from nt3 as nt3
  left join
    (select nt2.*, (nt2.b1 and ss1.a3) AS b3
     from nt2 as nt2
       left join
         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
         on ss1.id = nt2.nt1_id
    ) as ss2
    on ss2.id = nt3.nt2_id
where nt3.id = 1 and ss2.b3;
 id 
----
  1
(1 row)

--
-- test case where a PlaceHolderVar is propagated into a subquery
--
explain (num_nodes off, nodes off, costs off)
select * from
  int8_tbl t1 left join
  (select q1 as x, 42 as y from int8_tbl t2) ss
  on t1.q2 = ss.x
where
  1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
order by 1,2;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Remote Fast Query Execution
   ->  Sort
         Sort Key: t1.q1, t1.q2
         ->  Hash Left Join
               Hash Cond: (t1.q2 = t2.q1)
               Filter: (1 = (SubPlan 1))
               ->  Seq Scan on int8_tbl t1
               ->  Hash
                     ->  Seq Scan on int8_tbl t2
               SubPlan 1
                 ->  Limit
                       ->  Result
                             One-Time Filter: ((42) IS NOT NULL)
                             ->  Seq Scan on int8_tbl t3
(14 rows)

select * from
  int8_tbl t1 left join
  (select q1 as x, 42 as y from int8_tbl t2) ss
  on t1.q2 = ss.x
where
  1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
order by 1,2;
        q1        |        q2        |        x         | y  
------------------+------------------+------------------+----
              123 | 4567890123456789 | 4567890123456789 | 42
              123 | 4567890123456789 | 4567890123456789 | 42
              123 | 4567890123456789 | 4567890123456789 | 42
 4567890123456789 |              123 |              123 | 42
 4567890123456789 |              123 |              123 | 42
 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
(8 rows)

--
-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE
--
select * from int4_tbl a full join int4_tbl b on true order by 1,2;
     f1      |     f1      
-------------+-------------
 -2147483647 | -2147483647
 -2147483647 |     -123456
 -2147483647 |           0
 -2147483647 |      123456
 -2147483647 |  2147483647
     -123456 | -2147483647
     -123456 |     -123456
     -123456 |           0
     -123456 |      123456
     -123456 |  2147483647
           0 | -2147483647
           0 |     -123456
           0 |           0
           0 |      123456
           0 |  2147483647
      123456 | -2147483647
      123456 |     -123456
      123456 |           0
      123456 |      123456
      123456 |  2147483647
  2147483647 | -2147483647
  2147483647 |     -123456
  2147483647 |           0
  2147483647 |      123456
  2147483647 |  2147483647
(25 rows)

select * from int4_tbl a full join int4_tbl b on false order by 1,2;
     f1      |     f1      
-------------+-------------
 -2147483647 |            
     -123456 |            
           0 |            
      123456 |            
  2147483647 |            
             | -2147483647
             |     -123456
             |           0
             |      123456
             |  2147483647
(10 rows)

--
-- test for ability to use a cartesian join when necessary
--
explain (num_nodes off, nodes off, costs off)
select * from
  tenk1 join int4_tbl on f1 = twothousand,
  int4(sin(1)) q1,
  int4(sin(0)) q2
where q1 = thousand or q2 = thousand;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Nested Loop
   Join Filter: ((q1.q1 = tenk1.thousand) OR (q2.q2 = tenk1.thousand))
   ->  Nested Loop
         ->  Function Scan on q1
         ->  Function Scan on q2
   ->  Materialize
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Hash Join
                     Hash Cond: (tenk1.twothousand = int4_tbl.f1)
                     ->  Seq Scan on tenk1
                     ->  Hash
                           ->  Seq Scan on int4_tbl
(12 rows)

explain (num_nodes off, nodes off, costs off)
select * from
  tenk1 join int4_tbl on f1 = twothousand,
  int4(sin(1)) q1,
  int4(sin(0)) q2
where thousand = (q1 + q2);
                         QUERY PLAN                         
------------------------------------------------------------
 Hash Join
   Hash Cond: (tenk1.thousand = (q1.q1 + q2.q2))
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Hash Join
               Hash Cond: (tenk1.twothousand = int4_tbl.f1)
               ->  Seq Scan on tenk1
               ->  Hash
                     ->  Seq Scan on int4_tbl
   ->  Hash
         ->  Nested Loop
               ->  Function Scan on q1
               ->  Function Scan on q2
(12 rows)

--
-- test ability to generate a suitable plan for a star-schema query
--
explain (costs off)
select * from
  tenk1, int8_tbl a, int8_tbl b
where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Hash Join
         Hash Cond: (tenk1.tenthous = b.q1)
         ->  Nested Loop
               ->  Seq Scan on int8_tbl a
                     Filter: (q2 = 1)
               ->  Bitmap Heap Scan on tenk1
                     Recheck Cond: (thousand = a.q1)
                     ->  Bitmap Index Scan on tenk1_thous_tenthous
                           Index Cond: (thousand = a.q1)
         ->  Hash
               ->  Seq Scan on int8_tbl b
                     Filter: (q2 = 2)
(14 rows)

--
-- test a corner case in which we shouldn't apply the star-schema optimization
--
explain (costs off, nodes off)
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (values(1,0)) v1(x1,x2)
               left join (values(3,1)) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Nested Loop
   Join Filter: (t1.stringu1 > t2.stringu2)
   ->  Nested Loop
         ->  Nested Loop
               Join Filter: ((1) = (1))
               ->  Hash Join
                     Hash Cond: (i1.f1 = (0))
                     ->  Remote Subquery Scan on all (datanodes 1)
                           ->  Seq Scan on int4_tbl i1
                     ->  Hash
                           ->  Result
               ->  Result
         ->  Remote Subquery Scan on all (datanodes 2)
               Sort Key: t1.unique2
               ->  Index Scan using tenk1_unique2 on tenk1 t1
                     Index Cond: ((unique2 = (11)) AND (unique2 < 42))
   ->  Remote Subquery Scan on all (datanodes 2)
         Sort Key: t2.unique1
         ->  Index Scan using tenk1_unique1 on tenk1 t2
               Index Cond: (unique1 = (3))
(20 rows)

select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (values(1,0)) v1(x1,x2)
               left join (values(3,1)) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
 unique2 | stringu1 | unique1 | stringu2 
---------+----------+---------+----------
      11 | WFAAAA   |       3 | LKIAAA
(1 row)

-- variant that isn't quite a star-schema case
select ss1.d1 from
  tenk1 as t1
  inner join tenk1 as t2
  on t1.tenthous = t2.ten
  inner join
    int8_tbl as i8
    left join int4_tbl as i4
      inner join (select 64::information_schema.cardinal_number as d1
                  from tenk1 t3,
                       lateral (select abs(t3.unique1) + random()) ss0(x)
                  where t3.fivethous < 0) as ss1
      on i4.f1 = ss1.d1
    on i8.q1 = i4.f1
  on t1.tenthous = ss1.d1
where t1.unique1 < i4.f1;
 d1 
----
(0 rows)

--
-- test extraction of restriction OR clauses from join OR clause
-- (we used to only do this for indexable clauses)
--
explain (costs off)
select * from tenk1 a join tenk1 b on
  (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.hundred = 4)))
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Bitmap Heap Scan on tenk1 b
               Recheck Cond: ((unique1 = 2) OR (hundred = 4))
               ->  BitmapOr
                     ->  Bitmap Index Scan on tenk1_unique1
                           Index Cond: (unique1 = 2)
                     ->  Bitmap Index Scan on tenk1_hundred
                           Index Cond: (hundred = 4)
   ->  Materialize
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Bitmap Heap Scan on tenk1 a
                     Recheck Cond: ((unique1 = 1) OR (unique2 = 3))
                     ->  BitmapOr
                           ->  Bitmap Index Scan on tenk1_unique1
                                 Index Cond: (unique1 = 1)
                           ->  Bitmap Index Scan on tenk1_unique2
                                 Index Cond: (unique2 = 3)
(19 rows)

explain (costs off)
select * from tenk1 a join tenk1 b on
  (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.ten = 4)))
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Seq Scan on tenk1 b
               Filter: ((unique1 = 2) OR (ten = 4))
   ->  Materialize
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Bitmap Heap Scan on tenk1 a
                     Recheck Cond: ((unique1 = 1) OR (unique2 = 3))
                     ->  BitmapOr
                           ->  Bitmap Index Scan on tenk1_unique1
                                 Index Cond: (unique1 = 1)
                           ->  Bitmap Index Scan on tenk1_unique2
                                 Index Cond: (unique2 = 3)
(14 rows)

explain (costs off)
select * from tenk1 a join tenk1 b on
  (a.unique1 = 1 and b.unique1 = 2) or
  ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR (((a.unique2 = 3) OR (a.unique2 = 7)) AND (b.hundred = 4)))
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Bitmap Heap Scan on tenk1 b
               Recheck Cond: ((unique1 = 2) OR (hundred = 4))
               ->  BitmapOr
                     ->  Bitmap Index Scan on tenk1_unique1
                           Index Cond: (unique1 = 2)
                     ->  Bitmap Index Scan on tenk1_hundred
                           Index Cond: (hundred = 4)
   ->  Materialize
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Bitmap Heap Scan on tenk1 a
                     Recheck Cond: ((unique1 = 1) OR (unique2 = 3) OR (unique2 = 7))
                     ->  BitmapOr
                           ->  Bitmap Index Scan on tenk1_unique1
                                 Index Cond: (unique1 = 1)
                           ->  Bitmap Index Scan on tenk1_unique2
                                 Index Cond: (unique2 = 3)
                           ->  Bitmap Index Scan on tenk1_unique2
                                 Index Cond: (unique2 = 7)
(21 rows)

--
-- test placement of movable quals in a parameterized join tree
--
explain (num_nodes off, nodes off, costs off)
select * from tenk1 t1 left join
  (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
  on t1.hundred = t2.hundred and t1.ten = t3.ten
where t1.unique1 = 1;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Merge Right Join
         Merge Cond: ((t2.hundred = t1.hundred) AND (t3.ten = t1.ten))
         ->  Remote Subquery Scan on all (datanodes 2)
               Sort Key: t2.hundred, t3.ten
               Distribute results by S: hundred
               ->  Sort
                     Sort Key: t2.hundred, t3.ten
                     ->  Merge Join
                           Merge Cond: (t2.thousand = t3.unique2)
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Sort Key: t2.thousand
                                 Distribute results by S: thousand
                                 ->  Index Scan using tenk1_thous_tenthous on tenk1 t2
                           ->  Materialize
                                 ->  Remote Subquery Scan on all (datanodes 2)
                                       Sort Key: t3.unique2
                                       Distribute results by S: unique2
                                       ->  Index Scan using tenk1_unique2 on tenk1 t3
         ->  Materialize
               ->  Remote Subquery Scan on all (datanodes 1)
                     Distribute results by S: hundred
                     ->  Sort
                           Sort Key: t1.hundred, t1.ten
                           ->  Seq Scan on tenk1 t1
                                 Filter: (unique1 = 1)
(26 rows)

explain (num_nodes off, nodes off, costs off)
select * from tenk1 t1 left join
  (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
  on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten
where t1.unique1 = 1;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Right Join
         Hash Cond: (t2.hundred = t1.hundred)
         Join Filter: ((t1.ten + t2.ten) = t3.ten)
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: hundred
               ->  Merge Join
                     Merge Cond: (t2.thousand = t3.unique2)
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Sort Key: t2.thousand
                           Distribute results by S: thousand
                           ->  Index Scan using tenk1_thous_tenthous on tenk1 t2
                     ->  Materialize
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Sort Key: t3.unique2
                                 Distribute results by S: unique2
                                 ->  Index Scan using tenk1_unique2 on tenk1 t3
         ->  Hash
               ->  Remote Subquery Scan on all (datanodes 1)
                     Distribute results by S: hundred
                     ->  Seq Scan on tenk1 t1
                           Filter: (unique1 = 1)
(22 rows)

set enable_indexonlyscan to off;
explain (num_nodes off, nodes off, costs off)
select count(*) from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
  join int4_tbl on b.thousand = f1;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Right Join
                     Hash Cond: (c.thousand = a.thousand)
                     Join Filter: (a.unique2 = b.unique1)
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by S: thousand
                           ->  Seq Scan on tenk1 c
                     ->  Hash
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Distribute results by S: thousand
                                 ->  Nested Loop
                                       ->  Remote Subquery Scan on all (datanodes 2)
                                             Distribute results by H: unique2
                                             ->  Nested Loop
                                                   ->  Seq Scan on int4_tbl
                                                   ->  Index Scan using tenk1_thous_tenthous on tenk1 b
                                                         Index Cond: (thousand = int4_tbl.f1)
                                       ->  Index Scan using tenk1_unique1 on tenk1 a
                                             Index Cond: (unique1 = b.unique2)
(21 rows)

select count(*) from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
  join int4_tbl on b.thousand = f1;
 count 
-------
    10
(1 row)

explain (num_nodes off, nodes off, costs off)
select b.unique1 from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
  join int4_tbl i1 on b.thousand = f1
  right join int4_tbl i2 on i2.f1 = b.tenthous
  order by 1;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   Sort Key: b.unique1
   ->  Sort
         Sort Key: b.unique1
         ->  Hash Right Join
               Hash Cond: (b.tenthous = i2.f1)
               ->  Remote Subquery Scan on all (datanodes 2)
                     Distribute results by S: tenthous
                     ->  Hash Right Join
                           Hash Cond: (c.thousand = a.thousand)
                           Join Filter: (b.unique1 = 42)
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Distribute results by S: thousand
                                 ->  Seq Scan on tenk1 c
                           ->  Hash
                                 ->  Remote Subquery Scan on all (datanodes 2)
                                       Distribute results by S: thousand
                                       ->  Nested Loop
                                             ->  Remote Subquery Scan on all (datanodes 2)
                                                   Distribute results by H: unique2
                                                   ->  Nested Loop
                                                         ->  Seq Scan on int4_tbl i1
                                                         ->  Index Scan using tenk1_thous_tenthous on tenk1 b
                                                               Index Cond: (thousand = i1.f1)
                                             ->  Index Scan using tenk1_unique1 on tenk1 a
                                                   Index Cond: (unique1 = b.unique2)
               ->  Hash
                     ->  Remote Subquery Scan on all (datanodes 1)
                           Distribute results by S: f1
                           ->  Seq Scan on int4_tbl i2
(30 rows)

select b.unique1 from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
  join int4_tbl i1 on b.thousand = f1
  right join int4_tbl i2 on i2.f1 = b.tenthous
  order by 1;
 unique1 
---------
       0
        
        
        
        
(5 rows)

reset enable_indexonlyscan;
explain (num_nodes off, nodes off, costs off)
select * from
(
  select unique1, q1, coalesce(unique1, -1) + q1 as fault
  from int8_tbl left join tenk1 on (q2 = unique2)
) ss
where fault = 122
order by fault;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Right Join
         Hash Cond: (tenk1.unique2 = int8_tbl.q2)
         Filter: ((COALESCE(tenk1.unique1, '-1'::integer) + int8_tbl.q1) = 122)
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: unique2
               ->  Seq Scan on tenk1
         ->  Hash
               ->  Remote Subquery Scan on all (datanodes 1)
                     Distribute results by S: q2
                     ->  Seq Scan on int8_tbl
(11 rows)

select * from
(
  select unique1, q1, coalesce(unique1, -1) + q1 as fault
  from int8_tbl left join tenk1 on (q2 = unique2)
) ss
where fault = 122
order by fault;
 unique1 | q1  | fault 
---------+-----+-------
         | 123 |   122
(1 row)

explain (costs off)
select * from
(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x
left join unnest(v1ys) as u1(u1y) on u1y = v2y;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Nested Loop Left Join
   Join Filter: (u1.u1y = "*VALUES*_1".column2)
   ->  Remote Subquery Scan on all (datanodes 1)
         ->  Hash Left Join
               Hash Cond: ("*VALUES*".column1 = "*VALUES*_1".column1)
               ->  Values Scan on "*VALUES*"
               ->  Hash
                     ->  Values Scan on "*VALUES*_1"
   ->  Function Scan on unnest u1
(9 rows)

select * from
(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x
left join unnest(v1ys) as u1(u1y) on u1y = v2y;
 v1x |  v1ys   | v2x | v2y | u1y 
-----+---------+-----+-----+-----
   1 | {10,20} |   1 |  10 |  10
   2 | {20,30} |   2 |  20 |  20
(2 rows)

--
-- test handling of potential equivalence clauses above outer joins
--
explain (num_nodes off, nodes off, costs off)
select q1, unique2, thousand, hundred
  from int8_tbl a left join tenk1 b on q1 = unique2
  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Right Join
         Hash Cond: (b.unique2 = a.q1)
         Filter: ((COALESCE(b.thousand, 123) = a.q1) AND (a.q1 = COALESCE(b.hundred, 123)))
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: unique2
               ->  Seq Scan on tenk1 b
         ->  Hash
               ->  Remote Subquery Scan on all (datanodes 1)
                     Distribute results by S: q1
                     ->  Seq Scan on int8_tbl a
(11 rows)

select q1, unique2, thousand, hundred
  from int8_tbl a left join tenk1 b on q1 = unique2
  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
 q1 | unique2 | thousand | hundred 
----+---------+----------+---------
(0 rows)

set enable_indexonlyscan to off;
set enable_indexscan to off;
explain (num_nodes off, nodes off, costs off)
select f1, unique2, case when unique2 is null then f1 else 0 end
  from int4_tbl a left join tenk1 b on f1 = unique2
  where (case when unique2 is null then f1 else 0 end) = 0;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Right Join
         Hash Cond: (b.unique2 = a.f1)
         Filter: (CASE WHEN (b.unique2 IS NULL) THEN a.f1 ELSE 0 END = 0)
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: unique2
               ->  Seq Scan on tenk1 b
         ->  Hash
               ->  Remote Subquery Scan on all (datanodes 1)
                     Distribute results by S: f1
                     ->  Seq Scan on int4_tbl a
(11 rows)

select f1, unique2, case when unique2 is null then f1 else 0 end
  from int4_tbl a left join tenk1 b on f1 = unique2
  where (case when unique2 is null then f1 else 0 end) = 0;
 f1 | unique2 | case 
----+---------+------
  0 |       0 |    0
(1 row)

reset enable_indexonlyscan;
reset enable_indexscan;
--
-- another case with equivalence clauses above outer joins (bug #8591)
--
explain (costs off)
select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Nested Loop Left Join
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: (COALESCE(twothousand, twothousand))
               ->  Hash Right Join
                     Hash Cond: (b.thousand = a.unique1)
                     Filter: (COALESCE(b.twothousand, a.twothousand) = 44)
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by H: thousand
                           ->  Seq Scan on tenk1 b
                     ->  Hash
                           ->  Index Scan using tenk1_unique2 on tenk1 a
                                 Index Cond: (unique2 < 10)
         ->  Remote Subquery Scan on all (datanodes 2)
               Sort Key: c.unique2
               Distribute results by S: unique2
               ->  Index Scan using tenk1_unique2 on tenk1 c
                     Index Cond: ((unique2 = COALESCE(b.twothousand, a.twothousand)) AND (unique2 = 44))
(18 rows)

select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
 unique1 | unique1 | unique1 | coalesce 
---------+---------+---------+----------
(0 rows)

--
-- check handling of join aliases when flattening multiple levels of subquery
--
set enable_indexonlyscan to off;
set enable_mergejoin to off;
explain (verbose, costs off)
select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
  (values (0),(1)) foo1(join_key)
left join
  (select join_key, bug_field from
    (select ss1.join_key, ss1.bug_field from
      (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
    ) foo2
   left join
    (select unique2 as join_key from tenk1 i2) ss2
   using (join_key)
  ) foo3
using (join_key);
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1,datanode_2)
   Output: "*VALUES*".column1, i1.f1, (666)
   ->  Hash Right Join
         Output: "*VALUES*".column1, i1.f1, (666)
         Hash Cond: (i1.f1 = "*VALUES*".column1)
         ->  Hash Right Join
               Output: i1.f1, 666
               Hash Cond: (i2.unique2 = i1.f1)
               ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
                     Output: i2.unique2
                     Distribute results by S: unique2
                     ->  Seq Scan on public.tenk1 i2
                           Output: i2.unique2
               ->  Hash
                     Output: i1.f1
                     ->  Remote Subquery Scan[3] on all (datanode_1)
                           Output: i1.f1
                           Distribute results by S: f1
                           ->  Seq Scan on public.int4_tbl i1
                                 Output: i1.f1
         ->  Hash
               Output: "*VALUES*".column1
               ->  Remote Subquery Scan[4] on all (datanode_1)
                     Output: "*VALUES*".column1
                     Distribute results by S: column1
                     ->  Values Scan on "*VALUES*"
                           Output: "*VALUES*".column1
(27 rows)

select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
  (values (0),(1)) foo1(join_key)
left join
  (select join_key, bug_field from
    (select ss1.join_key, ss1.bug_field from
      (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
    ) foo2
   left join
    (select unique2 as join_key from tenk1 i2) ss2
   using (join_key)
  ) foo3
using (join_key) order by 1;
 foo1_id | foo3_id | bug_field 
---------+---------+-----------
       0 |       0 |       666
       1 |         |          
(2 rows)

reset enable_mergejoin;
reset enable_indexonlyscan;
--
-- test successful handling of nested outer joins with degenerate join quals
--
set enable_nestloop to on;
set enable_hashjoin to off;
set enable_mergejoin to off;
explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: t1.f1
   Node/s: datanode_1, datanode_2
   Remote query: SELECT t1.f1 FROM ((public.text_tbl t1 LEFT JOIN ((SELECT i8b1.q1, i8b1.q2, '***'::text AS d1 FROM public.int8_tbl i8b1) b1 LEFT JOIN (public.int8_tbl i8 LEFT JOIN (SELECT i8b2.q1, i8b2.q2, NULL::integer AS d2 FROM public.int8_tbl i8b2) b2 ON ((i8.q1 = b2.q1))) ON ((b2.d2 = b1.q2))) ON ((t1.f1 = b1.d1))) LEFT JOIN public.int4_tbl i4 ON ((i8.q2 = i4.f1)))
   ->  Nested Loop Left Join
         Output: t1.f1
         Join Filter: (i8.q2 = i4.f1)
         ->  Nested Loop Left Join
               Output: t1.f1, i8.q2
               Join Filter: (t1.f1 = '***'::text)
               ->  Seq Scan on public.text_tbl t1
                     Output: t1.f1
               ->  Nested Loop Left Join
                     Output: i8.q2
                     Join Filter: ((NULL::integer) = i8b1.q2)
                     ->  Seq Scan on public.int8_tbl i8b1
                           Output: i8b1.q1, i8b1.q2
                     ->  Materialize
                           Output: i8.q2, (NULL::integer)
                           ->  Nested Loop Left Join
                                 Output: i8.q2, (NULL::integer)
                                 Join Filter: (i8.q1 = i8b2.q1)
                                 ->  Seq Scan on public.int8_tbl i8
                                       Output: i8.q1, i8.q2
                                 ->  Materialize
                                       Output: i8b2.q1, (NULL::integer)
                                       ->  Seq Scan on public.int8_tbl i8b2
                                             Output: i8b2.q1, NULL::integer
         ->  Materialize
               Output: i4.f1
               ->  Seq Scan on public.int4_tbl i4
                     Output: i4.f1
(32 rows)

select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1) order by 1;
        f1         
-------------------
 doh!
 hi de ho neighbor
(2 rows)

set enable_fast_query_shipping to off;
explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1,datanode_2)
   Output: t1.f1
   ->  Nested Loop Left Join
         Output: t1.f1
         Join Filter: (i8.q2 = i4.f1)
         ->  Nested Loop Left Join
               Output: t1.f1, i8.q2
               Join Filter: (t1.f1 = '***'::text)
               ->  Seq Scan on public.text_tbl t1
                     Output: t1.f1
               ->  Nested Loop Left Join
                     Output: i8.q2
                     Join Filter: ((NULL::integer) = i8b1.q2)
                     ->  Seq Scan on public.int8_tbl i8b1
                           Output: i8b1.q1, i8b1.q2
                     ->  Materialize
                           Output: i8.q2, (NULL::integer)
                           ->  Nested Loop Left Join
                                 Output: i8.q2, (NULL::integer)
                                 Join Filter: (i8.q1 = i8b2.q1)
                                 ->  Seq Scan on public.int8_tbl i8
                                       Output: i8.q1, i8.q2
                                 ->  Materialize
                                       Output: i8b2.q1, (NULL::integer)
                                       ->  Nested Loop
                                             Output: i8b2.q1, NULL::integer
                                             ->  Seq Scan on public.int8_tbl i8b2
                                                   Output: i8b2.q1, i8b2.q2
                                             ->  Materialize
                                                   ->  Seq Scan on public.int4_tbl i4b2
         ->  Materialize
               Output: i4.f1
               ->  Seq Scan on public.int4_tbl i4
                     Output: i4.f1
(34 rows)

select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1) order by 1;
        f1         
-------------------
 doh!
 hi de ho neighbor
(2 rows)

explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2
                 where q1 = f1) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1,datanode_2)
   Output: t1.f1
   ->  Nested Loop Left Join
         Output: t1.f1
         Join Filter: (i8.q2 = i4.f1)
         ->  Nested Loop Left Join
               Output: t1.f1, i8.q2
               Join Filter: (t1.f1 = '***'::text)
               ->  Seq Scan on public.text_tbl t1
                     Output: t1.f1
               ->  Nested Loop Left Join
                     Output: i8.q2
                     Join Filter: ((NULL::integer) = i8b1.q2)
                     ->  Seq Scan on public.int8_tbl i8b1
                           Output: i8b1.q1, i8b1.q2
                     ->  Materialize
                           Output: i8.q2, (NULL::integer)
                           ->  Nested Loop Left Join
                                 Output: i8.q2, (NULL::integer)
                                 Join Filter: (i8.q1 = i8b2.q1)
                                 ->  Seq Scan on public.int8_tbl i8
                                       Output: i8.q1, i8.q2
                                 ->  Materialize
                                       Output: i8b2.q1, (NULL::integer)
                                       ->  Nested Loop
                                             Output: i8b2.q1, NULL::integer
                                             Join Filter: (i8b2.q1 = i4b2.f1)
                                             ->  Seq Scan on public.int8_tbl i8b2
                                                   Output: i8b2.q1, i8b2.q2
                                             ->  Materialize
                                                   Output: i4b2.f1
                                                   ->  Seq Scan on public.int4_tbl i4b2
                                                         Output: i4b2.f1
         ->  Materialize
               Output: i4.f1
               ->  Seq Scan on public.int4_tbl i4
                     Output: i4.f1
(37 rows)

select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2
                 where q1 = f1) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1) order by 1;
        f1         
-------------------
 doh!
 hi de ho neighbor
(2 rows)

reset enable_fast_query_shipping;
explain (verbose, costs off)
select * from
  text_tbl t1
  inner join int8_tbl i8
  on i8.q2 = 456
  right join text_tbl t2
  on t1.f1 = 'doh!'
  left join int4_tbl i4
  on i8.q1 = i4.f1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Nested Loop Left Join
   Output: t1.f1, i8.q1, i8.q2, t2.f1, i4.f1
   ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)
         Output: t2.f1
         ->  Seq Scan on public.text_tbl t2
               Output: t2.f1
   ->  Materialize
         Output: i8.q1, i8.q2, i4.f1, t1.f1
         ->  Remote Subquery Scan[2] on all (datanode_2)
               Output: i8.q1, i8.q2, i4.f1, t1.f1
               ->  Nested Loop
                     Output: i8.q1, i8.q2, i4.f1, t1.f1
                     ->  Nested Loop Left Join
                           Output: i8.q1, i8.q2, i4.f1
                           Join Filter: (i8.q1 = i4.f1)
                           ->  Seq Scan on public.int8_tbl i8
                                 Output: i8.q1, i8.q2
                                 Filter: (i8.q2 = 456)
                           ->  Materialize
                                 Output: i4.f1
                                 ->  Seq Scan on public.int4_tbl i4
                                       Output: i4.f1
                     ->  Materialize
                           Output: t1.f1
                           ->  Seq Scan on public.text_tbl t1
                                 Output: t1.f1
                                 Filter: (t1.f1 = 'doh!'::text)
(27 rows)

select * from
  text_tbl t1
  inner join int8_tbl i8
  on i8.q2 = 456
  right join text_tbl t2
  on t1.f1 = 'doh!'
  left join int4_tbl i4
  on i8.q1 = i4.f1 order by 4;
  f1  | q1  | q2  |        f1         | f1 
------+-----+-----+-------------------+----
 doh! | 123 | 456 | doh!              |   
 doh! | 123 | 456 | hi de ho neighbor |   
(2 rows)

reset enable_nestloop;
reset enable_hashjoin;
reset enable_mergejoin;
--
-- test for appropriate join order in the presence of lateral references
--
explain (verbose, costs off, nodes off)
select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss
where t1.f1 = ss.f1;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanodes 2)
   Output: t1.f1, i8.q1, i8.q2, (i8.q1), t2.f1
   ->  Nested Loop
         Output: t1.f1, i8.q1, i8.q2, (i8.q1), t2.f1
         Join Filter: (t1.f1 = t2.f1)
         ->  Nested Loop Left Join
               Output: t1.f1, i8.q1, i8.q2
               ->  Seq Scan on public.text_tbl t1
                     Output: t1.f1
               ->  Seq Scan on public.int8_tbl i8
                     Output: i8.q1, i8.q2
                     Filter: (i8.q2 = 123)
         ->  Remote Subquery Scan[2] param[4] on all (datanodes 1)
               Output: (i8.q1), t2.f1
               Distribute results by R
               ->  Limit
                     Output: (i8.q1), t2.f1
                     ->  Remote Subquery Scan[3] param[5] on all (datanodes 2)
                           Output: (i8.q1), t2.f1
                           Distribute results by R
                           ->  Limit
                                 Output: (i8.q1), t2.f1
                                 ->  Seq Scan on public.text_tbl t2
                                       Output: i8.q1, t2.f1
(24 rows)

select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 order by 2 desc limit 1) as ss
where t1.f1 = ss.f1;
        f1         |        q1        | q2  |        q1        |        f1         
-------------------+------------------+-----+------------------+-------------------
 hi de ho neighbor | 4567890123456789 | 123 | 4567890123456789 | hi de ho neighbor
(1 row)

explain (verbose, costs off, nodes off)
select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,
  lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanodes 2)
   Output: t1.f1, i8.q1, i8.q2, (i8.q1), t2.f1, ((i8.q1)), (t2.f1)
   ->  Nested Loop
         Output: t1.f1, i8.q1, i8.q2, (i8.q1), t2.f1, ((i8.q1)), (t2.f1)
         Join Filter: (t1.f1 = (t2.f1))
         ->  Nested Loop Left Join
               Output: t1.f1, i8.q1, i8.q2
               ->  Seq Scan on public.text_tbl t1
                     Output: t1.f1
               ->  Seq Scan on public.int8_tbl i8
                     Output: i8.q1, i8.q2
                     Filter: (i8.q2 = 123)
         ->  Remote Subquery Scan[2] param[5] on all (datanodes 1)
               Output: (i8.q1), t2.f1, ((i8.q1)), (t2.f1)
               Distribute results by R
               ->  Nested Loop
                     Output: (i8.q1), t2.f1, ((i8.q1)), (t2.f1)
                     ->  Limit
                           Output: (i8.q1), t2.f1
                           ->  Remote Subquery Scan[3] param[6] on all (datanodes 2)
                                 Output: (i8.q1), t2.f1
                                 Distribute results by R
                                 ->  Limit
                                       Output: (i8.q1), t2.f1
                                       ->  Seq Scan on public.text_tbl t2
                                             Output: i8.q1, t2.f1
                     ->  Limit
                           Output: ((i8.q1)), (t2.f1)
                           ->  Remote Subquery Scan[4] param[7] on all (datanodes 2)
                                 Output: ((i8.q1)), (t2.f1)
                                 Distribute results by R
                                 ->  Limit
                                       Output: ((i8.q1)), (t2.f1)
                                       ->  Seq Scan on public.text_tbl t3
                                             Output: (i8.q1), t2.f1
(35 rows)

select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 order by 2 desc limit 1) as ss1,
  lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;
        f1         |        q1        | q2  |        q1        |        f1         |        q1        |        f1         
-------------------+------------------+-----+------------------+-------------------+------------------+-------------------
 hi de ho neighbor | 4567890123456789 | 123 | 4567890123456789 | hi de ho neighbor | 4567890123456789 | hi de ho neighbor
(1 row)

explain (verbose, costs off, nodes off)
select 1 from
  text_tbl as tt1
  inner join text_tbl as tt2 on (tt1.f1 = 'foo')
  left join text_tbl as tt3 on (tt3.f1 = 'foo')
  left join text_tbl as tt4 on (tt3.f1 = tt4.f1),
  lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1
where tt1.f1 = ss1.c0;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Nested Loop
   Output: 1
   ->  Nested Loop Left Join
         Output: tt1.f1, tt4.f1
         ->  Nested Loop
               Output: tt1.f1
               ->  Remote Subquery Scan[1] on all (datanodes 1)
                     Output: tt1.f1
                     ->  Seq Scan on public.text_tbl tt1
                           Output: tt1.f1
                           Filter: (tt1.f1 = 'foo'::text)
               ->  Materialize
                     ->  Remote Subquery Scan[2] on all (datanodes 2)
                           ->  Seq Scan on public.text_tbl tt2
         ->  Materialize
               Output: tt4.f1
               ->  Remote Subquery Scan[3] on all (datanodes 1)
                     Output: tt4.f1
                     ->  Nested Loop Left Join
                           Output: tt4.f1
                           Join Filter: (tt3.f1 = tt4.f1)
                           ->  Seq Scan on public.text_tbl tt3
                                 Output: tt3.f1
                                 Filter: (tt3.f1 = 'foo'::text)
                           ->  Materialize
                                 Output: tt4.f1
                                 ->  Seq Scan on public.text_tbl tt4
                                       Output: tt4.f1
                                       Filter: (tt4.f1 = 'foo'::text)
   ->  Remote Subquery Scan[4] param[6] on all (datanodes 1)
         Output: ss1.c0
         ->  Subquery Scan on ss1
               Output: ss1.c0
               Filter: (ss1.c0 = 'foo'::text)
               ->  Limit
                     Output: (tt4.f1)
                     ->  Remote Subquery Scan[5] param[7] on all (datanodes 2)
                           Output: (tt4.f1)
                           Distribute results by R
                           ->  Limit
                                 Output: (tt4.f1)
                                 ->  Seq Scan on public.text_tbl tt5
                                       Output: tt4.f1
(43 rows)

select 1 from
  text_tbl as tt1
  inner join text_tbl as tt2 on (tt1.f1 = 'foo')
  left join text_tbl as tt3 on (tt3.f1 = 'foo')
  left join text_tbl as tt4 on (tt3.f1 = tt4.f1),
  lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1
where tt1.f1 = ss1.c0;
 ?column? 
----------
(0 rows)

--
-- check a case in which a PlaceHolderVar forces join order
--
explain (verbose, costs off, nodes off)
select ss2.* from
  int4_tbl i41
  left join int8_tbl i8
    join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
          from int4_tbl i42, int4_tbl i43) ss1
    on i8.q1 = ss1.c2
  on i41.f1 = ss1.c1,
  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where ss1.c2 = 0;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanodes 1)
   Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
   ->  Nested Loop
         Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
         ->  Nested Loop
               Output: i41.f1, i42.f1, i8.q1, i8.q2, i43.f1, 42
               ->  Nested Loop
                     Output: i41.f1, i42.f1, i8.q1, i8.q2
                     ->  Hash Join
                           Output: i41.f1, i42.f1
                           Hash Cond: (i41.f1 = i42.f1)
                           ->  Seq Scan on public.int4_tbl i41
                                 Output: i41.f1
                           ->  Hash
                                 Output: i42.f1
                                 ->  Seq Scan on public.int4_tbl i42
                                       Output: i42.f1
                     ->  Materialize
                           Output: i8.q1, i8.q2
                           ->  Seq Scan on public.int8_tbl i8
                                 Output: i8.q1, i8.q2
                                 Filter: (i8.q1 = 0)
               ->  Materialize
                     Output: i43.f1
                     ->  Seq Scan on public.int4_tbl i43
                           Output: i43.f1
                           Filter: (i43.f1 = 0)
         ->  Limit
               Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
               ->  Remote Subquery Scan[2] param[3] on all (datanodes 2)
                     Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
                     Distribute results by R
                     ->  Limit
                           Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
                           ->  Seq Scan on public.text_tbl
                                 Output: i41.f1, i8.q1, i8.q2, i42.f1, i43.f1, (42)
(36 rows)

select ss2.* from
  int4_tbl i41
  left join int8_tbl i8
    join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
          from int4_tbl i42, int4_tbl i43) ss1
    on i8.q1 = ss1.c2
  on i41.f1 = ss1.c1,
  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where ss1.c2 = 0;
 f1 | q1 | q2 | c1 | c2 | c3 
----+----+----+----+----+----
(0 rows)

--
-- test successful handling of full join underneath left join (bug #14105)
--
explain (costs off)
select * from
  (select 1 as id) as xx
  left join
    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))
  on (xx.id = coalesce(yy.id));
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop Left Join
   Join Filter: ((1) = COALESCE((1)))
   ->  Result
   ->  Materialize
         ->  Hash Full Join
               Hash Cond: (a1.unique1 = (1))
               ->  Remote Subquery Scan on all (datanodes 2)
                     ->  Seq Scan on tenk1 a1
               ->  Hash
                     ->  Result
(10 rows)

select * from
  (select 1 as id) as xx
  left join
    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))
  on (xx.id = coalesce(yy.id));
 id | unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | id 
----+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+----
  1 |       1 |    2838 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | EFEAAA   | OOOOxx  |  1
(1 row)

--
-- test ability to push constants through outer join clauses
--
explain (num_nodes off, nodes off, costs off)
  select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;
                         QUERY PLAN                          
-------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Right Join
         Hash Cond: (b.unique2 = a.f1)
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: unique2
               ->  Seq Scan on tenk1 b
                     Filter: (unique2 = 0)
         ->  Hash
               ->  Remote Subquery Scan on all (datanodes 1)
                     Distribute results by S: f1
                     ->  Seq Scan on int4_tbl a
                           Filter: (f1 = 0)
(12 rows)

explain (num_nodes off, nodes off, costs off)
  select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;
                         QUERY PLAN                          
-------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Full Join
         Hash Cond: (a.unique2 = b.unique2)
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: unique2
               ->  Seq Scan on tenk1 a
                     Filter: (unique2 = 42)
         ->  Hash
               ->  Remote Subquery Scan on all (datanodes 2)
                     Distribute results by S: unique2
                     ->  Seq Scan on tenk1 b
                           Filter: (unique2 = 42)
(12 rows)

--
-- test that quals attached to an outer join have correct semantics,
-- specifically that they don't re-use expressions computed below the join;
-- we force a mergejoin so that coalesce(b.q1, 1) appears as a join input
--
set enable_hashjoin to off;
set enable_nestloop to off;
explain (verbose, costs off)
  select a.q2, b.q1
    from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)
    where coalesce(b.q1, 1) > 0;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: a.q2, b.q1
   Node/s: datanode_1
   Remote query: SELECT a.q2, b.q1 FROM (public.int8_tbl a LEFT JOIN public.int8_tbl b ON ((a.q2 = COALESCE(b.q1, (1)::bigint)))) WHERE (COALESCE(b.q1, (1)::bigint) > 0)
   ->  Merge Left Join
         Output: a.q2, b.q1
         Merge Cond: (a.q2 = (COALESCE(b.q1, '1'::bigint)))
         Filter: (COALESCE(b.q1, '1'::bigint) > 0)
         ->  Sort
               Output: a.q2
               Sort Key: a.q2
               ->  Seq Scan on public.int8_tbl a
                     Output: a.q2
         ->  Sort
               Output: b.q1, (COALESCE(b.q1, '1'::bigint))
               Sort Key: (COALESCE(b.q1, '1'::bigint))
               ->  Seq Scan on public.int8_tbl b
                     Output: b.q1, COALESCE(b.q1, '1'::bigint)
(18 rows)

select a.q2, b.q1
  from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)
  where coalesce(b.q1, 1) > 0;
        q2         |        q1        
-------------------+------------------
 -4567890123456789 |                 
               123 |              123
               123 |              123
               456 |                 
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
  4567890123456789 | 4567890123456789
(10 rows)

reset enable_hashjoin;
reset enable_nestloop;
--
-- test join removal
--
begin;
CREATE TEMP TABLE a (id int PRIMARY KEY, b_id int);
CREATE TEMP TABLE b (id int PRIMARY KEY, c_id int);
CREATE TEMP TABLE c (id int PRIMARY KEY);
CREATE TEMP TABLE d (a int, b int);
INSERT INTO a VALUES (0, 0), (1, NULL);
INSERT INTO b VALUES (0, 0), (1, NULL);
INSERT INTO c VALUES (0), (1);
INSERT INTO d VALUES (1,3), (2,2), (3,1);
-- all three cases should be optimizable into a simple seqscan
explain (verbose false, costs false, nodes false) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   ->  Seq Scan on a
(2 rows)

explain (verbose false, costs false, nodes false) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   ->  Seq Scan on b
(2 rows)

explain (verbose false, costs false, nodes false)
  SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)
  ON (a.b_id = b.id);
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   ->  Seq Scan on a
(2 rows)

-- check optimization of outer join within another special join
explain (verbose false, costs false, nodes false)
select id from a where id in (
	select b.id from b left join c on b.id = c.id
);
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   ->  Hash Join
         Hash Cond: (a.id = b.id)
         ->  Seq Scan on a
         ->  Hash
               ->  Seq Scan on b
(6 rows)

-- check that join removal works for a left join when joining a subquery
-- that is guaranteed to be unique by its GROUP BY clause
explain (costs off)
select d.* from d left join (select * from b group by b.id, b.c_id) s
  on d.a = s.id and d.b = s.c_id;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Seq Scan on d
(3 rows)

-- similarly, but keying off a DISTINCT clause
explain (costs off)
select d.* from d left join (select distinct * from b) s
  on d.a = s.id and d.b = s.c_id;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Seq Scan on d
(3 rows)

-- join removal is not possible when the GROUP BY contains a column that is
-- not in the join condition.  (Note: as of 9.6, we notice that b.id is a
-- primary key and so drop b.c_id from the GROUP BY of the resulting plan;
-- but this happens too late for join removal in the outer plan level.)
explain (costs off)
select d.* from d left join (select * from b group by b.id, b.c_id) s
  on d.a = s.id;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Merge Right Join
         Merge Cond: (b.id = d.a)
         ->  Group
               Group Key: b.id
               ->  Index Scan using b_pkey on b
         ->  Sort
               Sort Key: d.a
               ->  Seq Scan on d
(10 rows)

-- similarly, but keying off a DISTINCT clause
explain (costs off)
select d.* from d left join (select distinct * from b) s
  on d.a = s.id;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Merge Right Join
         Merge Cond: (b.id = d.a)
         ->  Unique
               ->  Sort
                     Sort Key: b.id, b.c_id
                     ->  Seq Scan on b
         ->  Sort
               Sort Key: d.a
               ->  Seq Scan on d
(11 rows)

-- check join removal works when uniqueness of the join condition is enforced
-- by a UNION
explain (costs off)
select d.* from d left join (select id from a union select id from b) s
  on d.a = s.id;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Seq Scan on d
(3 rows)

-- check join removal with a cross-type comparison operator
-- commenting out queries on replicated tables
-- as they can go either on datanode_1 or datanode_2
--explain (costs off)
--select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4
  --on i8.q1 = i4.f1;
rollback;
create temp table parent (k int primary key, pd int);
create temp table child (k int unique, cd int);
insert into parent values (1, 10), (2, 20), (3, 30);
insert into child values (1, 100), (4, 400);
-- this case is optimizable
select p.* from parent p left join child c on (p.k = c.k) order by 1,2;
 k | pd 
---+----
 1 | 10
 2 | 20
 3 | 30
(3 rows)

explain (verbose false, costs false, nodes false)
  select p.* from parent p left join child c on (p.k = c.k) order by 1,2;
                QUERY PLAN                 
-------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   Sort Key: p.k, p.pd
   ->  Sort
         Sort Key: p.k, p.pd
         ->  Seq Scan on parent p
(5 rows)

-- this case is not
select p.*, linked from parent p
  left join (select c.*, true as linked from child c) as ss
  on (p.k = ss.k) order by p.k;
 k | pd | linked 
---+----+--------
 1 | 10 | t
 2 | 20 | 
 3 | 30 | 
(3 rows)

explain (verbose false, costs false, nodes false)
  select p.*, linked from parent p
    left join (select c.*, true as linked from child c) as ss
    on (p.k = ss.k) order by p.k;
                 QUERY PLAN                  
---------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   Sort Key: p.k
   ->  Sort
         Sort Key: p.k
         ->  Hash Left Join
               Hash Cond: (p.k = c.k)
               ->  Seq Scan on parent p
               ->  Hash
                     ->  Seq Scan on child c
(9 rows)

-- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling
select p.* from
  parent p left join child c on (p.k = c.k)
  where p.k = 1 and p.k = 2;
 k | pd 
---+----
(0 rows)

explain (verbose false, costs false, nodes false)
select p.* from
  parent p left join child c on (p.k = c.k)
  where p.k = 1 and p.k = 2;
           QUERY PLAN           
--------------------------------
 Remote Fast Query Execution
   ->  Result
         One-Time Filter: false
(3 rows)

select p.* from
  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
  where p.k = 1 and p.k = 2;
 k | pd 
---+----
(0 rows)

explain (verbose false, costs false, nodes false)
select p.* from
  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
  where p.k = 1 and p.k = 2;
           QUERY PLAN           
--------------------------------
 Remote Fast Query Execution
   ->  Result
         One-Time Filter: false
(3 rows)

-- bug 5255: this is not optimizable by join removal
begin;
CREATE TEMP TABLE a (id int PRIMARY KEY);
CREATE TEMP TABLE b (id int PRIMARY KEY, a_id int);
INSERT INTO a VALUES (0), (1);
INSERT INTO b VALUES (0, 0), (1, NULL);
SELECT * FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
 id | a_id | id 
----+------+----
  1 |      |   
(1 row)

SELECT b.* FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
 id | a_id 
----+------
  1 |     
(1 row)

rollback;
-- another join removal bug: this is not optimizable, either
begin;
create temp table innertab (id int8 primary key, dat1 int8);
insert into innertab values(123, 42);
SELECT * FROM
    (SELECT 1 AS x) ss1
  LEFT JOIN
    (SELECT q1, q2, COALESCE(dat1, q1) AS y
     FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2
  ON true order by 1, 2, 3, 4;
 x |        q1        |        q2         |        y         
---+------------------+-------------------+------------------
 1 |              123 |               456 |              123
 1 |              123 |  4567890123456789 |              123
 1 | 4567890123456789 | -4567890123456789 | 4567890123456789
 1 | 4567890123456789 |               123 |               42
 1 | 4567890123456789 |  4567890123456789 | 4567890123456789
(5 rows)

rollback;
-- another join removal bug: we must clean up correctly when removing a PHV
begin;
create temp table uniquetbl (f1 text unique);
explain (costs off)
select t1.* from
  uniquetbl as t1
  left join (select *, '***'::text as d1 from uniquetbl) t2
  on t1.f1 = t2.f1
  left join uniquetbl t3
  on t2.d1 = t3.f1;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Seq Scan on uniquetbl t1
(3 rows)

explain (costs off)
select t0.*
from
 text_tbl t0
 left join
   (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,
           t1.stringu2
     from tenk1 t1
     join int4_tbl i4 ON i4.f1 = t1.unique2
     left join uniquetbl u1 ON u1.f1 = t1.string4) ss
  on t0.f1 = ss.case1
where ss.stringu2 !~* ss.case1;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Nested Loop
         Join Filter: ((CASE t1.ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END) = t0.f1)
         ->  Seq Scan on text_tbl t0
         ->  Materialize
               ->  Remote Subquery Scan on all (datanodes 2)
                     Distribute results by H: (CASE ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END)
                     ->  Nested Loop
                           ->  Seq Scan on int4_tbl i4
                           ->  Index Scan using tenk1_unique2 on tenk1 t1
                                 Index Cond: (unique2 = i4.f1)
                                 Filter: (stringu2 !~* CASE ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END)
(12 rows)

select t0.*
from
 text_tbl t0
 left join
   (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,
           t1.stringu2
     from tenk1 t1
     join int4_tbl i4 ON i4.f1 = t1.unique2
     left join uniquetbl u1 ON u1.f1 = t1.string4) ss
  on t0.f1 = ss.case1
where ss.stringu2 !~* ss.case1;
  f1  
------
 doh!
(1 row)

rollback;
-- bug #8444: we've historically allowed duplicate aliases within aliased JOINs
select * from
  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1; -- error
ERROR:  column reference "f1" is ambiguous
LINE 2: ..._tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1;
                                                                    ^
select * from
  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1; -- error
ERROR:  invalid reference to FROM-clause entry for table "y"
LINE 2: ...bl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1;
                                                                  ^
HINT:  There is an entry for table "y", but it cannot be referenced from this part of the query.
select * from
  int8_tbl x join (int4_tbl x cross join int4_tbl y(ff)) j on q1 = f1; -- ok
 q1 | q2 | f1 | ff 
----+----+----+----
(0 rows)

--
-- Test hints given on incorrect column references are useful
--
select t1.uunique1 from
  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer "t1" suggestion
ERROR:  column t1.uunique1 does not exist
LINE 1: select t1.uunique1 from
               ^
HINT:  Perhaps you meant to reference the column "t1.unique1".
select t2.uunique1 from
  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer "t2" suggestion
ERROR:  column t2.uunique1 does not exist
LINE 1: select t2.uunique1 from
               ^
HINT:  Perhaps you meant to reference the column "t2.unique1".
select uunique1 from
  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, suggest both at once
ERROR:  column "uunique1" does not exist
LINE 1: select uunique1 from
               ^
HINT:  Perhaps you meant to reference the column "t1.unique1" or the column "t2.unique1".
--
-- Take care to reference the correct RTE
--
select atts.relid::regclass, s.* from pg_stats s join
    pg_attribute a on s.attname = a.attname and s.tablename =
    a.attrelid::regclass::text join (select unnest(indkey) attnum,
    indexrelid from pg_index i) atts on atts.attnum = a.attnum where
    schemaname != 'pg_catalog';
ERROR:  column atts.relid does not exist
LINE 1: select atts.relid::regclass, s.* from pg_stats s join
               ^
--
-- Test LATERAL
--
select unique2, x.*
from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
 unique2 | f1 
---------+----
    9998 |  0
(1 row)

explain (costs off)
  select unique2, x.*
  from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Nested Loop
         ->  Seq Scan on int4_tbl b
         ->  Index Scan using tenk1_unique1 on tenk1 a
               Index Cond: (unique1 = b.f1)
(6 rows)

select unique2, x.*
from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
 unique2 | f1 
---------+----
    9998 |  0
(1 row)

explain (costs off)
  select unique2, x.*
  from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Nested Loop
         ->  Seq Scan on int4_tbl x
         ->  Index Scan using tenk1_unique1 on tenk1
               Index Cond: (unique1 = x.f1)
(6 rows)

explain (costs off)
  select unique2, x.*
  from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Nested Loop
         ->  Seq Scan on int4_tbl x
         ->  Index Scan using tenk1_unique1 on tenk1
               Index Cond: (unique1 = x.f1)
(6 rows)

select unique2, x.*
from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true order by 2;
 unique2 |     f1      
---------+-------------
         | -2147483647
         |     -123456
    9998 |           0
         |      123456
         |  2147483647
(5 rows)

--explain (costs off)
  --select unique2, x.*
  --from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
-- check scoping of lateral versus parent references
-- the first of these should return int8_tbl.q2, the second int8_tbl.q1
select *, (select r from (select q1 as q2) x, (select q2 as r) y) from int8_tbl order by 1,2,3;
        q1        |        q2         |         r         
------------------+-------------------+-------------------
              123 |               456 |               456
              123 |  4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789 | -4567890123456789
 4567890123456789 |               123 |               123
 4567890123456789 |  4567890123456789 |  4567890123456789
(5 rows)

select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from int8_tbl order by 1,2,3;
        q1        |        q2         |        r         
------------------+-------------------+------------------
              123 |               456 |              123
              123 |  4567890123456789 |              123
 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 |               123 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789
(5 rows)

-- lateral with function in FROM
select count(*) from tenk1 a, lateral generate_series(1,two) g;
 count 
-------
  5000
(1 row)

explain (costs off)
  select count(*) from tenk1 a, lateral generate_series(1,two) g;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Seq Scan on tenk1 a
         ->  Function Scan on generate_series g
(5 rows)

explain (costs off)
  select count(*) from tenk1 a cross join lateral generate_series(1,two) g;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Seq Scan on tenk1 a
         ->  Function Scan on generate_series g
(5 rows)

-- don't need the explicit LATERAL keyword for functions
explain (costs off)
  select count(*) from tenk1 a, generate_series(1,two) g;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Seq Scan on tenk1 a
         ->  Function Scan on generate_series g
(5 rows)

-- lateral with UNION ALL subselect
explain (num_nodes off, nodes off, costs off)
  select * from generate_series(100,200) g,
    lateral (select * from int8_tbl a where g = q1 union all
             select * from int8_tbl b where g = q2) ss;
                   QUERY PLAN                    
-------------------------------------------------
 Nested Loop
   ->  Function Scan on generate_series g
   ->  Remote Subquery Scan on all (datanodes 1)
         ->  Append
               ->  Seq Scan on int8_tbl a
                     Filter: (g.g = q1)
               ->  Seq Scan on int8_tbl b
                     Filter: (g.g = q2)
(8 rows)

select * from generate_series(100,200) g,
  lateral (select * from int8_tbl a where g = q1 union all
           select * from int8_tbl b where g = q2) ss;
  g  |        q1        |        q2        
-----+------------------+------------------
 123 |              123 |              456
 123 |              123 | 4567890123456789
 123 | 4567890123456789 |              123
(3 rows)

-- lateral with VALUES
set enable_indexonlyscan to off;
explain (num_nodes off, nodes off, costs off)
  select count(*) from tenk1 a,
    tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (b.unique2 = a.unique1)
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by H: unique2
                           ->  Seq Scan on tenk1 b
                     ->  Hash
                           ->  Seq Scan on tenk1 a
(10 rows)

select count(*) from tenk1 a,
  tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
 count 
-------
 10000
(1 row)

-- lateral with VALUES, no flattening possible
explain (num_nodes off, nodes off, costs off)
  select count(*) from tenk1 a,
    tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: ("*VALUES*".column1 = b.unique2)
         ->  Nested Loop
               ->  Remote Subquery Scan on all (datanodes 2)
                     ->  Seq Scan on tenk1 a
               ->  Values Scan on "*VALUES*"
         ->  Hash
               ->  Remote Subquery Scan on all (datanodes 2)
                     ->  Seq Scan on tenk1 b
(10 rows)

select count(*) from tenk1 a,
  tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;
 count 
-------
 10000
(1 row)

reset enable_indexonlyscan;
-- lateral injecting a strange outer join condition
set enable_hashjoin to off;
set enable_mergejoin to off;
explain (num_nodes off, nodes off, costs off)
  select * from int8_tbl a,
    int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
      on x.q2 = ss.z
  order by a.q1, a.q2, x.q1, x.q2, ss.z;
                      QUERY PLAN                      
------------------------------------------------------
 Remote Fast Query Execution
   ->  Sort
         Sort Key: a.q1, a.q2, x.q1, x.q2, (a.q1)
         ->  Nested Loop
               ->  Seq Scan on int8_tbl a
               ->  Nested Loop Left Join
                     Join Filter: (x.q2 = (a.q1))
                     ->  Seq Scan on int8_tbl x
                     ->  Materialize
                           ->  Seq Scan on int4_tbl y
(10 rows)

select * from int8_tbl a,
  int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
    on x.q2 = ss.z
  order by a.q1, a.q2, x.q1, x.q2, ss.z;
        q1        |        q2         |        q1        |        q2         |        z         
------------------+-------------------+------------------+-------------------+------------------
              123 |               456 |              123 |               456 |                 
              123 |               456 |              123 |  4567890123456789 |                 
              123 |               456 | 4567890123456789 | -4567890123456789 |                 
              123 |               456 | 4567890123456789 |               123 |              123
              123 |               456 | 4567890123456789 |               123 |              123
              123 |               456 | 4567890123456789 |               123 |              123
              123 |               456 | 4567890123456789 |               123 |              123
              123 |               456 | 4567890123456789 |               123 |              123
              123 |               456 | 4567890123456789 |  4567890123456789 |                 
              123 |  4567890123456789 |              123 |               456 |                 
              123 |  4567890123456789 |              123 |  4567890123456789 |                 
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |                 
              123 |  4567890123456789 | 4567890123456789 |               123 |              123
              123 |  4567890123456789 | 4567890123456789 |               123 |              123
              123 |  4567890123456789 | 4567890123456789 |               123 |              123
              123 |  4567890123456789 | 4567890123456789 |               123 |              123
              123 |  4567890123456789 | 4567890123456789 |               123 |              123
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |                 
 4567890123456789 | -4567890123456789 |              123 |               456 |                 
 4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789 | -4567890123456789 |                 
 4567890123456789 | -4567890123456789 | 4567890123456789 |               123 |                 
 4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |               456 |                 
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 | 4567890123456789 | -4567890123456789 |                 
 4567890123456789 |               123 | 4567890123456789 |               123 |                 
 4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 |              123 |               456 |                 
 4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 |                 
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 |                 
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
(57 rows)

reset enable_hashjoin;
reset enable_mergejoin;
-- lateral reference to a join alias variable
select * from (select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
  lateral (select x) ss2(y);
 x | f1 | y 
---+----+---
 0 |  0 | 0
(1 row)

select * from (select f1 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
  lateral (values(x)) ss2(y) order by 1;
      x      |     f1      |      y      
-------------+-------------+-------------
 -2147483647 | -2147483647 | -2147483647
     -123456 |     -123456 |     -123456
           0 |           0 |           0
      123456 |      123456 |      123456
  2147483647 |  2147483647 |  2147483647
(5 rows)

select * from ((select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1) j,
  lateral (select x) ss2(y);
 x | f1 | y 
---+----+---
 0 |  0 | 0
(1 row)

-- lateral references requiring pullup
select * from (values(1)) x(lb),
  lateral generate_series(lb,4) x4;
 lb | x4 
----+----
  1 |  1
  1 |  2
  1 |  3
  1 |  4
(4 rows)

select * from (select f1/1000000000 from int4_tbl) x(lb),
  lateral generate_series(lb,4) x4 order by 1,2;
 lb | x4 
----+----
 -2 | -2
 -2 | -1
 -2 |  0
 -2 |  1
 -2 |  2
 -2 |  3
 -2 |  4
  0 |  0
  0 |  0
  0 |  0
  0 |  1
  0 |  1
  0 |  1
  0 |  2
  0 |  2
  0 |  2
  0 |  3
  0 |  3
  0 |  3
  0 |  4
  0 |  4
  0 |  4
  2 |  2
  2 |  3
  2 |  4
(25 rows)

select * from (values(1)) x(lb),
  lateral (values(lb)) y(lbcopy);
 lb | lbcopy 
----+--------
  1 |      1
(1 row)

select * from (values(1)) x(lb),
  lateral (select lb from int4_tbl) y(lbcopy);
 lb | lbcopy 
----+--------
  1 |      1
  1 |      1
  1 |      1
  1 |      1
  1 |      1
(5 rows)

select * from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);
        q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
              123 |               456 |                  |                   |              123 |                  |                  
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
              123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
 4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
 4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
(10 rows)

select * from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
        q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
              123 |               456 |                  |                   |              123 |                  |                  
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
              123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
 4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
 4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
(10 rows)

select x.* from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
        q1        |        q2         
------------------+-------------------
              123 |               456
              123 |  4567890123456789
              123 |  4567890123456789
              123 |  4567890123456789
 4567890123456789 |               123
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
 4567890123456789 |  4567890123456789
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(10 rows)

select v.* from
  (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy)
  order by vx, vy;
        vx         |        vy         
-------------------+-------------------
 -4567890123456789 |                  
               123 |               456
               123 |  4567890123456789
               123 |  4567890123456789
               123 |  4567890123456789
               123 |  4567890123456789
               123 |                  
               456 |                  
  4567890123456789 | -4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |               123
  4567890123456789 |               123
  4567890123456789 |               123
  4567890123456789 |               123
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |                  
(20 rows)

select v.* from
  (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy)
  order by vx, vy;
        vx         |        vy         
-------------------+-------------------
 -4567890123456789 |                  
               123 |               456
               123 |  4567890123456789
               123 |  4567890123456789
               123 |  4567890123456789
               123 |  4567890123456789
               123 |                  
               456 |                  
  4567890123456789 | -4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |               123
  4567890123456789 |               123
  4567890123456789 |               123
  4567890123456789 |               123
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |                  
(20 rows)

create temp table dual();
insert into dual default values;
analyze dual;
select v.* from
  (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 from dual union all select x.q2,y.q2 from dual) v(vx,vy)
  order by vx, vy;
        vx         |        vy         
-------------------+-------------------
 -4567890123456789 |                  
               123 |               456
               123 |  4567890123456789
               123 |  4567890123456789
               123 |  4567890123456789
               123 |  4567890123456789
               123 |                  
               456 |                  
  4567890123456789 | -4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |               123
  4567890123456789 |               123
  4567890123456789 |               123
  4567890123456789 |               123
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |                  
(20 rows)

explain (verbose, num_nodes off, nodes off, costs off)
select * from
  int8_tbl a left join
  lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: a.q1, a.q2, ss.q1, ss.q2, ss.x
   Remote query: SELECT a.q1, a.q2, ss.q1, ss.q2, ss.x FROM (public.int8_tbl a LEFT JOIN LATERAL (SELECT b.q1, b.q2, a.q2 AS x FROM public.int8_tbl b) ss ON ((a.q2 = ss.q1)))
   ->  Nested Loop Left Join
         Output: a.q1, a.q2, b.q1, b.q2, (a.q2)
         ->  Seq Scan on public.int8_tbl a
               Output: a.q1, a.q2
         ->  Seq Scan on public.int8_tbl b
               Output: b.q1, b.q2, a.q2
               Filter: (a.q2 = b.q1)
(10 rows)

select * from
  int8_tbl a left join
  lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
        q1        |        q2         |        q1        |        q2         |        x         
------------------+-------------------+------------------+-------------------+------------------
              123 |               456 |                  |                   |                 
              123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |               456 |              123
 4567890123456789 |               123 |              123 |  4567890123456789 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |                  |                   |                 
(10 rows)

--explain (verbose, costs off)
--select * from
  --int8_tbl a left join
  --lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
select * from
  int8_tbl a left join
  lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
        q1        |        q2         |        q1        |        q2         |        x         
------------------+-------------------+------------------+-------------------+------------------
              123 |               456 |                  |                   |                 
              123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 |               123 |              123 |               456 |              123
 4567890123456789 |               123 |              123 |  4567890123456789 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |                  |                   |                 
(10 rows)

-- lateral can result in join conditions appearing below their
-- real semantic level
set enable_nestloop to on;
set enable_hashjoin to off;
set enable_mergejoin to off;
explain (num_nodes off, nodes off, verbose, costs off)
select * from int4_tbl i left join
  lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
                        QUERY PLAN                        
----------------------------------------------------------
 Remote Subquery Scan[1] on all (datanodes 2)
   Output: i.f1, j.f1
   ->  Nested Loop Left Join
         Output: i.f1, j.f1
         Join Filter: (i.f1 = j.f1)
         ->  Remote Subquery Scan[2] on all (datanodes 1)
               Output: i.f1
               Distribute results by H: f1
               ->  Seq Scan on public.int4_tbl i
                     Output: i.f1
         ->  Materialize
               Output: j.f1
               ->  Seq Scan on public.int2_tbl j
                     Output: j.f1
(14 rows)

select * from int4_tbl i left join
  lateral (select * from int2_tbl j where i.f1 = j.f1) k on true order by 1;
     f1      | f1 
-------------+----
 -2147483647 |   
     -123456 |   
           0 |  0
      123456 |   
  2147483647 |   
(5 rows)

reset enable_nestloop;
reset enable_hashjoin;
reset enable_mergejoin;
explain (num_nodes off, nodes off, verbose, costs off)
select * from int4_tbl i left join
  lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
                        QUERY PLAN                        
----------------------------------------------------------
 Remote Subquery Scan[1] on all (datanodes 2)
   Output: i.f1, (COALESCE(i.*))
   ->  Nested Loop Left Join
         Output: i.f1, (COALESCE(i.*))
         ->  Remote Subquery Scan[2] on all (datanodes 1)
               Output: i.f1, i.*
               Distribute results by H: f1
               ->  Seq Scan on public.int4_tbl i
                     Output: i.f1, i.*
         ->  Seq Scan on public.int2_tbl j
               Output: j.f1, COALESCE(i.*)
               Filter: (i.f1 = j.f1)
(12 rows)

select * from int4_tbl i left join
  lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true order by 1;
     f1      | coalesce 
-------------+----------
 -2147483647 | 
     -123456 | 
           0 | (0)
      123456 | 
  2147483647 | 
(5 rows)

explain (num_nodes off, nodes off, verbose, costs off)
select * from int4_tbl a,
  lateral (
    select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
  ) ss;
                                                                                                QUERY PLAN                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: a.f1, ss.f1, ss.q1, ss.q2
   Remote query: SELECT a.f1, ss.f1, ss.q1, ss.q2 FROM public.int4_tbl a, LATERAL (SELECT b.f1, c.q1, c.q2 FROM (public.int4_tbl b LEFT JOIN public.int8_tbl c ON (((b.f1 = c.q1) AND (a.f1 = c.q2))))) ss
   ->  Nested Loop
         Output: a.f1, b.f1, c.q1, c.q2
         ->  Seq Scan on public.int4_tbl a
               Output: a.f1
         ->  Hash Right Join
               Output: b.f1, c.q1, c.q2
               Hash Cond: (c.q1 = b.f1)
               ->  Seq Scan on public.int8_tbl c
                     Output: c.q1, c.q2
                     Filter: (a.f1 = c.q2)
               ->  Hash
                     Output: b.f1
                     ->  Seq Scan on public.int4_tbl b
                           Output: b.f1
(17 rows)

select * from int4_tbl a,
  lateral (
    select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
  ) ss order by 1,2,3,4;
     f1      |     f1      | q1 | q2 
-------------+-------------+----+----
 -2147483647 | -2147483647 |    |   
 -2147483647 |     -123456 |    |   
 -2147483647 |           0 |    |   
 -2147483647 |      123456 |    |   
 -2147483647 |  2147483647 |    |   
     -123456 | -2147483647 |    |   
     -123456 |     -123456 |    |   
     -123456 |           0 |    |   
     -123456 |      123456 |    |   
     -123456 |  2147483647 |    |   
           0 | -2147483647 |    |   
           0 |     -123456 |    |   
           0 |           0 |    |   
           0 |      123456 |    |   
           0 |  2147483647 |    |   
      123456 | -2147483647 |    |   
      123456 |     -123456 |    |   
      123456 |           0 |    |   
      123456 |      123456 |    |   
      123456 |  2147483647 |    |   
  2147483647 | -2147483647 |    |   
  2147483647 |     -123456 |    |   
  2147483647 |           0 |    |   
  2147483647 |      123456 |    |   
  2147483647 |  2147483647 |    |   
(25 rows)

-- lateral reference in a PlaceHolderVar evaluated at join level
explain (num_nodes off, nodes off, verbose, costs off)
select * from
  int8_tbl a left join lateral
  (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
   int8_tbl b cross join int8_tbl c) ss
  on a.q2 = ss.bq1;
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: a.q1, a.q2, ss.bq1, ss.cq1, ss."least"
   Remote query: SELECT a.q1, a.q2, ss.bq1, ss.cq1, ss."least" FROM (public.int8_tbl a LEFT JOIN LATERAL (SELECT b.q1 AS bq1, c.q1 AS cq1, LEAST(a.q1, b.q1, c.q1) AS "least" FROM (public.int8_tbl b CROSS JOIN public.int8_tbl c)) ss ON ((a.q2 = ss.bq1)))
   ->  Nested Loop Left Join
         Output: a.q1, a.q2, b.q1, c.q1, (LEAST(a.q1, b.q1, c.q1))
         ->  Seq Scan on public.int8_tbl a
               Output: a.q1, a.q2
         ->  Nested Loop
               Output: b.q1, c.q1, LEAST(a.q1, b.q1, c.q1)
               ->  Seq Scan on public.int8_tbl b
                     Output: b.q1, b.q2
                     Filter: (a.q2 = b.q1)
               ->  Seq Scan on public.int8_tbl c
                     Output: c.q1, c.q2
(14 rows)

select * from
  int8_tbl a left join lateral
  (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
   int8_tbl b cross join int8_tbl c) ss
  on a.q2 = ss.bq1;
        q1        |        q2         |       bq1        |       cq1        |      least       
------------------+-------------------+------------------+------------------+------------------
              123 |               456 |                  |                  |                 
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 |              123 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
              123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 |              123 |              123
 4567890123456789 |               123 |              123 |              123 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 |              123 |              123
 4567890123456789 |               123 |              123 |              123 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |               123 |              123 | 4567890123456789 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
 4567890123456789 | -4567890123456789 |                  |                  |                 
(42 rows)

-- case requiring nested PlaceHolderVars
explain (num_nodes off, nodes off, verbose, costs off)
select * from
  int8_tbl c left join (
    int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1
      on a.q2 = ss1.q1
    cross join
    lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
  ) on c.q2 = ss2.q1,
  lateral (select ss2.y offset 0) ss3;
                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: c.q1, c.q2, a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint)), d.q1, (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)), ((COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)))
   ->  Remote Subquery Scan[1] on all (datanodes 1)
         Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, '42'::bigint)), (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
         ->  Hash Right Join
               Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, '42'::bigint)), (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
               Hash Cond: (d.q1 = c.q2)
               ->  Nested Loop
                     Output: a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, '42'::bigint)), (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
                     ->  Hash Left Join
                           Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint))
                           Hash Cond: (a.q2 = b.q1)
                           ->  Seq Scan on public.int8_tbl a
                                 Output: a.q1, a.q2
                           ->  Hash
                                 Output: b.q1, (COALESCE(b.q2, '42'::bigint))
                                 ->  Seq Scan on public.int8_tbl b
                                       Output: b.q1, COALESCE(b.q2, '42'::bigint)
                     ->  Seq Scan on public.int8_tbl d
                           Output: d.q1, COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)
               ->  Hash
                     Output: c.q1, c.q2
                     ->  Seq Scan on public.int8_tbl c
                           Output: c.q1, c.q2
   ->  Result
         Output: (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
(26 rows)

-- case that breaks the old ph_may_need optimization
explain (num_nodes off, nodes off, verbose, costs off)
select c.*,a.*,ss1.q1,ss2.q1,ss3.* from
  int8_tbl c left join (
    int8_tbl a left join
      (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2
       where q1 < f1) ss1
      on a.q2 = ss1.q1
    cross join
    lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
  ) on c.q2 = ss2.q1,
  lateral (select * from int4_tbl i where ss2.y > f1) ss3;
                                                                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: c.q1, c.q2, a.q1, a.q2, ss1.q1, ss2.q1, ss3.f1
   Remote query: SELECT c.q1, c.q2, a.q1, a.q2, ss1.q1, ss2.q1, ss3.f1 FROM (public.int8_tbl c LEFT JOIN ((public.int8_tbl a LEFT JOIN (SELECT b.q1, COALESCE(b.q2, (b2.f1)::bigint) AS x FROM public.int8_tbl b, public.int4_tbl b2 WHERE (b.q1 < b2.f1)) ss1 ON ((a.q2 = ss1.q1))) CROSS JOIN LATERAL (SELECT d.q1, COALESCE(ss1.x, d.q2) AS y FROM public.int8_tbl d) ss2) ON ((c.q2 = ss2.q1))), LATERAL (SELECT i.f1 FROM public.int4_tbl i WHERE (ss2.y > i.f1)) ss3
   ->  Nested Loop
         Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, i.f1
         Join Filter: ((COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)) > i.f1)
         ->  Hash Right Join
               Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
               Hash Cond: (d.q1 = c.q2)
               ->  Nested Loop
                     Output: a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
                     ->  Hash Right Join
                           Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, (b2.f1)::bigint))
                           Hash Cond: (b.q1 = a.q2)
                           ->  Nested Loop
                                 Output: b.q1, COALESCE(b.q2, (b2.f1)::bigint)
                                 Join Filter: (b.q1 < b2.f1)
                                 ->  Seq Scan on public.int8_tbl b
                                       Output: b.q1, b.q2
                                 ->  Materialize
                                       Output: b2.f1
                                       ->  Seq Scan on public.int4_tbl b2
                                             Output: b2.f1
                           ->  Hash
                                 Output: a.q1, a.q2
                                 ->  Seq Scan on public.int8_tbl a
                                       Output: a.q1, a.q2
                     ->  Seq Scan on public.int8_tbl d
                           Output: d.q1, COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)
               ->  Hash
                     Output: c.q1, c.q2
                     ->  Seq Scan on public.int8_tbl c
                           Output: c.q1, c.q2
         ->  Materialize
               Output: i.f1
               ->  Seq Scan on public.int4_tbl i
                     Output: i.f1
(37 rows)

-- check processing of postponed quals (bug #9041)
explain (num_nodes off, nodes off, verbose, costs off)
select * from
  (select 1 as x offset 0) x cross join (select 2 as y offset 0) y
  left join lateral (
    select * from (select 3 as z offset 0) z where z.z = x.x
  ) zz on zz.z = y.y;
                  QUERY PLAN                  
----------------------------------------------
 Nested Loop Left Join
   Output: (1), (2), (3)
   Join Filter: (((3) = (1)) AND ((3) = (2)))
   ->  Nested Loop
         Output: (1), (2)
         ->  Result
               Output: 1
         ->  Result
               Output: 2
   ->  Result
         Output: 3
(11 rows)

-- check handling of nested appendrels inside LATERAL
select * from
  ((select 2 as v) union all (select 3 as v)) as q1
  cross join lateral
  ((select * from
      ((select 4 as v) union all (select 5 as v)) as q3)
   union all
   (select q1.v)
  ) as q2;
 v | v 
---+---
 2 | 4
 2 | 5
 2 | 2
 3 | 4
 3 | 5
 3 | 3
(6 rows)

-- check we don't try to do a unique-ified semijoin with LATERAL
explain (verbose, costs off, nodes off)
select * from
  (values (0,9998), (1,1000)) v(id,x),
  lateral (select f1 from int4_tbl
           where f1 = any (select unique1 from tenk1
                           where unique2 = v.x offset 0)) ss;
                                                                                                                   QUERY PLAN                                                                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Output: v.id, v.x, ss.f1
   Remote query: SELECT v.id, v.x, ss.f1 FROM (VALUES (0,9998), (1,1000)) v(id, x), LATERAL (SELECT int4_tbl.f1 FROM public.int4_tbl WHERE (int4_tbl.f1 IN (SELECT tenk1.unique1 FROM public.tenk1 WHERE (tenk1.unique2 = v.x) OFFSET (0)))) ss
   ->  Nested Loop
         Output: "*VALUES*".column1, "*VALUES*".column2, int4_tbl.f1
         ->  Values Scan on "*VALUES*"
               Output: "*VALUES*".column1, "*VALUES*".column2
         ->  Hash Right Semi Join
               Output: int4_tbl.f1
               Hash Cond: (tenk1.unique1 = int4_tbl.f1)
               ->  Seq Scan on public.tenk1
                     Output: tenk1.unique1
                     Filter: (tenk1.unique2 = "*VALUES*".column2)
               ->  Hash
                     Output: int4_tbl.f1
                     ->  Seq Scan on public.int4_tbl
                           Output: int4_tbl.f1
(17 rows)

select * from
  (values (0,9998), (1,1000)) v(id,x),
  lateral (select f1 from int4_tbl
           where f1 = any (select unique1 from tenk1
                           where unique2 = v.x offset 0)) ss;
 id |  x   | f1 
----+------+----
  0 | 9998 |  0
(1 row)

-- check proper extParam/allParam handling (this isn't exactly a LATERAL issue,
-- but we can make the test case much more compact with LATERAL)
explain (verbose, costs off)
select * from (values (0), (1)) v(id),
lateral (select * from int8_tbl t1,
         lateral (select * from
                    (select * from int8_tbl t2
                     where q1 = any (select q2 from int8_tbl t3
                                     where q2 = (select greatest(t1.q1,t2.q2))
                                       and (select v.id=0)) offset 0) ss2) ss
         where t1.q1 = ss.q2) ss0;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1)
   Output: "*VALUES*".column1, t1.q1, t1.q2, ss2.q1, ss2.q2
   Params Evaluated: $5
   ->  Nested Loop
         Output: "*VALUES*".column1, t1.q1, t1.q2, ss2.q1, ss2.q2
         ->  Seq Scan on public.int8_tbl t1
               Output: t1.q1, t1.q2
         ->  Nested Loop
               Output: "*VALUES*".column1, ss2.q1, ss2.q2
               ->  Values Scan on "*VALUES*"
                     Output: "*VALUES*".column1
               ->  Subquery Scan on ss2
                     Output: ss2.q1, ss2.q2
                     Filter: (t1.q1 = ss2.q2)
                     ->  Seq Scan on public.int8_tbl t2
                           Output: t2.q1, t2.q2
                           Filter: (SubPlan 3)
                           SubPlan 3
                             ->  Remote Subquery Scan[2] param[3] on all (datanode_1)
                                   Output: t3.q2
                                   Params Evaluated: $2, $4
                                   Distribute results by R
                                   InitPlan 1 (returns $2)
                                     ->  Result
                                           Output: GREATEST($0, t2.q2)
                                   InitPlan 2 (returns $4)
                                     ->  Result
                                           Output: ($3 = 0)
                                   ->  Result
                                         Output: t3.q2
                                         One-Time Filter: $4
                                         ->  Seq Scan on public.int8_tbl t3
                                               Output: t3.q1, t3.q2
                                               Filter: (t3.q2 = $2)
(34 rows)

select * from (values (0), (1)) v(id),
lateral (select * from int8_tbl t1,
         lateral (select * from
                    (select * from int8_tbl t2
                     where q1 = any (select q2 from int8_tbl t3
                                     where q2 = (select greatest(t1.q1,t2.q2))
                                       and (select v.id=0)) offset 0) ss2) ss
         where t1.q1 = ss.q2) ss0 order by 3;
 id |        q1        |        q2         |        q1        |        q2        
----+------------------+-------------------+------------------+------------------
  0 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789
  0 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789
  0 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789
(3 rows)

-- test some error cases where LATERAL should have been used but wasn't
select f1,g from int4_tbl a, (select f1 as g) ss;
ERROR:  column "f1" does not exist
LINE 1: select f1,g from int4_tbl a, (select f1 as g) ss;
                                             ^
HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
select f1,g from int4_tbl a, (select a.f1 as g) ss;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: select f1,g from int4_tbl a, (select a.f1 as g) ss;
                                             ^
HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
select f1,g from int4_tbl a cross join (select f1 as g) ss;
ERROR:  column "f1" does not exist
LINE 1: select f1,g from int4_tbl a cross join (select f1 as g) ss;
                                                       ^
HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
select f1,g from int4_tbl a cross join (select a.f1 as g) ss;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: select f1,g from int4_tbl a cross join (select a.f1 as g) ss...
                                                       ^
HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
-- SQL:2008 says the left table is in scope but illegal to access here
select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: ... int4_tbl a right join lateral generate_series(0, a.f1) g on...
                                                             ^
DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;
ERROR:  invalid reference to FROM-clause entry for table "a"
LINE 1: ...m int4_tbl a full join lateral generate_series(0, a.f1) g on...
                                                             ^
DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
-- check we complain about ambiguous table references
select * from
  int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);
ERROR:  table reference "x" is ambiguous
LINE 2: ...cross join (int4_tbl x cross join lateral (select x.f1) ss);
                                                             ^
-- LATERAL can be used to put an aggregate into the FROM clause of its query
select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;
ERROR:  aggregate functions are not allowed in FROM clause of their own query level
LINE 1: select 1 from tenk1 a, lateral (select max(a.unique1) from i...
                                               ^
-- check behavior of LATERAL in UPDATE/DELETE
create temp table xx1 as select f1 as x1, -f1 as x2 from int4_tbl;
-- error, can't do this:
update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
ERROR:  column "x1" does not exist
LINE 1: ... set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...t x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss...
                                                             ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
-- can't do it even with LATERAL:
update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...= f1 from lateral (select * from int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
-- we might in future allow something like this, but for now it's an error:
update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;
ERROR:  table name "xx1" specified more than once
-- also errors:
delete from xx1 using (select * from int4_tbl where f1 = x1) ss;
ERROR:  column "x1" does not exist
LINE 1: ...te from xx1 using (select * from int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss...
                                                             ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
ERROR:  invalid reference to FROM-clause entry for table "xx1"
LINE 1: ...xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
-- demonstrate problem with extrememly slow join
CREATE TABLE testr (a int, b int) DISTRIBUTE BY REPLICATION;
INSERT INTO testr SELECT generate_series(1, 10000), generate_series(5001, 15000);
CREATE TABLE testh (a int, b int);
INSERT INTO testh SELECT generate_series(1, 10000), generate_series(8001, 18000);
set enable_mergejoin TO false;
set enable_hashjoin TO false;
EXPLAIN (VERBOSE, COSTS OFF) SELECT count(*) FROM testr WHERE NOT EXISTS (SELECT * FROM testh WHERE testr.b = testh.b);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(*)
   ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)
         Output: (PARTIAL count(*))
         ->  Partial Aggregate
               Output: PARTIAL count(*)
               ->  Nested Loop Anti Join
                     Join Filter: (testr.b = testh.b)
                     ->  Remote Subquery Scan[2] on all (datanode_1)
                           Output: testr.b
                           Distribute results by S: b
                           ->  Seq Scan on public.testr
                                 Output: testr.b
                     ->  Materialize
                           Output: testh.b
                           ->  Remote Subquery Scan[3] on all (datanode_1,datanode_2)
                                 Output: testh.b
                                 Distribute results by S: b
                                 ->  Seq Scan on public.testh
                                       Output: testh.b
(20 rows)

SELECT count(*) FROM testr WHERE NOT EXISTS (SELECT * FROM testh WHERE testr.b = testh.b);
 count 
-------
  3000
(1 row)

--
-- test LATERAL reference propagation down a multi-level inheritance hierarchy
-- produced for a multi-level partitioned table hierarchy.
--
create table pt1 (a int, b int, c varchar) partition by range(a);
create table pt1p1 partition of pt1 for values from (0) to (100) partition by range(b);
create table pt1p2 partition of pt1 for values from (100) to (200);
create table pt1p1p1 partition of pt1p1 for values from (0) to (100);
insert into pt1 values (1, 1, 'x'), (101, 101, 'y');
create table ut1 (a int, b int, c varchar);
insert into ut1 values (101, 101, 'y'), (2, 2, 'z');
explain (verbose, costs off)
select t1.b, ss.phv from ut1 t1 left join lateral
              (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv
                     from pt1 t2 join ut1 t3 on t2.a = t3.b) ss
              on t1.a = ss.t2a order by t1.a;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1,datanode_2)
   Output: t1.b, (LEAST(t1.a, t2.a, t3.a)), t1.a
   Sort Key: t1.a
   ->  Sort
         Output: t1.b, (LEAST(t1.a, t2.a, t3.a)), t1.a
         Sort Key: t1.a
         ->  Nested Loop Left Join
               Output: t1.b, (LEAST(t1.a, t2.a, t3.a)), t1.a
               ->  Seq Scan on public.ut1 t1
                     Output: t1.a, t1.b, t1.c
               ->  Remote Subquery Scan[2] param[4] on all (datanode_1,datanode_2)
                     Output: t2.a, (LEAST(t1.a, t2.a, t3.a))
                     Distribute results by H: a
                     ->  Nested Loop
                           Output: t2.a, LEAST(t1.a, t2.a, t3.a)
                           Join Filter: (t2.a = t3.b)
                           ->  Materialize
                                 Output: t3.b, t3.a
                                 ->  Remote Subquery Scan[3] on all (datanode_1,datanode_2)
                                       Output: t3.b, t3.a
                                       Distribute results by H: b
                                       ->  Seq Scan on public.ut1 t3
                                             Output: t3.b, t3.a
                           ->  Materialize
                                 Output: t2.a
                                 ->  PartIterator
                                       Output: t2.a
                                       ->  Seq Scan on public.pt1 t2
                                             Part Iterator:  public.pt1p1p1  public.pt1p2
                                             Output: t2.a
                                             Filter: (t1.a = t2.a)
(31 rows)

select t1.b, ss.phv from ut1 t1 left join lateral
              (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv
                     from pt1 t2 join ut1 t3 on t2.a = t3.b) ss
              on t1.a = ss.t2a order by t1.a;
  b  | phv 
-----+-----
   2 |    
 101 | 101
(2 rows)

drop table pt1;
drop table ut1;
--
-- test that foreign key join estimation performs sanely for outer joins
--
begin;
create table fkest (a int, b int, c int unique, primary key(a,b));
create table fkest1 (a int, b int, primary key(a,b));
insert into fkest select x/10, x%10, x from generate_series(1,2000) x;
insert into fkest1 select x/10, x%10 from generate_series(1,2000) x;
alter table fkest1
  add constraint fkest1_a_b_fkey foreign key (a,b) references fkest;
analyze fkest;
analyze fkest1;
explain (costs off)
select *
from fkest f
  left join fkest1 f1 on f.a = f1.a and f.b = f1.b
  left join fkest1 f2 on f.a = f2.a and f.b = f2.b
  left join fkest1 f3 on f.a = f3.a and f.b = f3.b
where f.c = 1;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Nested Loop Left Join
         ->  Nested Loop Left Join
               ->  Nested Loop Left Join
                     ->  Remote Subquery Scan on all (datanodes 1)
                           Distribute results by H: a
                           ->  Index Scan using fkest_c_key on fkest f
                                 Index Cond: (c = 1)
                     ->  Index Only Scan using fkest1_pkey on fkest1 f1
                           Index Cond: ((a = f.a) AND (b = f.b))
               ->  Index Only Scan using fkest1_pkey on fkest1 f2
                     Index Cond: ((a = f.a) AND (b = f.b))
         ->  Index Only Scan using fkest1_pkey on fkest1 f3
               Index Cond: ((a = f.a) AND (b = f.b))
(14 rows)

rollback;
--
-- test planner's ability to mark joins as unique
--
create table j1 (id int primary key);
create table j2 (id int primary key);
create table j3 (id int);
insert into j1 values(1),(2),(3);
insert into j2 values(1),(2),(3);
insert into j3 values(1),(1);
analyze j1;
analyze j2;
analyze j3;
-- ensure join is properly marked as unique
explain (verbose, costs off)
select * from j1 inner join j2 on j1.id = j2.id;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: j1.id, j2.id
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id, j2.id FROM (public.j1 JOIN public.j2 ON ((j1.id = j2.id)))
   ->  Nested Loop
         Output: j1.id, j2.id
         Inner Unique: true
         Join Filter: (j1.id = j2.id)
         ->  Seq Scan on public.j1
               Output: j1.id
         ->  Materialize
               Output: j2.id
               ->  Seq Scan on public.j2
                     Output: j2.id
(14 rows)

-- ensure join is not unique when not an equi-join
explain (verbose, costs off)
select * from j1 inner join j2 on j1.id > j2.id;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Nested Loop
   Output: j1.id, j2.id
   Join Filter: (j1.id > j2.id)
   ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)
         Output: j1.id
         ->  Seq Scan on public.j1
               Output: j1.id
   ->  Materialize
         Output: j2.id
         ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
               Output: j2.id
               ->  Seq Scan on public.j2
                     Output: j2.id
(13 rows)

-- ensure non-unique rel is not chosen as inner
explain (verbose, costs off)
select * from j1 inner join j3 on j1.id = j3.id;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: j1.id, j3.id
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id, j3.id FROM (public.j1 JOIN public.j3 ON ((j1.id = j3.id)))
   ->  Nested Loop
         Output: j1.id, j3.id
         Inner Unique: true
         Join Filter: (j1.id = j3.id)
         ->  Seq Scan on public.j3
               Output: j3.id
         ->  Materialize
               Output: j1.id
               ->  Seq Scan on public.j1
                     Output: j1.id
(14 rows)

-- ensure left join is marked as unique
explain (verbose, costs off)
select * from j1 left join j2 on j1.id = j2.id;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: j1.id, j2.id
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id, j2.id FROM (public.j1 LEFT JOIN public.j2 ON ((j1.id = j2.id)))
   ->  Nested Loop Left Join
         Output: j1.id, j2.id
         Inner Unique: true
         Join Filter: (j1.id = j2.id)
         ->  Seq Scan on public.j1
               Output: j1.id
         ->  Materialize
               Output: j2.id
               ->  Seq Scan on public.j2
                     Output: j2.id
(14 rows)

-- ensure right join is marked as unique
explain (verbose, costs off)
select * from j1 right join j2 on j1.id = j2.id;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Output: j1.id, j2.id
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id, j2.id FROM (public.j1 RIGHT JOIN public.j2 ON ((j1.id = j2.id)))
   ->  Nested Loop Left Join
         Output: j1.id, j2.id
         Inner Unique: true
         Join Filter: (j1.id = j2.id)
         ->  Seq Scan on public.j2
               Output: j2.id
         ->  Materialize
               Output: j1.id
               ->  Seq Scan on public.j1
                     Output: j1.id
(14 rows)

-- ensure full join is marked as unique
explain (verbose, costs off)
select * from j1 full join j2 on j1.id = j2.id;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Output: j1.id, j2.id
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id, j2.id FROM (public.j1 FULL JOIN public.j2 ON ((j1.id = j2.id)))
   ->  Hash Full Join
         Output: j1.id, j2.id
         Inner Unique: true
         Hash Cond: (j1.id = j2.id)
         ->  Seq Scan on public.j1
               Output: j1.id
         ->  Hash
               Output: j2.id
               ->  Seq Scan on public.j2
                     Output: j2.id
(14 rows)

-- a clauseless (cross) join can't be unique
explain (verbose, costs off)
select * from j1 cross join j2;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Nested Loop
   Output: j1.id, j2.id
   ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)
         Output: j1.id
         ->  Seq Scan on public.j1
               Output: j1.id
   ->  Materialize
         Output: j2.id
         ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
               Output: j2.id
               ->  Seq Scan on public.j2
                     Output: j2.id
(12 rows)

-- ensure a natural join is marked as unique
explain (verbose, costs off)
select * from j1 natural join j2;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: j1.id
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id FROM (public.j1 JOIN public.j2 USING (id))
   ->  Nested Loop
         Output: j1.id
         Inner Unique: true
         Join Filter: (j1.id = j2.id)
         ->  Seq Scan on public.j1
               Output: j1.id
         ->  Materialize
               Output: j2.id
               ->  Seq Scan on public.j2
                     Output: j2.id
(14 rows)

-- ensure a distinct clause allows the inner to become unique
explain (verbose, costs off)
select * from j1
inner join (select distinct id from j3) j3 on j1.id = j3.id;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Output: j1.id, j3.id
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id, j3.id FROM (public.j1 JOIN (SELECT DISTINCT j3_1.id FROM public.j3 j3_1) j3 ON ((j1.id = j3.id)))
   ->  Nested Loop
         Output: j1.id, j3_1.id
         Inner Unique: true
         Join Filter: (j1.id = j3_1.id)
         ->  Unique
               Output: j3_1.id
               ->  Sort
                     Output: j3_1.id
                     Sort Key: j3_1.id
                     ->  Seq Scan on public.j3 j3_1
                           Output: j3_1.id
         ->  Seq Scan on public.j1
               Output: j1.id
(17 rows)

-- ensure group by clause allows the inner to become unique
explain (verbose, costs off)
select * from j1
inner join (select id from j3 group by id) j3 on j1.id = j3.id;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Output: j1.id, j3.id
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id, j3.id FROM (public.j1 JOIN (SELECT j3_1.id FROM public.j3 j3_1 GROUP BY j3_1.id) j3 ON ((j1.id = j3.id)))
   ->  Nested Loop
         Output: j1.id, j3_1.id
         Inner Unique: true
         Join Filter: (j1.id = j3_1.id)
         ->  Group
               Output: j3_1.id
               Group Key: j3_1.id
               ->  Sort
                     Output: j3_1.id
                     Sort Key: j3_1.id
                     ->  Seq Scan on public.j3 j3_1
                           Output: j3_1.id
         ->  Seq Scan on public.j1
               Output: j1.id
(18 rows)

drop table j1;
drop table j2;
drop table j3;
-- test more complex permutations of unique joins
create table j1 (id1 int, id2 int, primary key(id1,id2));
create table j2 (id1 int, id2 int, primary key(id1,id2));
create table j3 (id1 int, id2 int, primary key(id1,id2));
insert into j1 values(1,1),(1,2);
insert into j2 values(1,1);
insert into j3 values(1,1);
analyze j1;
analyze j2;
analyze j3;
-- ensure there's no unique join when not all columns which are part of the
-- unique index are seen in the join clause
explain (verbose, costs off)
select * from j1
inner join j2 on j1.id1 = j2.id1;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: j1.id1, j1.id2, j2.id1, j2.id2
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id1, j1.id2, j2.id1, j2.id2 FROM (public.j1 JOIN public.j2 ON ((j1.id1 = j2.id1)))
   ->  Nested Loop
         Output: j1.id1, j1.id2, j2.id1, j2.id2
         Join Filter: (j1.id1 = j2.id1)
         ->  Seq Scan on public.j2
               Output: j2.id1, j2.id2
         ->  Seq Scan on public.j1
               Output: j1.id1, j1.id2
(11 rows)

-- ensure proper unique detection with multiple join quals
explain (verbose, costs off)
select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: j1.id1, j1.id2, j2.id1, j2.id2
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id1, j1.id2, j2.id1, j2.id2 FROM (public.j1 JOIN public.j2 ON (((j1.id1 = j2.id1) AND (j1.id2 = j2.id2))))
   ->  Nested Loop
         Output: j1.id1, j1.id2, j2.id1, j2.id2
         Inner Unique: true
         Join Filter: ((j1.id1 = j2.id1) AND (j1.id2 = j2.id2))
         ->  Seq Scan on public.j2
               Output: j2.id1, j2.id2
         ->  Seq Scan on public.j1
               Output: j1.id1, j1.id2
(12 rows)

-- ensure we don't detect the join to be unique when quals are not part of the
-- join condition
explain (verbose, costs off)
select * from j1
inner join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: j1.id1, j1.id2, j2.id1, j2.id2
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id1, j1.id2, j2.id1, j2.id2 FROM (public.j1 JOIN public.j2 ON ((j1.id1 = j2.id1))) WHERE (j1.id2 = 1)
   ->  Nested Loop
         Output: j1.id1, j1.id2, j2.id1, j2.id2
         Inner Unique: true
         Join Filter: (j1.id1 = j2.id1)
         ->  Seq Scan on public.j2
               Output: j2.id1, j2.id2
         ->  Seq Scan on public.j1
               Output: j1.id1, j1.id2
               Filter: (j1.id2 = 1)
(13 rows)

-- as above, but for left joins.
explain (verbose, costs off)
select * from j1
left join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: j1.id1, j1.id2, j2.id1, j2.id2
   Node/s: datanode_1, datanode_2
   Remote query: SELECT j1.id1, j1.id2, j2.id1, j2.id2 FROM (public.j1 LEFT JOIN public.j2 ON ((j1.id1 = j2.id1))) WHERE (j1.id2 = 1)
   ->  Nested Loop Left Join
         Output: j1.id1, j1.id2, j2.id1, j2.id2
         Join Filter: (j1.id1 = j2.id1)
         ->  Seq Scan on public.j1
               Output: j1.id1, j1.id2
               Filter: (j1.id2 = 1)
         ->  Materialize
               Output: j2.id1, j2.id2
               ->  Seq Scan on public.j2
                     Output: j2.id1, j2.id2
(14 rows)

-- validate logic in merge joins which skips mark and restore.
-- it should only do this if all quals which were used to detect the unique
-- are present as join quals, and not plain quals.
set enable_nestloop to 0;
set enable_hashjoin to 0;
set enable_sort to 0;
-- create an index that will be preferred over the PK to perform the join
create index j1_id1_idx on j1 (id1) where id1 % 1000 = 1;
explain (costs off) select * from j1 j1
inner join j1 j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Nested Loop
         Join Filter: ((j1.id1 = j2.id1) AND (j1.id2 = j2.id2))
         ->  Seq Scan on j1
               Filter: ((id1 % 1000) = 1)
         ->  Seq Scan on j1 j2
               Filter: ((id1 % 1000) = 1)
(8 rows)

select * from j1 j1
inner join j1 j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1;
 id1 | id2 | id1 | id2 
-----+-----+-----+-----
   1 |   1 |   1 |   1
   1 |   2 |   1 |   2
(2 rows)

reset enable_nestloop;
reset enable_hashjoin;
reset enable_sort;
drop table j1;
drop table j2;
drop table j3;
-- check that semijoin inner is not seen as unique for a portion of the outerrel
set enable_indexonlyscan to off;
explain (verbose, costs off)
select t1.unique1, t2.hundred
from onek t1, tenk1 t2
where exists (select 1 from tenk1 t3
              where t3.thousand = t1.unique1 and t3.tenthous = t2.hundred)
      and t1.unique1 < 1;
                                                                                                 QUERY PLAN                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1,datanode_2)
   Output: t1.unique1, t2.hundred
   ->  Nested Loop
         Output: t1.unique1, t2.hundred
         ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
               Output: t1.unique1, t3.tenthous
               Distribute results by R
               ->  Hash Join
                     Output: t1.unique1, t3.tenthous
                     Hash Cond: (t3.thousand = t1.unique1)
                     ->  HashAggregate
                           Output: t3.thousand, t3.tenthous
                           Group Key: t3.thousand, t3.tenthous
                           ->  Remote Subquery Scan[3] on all (datanode_1,datanode_2)
                                 Output: t3.thousand, t3.tenthous
                                 Distribute results by S: thousand, tenthous
                                 ->  Seq Scan on public.tenk1 t3
                                       Output: t3.thousand, t3.tenthous
                     ->  Hash
                           Output: t1.unique1
                           ->  Remote Subquery Scan[4] on all (datanode_1,datanode_2)
                                 Output: t1.unique1
                                 Sort Key: t1.unique1
                                 Distribute results by R
                                 ->  Index Scan using onek_unique1 on public.onek t1
                                       Output: t1.unique1
                                       Index Cond: (t1.unique1 < 1)
         ->  Index Scan using tenk1_hundred on public.tenk1 t2
               Output: t2.unique1, t2.unique2, t2.two, t2.four, t2.ten, t2.twenty, t2.hundred, t2.thousand, t2.twothousand, t2.fivethous, t2.tenthous, t2.odd, t2.even, t2.stringu1, t2.stringu2, t2.string4
               Index Cond: (t2.hundred = t3.tenthous)
(30 rows)

reset enable_indexonlyscan;
-- ... unless it actually is unique
create table j3 as select unique1, tenthous from onek;
vacuum analyze j3;
create unique index on j3(unique1, tenthous);
explain (verbose, costs off)
select t1.unique1, t2.hundred
from onek t1, tenk1 t2
where exists (select 1 from j3
              where j3.unique1 = t1.unique1 and j3.tenthous = t2.hundred)
      and t1.unique1 < 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1,datanode_2)
   Output: t1.unique1, t2.hundred
   ->  Nested Loop
         Output: t1.unique1, t2.hundred
         ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
               Output: t1.unique1, j3.tenthous
               Distribute results by R
               ->  Nested Loop
                     Output: t1.unique1, j3.tenthous
                     ->  Index Only Scan using onek_unique1 on public.onek t1
                           Output: t1.unique1
                           Index Cond: (t1.unique1 < 1)
                     ->  Index Only Scan using j3_unique1_tenthous_idx on public.j3
                           Output: j3.unique1, j3.tenthous
                           Index Cond: (j3.unique1 = t1.unique1)
         ->  Index Only Scan using tenk1_hundred on public.tenk1 t2
               Output: t2.hundred
               Index Cond: (t2.hundred = j3.tenthous)
(18 rows)

drop table j3;
--
-- exercises for the hash join code
--
-- something wrong with squeue + subtransaction, just reset
\c
begin;
set local min_parallel_table_scan_size = 0;
set local parallel_setup_cost = 0;
-- Extract bucket and batch counts from an explain analyze plan.  In
-- general we can't make assertions about how many batches (or
-- buckets) will be required because it can vary, but we can in some
-- special cases and we can check for growth.
create or replace function find_hash(node json)
returns json language plpgsql
as
$$
declare
  x json;
  child json;
begin
  if node->>'Node Type' = 'Hash' then
    return node;
  else
    for child in select json_array_elements(node->'Plans')
    loop
      x := find_hash(child);
      if x is not null then
        return x;
      end if;
    end loop;
    return null;
  end if;
end;
$$;
create or replace function hash_join_batches(query text)
returns table (original int, final int) language plpgsql
as
$$
declare
  whole_plan json;
  hash_node json;
begin
  for whole_plan in
    execute 'explain (analyze, format ''json'') ' || query
  loop
    hash_node := find_hash(json_extract_path(whole_plan, '0', 'Plan'));
    original := hash_node->>'Original Hash Batches';
    final := hash_node->>'Hash Batches';
    return next;
  end loop;
end;
$$;
-- Make a simple relation with well distributed keys and correctly
-- estimated size.
create table simple as
  select generate_series(1, 20000) AS id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
alter table simple set (parallel_workers = 2);
analyze simple;
-- Make a relation whose size we will under-estimate.  We want stats
-- to say 1000 rows, but actually there are 20,000 rows.
create table bigger_than_it_looks as
  select generate_series(1, 20000) as id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
alter table bigger_than_it_looks set (autovacuum_enabled = 'false');
alter table bigger_than_it_looks set (parallel_workers = 2);
analyze bigger_than_it_looks;
update pg_class set reltuples = 1000 where relname = 'bigger_than_it_looks';
-- Make a relation whose size we underestimate and that also has a
-- kind of skew that breaks our batching scheme.  We want stats to say
-- 2 rows, but actually there are 20,000 rows with the same key.
create table extremely_skewed (id int, t text);
alter table extremely_skewed set (autovacuum_enabled = 'false');
alter table extremely_skewed set (parallel_workers = 2);
analyze extremely_skewed;
insert into extremely_skewed
  select 42 as id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
  from generate_series(1, 20000);
DO $$
DECLARE
    v_size bigint;
BEGIN
    SELECT pg_relation_size('extremely_skewed') / 8192 INTO v_size;
    UPDATE pg_class
    SET reltuples = 2, relpages = v_size
    WHERE relname = 'extremely_skewed';
END;$$;
-- Make a relation with a couple of enormous tuples.
create table wide as select generate_series(1, 2) as id, rpad('', 320000, 'x') as t;
alter table wide set (parallel_workers = 2);
-- something wrong with savepoint, move all create table before it
create table foo as select generate_series(1, 3) as id, 'xxxxx'::text as t;
alter table foo set (parallel_workers = 0);
create table bar as select generate_series(1, 10000) as id, 'xxxxx'::text as t;
alter table bar set (parallel_workers = 2);
-- The "optimal" case: the hash table fits in memory; we plan for 1
-- batch, we stick to that number, and peak memory usage stays within
-- our work_mem budget
-- non-parallel
savepoint settings;
set local max_parallel_workers_per_gather = 0;
set local work_mem = '4MB';
explain (costs off)
  select count(*) from simple r join simple s using (id);
                     QUERY PLAN                     
----------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (r.id = s.id)
                     ->  Seq Scan on simple r
                     ->  Hash
                           ->  Seq Scan on simple s
(8 rows)

select count(*) from simple r join simple s using (id);
 count 
-------
 20000
(1 row)

--select original > 1 as initially_multibatch, final > original as increased_batches
--  from hash_join_batches(
--$$
--  select count(*) from simple r join simple s using (id);
--$$);
rollback to settings;
-- parallel with parallel-oblivious hash join
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '4MB';
set local enable_parallel_hash = off;
explain (costs off)
  select count(*) from simple r join simple s using (id);
                      QUERY PLAN                       
-------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         Workers Planned: 2
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (r.id = s.id)
                     ->  Parallel Seq Scan on simple r
                     ->  Hash
                           ->  Seq Scan on simple s
(9 rows)

select count(*) from simple r join simple s using (id);
 count 
-------
 20000
(1 row)

--select original > 1 as initially_multibatch, final > original as increased_batches
--  from hash_join_batches(
--$$
--  select count(*) from simple r join simple s using (id);
--$$);
rollback to settings;
-- parallel with parallel-aware hash join
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '4MB';
set local enable_parallel_hash = on;
explain (costs off)
  select count(*) from simple r join simple s using (id);
                         QUERY PLAN                          
-------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         Workers Planned: 2
         ->  Partial Aggregate
               ->  Parallel Hash Join
                     Hash Cond: (r.id = s.id)
                     ->  Parallel Seq Scan on simple r
                     ->  Parallel Hash
                           ->  Parallel Seq Scan on simple s
(9 rows)

select count(*) from simple r join simple s using (id);
 count 
-------
 20000
(1 row)

--select original > 1 as initially_multibatch, final > original as increased_batches
--  from hash_join_batches(
--$$
--  select count(*) from simple r join simple s using (id);
--$$);
rollback to settings;
-- The "good" case: batches required, but we plan the right number; we
-- plan for some number of batches, and we stick to that number, and
-- peak memory usage says within our work_mem budget
-- non-parallel
savepoint settings;
set local max_parallel_workers_per_gather = 0;
set local work_mem = '128kB';
explain (costs off)
  select count(*) from simple r join simple s using (id);
                     QUERY PLAN                     
----------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (r.id = s.id)
                     ->  Seq Scan on simple r
                     ->  Hash
                           ->  Seq Scan on simple s
(8 rows)

select count(*) from simple r join simple s using (id);
 count 
-------
 20000
(1 row)

--select original > 1 as initially_multibatch, final > original as increased_batches
--  from hash_join_batches(
--$$
--  select count(*) from simple r join simple s using (id);
--$$);
rollback to settings;
-- parallel with parallel-oblivious hash join
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '128kB';
set local enable_parallel_hash = off;
explain (costs off)
  select count(*) from simple r join simple s using (id);
                      QUERY PLAN                       
-------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         Workers Planned: 2
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (r.id = s.id)
                     ->  Parallel Seq Scan on simple r
                     ->  Hash
                           ->  Seq Scan on simple s
(9 rows)

select count(*) from simple r join simple s using (id);
 count 
-------
 20000
(1 row)

--select original > 1 as initially_multibatch, final > original as increased_batches
--  from hash_join_batches(
--$$
--  select count(*) from simple r join simple s using (id);
--$$);
rollback to settings;
-- parallel with parallel-aware hash join
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '192kB';
set local enable_parallel_hash = on;
explain (costs off)
  select count(*) from simple r join simple s using (id);
                         QUERY PLAN                          
-------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         Workers Planned: 2
         ->  Partial Aggregate
               ->  Parallel Hash Join
                     Hash Cond: (r.id = s.id)
                     ->  Parallel Seq Scan on simple r
                     ->  Parallel Hash
                           ->  Parallel Seq Scan on simple s
(9 rows)

select count(*) from simple r join simple s using (id);
 count 
-------
 20000
(1 row)

--select original > 1 as initially_multibatch, final > original as increased_batches
--  from hash_join_batches(
--$$
--  select count(*) from simple r join simple s using (id);
--$$);
rollback to settings;
-- The "bad" case: during execution we need to increase number of
-- batches; in this case we plan for 1 batch, and increase at least a
-- couple of times, and peak memory usage stays within our work_mem
-- budget
-- non-parallel
savepoint settings;
set local max_parallel_workers_per_gather = 0;
set local work_mem = '128kB';
explain (costs off)
  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
                            QUERY PLAN                            
------------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (r.id = s.id)
                     ->  Seq Scan on simple r
                     ->  Hash
                           ->  Seq Scan on bigger_than_it_looks s
(8 rows)

select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
 count 
-------
 20000
(1 row)

--select original > 1 as initially_multibatch, final > original as increased_batches
--  from hash_join_batches(
--$$
--  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
--$$);
rollback to settings;
-- parallel with parallel-oblivious hash join
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '128kB';
set local enable_parallel_hash = off;
explain (costs off)
  select count(*) from simple r join bigger_than_it_looks s using (id);
                            QUERY PLAN                            
------------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         Workers Planned: 2
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (r.id = s.id)
                     ->  Parallel Seq Scan on simple r
                     ->  Hash
                           ->  Seq Scan on bigger_than_it_looks s
(9 rows)

select count(*) from simple r join bigger_than_it_looks s using (id);
 count 
-------
 20000
(1 row)

--select original > 1 as initially_multibatch, final > original as increased_batches
--  from hash_join_batches(
--$$
--  select count(*) from simple r join bigger_than_it_looks s using (id);
--$$);
rollback to settings;
-- parallel with parallel-aware hash join
savepoint settings;
set local max_parallel_workers_per_gather = 1;
set local work_mem = '192kB';
set local enable_parallel_hash = on;
explain (costs off)
  select count(*) from simple r join bigger_than_it_looks s using (id);
                            QUERY PLAN                            
------------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (r.id = s.id)
                     ->  Seq Scan on simple r
                     ->  Hash
                           ->  Seq Scan on bigger_than_it_looks s
(8 rows)

select count(*) from simple r join bigger_than_it_looks s using (id);
 count 
-------
 20000
(1 row)

--select original > 1 as initially_multibatch, final > original as increased_batches
--  from hash_join_batches(
--$$
--  select count(*) from simple r join bigger_than_it_looks s using (id);
--$$);
rollback to settings;
-- The "ugly" case: increasing the number of batches during execution
-- doesn't help, so stop trying to fit in work_mem and hope for the
-- best; in this case we plan for 1 batch, increases just once and
-- then stop increasing because that didn't help at all, so we blow
-- right through the work_mem budget and hope for the best...
-- non-parallel
savepoint settings;
set local max_parallel_workers_per_gather = 0;
set local work_mem = '128kB';
explain (costs off)
  select count(*) from simple r join extremely_skewed s using (id);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Hash Join
               Hash Cond: (r.id = s.id)
               ->  Seq Scan on simple r
               ->  Hash
                     ->  Seq Scan on extremely_skewed s
(7 rows)

select count(*) from simple r join extremely_skewed s using (id);
 count 
-------
 20000
(1 row)

--select * from hash_join_batches(
--$$
--  select count(*) from simple r join extremely_skewed s using (id);
--$$);
rollback to settings;
-- parallel with parallel-oblivious hash join
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '128kB';
set local enable_parallel_hash = off;
explain (costs off)
  select count(*) from simple r join extremely_skewed s using (id);
                          QUERY PLAN                          
--------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         Workers Planned: 2
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (r.id = s.id)
                     ->  Parallel Seq Scan on simple r
                     ->  Hash
                           ->  Seq Scan on extremely_skewed s
(9 rows)

select count(*) from simple r join extremely_skewed s using (id);
 count 
-------
 20000
(1 row)

--select * from hash_join_batches(
--$$
--  select count(*) from simple r join extremely_skewed s using (id);
--$$);
rollback to settings;
-- parallel with parallel-aware hash join
savepoint settings;
set local max_parallel_workers_per_gather = 1;
set local work_mem = '128kB';
set local enable_parallel_hash = on;
explain (costs off)
  select count(*) from simple r join extremely_skewed s using (id);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Hash Join
               Hash Cond: (r.id = s.id)
               ->  Seq Scan on simple r
               ->  Hash
                     ->  Seq Scan on extremely_skewed s
(7 rows)

select count(*) from simple r join extremely_skewed s using (id);
 count 
-------
 20000
(1 row)

--select * from hash_join_batches(
--$$
--  select count(*) from simple r join extremely_skewed s using (id);
--$$);
rollback to settings;
-- A couple of other hash join tests unrelated to work_mem management.
-- Check that EXPLAIN ANALYZE has data even if the leader doesn't participate
savepoint settings;
set local max_parallel_workers_per_gather = 2;
set local work_mem = '4MB';
set local parallel_leader_participation = off;
WARNING:  The logical code corresponding to the GUC has been removed.
HINT:  Please remove the parameter settings related to this parameter from your business as soon as possible.
--select * from hash_join_batches(
--$$
--  select count(*) from simple r join simple s using (id);
--$$);
rollback to settings;
-- Exercise rescans.  We'll turn off parallel_leader_participation so
-- that we can check that instrumentation comes back correctly.
-- multi-batch with rescan, parallel-oblivious
savepoint settings;
set enable_parallel_hash = off;
set parallel_leader_participation = off;
WARNING:  The logical code corresponding to the GUC has been removed.
HINT:  Please remove the parameter settings related to this parameter from your business as soon as possible.
set min_parallel_table_scan_size = 0;
set parallel_setup_cost = 0;
set parallel_tuple_cost = 0;
set max_parallel_workers_per_gather = 2;
set enable_material = off;
set enable_mergejoin = off;
set work_mem = '64kB';
explain (costs off)
  select count(*) from foo
    left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
    on foo.id < ss.id + 1 and foo.id > ss.id - 1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop Left Join
         Join Filter: ((foo.id < (b1.id + 1)) AND (foo.id > (b1.id - 1)))
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Seq Scan on foo
         ->  Materialize
               ->  Remote Subquery Scan on all (datanodes 2)
                     Workers Planned: 2
                     ->  Hash Join
                           Hash Cond: (b1.id = b2.id)
                           ->  Parallel Seq Scan on bar b1
                           ->  Hash
                                 ->  Seq Scan on bar b2
(13 rows)

select count(*) from foo
  left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
  on foo.id < ss.id + 1 and foo.id > ss.id - 1;
 count 
-------
     3
(1 row)

--select final > 1 as multibatch
--  from hash_join_batches(
--$$
--  select count(*) from foo
--    left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
--    on foo.id < ss.id + 1 and foo.id > ss.id - 1;
--$$);
rollback to settings;
-- single-batch with rescan, parallel-oblivious
savepoint settings;
set enable_parallel_hash = off;
set parallel_leader_participation = off;
WARNING:  The logical code corresponding to the GUC has been removed.
HINT:  Please remove the parameter settings related to this parameter from your business as soon as possible.
set min_parallel_table_scan_size = 0;
set parallel_setup_cost = 0;
set parallel_tuple_cost = 0;
set max_parallel_workers_per_gather = 2;
set enable_material = off;
set enable_mergejoin = off;
set work_mem = '4MB';
explain (costs off)
  select count(*) from foo
    left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
    on foo.id < ss.id + 1 and foo.id > ss.id - 1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop Left Join
         Join Filter: ((foo.id < (b1.id + 1)) AND (foo.id > (b1.id - 1)))
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Seq Scan on foo
         ->  Materialize
               ->  Remote Subquery Scan on all (datanodes 2)
                     Workers Planned: 2
                     ->  Hash Join
                           Hash Cond: (b1.id = b2.id)
                           ->  Parallel Seq Scan on bar b1
                           ->  Hash
                                 ->  Seq Scan on bar b2
(13 rows)

select count(*) from foo
  left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
  on foo.id < ss.id + 1 and foo.id > ss.id - 1;
 count 
-------
     3
(1 row)

--select final > 1 as multibatch
--  from hash_join_batches(
--$$
--  select count(*) from foo
--    left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
--    on foo.id < ss.id + 1 and foo.id > ss.id - 1;
--$$);
rollback to settings;
-- multi-batch with rescan, parallel-aware
savepoint settings;
set enable_parallel_hash = on;
set parallel_leader_participation = off;
WARNING:  The logical code corresponding to the GUC has been removed.
HINT:  Please remove the parameter settings related to this parameter from your business as soon as possible.
set min_parallel_table_scan_size = 0;
set parallel_setup_cost = 0;
set parallel_tuple_cost = 0;
set max_parallel_workers_per_gather = 2;
set enable_material = off;
set enable_mergejoin = off;
set work_mem = '64kB';
explain (costs off)
  select count(*) from foo
    left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
    on foo.id < ss.id + 1 and foo.id > ss.id - 1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop Left Join
         Join Filter: ((foo.id < (b1.id + 1)) AND (foo.id > (b1.id - 1)))
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Seq Scan on foo
         ->  Materialize
               ->  Remote Subquery Scan on all (datanodes 2)
                     Workers Planned: 2
                     ->  Parallel Hash Join
                           Hash Cond: (b1.id = b2.id)
                           ->  Parallel Seq Scan on bar b1
                           ->  Parallel Hash
                                 ->  Parallel Seq Scan on bar b2
(13 rows)

select count(*) from foo
  left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
  on foo.id < ss.id + 1 and foo.id > ss.id - 1;
 count 
-------
     3
(1 row)

--select final > 1 as multibatch
--  from hash_join_batches(
--$$
--  select count(*) from foo
--    left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
--    on foo.id < ss.id + 1 and foo.id > ss.id - 1;
--$$);
rollback to settings;
-- single-batch with rescan, parallel-aware
savepoint settings;
set enable_parallel_hash = on;
set parallel_leader_participation = off;
WARNING:  The logical code corresponding to the GUC has been removed.
HINT:  Please remove the parameter settings related to this parameter from your business as soon as possible.
set min_parallel_table_scan_size = 0;
set parallel_setup_cost = 0;
set parallel_tuple_cost = 0;
set max_parallel_workers_per_gather = 2;
set enable_material = off;
set enable_mergejoin = off;
set work_mem = '4MB';
explain (costs off)
  select count(*) from foo
    left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
    on foo.id < ss.id + 1 and foo.id > ss.id - 1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop Left Join
         Join Filter: ((foo.id < (b1.id + 1)) AND (foo.id > (b1.id - 1)))
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Seq Scan on foo
         ->  Materialize
               ->  Remote Subquery Scan on all (datanodes 2)
                     Workers Planned: 2
                     ->  Parallel Hash Join
                           Hash Cond: (b1.id = b2.id)
                           ->  Parallel Seq Scan on bar b1
                           ->  Parallel Hash
                                 ->  Parallel Seq Scan on bar b2
(13 rows)

select count(*) from foo
  left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
  on foo.id < ss.id + 1 and foo.id > ss.id - 1;
 count 
-------
     3
(1 row)

--select final > 1 as multibatch
--  from hash_join_batches(
--$$
--  select count(*) from foo
--    left join (select b1.id, b1.t from bar b1 join bar b2 using (id)) ss
--    on foo.id < ss.id + 1 and foo.id > ss.id - 1;
--$$);
rollback to settings;
-- A full outer join where every record is matched.
-- non-parallel
savepoint settings;
set local max_parallel_workers_per_gather = 0;
explain (costs off)
     select  count(*) from simple r full outer join simple s using (id);
                     QUERY PLAN                     
----------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Full Join
                     Hash Cond: (r.id = s.id)
                     ->  Seq Scan on simple r
                     ->  Hash
                           ->  Seq Scan on simple s
(8 rows)

select  count(*) from simple r full outer join simple s using (id);
 count 
-------
 20000
(1 row)

rollback to settings;
-- parallelism not possible with parallel-oblivious outer hash join
savepoint settings;
set local max_parallel_workers_per_gather = 2;
explain (costs off)
     select  count(*) from simple r full outer join simple s using (id);
                     QUERY PLAN                     
----------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Full Join
                     Hash Cond: (r.id = s.id)
                     ->  Seq Scan on simple r
                     ->  Hash
                           ->  Seq Scan on simple s
(8 rows)

select  count(*) from simple r full outer join simple s using (id);
 count 
-------
 20000
(1 row)

rollback to settings;
-- An full outer join where every record is not matched.
-- non-parallel
savepoint settings;
set local max_parallel_workers_per_gather = 0;
explain (costs off)
     select  count(*) from simple r full outer join simple s on (r.id = 0 - s.id);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Full Join
                     Hash Cond: (((0 - s.id)) = r.id)
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by H: ((0 - id))
                           ->  Seq Scan on simple s
                     ->  Hash
                           ->  Seq Scan on simple r
(10 rows)

select  count(*) from simple r full outer join simple s on (r.id = 0 - s.id);
 count 
-------
 40000
(1 row)

rollback to settings;
-- parallelism not possible with parallel-oblivious outer hash join
savepoint settings;
set local max_parallel_workers_per_gather = 2;
explain (costs off)
     select  count(*) from simple r full outer join simple s on (r.id = 0 - s.id);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Full Join
                     Hash Cond: (((0 - s.id)) = r.id)
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by H: ((0 - id))
                           ->  Seq Scan on simple s
                     ->  Hash
                           ->  Seq Scan on simple r
(10 rows)

select  count(*) from simple r full outer join simple s on (r.id = 0 - s.id);
 count 
-------
 40000
(1 row)

rollback to settings;
-- exercise special code paths for huge tuples (note use of non-strict
-- expression and left join required to get the detoasted tuple into
-- the hash table)
-- parallel with parallel-aware hash join (hits ExecParallelHashLoadTuple and
-- sts_puttuple oversized tuple cases because it's multi-batch)
savepoint settings;
set max_parallel_workers_per_gather = 2;
set enable_parallel_hash = on;
set work_mem = '128kB';
explain (costs off)
  select length(max(s.t))
  from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id);
                           QUERY PLAN                           
----------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         Workers Planned: 2
         ->  Partial Aggregate
               ->  Parallel Hash Left Join
                     Hash Cond: (wide.id = wide_1.id)
                     ->  Parallel Seq Scan on wide
                     ->  Parallel Hash
                           ->  Parallel Seq Scan on wide wide_1
(9 rows)

select length(max(s.t))
from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id);
 length 
--------
 320000
(1 row)

--select final > 1 as multibatch
--  from hash_join_batches(
--$$
--  select length(max(s.t))
--  from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id);
--$$);
rollback to settings;
rollback;
--
-- Test nestloop path suppression if the selectivity could be under estimated
--
create table nestloop_suppression1(a int, b int, c int, d varchar(20));
create table nestloop_suppression2(a int, b int, c int, d varchar(20));
create table nestloop_suppression3(a int, b int);
insert into nestloop_suppression1 select i, i+1, i+2, 'char'||i from generate_series(1,10000) i;
insert into nestloop_suppression2 select i, i+1, i+2, 'char'||i from generate_series(1,10000) i;
insert into nestloop_suppression3 select i, i+1 from generate_series(1,100) i;
create index idx_nestloop_suppression1_b on nestloop_suppression1(b);
analyze nestloop_suppression1;
analyze nestloop_suppression2;
analyze nestloop_suppression3;
set enable_hashjoin = false;
set enable_indexonlyscan to off;
set enable_indexscan to off;
explain (costs off) select t3.b from nestloop_suppression1 t1, nestloop_suppression2 t2, nestloop_suppression3 t3 
	where t1.b=2 and t1.c=3 and t1.d like 'char%' and t1.a=t2.a and t3.b>t2.a;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (t3.b > t2.a)
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Merge Join
               Merge Cond: (t1.a = t2.a)
               ->  Sort
                     Sort Key: t1.a
                     ->  Seq Scan on nestloop_suppression1 t1
                           Filter: (((d)::text ~~ 'char%'::text) AND (b = 2) AND (c = 3))
               ->  Sort
                     Sort Key: t2.a
                     ->  Seq Scan on nestloop_suppression2 t2
   ->  Materialize
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Seq Scan on nestloop_suppression3 t3
(15 rows)

set enable_nestloop_suppression = true;
explain (costs off) select t3.b from nestloop_suppression1 t1, nestloop_suppression2 t2, nestloop_suppression3 t3 
	where t1.b=2 and t1.c=3 and t1.d like 'char%' and t1.a=t2.a and t3.b>t2.a;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (t3.b > t2.a)
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Merge Join
               Merge Cond: (t1.a = t2.a)
               ->  Sort
                     Sort Key: t1.a
                     ->  Seq Scan on nestloop_suppression1 t1
                           Filter: (((d)::text ~~ 'char%'::text) AND (b = 2) AND (c = 3))
               ->  Sort
                     Sort Key: t2.a
                     ->  Seq Scan on nestloop_suppression2 t2
   ->  Materialize
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Seq Scan on nestloop_suppression3 t3
(15 rows)

drop table nestloop_suppression1;
drop table nestloop_suppression2;
drop table nestloop_suppression3;
create table tb1(c1 int, c2 int);
create table tb2(c1 int, c2 int) PARTITION BY list(c2);
create table tb2_list1 partition of tb2 for values in (100);
explain select 1 from tb1
left outer join (select c1 from tb2
                  where tb2.c2 = 100
                    and tb2.c2 > 200) as tb3
on tb1.c1 = tb3.c1;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Nested Loop Left Join  (cost=0.00..40.38 rows=1350 width=4)
         Join Filter: (tb1.c1 = c1)
         ->  Seq Scan on tb1  (cost=0.00..23.50 rows=1350 width=4)
         ->  Result
               One-Time Filter: false
(7 rows)

explain select 1 from tb1
left outer join (select c1 from tb2
                  where tb2.c1 = 100
                    and tb2.c1 > 200) as tb3
on tb1.c1 = tb3.c1;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Nested Loop Left Join  (cost=0.00..40.38 rows=1350 width=4)
         Join Filter: (tb1.c1 = c1)
         ->  Seq Scan on tb1  (cost=0.00..23.50 rows=1350 width=4)
         ->  Result
               One-Time Filter: false
(7 rows)

explain select 1 from tb1
left outer join (select c1 from tb2
                  where tb2.c1 = 100
                    and tb2.c1 = 200) as tb3
on tb1.c1 = tb3.c1;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Remote Fast Query Execution Mode: fqs_mode_std_planer
   Node/s: datanode_1, datanode_2
   ->  Nested Loop Left Join  (cost=0.00..40.38 rows=1350 width=4)
         Join Filter: (tb1.c1 = c1)
         ->  Seq Scan on tb1  (cost=0.00..23.50 rows=1350 width=4)
         ->  Result
               One-Time Filter: false
(7 rows)

drop table tb1;
drop table tb2;
reset enable_nestloop_suppression;
reset enable_indexscan;
reset enable_indexonlyscan;
reset enable_hashjoin;
CREATE TABLE rqg_table1 (
c0 int,
c1 int,
c2 text,
c3 text,
c4 date,
c5 date,
c6 timestamp,
c7 timestamp,
c8 numeric,
c9 numeric)   distribute by shard(c0);
alter table rqg_table1 alter column c0 drop not null;
CREATE INDEX idx_rqg_table1_c1 ON rqg_table1(c1);
CREATE INDEX idx_rqg_table1_c3 ON rqg_table1(c3);
CREATE INDEX idx_rqg_table1_c5 ON rqg_table1(c5);
CREATE INDEX idx_rqg_table1_c7 ON rqg_table1(c7);
CREATE INDEX idx_rqg_table1_c9 ON rqg_table1(c9);
INSERT INTO rqg_table1 VALUES  (6, NULL, 'foo', 'foo', '1982-01-16 18:52:19', '2034-10-22 23:11:42', '1972-03-04 21:15:53.048712', '2013-11-26 11:04:23.043793', 0.6064453125, -0.123456789123457) ,  (0, 2, 'foo', 'foo', '2000-03-06 21:12:58', '2029-06-13 09:19:17', '2003-03-20', '2035-12-20 04:50:51', -1.23456789123457e+44, 1.23456789123457e+30) ,  (9, NULL, 'xmlbo', 'foo', '2010-05-11 12:38:22', '1985-08-25 14:58:27', '1973-03-22 01:32:46.047991', NULL, -1.23456789123457e+39, -0.123456789123457) ,  (2, 4, 'mlbopuyyo', NULL, '2025-06-11 03:05:26', '1991-09-20 02:41:55', '2032-03-28 12:47:16.063544', NULL, -96731136, 0.437469482421875) ,  (1, NULL, 'bar', 'bar', '1992-07-11', '1999-10-20 00:19:14', NULL, '2023-03-02 16:05:08.004696', 1.23456789123457e+39, -1.23456789123457e+43) ,  (NULL, NULL, 'bar', NULL, '1978-04-04', '1985-12-15 06:07:11', '1979-02-01 23:53:51.062078', '2021-12-11 23:07:45', -1.23456789123457e+43, -5.93236660915379e+18) ,  (9, NULL, 'foo', 'bar', '1987-09-19', '1978-02-21', '2034-11-23 16:52:42.014876', '2025-11-23 20:18:48.019448', -1.23456789123457e+44, -1336606720) ,  (5, 0, 'foo', 'foo', '2023-09-21 09:32:29', '2031-01-21 12:15:28', '1976-04-23 08:32:12.001141', '2015-08-22 16:08:05.021997', 1.23456789123457e+30, 6.5081787109375e+80) ,  (NULL, NULL, 'lbopuyyoixibkpkyoivmfshvcgmpzvdnxnxfpapiydzdpcixmfofwarsvxubcruomsozdfldaicsgheitlvdhdpuydxwpojdsnxliabrqjepfmbmgemihpfthigw', 'bar', '1994-06-21', '1976-03-24', '1972-05-25', '1975-11-11 07:05:24.001543', -0.123456789123457, 1.23456789123457e+39) ,  (7, 7, 'bopuyy', 'bar', '1988-02-06', '1998-03-02', '2010-11-17 14:52:51.063678', '2015-01-23 11:33:37', 1.23456789123457e-09, NULL) ;
CREATE TABLE rqg_table6 (
c0 int,
c1 int,
c2 text,
c3 text,
c4 date,
c5 date,
c6 timestamp,
c7 timestamp,
c8 numeric,
c9 numeric)   distribute by replication;
alter table rqg_table6 alter column c0 drop not null;
CREATE INDEX idx_rqg_table6_c1 ON rqg_table6(c1);
CREATE INDEX idx_rqg_table6_c3 ON rqg_table6(c3);
CREATE INDEX idx_rqg_table6_c5 ON rqg_table6(c5);
CREATE INDEX idx_rqg_table6_c7 ON rqg_table6(c7);
CREATE INDEX idx_rqg_table6_c9 ON rqg_table6(c9);
INSERT INTO rqg_table6 VALUES  (5, 0, 'mpzvdnx', NULL, '1985-12-26 00:38:24', '1994-02-07 00:27:30', '2003-08-07 22:25:05.049399', '1997-06-16 20:39:49.034445', -0.123456789123457, 1.23456789123457e+43) ,  (5, 1, NULL, 'foo', '1983-10-08', '2023-04-01', '1979-10-17', '1987-06-09 12:04:29.064057', 0.57427978515625, 1.23456789123457e+44) ,  (1, NULL, 'bar', 'pzvdnxnxf', '2002-11-11 01:11:12', '2013-01-10', '2001-09-22 04:16:14', '2017-08-22 11:20:36', -0.123456789123457, -5.1138373768792e+18) ,  (5, 4, 'zvdnxnxfpapiydzdpcixmfofw', 'vdnxnxfpa', '1979-02-10', '1990-02-01', '1998-07-06 05:11:49.060007', '2033-05-13 12:42:41', -1.23456789123457e+44, -4.979248046875e+80) ,  (6, 4, NULL, 'dnxnxfpapiydzdpcixmfofwarsvxubcruomsoz', '2004-02-13 20:18:29', '2023-09-03', '2029-04-15', '2002-12-06 01:52:57.010271', -1.23456789123457e+44, -1.23456789123457e+30) ,  (7, 6, 'bar', 'bar', '2033-08-24', '2018-02-07 05:41:10', '2029-06-15 19:55:56.049270', '2033-02-23', NULL, -1.23456789123457e+30) ,  (4, 9, 'nxnxfpapi', 'foo', '2031-04-08', '1978-08-22', '2035-06-18 14:44:17', '2020-10-20 22:57:11', -4.81750487763001e+124, 3.86383056640625e+80) ,  (4, 3, NULL, NULL, '2033-02-19 06:06:12', '2032-09-06', '1973-05-19 19:22:56.048458', '1977-10-08', -2.54028319566528e+124, -1.3995361328125e+80) ,  (9, 5, 'foo', 'bar', '2019-12-14 23:02:18', '1972-12-12 14:32:22', '2001-03-28 21:13:39.037798', '2025-07-04', 1.23456789123457e-09, -6.1541748046875e+80) ,  (8, 4, 'xnxfpapiydzdpcixmfofwarsvxubcruomsozdfldaicsgheitlvdhdpuydxwpojdsnxliabrqjepfmbmgemihpfthigwckkovxupsbqpekxcpuatmrftuuivlmuqiuurqojgh', 'nxfp', '1978-10-22 01:40:49', '2008-04-04', NULL, NULL, 1.23456789123457e+30, 1.23456789123457e+44) ;
set enable_seqscan = off;
set enable_indexscan = off;
drop table if exists rqg_table4;
NOTICE:  table "rqg_table4" does not exist, skipping
CREATE TABLE rqg_table4 (
c0 int,
c1 int,
c2 text,
c3 text,
c4 date,
c5 date,
c6 timestamp,
c7 timestamp,
c8 numeric,
c9 numeric)   distribute by shard(c3);
alter table rqg_table4 alter column c0 drop not null;
CREATE INDEX idx_rqg_table4_c1 ON rqg_table4(c1);
CREATE INDEX idx_rqg_table4_c3 ON rqg_table4(c3);
CREATE INDEX idx_rqg_table4_c5 ON rqg_table4(c5);
CREATE INDEX idx_rqg_table4_c7 ON rqg_table4(c7);
CREATE INDEX idx_rqg_table4_c9 ON rqg_table4(c9);
INSERT INTO rqg_table4 VALUES  (NULL, 4, 'foo', NULL, '1985-11-25 21:57:41', '2012-01-19 17:02:33', '2034-10-03 20:24:02.061413', '1987-05-26', 0.881423950195312, 1.23456789123457e+30) ,  (1, 9, 'bar', NULL, '1977-10-19', '1979-06-09', NULL, '1974-10-28 19:32:45', 1.23456789123457e+30, -1.23456789123457e+44) ,  (2, NULL, 'foo', 'bar', '2016-05-27 20:59:31', '1980-02-21', '2019-11-12 18:44:33', '2022-08-14 13:08:06.024802', 1.23456789123457e+43, 0.123456789123457) ,  (4, 7, 'lixijtqhzvfmfgsouvzcntxxugyvdrqhhrssjbpdflvbvarlgsuwmolgymptcbfdjyds', 'ixijtqhzvfmfgsouvzcntxxugyvdrqhhrssjbpdflvbvarlgsuwmolgymptcbfdj', '1983-12-23 17:09:01', '2012-08-25', '2025-01-14 06:40:38.039286', '2026-07-11', -1.23456789123457e-09, 1.23456789123457e+44) ,  (2, 2, NULL, NULL, '1991-01-23 01:21:39', '2017-02-20 15:39:23', '2007-08-06 14:40:11', '2000-02-23 16:25:21', -1.23456789123457e+25, -1.23456789123457e+43) ,  (8, 2, 'xijtqhzvfmfgsouvzcntxxugyvdrqhhrssjbpdflvbvarlgsuwmolgymptcbfdjydsrqmhapcflxfyagbalbcbjokujrifbolqjyymlkogflnpdwipokiluwgjdbltqivlmrloeaqlwuwhoukbmcqm', 'bar', '1987-03-26 05:21:59', '2008-12-17', '2024-05-06 07:37:53.048135', '2022-09-17 22:51:12.064065', -1.23456789123457e+25, 2.40936279296875e+80) ,  (9, 8, NULL, 'bar', '1972-09-09 17:41:09', '2023-11-14', '2023-10-22 22:59:21', '1979-07-10 00:13:19.020138', 1.23456789123457e+25, 0.123456789123457) ,  (NULL, NULL, NULL, 'bar', '2007-03-27 22:04:23', '1992-01-24 12:02:35', '2027-04-13', '1981-03-22 01:48:33.016070', 0.88189697265625, -3.86324405535375e+18) ,  (0, NULL, 'bar', NULL, '2028-04-01 04:31:07', '1998-07-05 16:08:05', '1981-04-25', '2023-01-06 12:42:41.034613', 1.23456789123457e+25, 0.123456789123457) ,  (0, 5, 'bar', 'i', '1999-09-28', '1983-02-01 12:18:37', '1990-05-26 18:04:19.009021', '1993-10-27 19:25:34', 0.123456789123457, 0.5126953125) ;
drop table if exists rqg_table6;
CREATE TABLE rqg_table6 (
c0 int,
c1 int,
c2 text,
c3 text,
c4 date,
c5 date,
c6 timestamp,
c7 timestamp,
c8 numeric,
c9 numeric)   distribute by replication;
alter table rqg_table6 alter column c0 drop not null;
CREATE INDEX idx_rqg_table6_c1 ON rqg_table6(c1);
CREATE INDEX idx_rqg_table6_c3 ON rqg_table6(c3);
CREATE INDEX idx_rqg_table6_c5 ON rqg_table6(c5);
CREATE INDEX idx_rqg_table6_c7 ON rqg_table6(c7);
CREATE INDEX idx_rqg_table6_c9 ON rqg_table6(c9);
INSERT INTO rqg_table6 VALUES  (8, 1, 'v', 'bar', '1973-12-09', '1974-10-15', '1985-01-26 06:26:28', '2024-09-27', 1.23456789123457e+43, 1.23456789123457e+44) ,  (NULL, 7, NULL, 'fmfgsouvz', '1977-03-06 13:22:11', '2024-07-04 15:41:53', '1992-11-22 00:48:55.031345', '2028-07-16 15:28:17.008752', NULL, NULL) ,  (2, 2, 'bar', 'mfgsouvzcntxxugyvdrqhhrssjbpdflvbvarlgsuwmolgymptcbfdjydsrqmhapcflxfyagbalbcbjokujrifbolqjyymlkogflnpdwipokiluwgjdbltqivlmrloeaqlwuwhou', '1996-09-03', '1990-02-09 00:37:47', '2022-08-25 11:04:36.008903', '1976-04-22 05:48:26.034826', -8.13547125186809e+18, 1.23456789123457e+25) ,  (NULL, NULL, 'fgsouv', 'gsouvzcntxxugyvdrqhhrssjbpdflvbvarlgsuwmolgymptcbfdjydsrqmhapcflxfyagbalbcbjokujrifbolqjyymlkogflnpdwipokiluwgjdbltqivlmrloeaqlwuwhou', '1975-08-19 00:51:09', '2003-09-25', NULL, '2026-12-02 10:34:34.019304', -2.73593677362758e+18, -1.23456789123457e+44) ,  (2, NULL, 'souvzcn', 'ouvzcntxxugyvdrqhhrssjbpdflvbvarlgsuwmolgymptcbf', '1976-01-09', '1999-08-05 08:49:36', '2007-07-02 23:16:01.039734', '1986-03-13', 1.23456789123457e+43, 1.23456789123457e-09) ,  (0, 5, 'foo', 'uvzcn', '1989-11-12 14:45:26', '2003-05-06 05:01:19', '2004-12-26 22:26:18.029048', '2024-11-02 14:36:48', -5.31959558485469e+18, 0.123456789123457) ,  (NULL, 2, 'bar', 'bar', '2021-05-14', '2016-04-17', '1989-08-07', '1983-05-26', -1.23456789123457e+30, -1.23456789123457e-09) ,  (9, NULL, 'bar', 'foo', '1998-08-19', '1979-11-20', '2026-08-08 09:21:42.026149', '2034-12-04 13:35:11.053542', 1913454592, 1.23456789123457e+39) ,  (NULL, 1, 'foo', 'vzcntxxugyvdrqhhrssjbpdflvbvarlgsuwmolgymptcbfdjydsrqmhapcflxfyagbalbcbjokujrifbolqjyymlkogflnpdwipokiluwgjdbltqivlmrloeaqlwuwhoukbmcqmwykqyjxebsajruafshdqzafcnlcbozucrhxbbawwonsaivqjosudqanoqsgqar', '1978-08-16', '1999-09-17 10:43:06', '1989-10-19', '1982-02-10 11:55:58.006975', -574750720, NULL) ,  (3, NULL, 'z', 'bar', '2013-03-15', '1978-02-01', '1989-06-23 01:37:07.024905', '1977-01-03 01:32:21.021484', -1.23456789123457e+25, NULL) ;
drop table if exists rqg_table12;
NOTICE:  table "rqg_table12" does not exist, skipping
CREATE TABLE rqg_table12 (
c0 int,
c1 int,
c2 text,
c3 text,
c4 date,
c5 date,
c6 timestamp,
c7 timestamp,
c8 numeric,
c9 numeric)    PARTITION BY hash( c9) distribute by replication;
create TABLE rqg_table12_p0 partition of rqg_table12 for values with(modulus 4,remainder 0);
create TABLE rqg_table12_p1 partition of rqg_table12 for values with(modulus 4,remainder 1);
create TABLE rqg_table12_p2 partition of rqg_table12 for values with(modulus 4,remainder 2);
create TABLE rqg_table12_p3 partition of rqg_table12 for values with(modulus 4,remainder 3);
alter table rqg_table12 alter column c0 drop not null;
CREATE INDEX idx_rqg_table12_c1 ON rqg_table12(c1);
CREATE INDEX idx_rqg_table12_c3 ON rqg_table12(c3);
CREATE INDEX idx_rqg_table12_c5 ON rqg_table12(c5);
CREATE INDEX idx_rqg_table12_c7 ON rqg_table12(c7);
CREATE INDEX idx_rqg_table12_c9 ON rqg_table12(c9);
INSERT INTO rqg_table12 VALUES  (NULL, 5, 'bar', 'bar', '1973-05-23 03:39:38', '2031-09-04', '2028-06-21 18:17:15', '2003-08-01', -0.123456789123457, 6.07957802197346e+18) ,  (5, 5, NULL, 'bar', '2028-12-21', '2002-07-05 20:34:19', '1973-02-18 01:02:35.024329', '1982-07-03', -1.23456789123457e+43, 1.23456789123457e-09) ,  (7, 9, NULL, 'foo', '1985-10-28 13:53:24', '2002-10-02 21:54:27', '2002-03-28 17:12:07.021140', '1972-07-15 21:21:35.060278', -6.37062314789228e+18, 0.123456789123457) ,  (8, 6, 'bfdjydsrqmhapcflxfyagbalbcbjokujrifbolqjyymlkogflnpdwipokiluwgjdbltqivlmrloeaqlwuwhou', 'bar', '2017-07-28 16:26:42', '1997-11-25 02:25:53', '2003-06-26 00:04:10.005657', '2002-06-12 11:52:59.006766', 1.23456789123457e+30, 1.23456789123457e+39) ,  (5, 6, 'bar', NULL, '2001-07-04', '1973-08-13 17:51:42', '2020-01-08 11:46:37.056358', '2005-02-11', -1.23456789123457e+44, 0.123456789123457) ,  (NULL, 6, NULL, NULL, '2019-06-11 00:28:47', '1997-08-06', '1985-04-13 04:49:00.047978', '1980-05-04 07:33:03.060762', 1.23456789123457e-09, 8.81410742071748e+18) ,  (2, 5, 'foo', 'fdjydsrq', '2004-12-17 12:59:58', '2026-06-20', '2024-11-15 19:08:15.020034', '1993-04-04 22:29:05.030482', 1.23456789123457e+39, 0.50250244140625) ,  (7, 7, 'djydsrqmhapcflxfyagbalbcbjokujrifbolqjyymlkogflnpdwipokiluwgjdbltqivlmrloeaqlwuwhoukbmcqmwykqyjxebsajruafshdqzafcnlcbozucrhxbbawwonsaivqjosudqanoqsgqarxfyxlglkhrefqckcqkejcqci', 'jydsrq', '1984-09-13', '2033-03-26', '2023-04-15 13:18:45.009238', NULL, -7.82021927795216e+18, -7.13145000994118e+18) ,  (2, NULL, 'yds', NULL, '1993-07-07 04:26:19', '1985-12-08 17:38:19', '1994-08-16 15:41:13.043276', '1981-08-18', 1.23456789123457e+39, 1.23456789123457e+44) ,  (0, 9, 'dsrqmhapcflxfyagbalbcbjokujrifbolqjyymlkogflnpdwipokiluwgjdbltqivlmrloeaqlwuwhoukbmcqmwykqyjxebsajruafshdqzafcnlcbozucrhxbbawwonsaivqjosudqa', 's', '2029-02-13', '2006-12-08 16:20:22', '1982-04-16', '2014-02-14 15:24:57', -1.23456789123457e+39, 0.07537841796875) ;
analyze rqg_table4;
analyze rqg_table6;
analyze rqg_table12;
explain (costs off)
select 
    1
from rqg_table12 t1 where c0 in (select c1 from rqg_table4 t4 where not exists(select 1 from rqg_table6 t2 where t2.c0 = t4.c0 AND t4.c0 = 7  ) ) and c1=2;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Join
         Hash Cond: (t1.c0 = t4.c1)
         ->  PartIterator
               ->  Bitmap Heap Scan on rqg_table12 t1
                     Recheck Cond: (c1 = 2)
                     ->  Bitmap Index Scan on idx_rqg_table12_c1
                           Index Cond: (c1 = 2)
         ->  Hash
               ->  HashAggregate
                     Group Key: t4.c1
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Sort Key: t4.c1
                           Distribute results by S: c1
                           ->  Nested Loop Anti Join
                                 Join Filter: ((t4.c0 = 7) AND (t2.c0 = t4.c0))
                                 ->  Index Scan using idx_rqg_table4_c1 on rqg_table4 t4
                                 ->  Materialize
                                       ->  Seq Scan on rqg_table6 t2
(19 rows)

drop table rqg_table4, rqg_table6, rqg_table12;
set enable_hashjoin=on;
set enable_mergejoin=off;
drop function if exists get_random_date(start_date date) cascade;
NOTICE:  function get_random_date(date) does not exist, skipping
create function get_random_date(start_date date) RETURNS date
as
$$
begin
 if start_date is not null then
 RETURN start_date;
 else
 RETURN date_trunc('day', now() - interval '1 day' * (random() * 365))::date;
 end if;
end;
$$
language plpgsql stable;
drop table if exists jt1;
NOTICE:  table "jt1" does not exist, skipping
drop table if exists jt2;
NOTICE:  table "jt2" does not exist, skipping
create table jt1(c0 int, c1 int, c2 int, c3 date);
create table jt2(c0 int, c1 int, c2 int, c3 date);
explain (costs off,verbose) select * from jt1 left join  jt2 s on s.c3=get_random_date('2020-02-10') and jt1.c2=s.c2;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Hash Right Join
   Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3, s.c0, s.c1, s.c2, s.c3
   Hash Cond: (s.c2 = jt1.c2)
   ->  Result
         Output: s.c0, s.c1, s.c2, s.c3
         Filter: (s.c3 = get_random_date('02-10-2020'::date))
         ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)
               Output: s.c0, s.c1, s.c2, s.c3
               ->  Seq Scan on public.jt2 s
                     Output: s.c0, s.c1, s.c2, s.c3
   ->  Hash
         Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
         ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
               Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
               ->  Seq Scan on public.jt1
                     Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
(16 rows)

explain (costs off,verbose) select * from jt1 left join (select * from jt2 where c3=get_random_date('2020-02-10')) s on jt1.c2=s.c2;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Hash Right Join
   Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3, jt2.c0, jt2.c1, jt2.c2, jt2.c3
   Hash Cond: (jt2.c2 = jt1.c2)
   ->  Result
         Output: jt2.c0, jt2.c1, jt2.c2, jt2.c3
         Filter: (jt2.c3 = get_random_date('02-10-2020'::date))
         ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)
               Output: jt2.c0, jt2.c1, jt2.c2, jt2.c3
               ->  Seq Scan on public.jt2
                     Output: jt2.c0, jt2.c1, jt2.c2, jt2.c3
   ->  Hash
         Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
         ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
               Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
               ->  Seq Scan on public.jt1
                     Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
(16 rows)

explain (costs off,verbose) select * from (select * from jt1 where c3=get_random_date('2020-02-10')) jt1 left join jt2 s on jt1.c2=s.c2;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Result
   Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3, s.c0, s.c1, s.c2, s.c3
   Filter: (jt1.c3 = get_random_date('02-10-2020'::date))
   ->  Hash Left Join
         Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3, s.c0, s.c1, s.c2, s.c3
         Hash Cond: (jt1.c2 = s.c2)
         ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)
               Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
               ->  Seq Scan on public.jt1
                     Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
         ->  Hash
               Output: s.c0, s.c1, s.c2, s.c3
               ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
                     Output: s.c0, s.c1, s.c2, s.c3
                     ->  Seq Scan on public.jt2 s
                           Output: s.c0, s.c1, s.c2, s.c3
(16 rows)

explain (costs off,verbose) select * from jt1 left join  jt2 s on jt1.c3=get_random_date('2020-02-10') and jt1.c2=s.c2;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Hash Left Join
   Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3, s.c0, s.c1, s.c2, s.c3
   Hash Cond: (jt1.c2 = s.c2)
   Join Filter: (jt1.c3 = get_random_date('02-10-2020'::date))
   ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)
         Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
         ->  Seq Scan on public.jt1
               Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
   ->  Hash
         Output: s.c0, s.c1, s.c2, s.c3
         ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
               Output: s.c0, s.c1, s.c2, s.c3
               ->  Seq Scan on public.jt2 s
                     Output: s.c0, s.c1, s.c2, s.c3
(14 rows)

explain (costs off,verbose) select * from jt1 left join  jt2 s on s.c3=get_random_date('2020-02-10') and jt1.c2=s.c2;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Hash Right Join
   Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3, s.c0, s.c1, s.c2, s.c3
   Hash Cond: (s.c2 = jt1.c2)
   ->  Result
         Output: s.c0, s.c1, s.c2, s.c3
         Filter: (s.c3 = get_random_date('02-10-2020'::date))
         ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)
               Output: s.c0, s.c1, s.c2, s.c3
               ->  Seq Scan on public.jt2 s
                     Output: s.c0, s.c1, s.c2, s.c3
   ->  Hash
         Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
         ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
               Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
               ->  Seq Scan on public.jt1
                     Output: jt1.c0, jt1.c1, jt1.c2, jt1.c3
(16 rows)

explain (costs off,verbose) select c1 from jt1 where c2 in (select c2 from jt2 where c3=get_random_date('2022-01-20'));
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Hash Join
   Output: jt1.c1
   Inner Unique: true
   Hash Cond: (jt1.c2 = jt2.c2)
   ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)
         Output: jt1.c1, jt1.c2
         ->  Seq Scan on public.jt1
               Output: jt1.c1, jt1.c2
   ->  Hash
         Output: jt2.c3, jt2.c2
         ->  Result
               Output: jt2.c3, jt2.c2
               Filter: (jt2.c3 = get_random_date('01-20-2022'::date))
               ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
                     Output: jt2.c3, jt2.c2
                     ->  HashAggregate
                           Output: jt2.c3, jt2.c2
                           Group Key: jt2.c3, jt2.c2
                           ->  Remote Subquery Scan[3] on all (datanode_1,datanode_2)
                                 Output: jt2.c3, jt2.c2
                                 Distribute results by S: c3, c2
                                 ->  Seq Scan on public.jt2
                                       Output: jt2.c3, jt2.c2
(23 rows)

explain (costs off,verbose) select c1 from jt1 where c2 in (select c2 from jt1 where c3=get_random_date('2022-01-20'));
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Hash Join
   Output: jt1.c1
   Inner Unique: true
   Hash Cond: (jt1.c2 = jt1_1.c2)
   ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)
         Output: jt1.c1, jt1.c2
         ->  Seq Scan on public.jt1
               Output: jt1.c1, jt1.c2
   ->  Hash
         Output: jt1_1.c3, jt1_1.c2
         ->  Result
               Output: jt1_1.c3, jt1_1.c2
               Filter: (jt1_1.c3 = get_random_date('01-20-2022'::date))
               ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
                     Output: jt1_1.c3, jt1_1.c2
                     ->  HashAggregate
                           Output: jt1_1.c3, jt1_1.c2
                           Group Key: jt1_1.c3, jt1_1.c2
                           ->  Remote Subquery Scan[3] on all (datanode_1,datanode_2)
                                 Output: jt1_1.c3, jt1_1.c2
                                 Distribute results by S: c3, c2
                                 ->  Seq Scan on public.jt1 jt1_1
                                       Output: jt1_1.c3, jt1_1.c2
(23 rows)

drop table if exists jt1;
drop table if exists jt2;
drop function if exists get_random_date(start_date date) cascade;
drop function if exists pullupf(x int);
NOTICE:  function pullupf(pg_catalog.int4) does not exist, skipping
create function pullupf(x int) returns int language plpgsql AS
$$
begin
    return x;
end $$ not pushdown;
drop table if exists ft1;
NOTICE:  table "ft1" does not exist, skipping
drop table if exists ft2;
NOTICE:  table "ft2" does not exist, skipping
drop table if exists ft3;
NOTICE:  table "ft3" does not exist, skipping
create table ft1(c0 int, c1 int, c2 int, c3 int);
create table ft2(c0 int, c1 int, c2 int, c3 int);
create table ft3(c0 int, c1 int, c2 int, c3 int);
explain (costs off)
select * from ft1 left join (select ft2.* from ft2 join (select * from ft3 where c2 = pullupf(c2)) fmm on ft2.c1=fmm.c1) fm on ft1.c2 = fm.c2;
                         QUERY PLAN                          
-------------------------------------------------------------
 Hash Right Join
   Hash Cond: (ft2.c2 = ft1.c2)
   ->  Hash Join
         Hash Cond: (ft3.c1 = ft2.c1)
         ->  Result
               Filter: (ft3.c2 = pullupf(ft3.c2))
               ->  Remote Subquery Scan on all (datanodes 2)
                     ->  Seq Scan on ft3
         ->  Hash
               ->  Remote Subquery Scan on all (datanodes 2)
                     ->  Seq Scan on ft2
   ->  Hash
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Seq Scan on ft1
(14 rows)

drop function if exists pullupfs(x int);
NOTICE:  function pullupfs(pg_catalog.int4) does not exist, skipping
create function pullupfs(x int) returns int language plpgsql AS
$$
begin
    return x;
end $$ not pushdown stable;
set enable_hashagg to off;
explain (costs off)
select count(1) from ft1 t1 where t1.c1=10 and exists (select c2 from ft2 t2 where t1.c3=t2.c3 and t2.c1=pullupfs(1));
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (t1.c3 = t2.c3)
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Seq Scan on ft1 t1
                     Filter: (c1 = 10)
         ->  Hash
               ->  Result
                     Filter: (t2.c1 = pullupfs(1))
                     ->  Remote Subquery Scan on all (datanodes 2)
                           ->  Unique
                                 ->  Sort
                                       Sort Key: t2.c3, t2.c1
                                       ->  Remote Subquery Scan on all (datanodes 2)
                                             Distribute results by S: c3, c1
                                             ->  Seq Scan on ft2 t2
(16 rows)

reset enable_hashagg;
drop function if exists pullupf(x int);
drop function if exists pullupfs(x int);
drop table if exists ft1;
drop table if exists ft2;
drop table if exists ft3;
