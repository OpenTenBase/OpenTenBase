--
-- UNION (also INTERSECT, EXCEPT)
--
-- Simple UNION constructs
SELECT 1 AS two UNION SELECT 2 ORDER BY 1;
 two 
-----
   1
   2
(2 rows)

SELECT 1 AS one UNION SELECT 1 ORDER BY 1;
 one 
-----
   1
(1 row)

SELECT 1 AS two UNION ALL SELECT 2 ORDER BY 1;
 two 
-----
   1
   2
(2 rows)

SELECT 1 AS two UNION ALL SELECT 1 ORDER BY 1;
 two 
-----
   1
   1
(2 rows)

SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;
 three 
-------
     1
     2
     3
(3 rows)

SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;
 two 
-----
   1
   2
(2 rows)

SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;
 three 
-------
     1
     2
     2
(3 rows)

SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;
 two 
-----
 1.1
 2.2
(2 rows)

-- Mixed types
SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;
 two 
-----
 1.1
   2
(2 rows)

SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;
 two 
-----
   1
 2.2
(2 rows)

SELECT 1 AS one UNION SELECT 1.0::float8 ORDER BY 1;
 one 
-----
   1
(1 row)

SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;
 two 
-----
 1.1
   2
(2 rows)

SELECT 1.0::float8 AS two UNION ALL SELECT 1 ORDER BY 1;
 two 
-----
   1
   1
(2 rows)

SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;
 three 
-------
   1.1
     2
     3
(3 rows)

SELECT 1.1::float8 AS two UNION SELECT 2 UNION SELECT 2.0::float8 ORDER BY 1;
 two 
-----
 1.1
   2
(2 rows)

SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;
 three 
-------
   1.1
     2
     2
(3 rows)

SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;
 two 
-----
 1.1
   2
(2 rows)

--
-- Try testing from tables...
--
SELECT f1 AS five FROM FLOAT8_TBL
UNION
SELECT f1 FROM FLOAT8_TBL
ORDER BY 1;
         five          
-----------------------
 -1.2345678901234e+200
               -1004.3
                -34.84
 -1.2345678901234e-200
                     0
(5 rows)

SELECT f1 AS ten FROM FLOAT8_TBL
UNION ALL
SELECT f1 FROM FLOAT8_TBL 
ORDER BY 1;
          ten          
-----------------------
 -1.2345678901234e+200
 -1.2345678901234e+200
               -1004.3
               -1004.3
                -34.84
                -34.84
 -1.2345678901234e-200
 -1.2345678901234e-200
                     0
                     0
(10 rows)

SELECT f1 AS nine FROM FLOAT8_TBL
UNION
SELECT f1 FROM INT4_TBL
ORDER BY 1;
         nine          
-----------------------
 -1.2345678901234e+200
           -2147483647
               -123456
               -1004.3
                -34.84
 -1.2345678901234e-200
                     0
                123456
            2147483647
(9 rows)

SELECT f1 AS ten FROM FLOAT8_TBL
UNION ALL
SELECT f1 FROM INT4_TBL 
ORDER BY 1;
          ten          
-----------------------
 -1.2345678901234e+200
           -2147483647
               -123456
               -1004.3
                -34.84
 -1.2345678901234e-200
                     0
                     0
                123456
            2147483647
(10 rows)

SELECT f1 AS five FROM FLOAT8_TBL
  WHERE f1 BETWEEN -1e6 AND 1e6
UNION
SELECT f1 FROM INT4_TBL
  WHERE f1 BETWEEN 0 AND 1000000
ORDER BY 1;
         five          
-----------------------
               -1004.3
                -34.84
 -1.2345678901234e-200
                     0
                123456
(5 rows)

SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL
UNION
SELECT f1 FROM CHAR_TBL
ORDER BY 1;
 three 
-------
 a   
 ab  
 abcd
(3 rows)

SELECT f1 AS three FROM VARCHAR_TBL
UNION
SELECT CAST(f1 AS varchar) FROM CHAR_TBL
ORDER BY 1;
 three 
-------
 a
 ab
 abcd
(3 rows)

SELECT f1 AS eight FROM VARCHAR_TBL
UNION ALL
SELECT f1 FROM CHAR_TBL 
ORDER BY 1;
 eight 
-------
 a
 a
 ab
 ab
 abcd
 abcd
 abcd
 abcd
(8 rows)

SELECT f1 AS five FROM TEXT_TBL
UNION
SELECT f1 FROM VARCHAR_TBL
UNION
SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL
ORDER BY 1;
       five        
-------------------
 a
 ab
 abcd
 doh!
 hi de ho neighbor
(5 rows)

--
-- INTERSECT and EXCEPT
--
SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;
        q2        
------------------
              123
 4567890123456789
(2 rows)

SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;
        q2        
------------------
              123
 4567890123456789
 4567890123456789
(3 rows)

SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
        q2         
-------------------
 -4567890123456789
               456
(2 rows)

SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;
        q2         
-------------------
 -4567890123456789
               456
(2 rows)

SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;
        q2         
-------------------
 -4567890123456789
               456
  4567890123456789
(3 rows)

SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;
 q1 
----
(0 rows)

SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;
        q1        
------------------
              123
 4567890123456789
(2 rows)

SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;
        q1        
------------------
              123
 4567890123456789
 4567890123456789
(3 rows)

SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;
ERROR:  FOR NO KEY UPDATE is not allowed with UNION/INTERSECT/EXCEPT
-- nested cases
(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;
 ?column? | ?column? | ?column? 
----------+----------+----------
        4 |        5 |        6
(1 row)

(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;
 ?column? | ?column? | ?column? 
----------+----------+----------
        4 |        5 |        6
(1 row)

(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;
 ?column? | ?column? | ?column? 
----------+----------+----------
        1 |        2 |        3
(1 row)

(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;
 ?column? | ?column? | ?column? 
----------+----------+----------
        1 |        2 |        3
(1 row)

-- exercise both hashed and sorted implementations of INTERSECT/EXCEPT
set enable_indexonlyscan to off;
set enable_hashagg to on;
explain (costs off)
select count(*) from
  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (NOT (tenk1.unique1 IS DISTINCT FROM tenk1_1.fivethous))
                     ->  HashAggregate
                           Group Key: tenk1.unique1
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Distribute results by S: unique1
                                 ->  HashAggregate
                                       Group Key: tenk1.unique1
                                       ->  Seq Scan on tenk1
                     ->  Hash
                           ->  HashAggregate
                                 Group Key: tenk1_1.fivethous
                                 ->  Remote Subquery Scan on all (datanodes 2)
                                       Distribute results by S: fivethous
                                       ->  Seq Scan on tenk1 tenk1_1
(18 rows)

select count(*) from
  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
 count 
-------
  5000
(1 row)

explain (costs off)
select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Anti Join
         Hash Cond: (NOT (tenk1.unique1 IS DISTINCT FROM tenk1_1.unique2))
         ->  HashAggregate
               Group Key: tenk1.unique1
               ->  Remote Subquery Scan on all (datanodes 2)
                     Distribute results by S: unique1
                     ->  HashAggregate
                           Group Key: tenk1.unique1
                           ->  Seq Scan on tenk1
         ->  Hash
               ->  HashAggregate
                     Group Key: tenk1_1.unique2
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by S: unique2
                           ->  HashAggregate
                                 Group Key: tenk1_1.unique2
                                 ->  Seq Scan on tenk1 tenk1_1
                                       Filter: (unique2 <> 10)
(19 rows)

select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
 unique1 
---------
      10
(1 row)

set enable_hashagg to off;
explain (costs off)
select count(*) from
  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Remote Subquery Scan on all (datanodes 2)
         ->  Partial Aggregate
               ->  Hash Join
                     Hash Cond: (NOT (tenk1.unique1 IS DISTINCT FROM tenk1_1.fivethous))
                     ->  HashAggregate
                           Group Key: tenk1.unique1
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Distribute results by S: unique1
                                 ->  Seq Scan on tenk1
                     ->  Hash
                           ->  HashAggregate
                                 Group Key: tenk1_1.fivethous
                                 ->  Remote Subquery Scan on all (datanodes 2)
                                       Distribute results by S: fivethous
                                       ->  Seq Scan on tenk1 tenk1_1
(16 rows)

select count(*) from
  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
 count 
-------
  5000
(1 row)

explain (costs off)
select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Anti Join
         Hash Cond: (NOT (tenk1.unique1 IS DISTINCT FROM tenk1_1.unique2))
         ->  HashAggregate
               Group Key: tenk1.unique1
               ->  Remote Subquery Scan on all (datanodes 2)
                     Distribute results by S: unique1
                     ->  Seq Scan on tenk1
         ->  Hash
               ->  HashAggregate
                     Group Key: tenk1_1.unique2
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by S: unique2
                           ->  Seq Scan on tenk1 tenk1_1
                                 Filter: (unique2 <> 10)
(15 rows)

select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
 unique1 
---------
      10
(1 row)

reset enable_hashagg;
reset enable_indexonlyscan;
--
-- Mixed types
--
SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;
 f1 
----
  0
(1 row)

SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;
          f1           
-----------------------
 -1.2345678901234e+200
               -1004.3
                -34.84
 -1.2345678901234e-200
(4 rows)

--
-- Operator precedence and (((((extra))))) parentheses
--
SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl ORDER BY 1;
        q1         
-------------------
 -4567890123456789
               123
               123
               456
  4567890123456789
  4567890123456789
  4567890123456789
(7 rows)

SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;
        q1        
------------------
              123
 4567890123456789
(2 rows)

(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl))) UNION ALL SELECT q2 FROM int8_tbl ORDER BY 1;
        q1         
-------------------
 -4567890123456789
               123
               123
               456
  4567890123456789
  4567890123456789
  4567890123456789
(7 rows)

SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
        q1         
-------------------
 -4567890123456789
               456
(2 rows)

SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1))) ORDER BY 1;
        q1         
-------------------
 -4567890123456789
               123
               123
               456
  4567890123456789
  4567890123456789
  4567890123456789
(7 rows)

(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
        q1         
-------------------
 -4567890123456789
               456
(2 rows)

--
-- Subqueries with ORDER BY & LIMIT clauses
--
-- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT
SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl
ORDER BY q2,q1;
        q1        |        q2         
------------------+-------------------
 4567890123456789 | -4567890123456789
              123 |               456
(2 rows)

-- This should fail, because q2 isn't a name of an EXCEPT output column
SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;
ERROR:  column "q2" does not exist
LINE 1: ... int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1...
                                                             ^
HINT:  There is a column named "q2" in table "*SELECT* 2", but it cannot be referenced from this part of the query.
-- But this should work:
SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;
        q1        
------------------
              123
 4567890123456789
(2 rows)

--
-- New syntaxes (7.1) permit new tests
--
(((((select * from int8_tbl  ORDER BY q1, q2)))));
        q1        |        q2         
------------------+-------------------
              123 |               456
              123 |  4567890123456789
 4567890123456789 | -4567890123456789
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
(5 rows)

--
-- Check behavior with empty select list (allowed since 9.4)
--
select union select;
--
(1 row)

select intersect select;
--
(1 row)

select except select;
--
(0 rows)

-- check hashed implementation
set enable_hashagg = true;
set enable_sort = false;
explain (costs off)
select from generate_series(1,5) union select from generate_series(1,3);
                           QUERY PLAN                           
----------------------------------------------------------------
 HashAggregate
   ->  Append
         ->  Function Scan on generate_series
         ->  Function Scan on generate_series generate_series_1
(4 rows)

explain (costs off)
select from generate_series(1,5) intersect select from generate_series(1,3);
                              QUERY PLAN                              
----------------------------------------------------------------------
 HashSetOp Intersect
   ->  Append
         ->  Subquery Scan on "*SELECT* 1"
               ->  Function Scan on generate_series
         ->  Subquery Scan on "*SELECT* 2"
               ->  Function Scan on generate_series generate_series_1
(6 rows)

select from generate_series(1,5) union select from generate_series(1,3);
--
(1 row)

select from generate_series(1,5) union all select from generate_series(1,3);
--
(8 rows)

select from generate_series(1,5) intersect select from generate_series(1,3);
--
(1 row)

select from generate_series(1,5) intersect all select from generate_series(1,3);
--
(3 rows)

select from generate_series(1,5) except select from generate_series(1,3);
--
(0 rows)

select from generate_series(1,5) except all select from generate_series(1,3);
--
(2 rows)

-- check sorted implementation
set enable_hashagg = false;
set enable_sort = true;
explain (costs off)
select from generate_series(1,5) union select from generate_series(1,3);
                           QUERY PLAN                           
----------------------------------------------------------------
 Unique
   ->  Append
         ->  Function Scan on generate_series
         ->  Function Scan on generate_series generate_series_1
(4 rows)

explain (costs off)
select from generate_series(1,5) intersect select from generate_series(1,3);
                              QUERY PLAN                              
----------------------------------------------------------------------
 SetOp Intersect
   ->  Append
         ->  Subquery Scan on "*SELECT* 1"
               ->  Function Scan on generate_series
         ->  Subquery Scan on "*SELECT* 2"
               ->  Function Scan on generate_series generate_series_1
(6 rows)

select from generate_series(1,5) union select from generate_series(1,3);
--
(1 row)

select from generate_series(1,5) union all select from generate_series(1,3);
--
(8 rows)

select from generate_series(1,5) intersect select from generate_series(1,3);
--
(1 row)

select from generate_series(1,5) intersect all select from generate_series(1,3);
--
(3 rows)

select from generate_series(1,5) except select from generate_series(1,3);
--
(0 rows)

select from generate_series(1,5) except all select from generate_series(1,3);
--
(2 rows)

reset enable_hashagg;
reset enable_sort;
--
-- Check handling of a case with unknown constants.  We don't guarantee
-- an undecorated constant will work in all cases, but historically this
-- usage has worked, so test we don't break it.
--
SELECT a.f1 FROM (SELECT 'test' AS f1 FROM varchar_tbl) a
UNION
SELECT b.f1 FROM (SELECT f1 FROM varchar_tbl) b
ORDER BY 1;
  f1  
------
 a
 ab
 abcd
 test
(4 rows)

-- This should fail, but it should produce an error cursor
SELECT '3.4'::numeric UNION SELECT 'foo';
ERROR:  invalid input syntax for type numeric: "foo"
LINE 1: SELECT '3.4'::numeric UNION SELECT 'foo';
                                           ^
--
-- Test that expression-index constraints can be pushed down through
-- UNION or UNION ALL
--
CREATE TEMP TABLE t1 (a text, b text);
CREATE INDEX t1_ab_idx on t1 ((a || b));
CREATE TEMP TABLE t2 (ab text primary key);
INSERT INTO t1 VALUES ('a', 'b'), ('x', 'y');
INSERT INTO t2 VALUES ('ab'), ('xy');
set enable_seqscan = off;
set enable_indexscan = on;
set enable_bitmapscan = off;
explain (num_nodes off, nodes off, costs off)
 SELECT * FROM
 (SELECT a || b AS ab FROM t1
  UNION ALL
  SELECT * FROM t2) t
 WHERE ab = 'ab';
                    QUERY PLAN                     
---------------------------------------------------
 Remote Fast Query Execution
   ->  Append
         ->  Index Scan using t1_ab_idx on t1
               Index Cond: ((a || b) = 'ab'::text)
         ->  Index Only Scan using t2_pkey on t2
               Index Cond: (ab = 'ab'::text)
(6 rows)

explain (num_nodes off, nodes off, costs off)
 SELECT * FROM
 (SELECT a || b AS ab FROM t1
  UNION
  SELECT * FROM t2) t
 WHERE ab = 'ab';
                             QUERY PLAN                              
---------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  HashAggregate
         Group Key: ((t1.a || t1.b))
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: ((a || b))
               ->  HashAggregate
                     Group Key: ((t1.a || t1.b))
                     ->  Append
                           ->  Index Scan using t1_ab_idx on t1
                                 Index Cond: ((a || b) = 'ab'::text)
                           ->  Index Only Scan using t2_pkey on t2
                                 Index Cond: (ab = 'ab'::text)
(12 rows)

--
-- Test that ORDER BY for UNION ALL can be pushed down to inheritance
-- children.
--
CREATE TEMP TABLE t1c (a text, b text);
ALTER TABLE t1c INHERIT t1;
CREATE TEMP TABLE t2c (primary key (ab)) INHERITS (t2);
INSERT INTO t1c (b, a)  VALUES ('v', 'w'), ('c', 'd'), ('m', 'n'), ('e', 'f');
INSERT INTO t2c VALUES ('vw'), ('cd'), ('mn'), ('ef');
CREATE INDEX t1c_ab_idx on t1c ((a || b));
set enable_seqscan = on;
set enable_indexonlyscan = off;
explain (costs off)
  SELECT * FROM
  (SELECT a || b AS ab FROM t1
   UNION ALL
   SELECT ab FROM t2) t
  ORDER BY 1 LIMIT 8;
                         QUERY PLAN                         
------------------------------------------------------------
 Limit
   ->  Remote Subquery Scan on all (datanodes 2)
         Sort Key: ((t1.a || t1.b))
         ->  Limit
               ->  Merge Append
                     Sort Key: ((t1.a || t1.b))
                     ->  Index Scan using t1_ab_idx on t1
                     ->  Index Scan using t1c_ab_idx on t1c
                     ->  Index Scan using t2_pkey on t2
                     ->  Index Scan using t2c_pkey on t2c
(10 rows)

  SELECT * FROM
  (SELECT a || b AS ab FROM t1
   UNION ALL
   SELECT ab FROM t2) t
  ORDER BY 1 LIMIT 8;
 ab 
----
 ab
 ab
 cd
 dc
 ef
 fe
 mn
 nm
(8 rows)

reset enable_seqscan;
reset enable_indexscan;
reset enable_bitmapscan;
-- This simpler variant of the above test has been observed to fail differently
create table events (event_id int primary key);
create table other_events (event_id int primary key);
create table events_child () inherits (events);
explain (costs off)
select event_id
 from (select event_id from events
       union all
       select event_id from other_events) ss
 order by event_id;
                    QUERY PLAN                    
--------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   Sort Key: events.event_id
   ->  Sort
         Sort Key: events.event_id
         ->  Append
               ->  Append
                     ->  Seq Scan on events
                     ->  Seq Scan on events_child
               ->  Seq Scan on other_events
(9 rows)

drop table events_child, events, other_events;
reset enable_indexonlyscan;
-- Test constraint exclusion of UNION ALL subqueries
explain (num_nodes off, nodes off, costs off)
 SELECT * FROM
  (SELECT 1 AS t, * FROM tenk1 a
   UNION ALL
   SELECT 2 AS t, * FROM tenk1 b) c
 WHERE t = 2;
           QUERY PLAN            
---------------------------------
 Remote Fast Query Execution
   ->  Append
         ->  Seq Scan on tenk1 b
(3 rows)

-- Test that we push quals into UNION sub-selects only when it's safe
explain (costs off)
SELECT * FROM
  (SELECT 1 AS t, 2 AS x
   UNION
   SELECT 2 AS t, 4 AS x) ss
WHERE x < 4
ORDER BY x;
                    QUERY PLAN                    
--------------------------------------------------
 Sort
   Sort Key: (2)
   ->  Unique
         ->  Sort
               Sort Key: (1), (2)
               ->  Append
                     ->  Result
                     ->  Result
                           One-Time Filter: false
(9 rows)

SELECT * FROM
  (SELECT 1 AS t, 2 AS x
   UNION
   SELECT 2 AS t, 4 AS x) ss
WHERE x < 4
ORDER BY x;
 t | x 
---+---
 1 | 2
(1 row)

explain (costs off)
SELECT * FROM
  (SELECT 1 AS t, generate_series(1,10) AS x
   UNION
   SELECT 2 AS t, 4 AS x) ss
WHERE x < 4
ORDER BY x;
                       QUERY PLAN                       
--------------------------------------------------------
 Sort
   Sort Key: ss.x
   ->  Subquery Scan on ss
         Filter: (ss.x < 4)
         ->  HashAggregate
               Group Key: (1), (generate_series(1, 10))
               ->  Append
                     ->  ProjectSet
                           ->  Result
                     ->  Result
(10 rows)

SELECT * FROM
  (SELECT 1 AS t, generate_series(1,10) AS x
   UNION
   SELECT 2 AS t, 4 AS x) ss
WHERE x < 4
ORDER BY x;
 t | x 
---+---
 1 | 1
 1 | 2
 1 | 3
(3 rows)

explain (costs off)
SELECT * FROM
  (SELECT 1 AS t, (random()*3)::int AS x
   UNION
   SELECT 2 AS t, 4 AS x) ss
WHERE x > 3
ORDER BY x;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Sort Key: ss.x
   ->  Subquery Scan on ss
         Filter: (ss.x > 3)
         ->  Unique
               ->  Sort
                     Sort Key: (1), (((random() * '3'::double precision))::integer)
                     ->  Append
                           ->  Result
                           ->  Result
(10 rows)

SELECT * FROM
  (SELECT 1 AS t, (random()*3)::int AS x
   UNION
   SELECT 2 AS t, 4 AS x) ss
WHERE x > 3
ORDER BY x;
 t | x 
---+---
 2 | 4
(1 row)

-- Test proper handling of parameterized appendrel paths when the
-- potential join qual is expensive
create function expensivefunc(int) returns int
language plpgsql immutable strict pushdown cost 10000
as $$begin return $1; end$$;
WARNING:  You are pushing function down to datanode for execution
HINT:  Make sure it's not attempt to access any other datanode OR YOU MAY SUFFER DATA LOSE !!
create temp table t3 as select generate_series(-1000,1000) as x;
create index t3i on t3 (expensivefunc(x));
analyze t3;
explain (num_nodes off, nodes off, costs off)
select * from
  (select * from t3 a union all select * from t3 b) ss
  join int4_tbl on f1 = expensivefunc(x);
                            QUERY PLAN                            
------------------------------------------------------------------
 Remote Fast Query Execution
   ->  Nested Loop
         ->  Seq Scan on int4_tbl
         ->  Append
               ->  Index Scan using t3i on t3 a
                     Index Cond: (expensivefunc(x) = int4_tbl.f1)
               ->  Index Scan using t3i on t3 b
                     Index Cond: (expensivefunc(x) = int4_tbl.f1)
(8 rows)

select * from
  (select * from t3 a union all select * from t3 b) ss
  join int4_tbl on f1 = expensivefunc(x);
 x | f1 
---+----
 0 |  0
 0 |  0
(2 rows)

alter function expensivefunc not pushdown;
explain (num_nodes off, nodes off, costs off)
select * from
  (select * from t3 a union all select * from t3 b) ss
  join int4_tbl on f1 = expensivefunc(x);
                            QUERY PLAN                            
------------------------------------------------------------------
 Remote Fast Query Execution
   ->  Nested Loop
         ->  Seq Scan on int4_tbl
         ->  Append
               ->  Index Scan using t3i on t3 a
                     Index Cond: (expensivefunc(x) = int4_tbl.f1)
               ->  Index Scan using t3i on t3 b
                     Index Cond: (expensivefunc(x) = int4_tbl.f1)
(8 rows)

select * from
  (select * from t3 a union all select * from t3 b) ss
  join int4_tbl on f1 = expensivefunc(x);
 x | f1 
---+----
 0 |  0
 0 |  0
(2 rows)

drop table t3;
drop function expensivefunc(int);
-- Test handling of appendrel quals that const-simplify into an AND
explain (costs off)
select * from
  (select *, 0 as x from int8_tbl a
   union all
   select *, 1 as x from int8_tbl b) ss
where (x = 0) or (q1 >= q2 and q1 <= q2);
                    QUERY PLAN                     
---------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1
   ->  Append
         ->  Seq Scan on int8_tbl a
         ->  Seq Scan on int8_tbl b
               Filter: ((q1 >= q2) AND (q1 <= q2))
(6 rows)

select * from
  (select *, 0 as x from int8_tbl a
   union all
   select *, 1 as x from int8_tbl b) ss
where (x = 0) or (q1 >= q2 and q1 <= q2) order by 1,2,3;
        q1        |        q2         | x 
------------------+-------------------+---
              123 |               456 | 0
              123 |  4567890123456789 | 0
 4567890123456789 | -4567890123456789 | 0
 4567890123456789 |               123 | 0
 4567890123456789 |  4567890123456789 | 0
 4567890123456789 |  4567890123456789 | 1
(6 rows)

CREATE TABLE tb1 (c1 int, c2 int) DISTRIBUTE BY REPLICATION;
CREATE TABLE tb2 (c1 int, c2 int);
insert into tb2 select i,i from generate_series(1, 10) i;
insert into tb1 select i,i from generate_series(1, 10) i;
explain (costs off) select c1 from tb1 union all select c1 from tb2;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Append
         ->  Remote Subquery Scan on all (datanodes 1)
               Distribute results by S: c1
               ->  Seq Scan on tb1
         ->  Seq Scan on tb2
(6 rows)

select c1 from tb1 union all select c1 from tb2 order by c1;
 c1 
----
  1
  1
  2
  2
  3
  3
  4
  4
  5
  5
  6
  6
  7
  7
  8
  8
  9
  9
 10
 10
(20 rows)

explain (costs off) select c1 from tb2 union all select c1 from tb1;
                      QUERY PLAN                       
-------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Append
         ->  Seq Scan on tb2
         ->  Remote Subquery Scan on all (datanodes 1)
               Distribute results by S: c1
               ->  Seq Scan on tb1
(6 rows)

select c1 from tb2 union all select c1 from tb1 order by c1;
 c1 
----
  1
  1
  2
  2
  3
  3
  4
  4
  5
  5
  6
  6
  7
  7
  8
  8
  9
  9
 10
 10
(20 rows)

drop table tb1;
drop table tb2;
--plan of setop (not union)
explain (costs off) select * from (select 2 except select 1 from t1);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 1)
   ->  Subquery Scan on "__Alias_34__"
         ->  HashSetOp Except
               ->  Append
                     ->  Subquery Scan on "*SELECT* 1"
                           ->  Result
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by R
                           ->  Subquery Scan on "*SELECT* 2"
                                 ->  Result
                                       ->  Append
                                             ->  Seq Scan on t1
                                             ->  Seq Scan on t1c
(13 rows)

select * from (select 2 except select 1 from t1);
 ?column? 
----------
        2
(1 row)

create table test_nonunion(a int);
insert into test_nonunion values (1);
explain (costs off, verbose) select 'x' from test_nonunion t1 union select 'x' from test_nonunion t2 where 1=2 except select 'y' from test_nonunion t3 intersect select 'y' from test_nonunion t4;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1)
   Output: ('x'::text), (0)
   ->  HashSetOp Except
         Output: ('x'::text), (0)
         ->  Append
               ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
                     Output: ('x'::text), 0
                     Distribute results by R
                     ->  HashAggregate
                           Output: ('x'::text), 0
                           Group Key: ('x'::text)
                           ->  Remote Subquery Scan[3] on all (datanode_1,datanode_2)
                                 Output: ('x'::text)
                                 Distribute results by S: ('x'::text)
                                 ->  HashAggregate
                                       Output: ('x'::text)
                                       Group Key: ('x'::text)
                                       ->  Append
                                             ->  Seq Scan on public.test_nonunion t1
                                                   Output: 'x'::text
                                             ->  Remote Subquery Scan[4] on all (datanode_1)
                                                   Output: 'x'::text
                                                   Distribute results by S: 'x'::text
                                                   ->  Result
                                                         Output: 'x'::text
                                                         One-Time Filter: false
               ->  Remote Subquery Scan[5] on all (datanode_1,datanode_2)
                     Output: 'y'::text, 1
                     Distribute results by R
                     ->  Hash Join
                           Output: 'y'::text, 1
                           Hash Cond: (NOT ('y'::text IS DISTINCT FROM 'y'::text))
                           ->  HashAggregate
                                 Output: ('y'::text)
                                 Group Key: 'y'::text
                                 ->  Remote Subquery Scan[6] on all (datanode_1,datanode_2)
                                       Output: 'y'::text
                                       Distribute results by S: 'y'::text
                                       ->  HashAggregate
                                             Output: ('y'::text)
                                             Group Key: 'y'::text
                                             ->  Seq Scan on public.test_nonunion t3
                                                   Output: 'y'::text
                           ->  Hash
                                 Output: 'y'::text
                                 ->  HashAggregate
                                       Output: ('y'::text)
                                       Group Key: 'y'::text
                                       ->  Remote Subquery Scan[7] on all (datanode_1,datanode_2)
                                             Output: 'y'::text
                                             Distribute results by S: 'y'::text
                                             ->  HashAggregate
                                                   Output: ('y'::text)
                                                   Group Key: 'y'::text
                                                   ->  Seq Scan on public.test_nonunion t4
                                                         Output: 'y'::text
(56 rows)

select 'x' from test_nonunion t1 except select 'y' from test_nonunion t2 except select 'x' from test_nonunion t3 intersect select 'x' from test_nonunion t4 except select 'y' from test_nonunion t5 ;
 ?column? 
----------
(0 rows)

drop table test_nonunion;
--bugfix
create table test_setop(c0 int, c1 bytea, c2 char, c3 bigint, c4 smallint) distribute by shard(c0);
set nonunion_optimizer = off;
EXPLAIN (costs off, verbose)
SELECT ALL ref_0.c4 AS c0
FROM test_setop AS ref_0
EXCEPT
SELECT ALL ref_0.c4 AS c0
FROM test_setop AS ref_0
WHERE (ref_0.c1 <> ref_0.c1)
EXCEPT
SELECT ALL ref_0.c4 AS c0
FROM test_setop AS ref_0
INTERSECT DISTINCT VALUES (CAST(NULL AS NUMERIC)) FOR READ ONLY;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1)
   Output: (("*SELECT* 1".c0)::numeric), (0)
   ->  HashSetOp Except
         Output: (("*SELECT* 1".c0)::numeric), (0)
         ->  Append
               ->  Result
                     Output: "*SELECT* 1".c0, 0
                     ->  HashSetOp Except
                           Output: "*SELECT* 1".c0, (0)
                           ->  Append
                                 ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
                                       Output: "*SELECT* 1".c0, 0
                                       Distribute results by R
                                       ->  Subquery Scan on "*SELECT* 1"
                                             Output: "*SELECT* 1".c0, 0
                                             ->  Seq Scan on public.test_setop ref_0
                                                   Output: ref_0.c4
                                 ->  Remote Subquery Scan[3] on all (datanode_1,datanode_2)
                                       Output: "*SELECT* 2".c0, 1
                                       Distribute results by R
                                       ->  Subquery Scan on "*SELECT* 2"
                                             Output: "*SELECT* 2".c0, 1
                                             ->  Seq Scan on public.test_setop ref_0_1
                                                   Output: ref_0_1.c4
                                                   Filter: (ref_0_1.c1 <> ref_0_1.c1)
               ->  Result
                     Output: (NULL::numeric), 1
                     ->  HashSetOp Intersect
                           Output: (NULL::numeric), (1)
                           ->  Append
                                 ->  Subquery Scan on "*SELECT* 4"
                                       Output: NULL::numeric, 1
                                       ->  Result
                                             Output: NULL::numeric
                                 ->  Remote Subquery Scan[4] on all (datanode_1,datanode_2)
                                       Output: (("*SELECT* 3".c0)::numeric), 0
                                       Distribute results by R
                                       ->  Subquery Scan on "*SELECT* 3"
                                             Output: "*SELECT* 3".c0, 0
                                             ->  Seq Scan on public.test_setop ref_0_2
                                                   Output: ref_0_2.c4
(41 rows)

set nonunion_optimizer = on;
EXPLAIN (costs off, verbose)
SELECT ALL ref_0.c4 AS c0
FROM test_setop AS ref_0
EXCEPT
SELECT ALL ref_0.c4 AS c0
FROM test_setop AS ref_0
WHERE (ref_0.c1 <> ref_0.c1)
EXCEPT
SELECT ALL ref_0.c4 AS c0
FROM test_setop AS ref_0
INTERSECT DISTINCT VALUES (CAST(NULL AS NUMERIC)) FOR READ ONLY;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1)
   Output: ((ref_0.c4)::numeric), (0)
   ->  HashSetOp Except
         Output: ((ref_0.c4)::numeric), (0)
         ->  Append
               ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
                     Output: ((ref_0.c4)::numeric), 0
                     Distribute results by R
                     ->  Hash Anti Join
                           Output: ref_0.c4, 0
                           Hash Cond: (NOT (ref_0.c4 IS DISTINCT FROM ref_0_1.c4))
                           ->  HashAggregate
                                 Output: ref_0.c4
                                 Group Key: ref_0.c4
                                 ->  Remote Subquery Scan[3] on all (datanode_1,datanode_2)
                                       Output: ref_0.c4
                                       Distribute results by S: c4
                                       ->  HashAggregate
                                             Output: ref_0.c4
                                             Group Key: ref_0.c4
                                             ->  Seq Scan on public.test_setop ref_0
                                                   Output: ref_0.c4
                           ->  Hash
                                 Output: ref_0_1.c4
                                 ->  HashAggregate
                                       Output: ref_0_1.c4
                                       Group Key: ref_0_1.c4
                                       ->  Remote Subquery Scan[4] on all (datanode_1,datanode_2)
                                             Output: ref_0_1.c4
                                             Distribute results by S: c4
                                             ->  HashAggregate
                                                   Output: ref_0_1.c4
                                                   Group Key: ref_0_1.c4
                                                   ->  Seq Scan on public.test_setop ref_0_1
                                                         Output: ref_0_1.c4
                                                         Filter: (ref_0_1.c1 <> ref_0_1.c1)
               ->  Result
                     Output: (NULL::numeric), 1
                     ->  HashSetOp Intersect
                           Output: (NULL::numeric), (1)
                           ->  Append
                                 ->  Subquery Scan on "*SELECT* 4"
                                       Output: NULL::numeric, 1
                                       ->  Result
                                             Output: NULL::numeric
                                 ->  Remote Subquery Scan[5] on all (datanode_1,datanode_2)
                                       Output: (("*SELECT* 3".c0)::numeric), 0
                                       Distribute results by R
                                       ->  Subquery Scan on "*SELECT* 3"
                                             Output: "*SELECT* 3".c0, 0
                                             ->  Seq Scan on public.test_setop ref_0_2
                                                   Output: ref_0_2.c4
(52 rows)

drop table test_setop;
reset nonunion_optimizer;
CREATE TABLE rqg_table4 (
c0 int,
c1 int,
c2 text,
c3 text,
c4 date,
c5 date,
c6 timestamp,
c7 timestamp,
c8 time,
c9 time,
pk text,
/*Indices*/
primary key (pk))    PARTITION BY hash(pk) distribute by replication;
set nonunion_optimizer = off;
explain (costs off, verbose) select c2 FROM rqg_table4 EXCEPT ALL select c3 FROM rqg_table4 INTERSECT select c2 FROM rqg_table4 order by 1;
                                                                                         QUERY PLAN                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: "*SELECT* 1".c2
   Node/s: datanode_1
   Remote query: SELECT rqg_table4.c2 FROM public.rqg_table4 EXCEPT ALL (SELECT rqg_table4.c3 AS c2 FROM public.rqg_table4 INTERSECT SELECT rqg_table4.c2 FROM public.rqg_table4) ORDER BY 1
   ->  Sort
         Output: "*SELECT* 1".c2, (0)
         Sort Key: "*SELECT* 1".c2
         ->  HashSetOp Except All
               Output: "*SELECT* 1".c2, (0)
               ->  Append
                     ->  Subquery Scan on "*SELECT* 1"
                           Output: "*SELECT* 1".c2, 0
                           ->  Result
                                 Output: c2
                                 One-Time Filter: false
                     ->  Result
                           Output: "*SELECT* 2".c2, 1
                           ->  HashSetOp Intersect
                                 Output: "*SELECT* 2".c2, (0)
                                 ->  Append
                                       ->  Subquery Scan on "*SELECT* 2"
                                             Output: "*SELECT* 2".c2, 0
                                             ->  Result
                                                   Output: c3
                                                   One-Time Filter: false
                                       ->  Subquery Scan on "*SELECT* 3"
                                             Output: "*SELECT* 3".c2, 1
                                             ->  Result
                                                   Output: c2
                                                   One-Time Filter: false
(30 rows)

set nonunion_optimizer = on;
explain (costs off, verbose) select c2 FROM rqg_table4 EXCEPT ALL select c3 FROM rqg_table4 INTERSECT select c2 FROM rqg_table4 order by 1;
                                                                                         QUERY PLAN                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Output: "*SELECT* 1".c2
   Node/s: datanode_1
   Remote query: SELECT rqg_table4.c2 FROM public.rqg_table4 EXCEPT ALL (SELECT rqg_table4.c3 AS c2 FROM public.rqg_table4 INTERSECT SELECT rqg_table4.c2 FROM public.rqg_table4) ORDER BY 1
   ->  Sort
         Output: "*SELECT* 1".c2, (0)
         Sort Key: "*SELECT* 1".c2
         ->  HashSetOp Except All
               Output: "*SELECT* 1".c2, (0)
               ->  Append
                     ->  Subquery Scan on "*SELECT* 1"
                           Output: "*SELECT* 1".c2, 0
                           ->  Result
                                 Output: c2
                                 One-Time Filter: false
                     ->  Result
                           Output: "*SELECT* 2".c2, 1
                           ->  HashSetOp Intersect
                                 Output: "*SELECT* 2".c2, (0)
                                 ->  Append
                                       ->  Subquery Scan on "*SELECT* 2"
                                             Output: "*SELECT* 2".c2, 0
                                             ->  Result
                                                   Output: c3
                                                   One-Time Filter: false
                                       ->  Subquery Scan on "*SELECT* 3"
                                             Output: "*SELECT* 3".c2, 1
                                             ->  Result
                                                   Output: c2
                                                   One-Time Filter: false
(30 rows)

drop table rqg_table4;
reset nonunion_optimizer;
create table union_test(c1 int, c2 int);
explain (costs off) select 1 union select c1 from union_test;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  HashAggregate
         Group Key: (1)
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: (1)
               ->  HashAggregate
                     Group Key: (1)
                     ->  Append
                           ->  Remote Subquery Scan on all (datanodes 1)
                                 Distribute results by S: 1
                                 ->  Result
                           ->  Seq Scan on union_test
(12 rows)

explain (costs off) select c1 from union_test union select 1;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  HashAggregate
         Group Key: union_test.c1
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: c1
               ->  HashAggregate
                     Group Key: union_test.c1
                     ->  Append
                           ->  Seq Scan on union_test
                           ->  Remote Subquery Scan on all (datanodes 1)
                                 Distribute results by S: 1
                                 ->  Result
(12 rows)

explain (costs off) select 1 union select 2;
        QUERY PLAN        
--------------------------
 Unique
   ->  Sort
         Sort Key: (1)
         ->  Append
               ->  Result
               ->  Result
(6 rows)

prepare union_test_fun(int, int) as select $1 union select c1 from union_test union select $2;
explain (costs off) execute union_test_fun(1,2);
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  HashAggregate
         Group Key: (1)
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: (1)
               ->  HashAggregate
                     Group Key: (1)
                     ->  Append
                           ->  Remote Subquery Scan on all (datanodes 1)
                                 Distribute results by S: 1
                                 ->  Result
                           ->  Seq Scan on union_test
                           ->  Remote Subquery Scan on all (datanodes 1)
                                 Distribute results by S: 2
                                 ->  Result
(15 rows)

DEALLOCATE  union_test_fun;
prepare union_test_fun(int) as select c1 from union_test union select $1;
explain (costs off) execute union_test_fun(1);
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  HashAggregate
         Group Key: union_test.c1
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: c1
               ->  HashAggregate
                     Group Key: union_test.c1
                     ->  Append
                           ->  Seq Scan on union_test
                           ->  Remote Subquery Scan on all (datanodes 1)
                                 Distribute results by S: 1
                                 ->  Result
(12 rows)

DEALLOCATE  union_test_fun;
prepare union_test_fun(int) as select $1 union select c1 from union_test;
explain (costs off) execute union_test_fun(1);
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  HashAggregate
         Group Key: (1)
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: (1)
               ->  HashAggregate
                     Group Key: (1)
                     ->  Append
                           ->  Remote Subquery Scan on all (datanodes 1)
                                 Distribute results by S: 1
                                 ->  Result
                           ->  Seq Scan on union_test
(12 rows)

DEALLOCATE  union_test_fun;
drop table union_test;
