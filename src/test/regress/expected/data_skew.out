DROP TABLE IF EXISTS lineitem;
NOTICE:  table "lineitem" does not exist, skipping
CREATE TABLE lineitem ( l_orderkey    bigint not null,
                        l_partkey     integer not null,
                        l_suppkey     integer not null,
                        l_linenumber  integer not null,
                        l_quantity    decimal(15,2) not null,
                        l_extendedprice  decimal(15,2) not null,
                        l_discount    decimal(15,2) not null,
                        l_tax         decimal(15,2) not null,
                        l_returnflag  char(1) not null,
                        l_linestatus  char(1) not null,
                        l_shipdate    date not null,
                        l_commitdate  date not null,
                        l_receiptdate date not null,
                        l_shipinstruct char(25) not null,
                        l_shipmode     char(10) not null,
                        l_comment      varchar(44) not null)
                        distribute by shard(l_orderkey);
set data_skew_option=3;
-- Test prefer distribute clause with const in current query block
EXPLAIN (COSTS OFF)
SELECT l1.l_partkey, l1.l_partkey
  FROM (SELECT MIN(l_suppkey) AS l_suppkey, 
               MIN(l_linenumber) AS l_linenumber,
               MIN(l_partkey) as l_partkey
         FROM  lineitem
         GROUP by l_quantity) as l1
  LEFT OUTER JOIN
       (SELECT MIN(l_suppkey) as l_suppkey, 
               MIN(l_linenumber) as l_linenumber,
               MIN(l_partkey) as l_partkey 
         FROM  lineitem 
         GROUP BY l_quantity) as l2
   ON  l1.l_partkey = l2.l_suppkey
   AND l1.l_suppkey = l2.l_linenumber
   AND l1.l_linenumber = l2.l_partkey
 WHERE l1.l_partkey = 10;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Nested Loop Left Join
         Join Filter: ((l1.l_partkey = l2.l_suppkey) AND (l1.l_suppkey = l2.l_linenumber) AND (l1.l_linenumber = l2.l_partkey))
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: l_suppkey
               ->  Subquery Scan on l1
                     ->  Finalize GroupAggregate
                           Group Key: lineitem.l_quantity
                           Filter: (min(lineitem.l_partkey) = 10)
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Sort Key: lineitem.l_quantity
                                 Distribute results by S: l_quantity
                                 ->  Partial GroupAggregate
                                       Group Key: lineitem.l_quantity
                                       ->  Sort
                                             Sort Key: lineitem.l_quantity
                                             ->  Seq Scan on lineitem
         ->  Materialize
               ->  Remote Subquery Scan on all (datanodes 2)
                     Distribute results by S: l_linenumber
                     ->  Subquery Scan on l2
                           ->  Finalize GroupAggregate
                                 Group Key: lineitem_1.l_quantity
                                 Filter: (min(lineitem_1.l_suppkey) = 10)
                                 ->  Remote Subquery Scan on all (datanodes 2)
                                       Sort Key: lineitem_1.l_quantity
                                       Distribute results by S: l_quantity
                                       ->  Partial GroupAggregate
                                             Group Key: lineitem_1.l_quantity
                                             ->  Sort
                                                   Sort Key: lineitem_1.l_quantity
                                                   ->  Seq Scan on lineitem lineitem_1
(32 rows)

-- Test prefer distribute clause with const in subquery block
EXPLAIN (COSTS OFF)
SELECT l1.l_partkey, l1.l_partkey
  FROM (SELECT MIN(l_suppkey) AS l_suppkey, 
               MIN(l_linenumber) AS l_linenumber,
               l_partkey
         FROM  lineitem
         WHERE l_partkey = 10
         GROUP by l_partkey) as l1
  LEFT OUTER JOIN
       (SELECT MIN(l_suppkey) as l_suppkey, 
               MIN(l_linenumber) as l_linenumber,
               MIN(l_partkey) as l_partkey 
         FROM  lineitem 
         GROUP BY l_quantity) as l2
   ON  l1.l_partkey = l2.l_suppkey
   AND l1.l_suppkey = l2.l_linenumber
   AND l1.l_linenumber = l2.l_partkey;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Right Join
         Hash Cond: ((l2.l_suppkey = l1.l_partkey) AND (l2.l_linenumber = l1.l_suppkey) AND (l2.l_partkey = l1.l_linenumber))
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: l_suppkey
               ->  Subquery Scan on l2
                     ->  Finalize GroupAggregate
                           Group Key: lineitem.l_quantity
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Sort Key: lineitem.l_quantity
                                 Distribute results by S: l_quantity
                                 ->  Partial GroupAggregate
                                       Group Key: lineitem.l_quantity
                                       ->  Sort
                                             Sort Key: lineitem.l_quantity
                                             ->  Seq Scan on lineitem
         ->  Hash
               ->  Subquery Scan on l1
                     ->  Finalize GroupAggregate
                           Group Key: lineitem_1.l_partkey
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Distribute results by S: l_partkey
                                 ->  Partial GroupAggregate
                                       Group Key: lineitem_1.l_partkey
                                       ->  Seq Scan on lineitem lineitem_1
                                             Filter: (l_partkey = 10)
(26 rows)

-- Test roundrobin for only distribute clause with const
EXPLAIN (COSTS OFF)
SELECT l1.l_partkey, l1.l_partkey
  FROM (SELECT MIN(l_suppkey) AS l_suppkey, 
               MIN(l_linenumber) AS l_linenumber,
               MIN(l_partkey) as l_partkey
         FROM  lineitem
         GROUP by l_quantity) as l1
  LEFT OUTER JOIN
       (SELECT MIN(l_suppkey) as l_suppkey, 
               MIN(l_linenumber) as l_linenumber,
               MIN(l_partkey) as l_partkey 
         FROM  lineitem 
         GROUP BY l_quantity) as l2
   ON  l1.l_partkey = l2.l_suppkey
 WHERE l1.l_partkey = 10;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Nested Loop Left Join
         Join Filter: (l1.l_partkey = l2.l_suppkey)
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: l_partkey
               ->  Subquery Scan on l1
                     ->  Finalize GroupAggregate
                           Group Key: lineitem.l_quantity
                           Filter: (min(lineitem.l_partkey) = 10)
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Sort Key: lineitem.l_quantity
                                 Distribute results by S: l_quantity
                                 ->  Partial GroupAggregate
                                       Group Key: lineitem.l_quantity
                                       ->  Sort
                                             Sort Key: lineitem.l_quantity
                                             ->  Seq Scan on lineitem
         ->  Materialize
               ->  Remote Subquery Scan on all (datanodes 2)
                     Distribute results by S: l_suppkey
                     ->  Subquery Scan on l2
                           ->  Finalize GroupAggregate
                                 Group Key: lineitem_1.l_quantity
                                 Filter: (min(lineitem_1.l_suppkey) = 10)
                                 ->  Remote Subquery Scan on all (datanodes 2)
                                       Sort Key: lineitem_1.l_quantity
                                       Distribute results by S: l_quantity
                                       ->  Partial GroupAggregate
                                             Group Key: lineitem_1.l_quantity
                                             ->  Sort
                                                   Sort Key: lineitem_1.l_quantity
                                                   ->  Seq Scan on lineitem lineitem_1
(32 rows)

DROP TABLE lineitem;
DROP TABLE IF EXISTS t1;
NOTICE:  table "t1" does not exist, skipping
DROP TABLE IF EXISTS t2;
NOTICE:  table "t2" does not exist, skipping
CREATE TABLE t1 (                                         
    c11 integer,                                           
    c12 integer,                                                 
    c13 integer,                                                  
    c14 integer,                                                     
    c15 integer                                                       
) distribute by shard(c11);
CREATE TABLE t2 (                                         
    c21 integer,                                           
    c22 integer,                                                 
    c23 integer,                                                  
    c24 integer,                                                     
    c25 integer                                                       
) distribute by shard(c21);
insert into t1              
    select  i,i,i,i,i
    from generate_series(2, 9) as i;
insert into t1              
    select  mod(i,2)+1,mod(i,2)+1,mod(i,9)+1,mod(i,2)+1,mod(i,2)+1
    from generate_series(1, 20000) as i;
insert into t2              
    select  i,i,i,i,i
    from generate_series(1, 7) as i;
insert into t2              
    select  mod(i,2)+8,mod(i,2)+8,mod(i,9)+1,mod(i,2)+8,mod(i,2)+8
    from generate_series(1, 20000) as i;
ANALYZE t1;
ANALYZE t2;
-- Test MCV with filter
/*+ SEQSCAN(1.1) SEQSCAN(1.2) 
    Parallel(1.1 0 hard) Parallel(1.2 0 hard) 
    HASHJOIN(1.1 1.2) 
    LEADING((1.1 1.2 ))
    Distribution(Left(1.1 ) Right( 1.2 )) */
EXPLAIN (COSTS OFF)
select * from t1,t2
where t1.c12 = t2.c22
  and t1.c12 < 4;
                         QUERY PLAN                          
-------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Merge Join
         Merge Cond: (t2.c22 = t1.c12)
         ->  Remote Subquery Scan on all (datanodes 2)
               Sort Key: t2.c22
               Distribute results by S: c22
               ->  Sort
                     Sort Key: t2.c22
                     ->  Seq Scan on t2
         ->  Materialize
               ->  Remote Subquery Scan on all (datanodes 2)
                     Sort Key: t1.c12
                     Distribute results by S: c12
                     ->  Sort
                           Sort Key: t1.c12
                           ->  Seq Scan on t1
                                 Filter: (c12 < 4)
(17 rows)

-- Test choosing flatting column as distribution key
/*+ SEQSCAN(1.1) SEQSCAN(1.2) 
    Parallel(1.1 0 hard) Parallel(1.2 0 hard) 
    HASHJOIN(1.1 1.2) 
    LEADING((1.1 1.2 ))
    Distribution(Left(1.1 ) Right( 1.2 )) */
EXPLAIN (COSTS OFF)
select * from t1,t2
where t1.c12 = t2.c22
  and t1.c13 = t2.c23;
                          QUERY PLAN                           
---------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Merge Join
         Merge Cond: ((t1.c12 = t2.c22) AND (t1.c13 = t2.c23))
         ->  Remote Subquery Scan on all (datanodes 2)
               Sort Key: t1.c12, t1.c13
               Distribute results by S: c12
               ->  Sort
                     Sort Key: t1.c12, t1.c13
                     ->  Seq Scan on t1
         ->  Materialize
               ->  Remote Subquery Scan on all (datanodes 2)
                     Sort Key: t2.c22, t2.c23
                     Distribute results by S: c22
                     ->  Sort
                           Sort Key: t2.c22, t2.c23
                           ->  Seq Scan on t2
(16 rows)

DROP TABLE t1;
DROP TABLE t2;
set data_skew_option=0;
