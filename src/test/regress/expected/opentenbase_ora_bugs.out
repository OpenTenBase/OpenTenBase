\c regression_ora

-- datetime to_char, format mixed with upper/lower character
select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:Mi:ss') from dual;
       to_char       
---------------------
 2023-01-03 15:04:10
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'YyYy-Mm-dD hH24:Mi:sS') from dual;
       to_char       
---------------------
 2023-01-03 15:04:10
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'YyYy-Mm-dD hH12:Mi:sS') from dual;
       to_char       
---------------------
 2023-01-03 03:04:10
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'YyYy-Mm-dD hH12:Mi:sS.Ff') from dual;
        to_char        
-----------------------
 2023-01-03 03:04:10.0
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'YyYy-Mm-dD hH12:Mi:sS.Ff.ff.FF.fF.ff1.ff2.ff3.ff4.ff5.ff6.ff7.ff8.ff9.Ff1.Ff2.Ff3.Ff4.Ff5.Ff6.Ff7.Ff8.Ff9.fF1.fF2.fF3.fF4.fF5.fF6.fF7.fF8.fF9.FF1.FF2.FF3.FF4.FF5.FF6.FF7.FF8.FF9') from dual;
                                               to_char                                               
-----------------------------------------------------------------------------------------------------
 2023-01-03 03:04:10.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'YyYy-Mm-dD hH12:Mi:sSsSs:SsSsS:ssss:Ssss:SSss:sSss:ss:Ss:sS:SS') from dual;
                             to_char                              
------------------------------------------------------------------
 2023-01-03 03:04:54250:54250:54250:54250:54250:54250:10:10:10:10
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-ddD-Ddd-DdD-DDD hh24:Mi:ss') from dual;
             to_char              
----------------------------------
 2023-01-003-003-003-003 15:04:10
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd Hh24:Mi:mI:MI:mi:ss:Ss:SS') from dual;
              to_char               
------------------------------------
 2023-01-03 15:04:04:04:04:10:10:10
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'y,yyy-Y,yyy-Y,YYY-Y,Yyy-Y,yYY-mm-dd hh24:Mi:ss') from dual;
                   to_char                    
----------------------------------------------
 2,023-2,023-2,023-2,023-2,023-01-03 15:04:10
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'yyy-Yyy-YyY-yYY-YYY-YyY-yy-YY-Yy-yY-y-Y-mm-dd hh24:Mi:ss') from dual;
                        to_char                         
--------------------------------------------------------
 023-023-023-023-023-023-23-23-23-23-3-3-01-03 15:04:10
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'YyYy-Mm-dD') from dual;
  to_char   
------------
 2023-01-03
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'Dd-Mm-YyYY') from dual;
  to_char   
------------
 03-01-2023
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'Dd-Mm-Yy') from dual;
 to_char  
----------
 03-01-23
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'Dd/Mm/Yy') from dual;
 to_char  
----------
 03/01/23
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'Dd/Mm/Y,YYy') from dual;
   to_char   
-------------
 03/01/2,023
(1 row)

select to_char(to_date('2023-01-03 15:04:10', 'yyyy-mm-dd hh24:mi:ss'), 'Dd/Mm/Yy wW Ww ww WW w W d D cc Cc cC CC') from dual;
                 to_char                  
------------------------------------------
 03/01/23 01 01 01 01 1 1 3 3 21 21 21 21
(1 row)

CREATE TABLE varchar4000_20230707(
v1 VARCHAR(4000 CHAR),
v2 VARCHAR(4000 BYTE),
v3 VARCHAR(1CHAR),
v4 VARCHAR(10000BYTE),
v5 VARCHAR2(4000 CHAR),
v6 VARCHAR2(4000 BYTE),
v7 VARCHAR2(1CHAR),
v8 VARCHAR2(10000BYTE)
);
\d varchar4000_20230707
                Table "public.varchar4000_20230707"
 Column |           Type           | Collation | Nullable | Default 
--------+--------------------------+-----------+----------+---------
 v1     | character varying(4000)  |           |          | 
 v2     | character varying(4000)  |           |          | 
 v3     | character varying(1)     |           |          | 
 v4     | character varying(10000) |           |          | 
 v5     | varchar2(4000)           |           |          | 
 v6     | varchar2(4000)           |           |          | 
 v7     | varchar2(1)              |           |          | 
 v8     | varchar2(10000)          |           |          | 

DO $$
DECLARE
v1 VARCHAR(4000 CHAR);
v2 VARCHAR(4000 BYTE);
v3 VARCHAR(1CHAR);
v4 VARCHAR(10000BYTE);
BEGIN
v1 := 'a'; v2 := 'b'; v3 := 'c'; v4 := 'd';
raise notice '% % % %', v1, v2, v3, v4;
END; $$;
NOTICE:  a b c d
DROP TABLE varchar4000_20230707;
-- TAPD: 113708041
\c regression
select to_char(to_timestamp('20230803151617','yyyyMMddHH24miss'), 'ssxff') from dual;
 to_char 
---------
 17x0
(1 row)

select to_char(to_timestamp('20230803151617','yyyyMMddHH24miss'), 'Ssxff') from dual;
 to_char 
---------
 Ssx0
(1 row)

\c regression_ora
select to_char(to_timestamp('20230803151617','yyyyMMddHH24miss'), 'ssxff') from dual;
 to_char 
---------
 17.0
(1 row)

select to_char(to_timestamp('20230803151617','yyyyMMddHH24miss'), 'Ssxff') from dual;
 to_char 
---------
 17.0
(1 row)

-- END TAPD: 113708041 
-- tapd:114541919
select to_date('', ' ') from dual;
 to_date 
---------
 
(1 row)

select to_date(NULL, ' ') from dual;
 to_date 
---------
 
(1 row)

select to_date('2023-08-23 11:59:59', '') from dual;
 to_date 
---------
 
(1 row)

select to_date('2023-08-23 11:59:59', NULL) from dual;
 to_date 
---------
 
(1 row)

--expected error
select to_date('2023-08-23 11:59:59', ' ') from dual;
ERROR:  literal does not match format string
select to_date('2023-08-23 11:59:59', '    ') from dual;
ERROR:  literal does not match format string
-- end taapd: 114541919
-- START TAPD: 887262271
select regexp_split_to_array(' ', ' ');
 regexp_split_to_array 
-----------------------
 {"",""}
(1 row)

select regexp_split_to_array(' ', '');
 regexp_split_to_array 
-----------------------
 
(1 row)

select regexp_split_to_array('', ' ');
 regexp_split_to_array 
-----------------------
 
(1 row)

select regexp_split_to_array('   ', '  ');
 regexp_split_to_array 
-----------------------
 {""," "}
(1 row)

select regexp_split_to_array('    ', '  ');
 regexp_split_to_array 
-----------------------
 {"","",""}
(1 row)

-- END TPAD: 887262271
-- tapd:114400655
create schema s1;
create function s1.func1() return void as
begin
    raise notice '%', 'schema_s1_func1';
end;
/
select s1.func1();
NOTICE:  schema_s1_func1
 func1 
-------
 
(1 row)

create public synonym synonym1 for s1;
--expect error
select synonym1.func1();
ERROR:  schema "synonym1" does not exist
LINE 1: select synonym1.func1();
               ^
create package s1 AS
end s1;
/
--expect error
select synonym1.func1();
ERROR:  schema "synonym1" does not exist
LINE 1: select synonym1.func1();
               ^
create or replace function s1(a int) return int is
begin return a; end;
/
--expect error
select synonym1.func1();
ERROR:  schema "synonym1" does not exist
LINE 1: select synonym1.func1();
               ^
drop package s1;
--expect error
select synonym1.func1();
ERROR:  schema "synonym1" does not exist
LINE 1: select synonym1.func1();
               ^
-- tapd: 115928377
create or replace package s1 as
a int;
function func1 () return int;
end;
/
create or replace package body s1 as
function func1 () return int as
begin
raise notice '%', 'package s1 func1';
return 1;
end;
end;
/
--expected ok
select synonym1.func1();
NOTICE:  package s1 func1
 func1 
-------
     1
(1 row)

drop package s1;
-- end tapd: 115928377
drop schema s1 cascade;
NOTICE:  drop cascades to function s1.func1()
drop function s1;
--end tapd:114400655
-- START TAPD: 887262065
-- case: table 
create table tbl_20230920_1(id int, name varchar2(20));
insert into tbl_20230920_1 values(1, 'xxx');
insert into tbl_20230920_1 values(2, 'yyy');
insert into tbl_20230920_1 values(0, 'mmm');
select 1+2 as col1, 'kkk' as col2, id, name from tbl_20230920_1 order by to_number(col1), 3;
 col1 | col2 | id | name 
------+------+----+------
    3 | kkk  |  0 | mmm
    3 | kkk  |  1 | xxx
    3 | kkk  |  2 | yyy
(3 rows)

select 1+2 as col1, 'kkk' as col2, id, name from tbl_20230920_1 order by to_number(col1) || id, 3;
 col1 | col2 | id | name 
------+------+----+------
    3 | kkk  |  0 | mmm
    3 | kkk  |  1 | xxx
    3 | kkk  |  2 | yyy
(3 rows)

select 1+2 as col1, 'kkk' as col2, id, name from tbl_20230920_1 order by to_number(col1) + 1, 3;
 col1 | col2 | id | name 
------+------+----+------
    3 | kkk  |  0 | mmm
    3 | kkk  |  1 | xxx
    3 | kkk  |  2 | yyy
(3 rows)

select 1+2 as col1, 'kkk' as col2, id, name from tbl_20230920_1 order by col1 + 1, 3;
 col1 | col2 | id | name 
------+------+----+------
    3 | kkk  |  0 | mmm
    3 | kkk  |  1 | xxx
    3 | kkk  |  2 | yyy
(3 rows)

select 1+2 as col1, to_number('333.44') as col2, id, name from tbl_20230920_1 order by to_number(col1), to_number(col2) || id, 3;
 col1 |  col2  | id | name 
------+--------+----+------
    3 | 333.44 |  0 | mmm
    3 | 333.44 |  1 | xxx
    3 | 333.44 |  2 | yyy
(3 rows)

select (select 1 from dual) as col1 from dual order by (select id from tbl_20230920_1) || col1;
 col1 
------
    1
(1 row)

select id + 1 as col1 from tbl_20230920_1 order by (select max(id) from tbl_20230920_1) || col1;
 col1 
------
    1
    2
    3
(3 rows)

-- expected error
select (select 1 from dual) as col1 from dual order by (select col1 from dual);
ERROR:  column "col1" does not exist
LINE 1: ...t 1 from dual) as col1 from dual order by (select col1 from ...
                                                             ^
select (select 1 from dual) as col1 from dual order by (select to_number(col1) from dual);
ERROR:  column "col1" does not exist
LINE 1: ...ual) as col1 from dual order by (select to_number(col1) from...
                                                             ^
select (select 1 from dual) as col1 from dual order by (select id from tbl_20230920_1 order by col1);
ERROR:  column "col1" does not exist
LINE 1: ...dual order by (select id from tbl_20230920_1 order by col1);
                                                                 ^
select 1+2 as col1, name || '_x' as col2 from tbl_20230920_1 where col1 = 3;
ERROR:  column "col1" does not exist
LINE 1: ...l1, name || '_x' as col2 from tbl_20230920_1 where col1 = 3;
                                                              ^
-- case: sublink
select (select 1 from dual) as col1 from dual order by to_number(col1);
 col1 
------
    1
(1 row)

select (select 1 from dual) as col1 from dual order by to_number(col1), to_number(col1);
 col1 
------
    1
(1 row)

select (select 1 from dual) as col1, (select 'aaa' from dual) as col2 from dual order by to_number(col1), to_char(col2);
 col1 | col2 
------+------
    1 | aaa
(1 row)

select 'xxxx' as col1, '123' as col2 from dual order by to_number(col1), col2;
 col1 | col2 
------+------
 xxxx | 123
(1 row)

-- case: view
create view v_orderby_20230920 as select (select 1 from dual) as col1, (select 'aaa' from dual) as col2 from dual order by to_number(col1), to_char(col2);
select * from v_orderby_20230920;
 col1 | col2 
------+------
    1 | aaa
(1 row)

select * from v_orderby_20230920 order by to_number(col1);
 col1 | col2 
------+------
    1 | aaa
(1 row)

drop view v_orderby_20230920;
drop table tbl_20230920_1;
-- END TAPD: 887262065
-- START TAPD: 115868195
drop table if exists t_syntax_check07_20231001_5;
NOTICE:  table "t_syntax_check07_20231001_5" does not exist, skipping
create table t_syntax_check07_20231001_5(employee_id number(6) primary key,
	first_name varchar2(20),
	last_name varchar2(25),
	email varchar2(25),
	phone_number varchar2(20),
	hire_date date,
	job_id varchar2(10),
	salary number(8,2),
	commission_pct number(2,2),
	manager_id number(6),
	department_id number(4)
);
-- Fix using non-existing columns to order by in listagg will produce core 
SELECT department_id "Dept.", LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hire_date_no) "Employees"
FROM t_syntax_check07_20231001_5
GROUP BY department_id
ORDER BY department_id;
ERROR:  column "hire_date_no" does not exist
LINE 1: ..., LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hire_date_...
                                                             ^
HINT:  Perhaps you meant to reference the column "t_syntax_check07_20231001_5.hire_date".
-- Using existing columns to order by in listagg will done. 
SELECT department_id "Dept.", LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hire_date) "Employees"
FROM t_syntax_check07_20231001_5
GROUP BY department_id
ORDER BY department_id;
 Dept. | Employees 
-------+-----------
(0 rows)

-- END TAPD: 115868195
