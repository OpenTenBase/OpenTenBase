-- pg_regress should ensure that this default value applies; however
-- we can't rely on any specific default value of vacuum_cost_delay
SHOW datestyle;
   DateStyle   
---------------
 Postgres, MDY
(1 row)

-- SET to some nondefault value
SET vacuum_cost_delay TO 40;
SET datestyle = 'ISO, YMD';
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56-07
(1 row)

-- SET LOCAL has no effect outside of a transaction
SET LOCAL vacuum_cost_delay TO 50;
WARNING:  SET LOCAL can only be used in transaction blocks
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SET LOCAL datestyle = 'SQL';
WARNING:  SET LOCAL can only be used in transaction blocks
SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56-07
(1 row)

-- SET LOCAL within a transaction that commits
BEGIN;
SET LOCAL vacuum_cost_delay TO 50;
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 50ms
(1 row)

SET LOCAL datestyle = 'SQL';
SHOW datestyle;
 DateStyle 
-----------
 SQL, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
       timestamptz       
-------------------------
 08/13/2006 12:34:56 PDT
(1 row)

COMMIT;
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56-07
(1 row)

-- SET should be reverted after ROLLBACK
BEGIN;
SET vacuum_cost_delay TO 60;
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 60ms
(1 row)

SET datestyle = 'German';
SHOW datestyle;
  DateStyle  
-------------
 German, DMY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
       timestamptz       
-------------------------
 13.08.2006 12:34:56 PDT
(1 row)

ROLLBACK;
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56-07
(1 row)

-- SET followed by SET LOCAL
BEGIN;
SET vacuum_cost_delay TO 40;
SET LOCAL vacuum_cost_delay TO 50;
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 50ms
(1 row)

SET datestyle = 'ISO, DMY';
SET LOCAL datestyle = 'Postgres, MDY';
SHOW datestyle;
   DateStyle   
---------------
 Postgres, MDY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
         timestamptz          
------------------------------
 Sun Aug 13 12:34:56 2006 PDT
(1 row)

COMMIT;
SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 40ms
(1 row)

SHOW datestyle;
 DateStyle 
-----------
 ISO, DMY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56-07
(1 row)

--
-- Test RESET.  We use datestyle because the reset value is forced by
-- pg_regress, so it doesn't depend on the installation's configuration.
--
SET datestyle = iso, ymd;
SHOW datestyle;
 DateStyle 
-----------
 ISO, YMD
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
      timestamptz       
------------------------
 2006-08-13 12:34:56-07
(1 row)

RESET datestyle;
SHOW datestyle;
   DateStyle   
---------------
 Postgres, MDY
(1 row)

SELECT '2006-08-13 12:34:56'::timestamptz;
         timestamptz          
------------------------------
 Sun Aug 13 12:34:56 2006 PDT
(1 row)

--
-- Test DISCARD TEMP
--
CREATE TEMP TABLE reset_test ( data text ) ON COMMIT DELETE ROWS;
SELECT relname FROM pg_class WHERE relname = 'reset_test';
  relname   
------------
 reset_test
(1 row)

DISCARD TEMP;
SELECT relname FROM pg_class WHERE relname = 'reset_test';
 relname 
---------
(0 rows)

--
-- Test DISCARD ALL
--
-- do changes
DECLARE foo CURSOR WITH HOLD FOR SELECT 1;
PREPARE foo AS SELECT 1;
LISTEN foo_event;
SET vacuum_cost_delay = 13;
CREATE TEMP TABLE tmp_foo (data text) ON COMMIT DELETE ROWS;
CREATE ROLE regress_guc_user;
SET SESSION AUTHORIZATION regress_guc_user;
-- look changes
SELECT pg_listening_channels();
 pg_listening_channels 
-----------------------
 foo_event
(1 row)

SELECT name FROM pg_prepared_statements;
 name 
------
 foo
(1 row)

SELECT name FROM pg_cursors;
 name 
------
 foo
(1 row)

SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 13ms
(1 row)

SELECT relname from pg_class where relname = 'tmp_foo';
 relname 
---------
 tmp_foo
(1 row)

SELECT current_user = 'regress_guc_user';
 ?column? 
----------
 t
(1 row)

-- discard everything
DISCARD ALL;
-- look again
SELECT pg_listening_channels();
 pg_listening_channels 
-----------------------
(0 rows)

SELECT name FROM pg_prepared_statements;
 name 
------
(0 rows)

SELECT name FROM pg_cursors;
 name 
------
(0 rows)

SHOW vacuum_cost_delay;
 vacuum_cost_delay 
-------------------
 0
(1 row)

SELECT relname from pg_class where relname = 'tmp_foo';
 relname 
---------
(0 rows)

SELECT current_user = 'regress_guc_user';
 ?column? 
----------
 f
(1 row)

DROP ROLE regress_guc_user;
--
-- search_path should react to changes in pg_namespace
--
set search_path = foo, public, not_there_initially;
select current_schemas(false);
     current_schemas      
--------------------------
 {public,opentenbase_ora}
(1 row)

create schema not_there_initially;
select current_schemas(false);
               current_schemas                
----------------------------------------------
 {public,not_there_initially,opentenbase_ora}
(1 row)

drop schema not_there_initially;
select current_schemas(false);
     current_schemas      
--------------------------
 {public,opentenbase_ora}
(1 row)

reset search_path;
--
-- Tests for function-local GUC settings
--
set work_mem = '3MB';
create function report_guc(text) returns text as
$$ select current_setting($1) $$ language sql
set work_mem = '1MB';
select report_guc('work_mem'), current_setting('work_mem');
 report_guc | current_setting 
------------+-----------------
 1MB        | 3MB
(1 row)

alter function report_guc(text) set work_mem = '2MB';
select report_guc('work_mem'), current_setting('work_mem');
 report_guc | current_setting 
------------+-----------------
 2MB        | 3MB
(1 row)

alter function report_guc(text) reset all;
select report_guc('work_mem'), current_setting('work_mem');
 report_guc | current_setting 
------------+-----------------
 3MB        | 3MB
(1 row)

-- SET LOCAL is restricted by a function SET option
create or replace function myfunc(int) returns text as $$
begin
  set local work_mem = '2MB';
  return current_setting('work_mem');
end $$
language plpgsql
set work_mem = '1MB';
select myfunc(0), current_setting('work_mem');
 myfunc | current_setting 
--------+-----------------
 2MB    | 3MB
(1 row)

alter function myfunc(int) reset all;
select myfunc(0), current_setting('work_mem');
 myfunc | current_setting 
--------+-----------------
 2MB    | 2MB
(1 row)

set work_mem = '3MB';
-- but SET isn't
create or replace function myfunc(int) returns text as $$
begin
  set work_mem = '2MB';
  return current_setting('work_mem');
end $$
language plpgsql
set work_mem = '1MB';
select myfunc(0), current_setting('work_mem');
 myfunc | current_setting 
--------+-----------------
 2MB    | 2MB
(1 row)

set work_mem = '3MB';
-- it should roll back on error, though
create or replace function myfunc(int) returns text as $$
begin
  set work_mem = '2MB';
  perform 1/$1;
  return current_setting('work_mem');
end $$
language plpgsql
set work_mem = '1MB';
select myfunc(0);
ERROR:  division by zero
CONTEXT:  SQL statement "SELECT 1/$1"
PL/pgSQL function myfunc(integer) line 4 at PERFORM
select current_setting('work_mem');
 current_setting 
-----------------
 3MB
(1 row)

select myfunc(1), current_setting('work_mem');
 myfunc | current_setting 
--------+-----------------
 2MB    | 2MB
(1 row)

-- check current_setting()'s behavior with invalid setting name
select current_setting('nosuch.setting');  -- FAIL
ERROR:  unrecognized configuration parameter "nosuch.setting"
select current_setting('nosuch.setting', false);  -- FAIL
ERROR:  unrecognized configuration parameter "nosuch.setting"
select current_setting('nosuch.setting', true) is null;
 ?column? 
----------
 t
(1 row)

-- after this, all three cases should yield 'nada'
set nosuch.setting = 'nada';
select current_setting('nosuch.setting');
 current_setting 
-----------------
 nada
(1 row)

select current_setting('nosuch.setting', false);
 current_setting 
-----------------
 nada
(1 row)

select current_setting('nosuch.setting', true);
 current_setting 
-----------------
 nada
(1 row)

-- Normally, CREATE FUNCTION should complain about invalid values in
-- function SET options; but not if check_function_bodies is off,
-- because that creates ordering hazards for pg_dump
create function func_with_bad_set() returns int as $$ select 1 $$
language sql
set default_text_search_config = no_such_config;
NOTICE:  text search configuration "no_such_config" does not exist
ERROR:  invalid value for parameter "default_text_search_config": "no_such_config"
set check_function_bodies = off;
create function func_with_bad_set() returns int as $$ select 1 $$
language sql
set default_text_search_config = no_such_config;
NOTICE:  text search configuration "no_such_config" does not exist
select func_with_bad_set();
ERROR:  invalid value for parameter "default_text_search_config": "no_such_config"
reset check_function_bodies;
SET application_name TO "special name";
CREATE TABLE testtab (a int);
INSERT INTO testtab VALUES (1), (2), (3);
SELECT * FROM testtab order by 1;
 a 
---
 1
 2
 3
(3 rows)

DROP TABLE testtab;
SET default_transaction_isolation TO "read committed";
CREATE TABLE testtab (a int);
INSERT INTO testtab VALUES (1), (2), (3);
SELECT * FROM testtab order by 1;
 a 
---
 1
 2
 3
(3 rows)

DROP TABLE testtab;
SET work_mem TO '64kB';
CREATE TABLE testtab (a int);
INSERT INTO testtab VALUES (1), (2), (3);
SELECT * FROM testtab order by 1;
 a 
---
 1
 2
 3
(3 rows)

DROP TABLE testtab;
SET work_mem TO "64kB";
CREATE TABLE testtab (a int);
INSERT INTO testtab VALUES (1), (2), (3);
SELECT * FROM testtab order by 1;
 a 
---
 1
 2
 3
(3 rows)

DROP TABLE testtab;
SET log_min_duration_statement = '1s';
CREATE TABLE testtab (a int);
INSERT INTO testtab VALUES (1), (2), (3);
SELECT * FROM testtab order by 1;
 a 
---
 1
 2
 3
(3 rows)

DROP TABLE testtab;
CREATE SCHEMA testschema;
CREATE SCHEMA "testschema 2";
CREATE SCHEMA "testschema 3";
CREATE SCHEMA READ;
CREATE SCHEMA "READ";
-- ERROR
CREATE SCHEMA SELECT;
ERROR:  syntax error at or near "SELECT"
LINE 1: CREATE SCHEMA SELECT;
                      ^
-- Ok
CREATE SCHEMA "SELECT";
SET search_path TO testschema;
CREATE TABLE testtab (a int);
\d+ testtab
                                Table "testschema.testtab"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 a      | integer |           |          |         | plain   |              | 
Distribute By: HASH(a)
Location Nodes: ALL DATANODES

INSERT INTO testtab VALUES (1), (2), (3);
SELECT * FROM testtab order by 1;
 a 
---
 1
 2
 3
(3 rows)

DROP TABLE testtab;
SET search_path TO "testschema";
CREATE TABLE testtab (a int);
\d+ testtab
                                Table "testschema.testtab"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 a      | integer |           |          |         | plain   |              | 
Distribute By: HASH(a)
Location Nodes: ALL DATANODES

INSERT INTO testtab VALUES (1), (2), (3);
SELECT * FROM testtab order by 1;
 a 
---
 1
 2
 3
(3 rows)

DROP TABLE testtab;
SET search_path TO testschema, "testschema 2";
CREATE TABLE testtab (a int);
\d+ testtab
                                Table "testschema.testtab"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 a      | integer |           |          |         | plain   |              | 
Distribute By: HASH(a)
Location Nodes: ALL DATANODES

INSERT INTO testtab VALUES (1), (2), (3);
SELECT * FROM testtab order by 1;
 a 
---
 1
 2
 3
(3 rows)

DROP TABLE testtab;
SET search_path TO "testschema 3", "testschema 2";
CREATE TABLE testtab (a int);
\d+ testtab
                               Table "testschema 3.testtab"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 a      | integer |           |          |         | plain   |              | 
Distribute By: HASH(a)
Location Nodes: ALL DATANODES

INSERT INTO testtab VALUES (1), (2), (3);
SELECT * FROM testtab order by 1;
 a 
---
 1
 2
 3
(3 rows)

DROP TABLE testtab;
-- EXPERIMENT MODE
SET enable_experiment_isolation to false;
ALTER SYSTEM SET default_transaction_isolation TO 'repeatable read';
ERROR:  parameter "default_transaction_isolation" is restricted to default value.
HINT:  enable_experiment_isolation is not restricted but might cause instability.
SET default_transaction_isolation TO 'repeatable read';
ERROR:  parameter "default_transaction_isolation" is restricted to default value.
HINT:  enable_experiment_isolation is not restricted but might cause instability.
BEGIN TRANSACTION ISOLATION level REPEATABLE READ ;
ERROR:  transaction mode is restricted to READ COMMITTED.
HINT:  Isolation modes other than READ COMMITTED can be enabled by setting enable_experiment_isolation to on, but as experimental feature they are not recommended to use in production environment.
SET enable_experiment_isolation to true;
SET default_transaction_isolation TO 'repeatable read';
BEGIN TRANSACTION ISOLATION level REPEATABLE READ ;
COMMIT;
RESET default_transaction_isolation;
-- ERROR
SET search_path TO "testschema 3", SELECT;
ERROR:  syntax error at or near "SELECT"
LINE 1: SET search_path TO "testschema 3", SELECT;
                                           ^
SET search_path TO "SELECT", "testschema 3";
CREATE TABLE testtab (a int);
\d+ testtab
                                  Table "SELECT.testtab"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 a      | integer |           |          |         | plain   |              | 
Distribute By: HASH(a)
Location Nodes: ALL DATANODES

CREATE TABLE "testschema 3".testtab (a int);
\d+ testtab
                                  Table "SELECT.testtab"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 a      | integer |           |          |         | plain   |              | 
Distribute By: HASH(a)
Location Nodes: ALL DATANODES

INSERT INTO "testschema 3".testtab VALUES (1), (2), (3);
INSERT INTO "SELECT".testtab VALUES (4);
SELECT * FROM "testschema 3".testtab order by 1;
 a 
---
 1
 2
 3
(3 rows)

INSERT INTO testtab SELECT * FROM "testschema 3".testtab;
SELECT * FROM "testschema 3".testtab order by 1;
 a 
---
 1
 2
 3
(3 rows)

\d+ testtab
                                  Table "SELECT.testtab"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 a      | integer |           |          |         | plain   |              | 
Distribute By: HASH(a)
Location Nodes: ALL DATANODES

SELECT * FROM testtab order by 1;
 a 
---
 1
 2
 3
 4
(4 rows)

INSERT INTO testtab SELECT * FROM testtab;
SELECT * FROM testtab order by 1;
 a 
---
 1
 1
 2
 2
 3
 3
 4
 4
(8 rows)

DROP TABLE testtab;
DROP SCHEMA testschema CASCADE;
DROP SCHEMA "testschema 2" CASCADE;
DROP SCHEMA "testschema 3" CASCADE;
NOTICE:  drop cascades to table testtab
DROP SCHEMA "READ" CASCADE;
DROP SCHEMA SELECT CASCADE;
ERROR:  syntax error at or near "SELECT"
LINE 1: DROP SCHEMA SELECT CASCADE;
                    ^
DROP SCHEMA "SELECT" CASCADE;
create schema test_alter_1;
create schema test_alter_2;
create role test_alter_set with login superuser;
\c - test_alter_set
alter user test_alter_set set search_path=test_alter_1;
\c 
show search_path;
 search_path  
--------------
 test_alter_1
(1 row)

alter user test_alter_set set search_path=test_alter_2;
show search_path;
 search_path  
--------------
 test_alter_1
(1 row)

create table test_alter_table(id int);
\d+ test_alter_table
                          Table "test_alter_1.test_alter_table"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 id     | integer |           |          |         | plain   |              | 
Distribute By: HASH(id)
Location Nodes: ALL DATANODES

insert into test_alter_table values(1);
select * from test_alter_table;
 id 
----
  1
(1 row)

drop table test_alter_table;
-- Test extension black list and white list
create extension opentenbase_ora_package_function;
ERROR:  The extension "opentenbase_ora_package_function" is not supported in postgresql sql mode
\c regression_ora
-- Test search_path are be cut into 64 and cause something wrong
-- TAPD: https://tapd.woa.com/OpenTenBase_C/bugtrace/bugs/view?bug_id=1020385652126678671
\c regression_ora
create schema "rownum_dml_dis_01_schema_20240702";
create schema "opentenbase_pg_proc_20240702";
set search_path = "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog";
create table r_search_path_bug_20240702
(
    id   number primary key,
    col1 number
);
insert into r_search_path_bug_20240702 values(1, 1);
set search_path = "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog";
ERROR:  The size of guc search_path value is larger than 1024
drop schema "rownum_dml_dis_01_schema_20240702" cascade;
NOTICE:  drop cascades to table R_SEARCH_PATH_BUG_20240702
drop schema "opentenbase_pg_proc_20240702";
\c regression
create schema "rownum_dml_dis_01_schema_20240702";
create schema "opentenbase_pg_proc_20240702";
set search_path = "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog";
create table r_search_path_bug_20240702
(
    id   int primary key,
    col1 int
);
insert into r_search_path_bug_20240702 values(1, 1);
update r_search_path_bug_20240702 set col1 = 1 where id in (select * from (select id from r_search_path_bug_20240702 order by id));
set search_path = "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog", "rownum_dml_dis_01_schema_20240702", "$user", "public", "opentenbase_pg_proc_20240702", "pg_catalog";
ERROR:  The size of guc search_path value is larger than 1024
update r_search_path_bug_20240702 set col1 = 1 where id in (select * from (select id from r_search_path_bug_20240702 order by id));
drop schema "rownum_dml_dis_01_schema_20240702" cascade;
NOTICE:  drop cascades to table r_search_path_bug_20240702
drop schema "opentenbase_pg_proc_20240702";
-- Test unit memory display
-- TAPD: https://tapd.woa.com/OpenTenBase_C/prong/stories/view/1020385652118989323
-- GUC_UNIT_KB
SHOW work_mem;
 work_mem 
----------
 65535kB
(1 row)

-- GUC_UNIT_BLOCKS
SHOW checkpoint_flush_after;
 checkpoint_flush_after 
------------------------
 256kB
(1 row)

-- GUC_UNIT_XBLOCKS
SHOW wal_segment_size;
 wal_segment_size 
------------------
 16MB
(1 row)

-- test reset all
\c regression root
CREATE SCHEMA TEST_S1;
SET SEARCH_PATH TO 'TEST_S1';
RESET ALL;
CREATE TABLE TEST_T20241231(A INT);
INSERT INTO TEST_T20241231 VALUES(1);
INSERT INTO TEST_T20241231 VALUES(2);
INSERT INTO TEST_T20241231 VALUES(3);
INSERT INTO TEST_T20241231 VALUES(4);
INSERT INTO TEST_T20241231 VALUES(5);
SELECT * FROM TEST_T20241231 ORDER BY 1;
 a 
---
 1
 2
 3
 4
 5
(5 rows)

DROP TABLE TEST_T20241231;
DROP SCHEMA TEST_S1;
DISCARD ALL;
\c regression_ora  root
CREATE SCHEMA TEST_S1;
show search_path;
   search_path   
-----------------
 "$user", public
(1 row)

SET SEARCH_PATH TO 'TEST_S1';
show search_path;
 search_path 
-------------
 TEST_S1
(1 row)

RESET ALL;
show search_path;
   search_path   
-----------------
 "$user", public
(1 row)

CREATE TABLE TEST_T20241231(A INT);
INSERT INTO TEST_T20241231 VALUES(1);
INSERT INTO TEST_T20241231 VALUES(2);
INSERT INTO TEST_T20241231 VALUES(3);
INSERT INTO TEST_T20241231 VALUES(4);
INSERT INTO TEST_T20241231 VALUES(5);
SELECT * FROM TEST_T20241231 ORDER BY 1;
 A 
---
 1
 2
 3
 4
 5
(5 rows)

DROP TABLE TEST_T20241231;
DROP SCHEMA TEST_S1;
DISCARD ALL;
