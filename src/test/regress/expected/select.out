--
-- SELECT
--
-- btree index
-- awk '{if($1<10){print;}else{next;}}' onek.data | sort +0n -1
--
SELECT * FROM onek
   WHERE onek.unique1 < 10
   ORDER BY onek.unique1;
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
       0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
       1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
       2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx
       3 |     431 |   1 |    3 |   3 |      3 |       3 |        3 |           3 |         3 |        3 |   6 |    7 | DAAAAA   | PQAAAA   | VVVVxx
       4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
       5 |     541 |   1 |    1 |   5 |      5 |       5 |        5 |           5 |         5 |        5 |  10 |   11 | FAAAAA   | VUAAAA   | HHHHxx
       6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
       7 |     647 |   1 |    3 |   7 |      7 |       7 |        7 |           7 |         7 |        7 |  14 |   15 | HAAAAA   | XYAAAA   | VVVVxx
       8 |     653 |   0 |    0 |   8 |      8 |       8 |        8 |           8 |         8 |        8 |  16 |   17 | IAAAAA   | DZAAAA   | HHHHxx
       9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
(10 rows)

--
-- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
--
SELECT onek.unique1, onek.stringu1 FROM onek
   WHERE onek.unique1 < 20
   ORDER BY unique1 using >;
 unique1 | stringu1 
---------+----------
      19 | TAAAAA
      18 | SAAAAA
      17 | RAAAAA
      16 | QAAAAA
      15 | PAAAAA
      14 | OAAAAA
      13 | NAAAAA
      12 | MAAAAA
      11 | LAAAAA
      10 | KAAAAA
       9 | JAAAAA
       8 | IAAAAA
       7 | HAAAAA
       6 | GAAAAA
       5 | FAAAAA
       4 | EAAAAA
       3 | DAAAAA
       2 | CAAAAA
       1 | BAAAAA
       0 | AAAAAA
(20 rows)

--
-- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
--
SELECT onek.unique1, onek.stringu1 FROM onek
   WHERE onek.unique1 > 980
   ORDER BY stringu1 using <;
 unique1 | stringu1 
---------+----------
     988 | AMAAAA
     989 | BMAAAA
     990 | CMAAAA
     991 | DMAAAA
     992 | EMAAAA
     993 | FMAAAA
     994 | GMAAAA
     995 | HMAAAA
     996 | IMAAAA
     997 | JMAAAA
     998 | KMAAAA
     999 | LMAAAA
     981 | TLAAAA
     982 | ULAAAA
     983 | VLAAAA
     984 | WLAAAA
     985 | XLAAAA
     986 | YLAAAA
     987 | ZLAAAA
(19 rows)

--
-- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
-- sort +1d -2 +0nr -1
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 > 980
   ORDER BY string4 using <, unique1 using >;
 unique1 | string4 
---------+---------
     999 | AAAAxx
     995 | AAAAxx
     983 | AAAAxx
     982 | AAAAxx
     981 | AAAAxx
     998 | HHHHxx
     997 | HHHHxx
     993 | HHHHxx
     990 | HHHHxx
     986 | HHHHxx
     996 | OOOOxx
     991 | OOOOxx
     988 | OOOOxx
     987 | OOOOxx
     985 | OOOOxx
     994 | VVVVxx
     992 | VVVVxx
     989 | VVVVxx
     984 | VVVVxx
(19 rows)

--
-- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
-- sort +1dr -2 +0n -1
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 > 980
   ORDER BY string4 using >, unique1 using <;
 unique1 | string4 
---------+---------
     984 | VVVVxx
     989 | VVVVxx
     992 | VVVVxx
     994 | VVVVxx
     985 | OOOOxx
     987 | OOOOxx
     988 | OOOOxx
     991 | OOOOxx
     996 | OOOOxx
     986 | HHHHxx
     990 | HHHHxx
     993 | HHHHxx
     997 | HHHHxx
     998 | HHHHxx
     981 | AAAAxx
     982 | AAAAxx
     983 | AAAAxx
     995 | AAAAxx
     999 | AAAAxx
(19 rows)

--
-- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
-- sort +0nr -1 +1d -2
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 < 20
   ORDER BY unique1 using >, string4 using <;
 unique1 | string4 
---------+---------
      19 | OOOOxx
      18 | VVVVxx
      17 | HHHHxx
      16 | OOOOxx
      15 | VVVVxx
      14 | AAAAxx
      13 | OOOOxx
      12 | AAAAxx
      11 | OOOOxx
      10 | AAAAxx
       9 | HHHHxx
       8 | HHHHxx
       7 | VVVVxx
       6 | OOOOxx
       5 | HHHHxx
       4 | HHHHxx
       3 | VVVVxx
       2 | OOOOxx
       1 | OOOOxx
       0 | OOOOxx
(20 rows)

--
-- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
-- sort +0n -1 +1dr -2
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 < 20
   ORDER BY unique1 using <, string4 using >;
 unique1 | string4 
---------+---------
       0 | OOOOxx
       1 | OOOOxx
       2 | OOOOxx
       3 | VVVVxx
       4 | HHHHxx
       5 | HHHHxx
       6 | OOOOxx
       7 | VVVVxx
       8 | HHHHxx
       9 | HHHHxx
      10 | AAAAxx
      11 | OOOOxx
      12 | AAAAxx
      13 | OOOOxx
      14 | AAAAxx
      15 | VVVVxx
      16 | OOOOxx
      17 | HHHHxx
      18 | VVVVxx
      19 | OOOOxx
(20 rows)

--
-- test partial btree indexes
--
-- As of 7.2, planner probably won't pick an indexscan without stats,
-- so ANALYZE first.  Also, we want to prevent it from picking a bitmapscan
-- followed by sort, because that could hide index ordering problems.
--
ANALYZE onek2;
SET enable_seqscan TO off;
SET enable_bitmapscan TO off;
SET enable_sort TO off;
--
-- awk '{if($1<10){print $0;}else{next;}}' onek.data | sort +0n -1
--
SELECT onek2.* FROM onek2 WHERE onek2.unique1 < 10 ORDER BY unique1;
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
       0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
       1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
       2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx
       3 |     431 |   1 |    3 |   3 |      3 |       3 |        3 |           3 |         3 |        3 |   6 |    7 | DAAAAA   | PQAAAA   | VVVVxx
       4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
       5 |     541 |   1 |    1 |   5 |      5 |       5 |        5 |           5 |         5 |        5 |  10 |   11 | FAAAAA   | VUAAAA   | HHHHxx
       6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
       7 |     647 |   1 |    3 |   7 |      7 |       7 |        7 |           7 |         7 |        7 |  14 |   15 | HAAAAA   | XYAAAA   | VVVVxx
       8 |     653 |   0 |    0 |   8 |      8 |       8 |        8 |           8 |         8 |        8 |  16 |   17 | IAAAAA   | DZAAAA   | HHHHxx
       9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
(10 rows)

--
-- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
--
SELECT onek2.unique1, onek2.stringu1 FROM onek2
    WHERE onek2.unique1 < 20
    ORDER BY unique1 using >;
 unique1 | stringu1 
---------+----------
      19 | TAAAAA
      18 | SAAAAA
      17 | RAAAAA
      16 | QAAAAA
      15 | PAAAAA
      14 | OAAAAA
      13 | NAAAAA
      12 | MAAAAA
      11 | LAAAAA
      10 | KAAAAA
       9 | JAAAAA
       8 | IAAAAA
       7 | HAAAAA
       6 | GAAAAA
       5 | FAAAAA
       4 | EAAAAA
       3 | DAAAAA
       2 | CAAAAA
       1 | BAAAAA
       0 | AAAAAA
(20 rows)

--
-- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
--
SELECT onek2.unique1, onek2.stringu1 FROM onek2
   WHERE onek2.unique1 > 980 
   ORDER BY unique1 using <;
 unique1 | stringu1 
---------+----------
     981 | TLAAAA
     982 | ULAAAA
     983 | VLAAAA
     984 | WLAAAA
     985 | XLAAAA
     986 | YLAAAA
     987 | ZLAAAA
     988 | AMAAAA
     989 | BMAAAA
     990 | CMAAAA
     991 | DMAAAA
     992 | EMAAAA
     993 | FMAAAA
     994 | GMAAAA
     995 | HMAAAA
     996 | IMAAAA
     997 | JMAAAA
     998 | KMAAAA
     999 | LMAAAA
(19 rows)

RESET enable_seqscan;
RESET enable_bitmapscan;
RESET enable_sort;
SELECT two, stringu1, ten, string4
   INTO TABLE tmp
   FROM onek;
--
-- awk '{print $1,$2;}' person.data |
-- awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
-- awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
-- awk 'BEGIN{FS="      ";}{if(NF!=2){print $4,$5;}else{print;}}' - stud_emp.data
--
-- SELECT name, age FROM person*; ??? check if different
SELECT p.name, p.age FROM person* p 
    ORDER BY p.name, p.age;
  name   | age 
---------+-----
 alex    |  30
 belinda |  38
 bertha  |  88
 bill    |  20
 carina  |  58
 carmen  |  78
 chris   |  78
 cim     |  30
 denise  |  24
 diane   |  18
 edna    |  18
 esther  |  98
 fanny   |   8
 fred    |  28
 gina    |  18
 jane    |  58
 jean    |  28
 jeff    |  23
 jenifer |  38
 joan    |  18
 joe     |  20
 juanita |  58
 julie   |  68
 karen   |  48
 koko    |  88
 larry   |  60
 leah    |  68
 linda   |  19
 lita    |  25
 liza    |  38
 louise  |  98
 martie  |  88
 mary    |   8
 melissa |  28
 mike    |  40
 nan     |  28
 pamela  |  48
 pat     |  18
 paula   |  68
 rean    |  48
 sally   |  34
 sam     |  30
 sandra  |  19
 sandy   |  38
 sarah   |  88
 sharon  |  25
 sharon  |  78
 sue     |  50
 sumi    |  38
 susan   |  78
 teresa  |  38
 trisha  |  88
 trudy   |  88
 uma     |  78
 velma   |  68
 wendy   |  78
 zena    |  98
 zola    |  58
(58 rows)

--
-- awk '{print $1,$2;}' person.data |
-- awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
-- awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
-- awk 'BEGIN{FS="      ";}{if(NF!=1){print $4,$5;}else{print;}}' - stud_emp.data |
-- sort +1nr -2
--
SELECT p.name, p.age FROM person* p ORDER BY age using >, name;
  name   | age 
---------+-----
 esther  |  98
 louise  |  98
 zena    |  98
 bertha  |  88
 koko    |  88
 martie  |  88
 sarah   |  88
 trisha  |  88
 trudy   |  88
 carmen  |  78
 chris   |  78
 sharon  |  78
 susan   |  78
 uma     |  78
 wendy   |  78
 julie   |  68
 leah    |  68
 paula   |  68
 velma   |  68
 larry   |  60
 carina  |  58
 jane    |  58
 juanita |  58
 zola    |  58
 sue     |  50
 karen   |  48
 pamela  |  48
 rean    |  48
 mike    |  40
 belinda |  38
 jenifer |  38
 liza    |  38
 sandy   |  38
 sumi    |  38
 teresa  |  38
 sally   |  34
 alex    |  30
 cim     |  30
 sam     |  30
 fred    |  28
 jean    |  28
 melissa |  28
 nan     |  28
 lita    |  25
 sharon  |  25
 denise  |  24
 jeff    |  23
 bill    |  20
 joe     |  20
 linda   |  19
 sandra  |  19
 diane   |  18
 edna    |  18
 gina    |  18
 joan    |  18
 pat     |  18
 fanny   |   8
 mary    |   8
(58 rows)

--
-- Test some cases involving whole-row Var referencing a subquery
--
select foo from (select 1) as foo;
 foo 
-----
 (1)
(1 row)

select foo from (select null) as foo;
 foo 
-----
 ()
(1 row)

select foo from (select 'xyzzy',1,null) as foo;
    foo     
------------
 (xyzzy,1,)
(1 row)

--
-- Test VALUES lists
--
select * from onek, (values(147, 'RFAAAA'), (931, 'VJAAAA')) as v (i, j)
    WHERE onek.unique1 = v.i and onek.stringu1 = v.j 
    ORDER BY unique1;
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 |  i  |   j    
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+-----+--------
     147 |       0 |   1 |    3 |   7 |      7 |       7 |       47 |         147 |       147 |      147 |  14 |   15 | RFAAAA   | AAAAAA   | AAAAxx  | 147 | RFAAAA
     931 |       1 |   1 |    3 |   1 |     11 |       1 |       31 |         131 |       431 |      931 |   2 |    3 | VJAAAA   | BAAAAA   | HHHHxx  | 931 | VJAAAA
(2 rows)

-- a more complex case
-- looks like we're coding lisp :-)
select * from onek,
  (values ((select i from
    (values(10000), (2), (389), (1000), (2000), ((select 10029))) as foo(i)
    order by i asc limit 1))) bar (i)
  where onek.unique1 = bar.i 
  ORDER BY unique1;
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | i 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+---
       2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx  | 2
(1 row)

-- try VALUES in a subquery
select * from onek
    where (unique1,ten) in (values (1,1), (20,0), (99,9), (17,99))
    order by unique1;
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
       1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
      20 |     306 |   0 |    0 |   0 |      0 |       0 |       20 |          20 |        20 |       20 |   0 |    1 | UAAAAA   | ULAAAA   | OOOOxx
      99 |     101 |   1 |    3 |   9 |     19 |       9 |       99 |          99 |        99 |       99 |  18 |   19 | VDAAAA   | XDAAAA   | HHHHxx
(3 rows)

-- VALUES is also legal as a standalone query or a set-operation member
VALUES (1,2), (3,4+4), (7,77.7);
 column1 | column2 
---------+---------
       1 |       2
       3 |       8
       7 |    77.7
(3 rows)

VALUES (1,2), (3,4+4), (7,77.7)
UNION ALL
SELECT 2+2, 57
UNION ALL
TABLE int8_tbl 
ORDER BY column1,column2;
     column1      |      column2      
------------------+-------------------
                1 |                 2
                3 |                 8
                4 |                57
                7 |              77.7
              123 |               456
              123 |  4567890123456789
 4567890123456789 | -4567890123456789
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
(9 rows)

--
-- Test ORDER BY options
--
CREATE TEMP TABLE foo (f1 int);
INSERT INTO foo VALUES (42),(3),(10),(7),(null),(null),(1);
SELECT * FROM foo ORDER BY f1;
 f1 
----
  1
  3
  7
 10
 42
   
   
(7 rows)

SELECT * FROM foo ORDER BY f1 ASC;	-- same thing
 f1 
----
  1
  3
  7
 10
 42
   
   
(7 rows)

SELECT * FROM foo ORDER BY f1 NULLS FIRST;
 f1 
----
   
   
  1
  3
  7
 10
 42
(7 rows)

SELECT * FROM foo ORDER BY f1 DESC;
 f1 
----
   
   
 42
 10
  7
  3
  1
(7 rows)

SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
 f1 
----
 42
 10
  7
  3
  1
   
   
(7 rows)

-- check if indexscans do the right things
CREATE INDEX fooi ON foo (f1);
SET enable_sort = false;
SELECT * FROM foo ORDER BY f1;
 f1 
----
  1
  3
  7
 10
 42
   
   
(7 rows)

SELECT * FROM foo ORDER BY f1 NULLS FIRST;
 f1 
----
   
   
  1
  3
  7
 10
 42
(7 rows)

SELECT * FROM foo ORDER BY f1 DESC;
 f1 
----
   
   
 42
 10
  7
  3
  1
(7 rows)

SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
 f1 
----
 42
 10
  7
  3
  1
   
   
(7 rows)

DROP INDEX fooi;
CREATE INDEX fooi ON foo (f1 DESC);
SELECT * FROM foo ORDER BY f1;
 f1 
----
  1
  3
  7
 10
 42
   
   
(7 rows)

SELECT * FROM foo ORDER BY f1 NULLS FIRST;
 f1 
----
   
   
  1
  3
  7
 10
 42
(7 rows)

SELECT * FROM foo ORDER BY f1 DESC;
 f1 
----
   
   
 42
 10
  7
  3
  1
(7 rows)

SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
 f1 
----
 42
 10
  7
  3
  1
   
   
(7 rows)

DROP INDEX fooi;
CREATE INDEX fooi ON foo (f1 DESC NULLS LAST);
SELECT * FROM foo ORDER BY f1;
 f1 
----
  1
  3
  7
 10
 42
   
   
(7 rows)

SELECT * FROM foo ORDER BY f1 NULLS FIRST;
 f1 
----
   
   
  1
  3
  7
 10
 42
(7 rows)

SELECT * FROM foo ORDER BY f1 DESC;
 f1 
----
   
   
 42
 10
  7
  3
  1
(7 rows)

SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
 f1 
----
 42
 10
  7
  3
  1
   
   
(7 rows)

--
-- Test planning of some cases with partial indexes
--
-- partial index is usable
explain (costs off)
select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
                  QUERY PLAN                   
-----------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Index Scan using onek2_u2_prtl on onek2
         Index Cond: (unique2 = 11)
         Filter: (stringu1 = 'ATAAAA'::name)
(5 rows)

select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
     494 |      11 |   0 |    2 |   4 |     14 |       4 |       94 |          94 |       494 |      494 |   8 |    9 | ATAAAA   | LAAAAA   | VVVVxx
(1 row)

-- get the plan for the following query
explain (costs off, timing off, summary off)
select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
                  QUERY PLAN                   
-----------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Index Scan using onek2_u2_prtl on onek2
         Index Cond: (unique2 = 11)
         Filter: (stringu1 = 'ATAAAA'::name)
(5 rows)

-- actually run the query with an analyze to use the partial index
explain (costs off, analyze on, timing off, summary off)
select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
                     QUERY PLAN                      
-----------------------------------------------------
 Remote Fast Query Execution (actual rows=1 loops=1)
   Node/s: datanode_1, datanode_2
(2 rows)

explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
                  QUERY PLAN                   
-----------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Index Scan using onek2_u2_prtl on onek2
         Index Cond: (unique2 = 11)
         Filter: (stringu1 = 'ATAAAA'::name)
(5 rows)

select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
 unique2 
---------
      11
(1 row)

-- partial index predicate implies clause, so no need for retest
explain (costs off)
select * from onek2 where unique2 = 11 and stringu1 < 'B';
                  QUERY PLAN                   
-----------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Index Scan using onek2_u2_prtl on onek2
         Index Cond: (unique2 = 11)
(4 rows)

select * from onek2 where unique2 = 11 and stringu1 < 'B';
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
     494 |      11 |   0 |    2 |   4 |     14 |       4 |       94 |          94 |       494 |      494 |   8 |    9 | ATAAAA   | LAAAAA   | VVVVxx
(1 row)

explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
                     QUERY PLAN                     
----------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Index Only Scan using onek2_u2_prtl on onek2
         Index Cond: (unique2 = 11)
(4 rows)

select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
 unique2 
---------
      11
(1 row)

-- but if it's an update target, must retest anyway
explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update;
                     QUERY PLAN                      
-----------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  LockRows
         ->  Index Scan using onek2_u2_prtl on onek2
               Index Cond: (unique2 = 11)
               Filter: (stringu1 < 'B'::name)
(6 rows)

select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update;
 unique2 
---------
      11
(1 row)

-- partial index is not applicable
explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'C';
                         QUERY PLAN                          
-------------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Seq Scan on onek2
         Filter: ((stringu1 < 'C'::name) AND (unique2 = 11))
(4 rows)

select unique2 from onek2 where unique2 = 11 and stringu1 < 'C';
 unique2 
---------
      11
(1 row)

-- partial index implies clause, but bitmap scan must recheck predicate anyway
SET enable_indexscan TO off;
SET enable_bitmapscan TO off;
explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
                         QUERY PLAN                          
-------------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Seq Scan on onek2
         Filter: ((stringu1 < 'B'::name) AND (unique2 = 11))
(4 rows)

select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
 unique2 
---------
      11
(1 row)

RESET enable_indexscan;
RESET enable_bitmapscan;
-- check multi-index cases too
explain (costs off)
select unique1, unique2 from onek2
  where (unique2 = 11 or unique1 = 0) and stringu1 < 'B';
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Bitmap Heap Scan on onek2
         Recheck Cond: (((unique2 = 11) AND (stringu1 < 'B'::name)) OR (unique1 = 0))
         Filter: (stringu1 < 'B'::name)
         ->  BitmapOr
               ->  Bitmap Index Scan on onek2_u2_prtl
                     Index Cond: (unique2 = 11)
               ->  Bitmap Index Scan on onek2_u1_prtl
                     Index Cond: (unique1 = 0)
(10 rows)

select unique1, unique2 from onek2
  where (unique2 = 11 or unique1 = 0) and stringu1 < 'B';
 unique1 | unique2 
---------+---------
     494 |      11
       0 |     998
(2 rows)

explain (costs off)
select unique1, unique2 from onek2
  where (unique2 = 11 and stringu1 < 'B') or unique1 = 0;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Bitmap Heap Scan on onek2
         Recheck Cond: (((unique2 = 11) AND (stringu1 < 'B'::name)) OR (unique1 = 0))
         ->  BitmapOr
               ->  Bitmap Index Scan on onek2_u2_prtl
                     Index Cond: (unique2 = 11)
               ->  Bitmap Index Scan on onek2_u1_prtl
                     Index Cond: (unique1 = 0)
(9 rows)

select unique1, unique2 from onek2
  where (unique2 = 11 and stringu1 < 'B') or unique1 = 0;
 unique1 | unique2 
---------+---------
     494 |      11
       0 |     998
(2 rows)

--
-- Test some corner cases that have been known to confuse the planner
--
-- ORDER BY on a constant doesn't really need any sorting
SELECT 1 AS x ORDER BY x;
 x 
---
 1
(1 row)

-- But ORDER BY on a set-valued expression does
create function sillysrf(int) returns setof int as
  'values (1),(10),(2),($1)' language sql immutable;
select sillysrf(42) order by 1;
 sillysrf 
----------
        1
        2
       10
       42
(4 rows)

select sillysrf(-1) order by 1;
 sillysrf 
----------
       -1
        1
        2
       10
(4 rows)

drop function sillysrf(int);
-- X = X isn't a no-op, it's effectively X IS NOT NULL assuming = is strict
-- (see bug #5084)
select * from (values (2),(null),(1)) v(k) where k = k order by k;
 k 
---
 1
 2
(2 rows)

select * from (values (2),(null),(1)) v(k) where k = k order by k desc;
 k 
---
 2
 1
(2 rows)

-- Test partitioned tables with no partitions, which should be handled the
-- same as the non-inheritance case when expanding its RTE.
create table list_parted_tbl (a int,b int) partition by list (a);
create table list_parted_tbl1 partition of list_parted_tbl
  for values in (1) partition by list(b);
explain (costs off) select * from list_parted_tbl;
            QUERY PLAN            
----------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Result
         One-Time Filter: false
(4 rows)

drop table list_parted_tbl;
create table tt1 (
    c11 integer,
    c12 integer,
    c13 integer,
    c14 integer,
    c15 integer
);
insert into tt1
select  i,i,i,i,i
from generate_series(1, 50) as i;
explain
select c12
from tt1
order by c12
for update
limit 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit  (cost=10000001022.86..10000001022.95 rows=10 width=14)
   ->  Remote Subquery Scan on all (datanodes 2)  (cost=10000001022.86..10000001023.03 rows=20 width=14)
         Sort Key: c12
         ->  Sort  (cost=20000000023.15..20000000023.18 rows=10 width=14)
               Sort Key: c12
               ->  Limit  (cost=10000000022.86..10000000022.98 rows=10 width=14)
                     ->  LockRows  (cost=10000000022.86..10000000029.92 rows=565 width=14)
                           ->  Sort  (cost=10000000022.86..10000000024.27 rows=565 width=14)
                                 Sort Key: c12
                                 ->  Seq Scan on tt1  (cost=0.00..10.65 rows=565 width=14)
(10 rows)

select c12
from tt1
order by c12
for update
limit 10;
 c12 
-----
   1
   2
   3
   4
   5
   6
   7
   8
   9
  10
(10 rows)

drop table tt1;
create table tt1
(
c1 int,
c2 int,
c3 int
);
insert into tt1 values(1,1,1);
insert into tt1 values(1,2,1);
select distinct max(c3) over(partition by c2) from tt1 order by 1;
 max 
-----
   1
(1 row)

drop table tt1;
explain (costs off, verbose) select distinct(1,'a');
                   QUERY PLAN                    
-------------------------------------------------
 Unique
   Output: (ROW(1, 'a'::text)), 1, 'a'::text
   ->  Result
         Output: ROW(1, 'a'::text), 1, 'a'::text
(4 rows)

select distinct(1,'a');
  row  
-------
 (1,a)
(1 row)

set enable_hashagg = off;
create table tt1(site text, pt_d text, cnty_code text) DISTRIBUTE BY SHARD (pt_d,cnty_code);
create table tt2(site text, pt_d text, cnty_code text) DISTRIBUTE BY SHARD (pt_d,cnty_code);
explain (costs off, verbose)
select t3.site
from (select site, pt_d  from tt1 group by 1,2) as t3
left outer join
     (select pt_d, site  from tt2 group by 1,2) as t4
on t3.site=t4.site and t3.pt_d=t4.pt_d
group by 1;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1,datanode_2)
   Output: tt1.site
   Sort Key: tt1.site
   ->  Group
         Output: tt1.site
         Group Key: tt1.site
         ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)
               Output: tt1.site
               Sort Key: tt1.site
               Distribute results by S: site
               ->  Group
                     Output: tt1.site
                     Group Key: tt1.site
                     ->  Group
                           Output: tt1.site, tt1.pt_d
                           Group Key: tt1.site, tt1.pt_d
                           ->  Remote Subquery Scan[3] on all (datanode_1,datanode_2)
                                 Output: tt1.site, tt1.pt_d
                                 Sort Key: tt1.site, tt1.pt_d
                                 Distribute results by S: site, pt_d
                                 ->  Group
                                       Output: tt1.site, tt1.pt_d
                                       Group Key: tt1.site, tt1.pt_d
                                       ->  Sort
                                             Output: tt1.site, tt1.pt_d
                                             Sort Key: tt1.site, tt1.pt_d
                                             ->  Seq Scan on public.tt1
                                                   Output: tt1.site, tt1.pt_d
(28 rows)

drop table tt1;
drop table tt2;
set enable_hashagg = on;
CREATE TABLE tt1 (
c0 int not null,
c1 int,
c2 text,
c3 text,
c4 date,
c5 date
);
CREATE TABLE tt2 (
c0 int,
c1 int,
c2 text,
c3 text,
c4 date,
c5 date);
INSERT INTO tt1 VALUES  (9, 2, NULL, 'bar', '1993-04-07', '2022-04-09');
INSERT INTO tt1 VALUES  (8, 2, NULL, 'bar', '1993-04-07', '2022-04-09');
SELECT DISTINCT a1.c0
FROM ( tt1 a1 
       LEFT JOIN tt2 a2
       ON ( NOT ( a2.c5 >= a1.c4 ) AND ( a1.c0 = a2.c1 ) ) )
     RIGHT JOIN tt1 a3
     ON ( ( NOT ( a3.c1 = 9 )
      AND ( a1.c0 = a3.c1 ) )
      AND ( a3.c2 LIKE 'C%' ) )
WHERE a1.c0 IS NULL;
 c0 
----
   
(1 row)

drop table tt1;
drop table tt2;
\c regression_ora
-- test 'select unique xxx from table'
create table t_unique(f1 varchar(10),f2 int);
insert into t_unique values('test1',1);
insert into t_unique values('test2',1);
insert into t_unique values('test1',1);
insert into t_unique values('test3',1);
insert into t_unique values('test2',1);
select unique f1 from t_unique order by 1;
  F1   
-------
 test1
 test2
 test3
(3 rows)

select count(unique f1) from t_unique;
 COUNT 
-------
     3
(1 row)

drop table t_unique;
create table test_unique1(id int, c0 int, c1 number , c2 varchar(100), c3 varchar2(100));
insert into test_unique1(id, c0, c1, c2, c3) values(1,123, 123.123, 'abc', '123');
insert into test_unique1(id, c0, c1, c2, c3) values(2,234, 234.234, 'bcd', '234');
insert into test_unique1(id, c0, c1, c2, c3) values(3,345, 345.345, 'cde', '345');
insert into test_unique1(id, c0, c1, c2, c3) values(4,456, 234.234, 'def', '456');
insert into test_unique1(id, c0, c1, c2, c3) values(5,567, 567.567, 'efg', '567');
insert into test_unique1(id, c0, c1, c2, c3) values(6,567, 567.567, 'fgh', '567');
insert into test_unique1(id, c0, c1, c2, c3) values(7,678, 678.678, 'ghi', '789');
insert into test_unique1(id, c0, c1, c2, c3) values(8,678, 678.678, '', '789');
insert into test_unique1(id, c0, c1, c2, c3) values(9,678, 678678.8123, '', '8423');
insert into test_unique1(id, c0, c1, c2) values(10,789, 789.789, 'hij');
insert into test_unique1(id, c0, c1, c2) values(11,890, 123.123, 'ijk');
insert into test_unique1(id, c0, c1, c2) values(12,901, 901.901, 'abc');
create table test_unique2(id int, c0 int, c1 number , c2 varchar(100), c3 varchar2(100));
insert into test_unique2(id, c0, c1, c2, c3) values(1,123, 123.123, 'abc', '123');
insert into test_unique2(id, c0, c1, c2, c3) values(2,234, 234.234, 'bcd', '234');
insert into test_unique2(id, c0, c1, c2, c3) values(3,345, 345.345, 'cde', '345');
insert into test_unique2(id, c0, c1, c2, c3) values(4,456, 234.234, 'def', '456');
insert into test_unique2(id, c0, c1, c2, c3) values(5,567, 567.567, 'efg', '567');
insert into test_unique2(id, c0, c1, c2, c3) values(6,567, 567.567, 'fgh', '567');
insert into test_unique2(id, c0, c1, c2, c3) values(7,678, 678.678, 'ghi', '789');
insert into test_unique2(id, c0, c1, c2, c3) values(8,678, 678.678, '', '789');
insert into test_unique2(id, c0, c1, c2, c3) values(9,678, 678678.8123, '', '8423');
insert into test_unique2(id, c0, c1, c2) values(10,789, 789.789, 'hij');
insert into test_unique2(id, c0, c1, c2) values(11,890, 123.123, 'ijk');
insert into test_unique2(id, c0, c1, c2) values(12,901, 901.901, 'abc');
select * from test_unique2 where c3 in (select unique c3 from test_unique1) order by id;
 ID | C0  |     C1      | C2  |  C3  
----+-----+-------------+-----+------
  1 | 123 |     123.123 | abc | 123
  2 | 234 |     234.234 | bcd | 234
  3 | 345 |     345.345 | cde | 345
  4 | 456 |     234.234 | def | 456
  5 | 567 |     567.567 | efg | 567
  6 | 567 |     567.567 | fgh | 567
  7 | 678 |     678.678 | ghi | 789
  8 | 678 |     678.678 |     | 789
  9 | 678 | 678678.8123 |     | 8423
(9 rows)

select unique sin(c3) from (select unique c3 from test_unique1) order by 1;
         SIN          
----------------------
  -0.5439958173735323
 -0.45990349068959124
    -0.45205267588297
  -0.4441666848300092
 -0.38027695100780123
   0.9983488258124457
   0.9988166912028082
                     
(8 rows)

drop table test_unique1;
drop table test_unique2;
-- Test partitioned tables with no partitions, which should be handled the
-- same as the non-inheritance case when expanding its RTE.
create table list_parted_tbl (a int,b int) partition by list (a);
create table list_parted_tbl1 partition of list_parted_tbl
  for values in (1) partition by list(b);
explain (costs off) select * from list_parted_tbl;
            QUERY PLAN            
----------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Result
         One-Time Filter: false
(4 rows)

drop table list_parted_tbl;
create table k(k1 int, k2 varchar(10));
create index on k((k2::numeric));
insert into k values(1, 2);
insert into k select * from k;
insert into k select * from k;
insert into k select * from k;
insert into k select * from k;
insert into k select * from k;
insert into k select * from k;
insert into k select * from k;
insert into k select * from k;
analyze k;
explain (costs off) 
select * from k where k2 = 1;
                     QUERY PLAN                     
----------------------------------------------------
 Remote Fast Query Execution
   Node/s: datanode_1, datanode_2
   ->  Index Scan using K_K2_IDX on K
         Index Cond: ((K2)::NUMERIC = '1'::NUMERIC)
(4 rows)

create table u(h1 numeric, u2 numeric);
insert into u select * from k;
analyze u;
explain (costs off) 
select * from u, k where k2 = u2;
                          QUERY PLAN                          
--------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  Hash Join
         Hash Cond: (U.U2 = ((K.K2)::NUMERIC))
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: U2
               ->  Seq Scan on U
         ->  Hash
               ->  Remote Subquery Scan on all (datanodes 2)
                     Distribute results by S: ((K2)::NUMERIC)
                     ->  Seq Scan on K
(10 rows)

drop table k;
drop table u;
BEGIN;
CREATE TYPE casetestenum AS ENUM ('e');
SELECT
  CASE 'foo'::text
    WHEN 'foo' THEN enum_range(NULL::casetestenum)::text[]
    ELSE ARRAY['x']
    END;
 array 
-------
 {e}
(1 row)

ROLLBACK;
CREATE TABLE FEE (
FEE_C1 NUMERIC(10, 0) NOT NULL,
FEE_C2 CHARACTER(1),
FEE_C3 NUMERIC(10,0) NOT NULL
);
CREATE TABLE TT (
TT_C1 NUMERIC(2,0) NOT NULL,
TT_C2 CHARACTER VARYING(90) NOT NULL
);
CREATE TABLE TP (
T_C1 CHARACTER VARYING(100),
T_C2 CHARACTER(1) NOT NULL
);
select
count(*)
from
(
select *
from
(
select
(case when F.TT_C2='aa' then null
      else(select distinct T.T_C1
           from FEE FEE,
                TT TT,
                TP T
            where FEE.FEE_C2 = T.T_C2
              and FEE.FEE_C1=TT.TT_C1
              and TT.TT_C2 = F.TT_C2)
      end)period
from
( select A.*
  from (select FIT.TT_C2
        from TT FIT)A
  union select B.*
         from (select FIT.TT_C2
               from TT FIT) B) F) T);
 COUNT 
-------
     0
(1 row)

explain (costs off, nodes off)
select
count(*)
from
(
select *
from
(
select
(case when F.TT_C2='aa' then null
      else(select distinct T.T_C1
           from FEE FEE,
                TT TT,
                TP T
            where FEE.FEE_C2 = T.T_C2
              and FEE.FEE_C1=TT.TT_C1
              and TT.TT_C2 = F.TT_C2)
      end)period
from
( select A.*
  from (select FIT.TT_C2
        from TT FIT)A
  union select B.*
         from (select FIT.TT_C2
               from TT FIT) B) F) T);
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop Left Scalar Join
         Join Filter: (((FIT.TT_C2)::TEXT <> 'aa'::TEXT) OR (((FIT.TT_C2)::TEXT = 'aa'::TEXT) IS NULL))
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  HashAggregate
                     Group Key: FIT.TT_C2
                     ->  Remote Subquery Scan on all (datanodes 2)
                           Distribute results by S: TT_C2
                           ->  HashAggregate
                                 Group Key: FIT.TT_C2
                                 ->  Append
                                       ->  Seq Scan on TT FIT
                                       ->  Seq Scan on TT FIT_1
         ->  Remote Subquery Scan on all (datanodes 2)
               ->  Subquery Scan on "TARGETLIST_subquery"
                     ->  HashAggregate
                           Group Key: T.T_C1
                           ->  Remote Subquery Scan on all (datanodes 2)
                                 Distribute results by S: T_C1
                                 ->  HashAggregate
                                       Group Key: T.T_C1
                                       ->  Hash Join
                                             Hash Cond: (FEE.FEE_C2 = T.T_C2)
                                             ->  Remote Subquery Scan on all (datanodes 2)
                                                   Distribute results by S: FEE_C2
                                                   ->  Hash Join
                                                         Hash Cond: (FEE.FEE_C1 = TT.TT_C1)
                                                         ->  Seq Scan on FEE
                                                         ->  Hash
                                                               ->  Seq Scan on TT
                                                                     Filter: ((TT_C2)::TEXT = (FIT.TT_C2)::TEXT)
                                             ->  Hash
                                                   ->  Materialize
                                                         ->  Remote Subquery Scan on all (datanodes 2)
                                                               Distribute results by S: T_C2
                                                               ->  Seq Scan on TP T
(36 rows)

drop table FEE;
drop table TT;
drop table TP;
drop table if exists ut1;
NOTICE:  table "UT1" does not exist, skipping
drop table if exists ut2;
NOTICE:  table "UT2" does not exist, skipping
drop table if exists ut3;
NOTICE:  table "UT3" does not exist, skipping
drop table if exists ut4;
NOTICE:  table "UT4" does not exist, skipping
create table ut1(c0 int, c1 int, c2 int);
create table ut2(c0 int, c1 int, c2 int);
create table ut3(c0 int, c1 int, c2 int);
create table ut4(c0 int, c1 int, c2 int);
explain (costs off)
SELECT DISTINCT 
    c0, c1
    FROM ut1 t1
WHERE exists
    (SELECT c0 FROM ut2 t2)
UNION
SELECT DISTINCT c0, c1 FROM ut3 t1
UNION 
SELECT  c0,
        c1::int8
FROM ut4
    GROUP BY  c0, c1;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Remote Subquery Scan on all (datanodes 2)
   ->  HashAggregate
         Group Key: T1.C0, ((T1.C1)::BIGINT)
         ->  Remote Subquery Scan on all (datanodes 2)
               Distribute results by S: C0, ((C1)::BIGINT)
               ->  HashAggregate
                     Group Key: T1.C0, ((T1.C1)::BIGINT)
                     ->  Append
                           ->  HashAggregate
                                 Group Key: T1.C0, T1.C1
                                 ->  Remote Subquery Scan on all (datanodes 2)
                                       Params Evaluated: $0
                                       Distribute results by S: C0, C1
                                       ->  HashAggregate
                                             Group Key: T1.C0, T1.C1
                                             ->  Append
                                                   ->  HashAggregate
                                                         Group Key: T1.C0, T1.C1
                                                         InitPlan 1 (returns $0)
                                                           ->  Remote Subquery Scan on all (datanodes 2)
                                                                 Distribute results by R
                                                                 ->  Seq Scan on UT2 T2
                                                         ->  Result
                                                               One-Time Filter: $0
                                                               ->  Seq Scan on UT1 T1
                                                   ->  HashAggregate
                                                         Group Key: T1_1.C0, T1_1.C1
                                                         ->  Seq Scan on UT3 T1_1
                           ->  Subquery Scan on "*SELECT* 3"
                                 ->  HashAggregate
                                       Group Key: UT4.C0, UT4.C1
                                       ->  Seq Scan on UT4
(32 rows)

drop table if exists ut1;
drop table if exists ut2;
drop table if exists ut3;
drop table if exists ut4;
CREATE TABLE rqg_table10 (
c0 int,
c1 int,
pk int)    PARTITION BY hash(pk) ;
create TABLE rqg_table10_p0 partition of rqg_table10 for values with(modulus 4,remainder 0);
create TABLE rqg_table10_p1 partition of rqg_table10 for values with(modulus 4,remainder 1);
create TABLE rqg_table10_p2 partition of rqg_table10 for values with(modulus 4,remainder 2);
create TABLE rqg_table10_p3 partition of rqg_table10 for values with(modulus 4,remainder 3);
select t1.c0, t1.c1
from rqg_table10 t1
left outer join rqg_table10 t2
on t1.c1 = t2.c1
group by t1.c0, t1.c1;
 C0 | C1 
----+----
(0 rows)

DROP TABLE rqg_table10;
-- join two tables with FOR UPDATE clause
-- tests whole-row reference for row marks
create table rel1_for_update_with_join(c1 int, c3 int);
create table rel2_for_update_with_join(c1 int);
insert into rel1_for_update_with_join values (50, 60);
insert into rel2_for_update_with_join values (50);
SELECT t1.c1, t2.c1 FROM rel1_for_update_with_join t1 JOIN rel2_for_update_with_join t2
    ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 0 LIMIT 10 FOR UPDATE OF t1;
ERROR:  FOR UPDATE is not allowed with joins
-- test deparsing rowmarked relations as subqueries
SELECT t1.c1, ss.a, ss.b FROM (SELECT c1 FROM rel1_for_update_with_join WHERE c1 = 50) t1
    INNER JOIN (SELECT t2.c1, t3.c1 FROM (SELECT c1 FROM rel1_for_update_with_join WHERE c1 between 50 and 60) t2
    FULL JOIN (SELECT c1 FROM rel2_for_update_with_join WHERE c1 between 50 and 60) t3
    ON (t2.c1 = t3.c1) WHERE t2.c1 IS NULL OR t2.c1 IS NOT NULL) ss(a, b) ON (TRUE)
    ORDER BY t1.c1, ss.a, ss.b FOR UPDATE OF t1;
ERROR:  FOR UPDATE is not allowed with joins
drop table rel1_for_update_with_join;
drop table rel2_for_update_with_join;
create table t1_function(c1 int);
insert into t1_function
select 1
from generate_series(1, 100) as i;
SELECT pg_catalog.regr_sxx(5, 3.14) as c1 from t1_function;
           C1           
------------------------
 1.9360582523356857e-27
(1 row)

SELECT pg_catalog.regr_syy(5, 3.14) as c1 from t1_function;
 C1 
----
  0
(1 row)

SELECT pg_catalog.regr_sxy(5, 3.14) as c1 from t1_function;
 C1 
----
  0
(1 row)

SELECT pg_catalog.regr_avgx(5, 3.14) as c1 from t1_function;
        C1         
-------------------
 3.139999999999992
(1 row)

SELECT pg_catalog.regr_avgy(5, 3.14) as c1 from t1_function;
 C1 
----
  5
(1 row)

SELECT pg_catalog.regr_r2(5, 3.14) as c1 from t1_function;
 C1 
----
  1
(1 row)

SELECT pg_catalog.regr_slope(5, 3.14) as c1 from t1_function;
 C1 
----
  0
(1 row)

SELECT pg_catalog.regr_intercept(5, 3.14) as c1 from t1_function;
 C1 
----
  5
(1 row)

SELECT pg_catalog.covar_pop(5, 3.14) as c1 from t1_function;
 C1 
----
  0
(1 row)

SELECT pg_catalog.covar_samp(5, 3.14) as c1 from t1_function;
 C1 
----
  0
(1 row)

SELECT pg_catalog.corr(5, 3.14) as c1 from t1_function;
 C1 
----
   
(1 row)

drop table t1_function;
drop table if exists t1_row_c;
NOTICE:  table "T1_ROW_C" does not exist, skipping
create table t1_row_c(c0 int, c1 text);
insert into t1_row_c values(1, '(1,0)'),(2, '(1,1)');
reset enable_hashjoin;
reset enable_nestloop;
drop table if exists t1_row_c;
CREATE TABLE rqg_table4 (
c0 int,
c1 int,
c2 text,
c3 text,
c4 date,
c5 date);
CREATE TABLE rqg_table1 (
c0 int,
c1 int,
c2 text,
c3 text,
c4 date,
c5 date);
CREATE TABLE rqg_table5 (
c0 int,
c1 int,
c2 text,
c3 text,
c4 date,
c5 date);
explain (costs off, verbose) 
select * from rqg_table4 tt1 where 
c1=( select (c1+1) from ( SELECT DISTINCT a2.c0, a1.c1
                                            FROM  rqg_table1 a1 INNER JOIN
                                                  rqg_table5 a2 ON   a1.c0 = a2.c0 +1  AND  a2.c5 = a2.c5  order by 2) tt2
           where tt1.c0=tt2.c0 and tt1.c1=1 ) ;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Remote Subquery Scan[1] on all (datanode_1,datanode_2)
   Output: TT1.C0, TT1.C1, TT1.C2, TT1.C3, TT1.C4, TT1.C5
   ->  Seq Scan on "public".RQG_TABLE4 TT1
         Output: TT1.C0, TT1.C1, TT1.C2, TT1.C3, TT1.C4, TT1.C5
         Filter: (TT1.C1 = (SubPlan 1))
         SubPlan 1
           ->  Remote Subquery Scan[2] param[5] on all (datanode_1,datanode_2)
                 Output: ((A1.C1 + 1))
                 Distribute results by R
                 ->  Result
                       Output: (A1.C1 + 1)
                       One-Time Filter: (TT1.C1 = 1)
                       ->  Sort
                             Output: A2.C0, A1.C1
                             Sort Key: A1.C1
                             ->  HashAggregate
                                   Output: A2.C0, A1.C1
                                   Group Key: A1.C1, A2.C0
                                   ->  Remote Subquery Scan[3] param[6] on all (datanode_1,datanode_2)
                                         Output: A2.C0, A1.C1
                                         Distribute results by S: C1, C0
                                         ->  HashAggregate
                                               Output: A2.C0, A1.C1
                                               Group Key: A1.C1, A2.C0
                                               ->  Hash Join
                                                     Output: A2.C0, A1.C1
                                                     Hash Cond: (((A2.C0 + 1)) = A1.C0)
                                                     ->  Remote Subquery Scan[4] param[7] on all (datanode_1,datanode_2)
                                                           Output: A2.C0, ((A2.C0 + 1))
                                                           Distribute results by H: ((C0 + 1))
                                                           ->  Seq Scan on "public".RQG_TABLE5 A2
                                                                 Output: A2.C0, (A2.C0 + 1)
                                                                 Filter: ((A2.C5 IS NOT NULL) AND (TT1.C0 = A2.C0))
                                                     ->  Hash
                                                           Output: A1.C1, A1.C0
                                                           ->  Seq Scan on "public".RQG_TABLE1 A1
                                                                 Output: A1.C1, A1.C0
(37 rows)

DROP TABLE rqg_table1;
DROP TABLE rqg_table4;
DROP TABLE rqg_table5;
create table tt1(c1 int, c2 int, c3 int);
select c1 from tt1 union select all 29 from tt1 a left join tt1 b on a.c2 = b.c2 or a.c1 is not null ;
 C1 
----
(0 rows)

drop table tt1;
