*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/oracle.out"	2025-07-31 16:07:14.994067993 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/oracle.out"	2025-07-31 16:37:56.957025917 +0800
***************
*** 127,133 ****
                                         Table "public.test1"
   Column |       Type       | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+------------------+-----------+----------+---------+---------+--------------+-------------
!  tc1    | real             |           |          |         | plain   |              | 
   tc2    | double precision |           |          |         | plain   |              | 
   tc3    | numeric          |           |          |         | main    |              | 
   tc4    | real             |           |          |         | plain   |              | 
--- 127,133 ----
                                         Table "public.test1"
   Column |       Type       | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+------------------+-----------+----------+---------+---------+--------------+-------------
!  tc1    | real             |           | not null |         | plain   |              | 
   tc2    | double precision |           |          |         | plain   |              | 
   tc3    | numeric          |           |          |         | main    |              | 
   tc4    | real             |           |          |         | plain   |              | 
***************
*** 140,146 ****
      "idx_test1_tc4" btree (tc4)
      "idx_test1_tc5" btree (tc5)
      "idx_test1_tc6" btree (tc6)
! Distribute By: HASH(tc1)
  Location Nodes: ALL DATANODES
  
  insert into test1 values(10.0123456789, 11.0123456789, 12.0123456789, 13.0123456789, 14.0123456789, 15.0123456789);
--- 140,146 ----
      "idx_test1_tc4" btree (tc4)
      "idx_test1_tc5" btree (tc5)
      "idx_test1_tc6" btree (tc6)
! Distribute By: SHARD(tc1)
  Location Nodes: ALL DATANODES
  
  insert into test1 values(10.0123456789, 11.0123456789, 12.0123456789, 13.0123456789, 14.0123456789, 15.0123456789);
***************
*** 276,290 ****
  insert into test values(4,2);
  insert into test values(5,2);
  insert into test values(null, null);
  insert into test values(null, 1);
  insert into test values(1, null);
  \d+ test
                                     Table "public.test"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  tc1    | integer |           |          |         | plain   |              | 
   tc2    | integer |           |          |         | plain   |              | 
! Distribute By: HASH(tc1)
  Location Nodes: ALL DATANODES
  
  set enable_oracle_compatible = on;
--- 276,294 ----
  insert into test values(4,2);
  insert into test values(5,2);
  insert into test values(null, null);
+ ERROR:  node:datanode_1, backend_pid:381326, nodename:datanode_1,backend_pid:381326,message:null value in column "tc1" violates not-null constraint
+ DETAIL:  Failing row contains (null, null).
  insert into test values(null, 1);
+ ERROR:  node:datanode_1, backend_pid:381326, nodename:datanode_1,backend_pid:381326,message:null value in column "tc1" violates not-null constraint
+ DETAIL:  Failing row contains (null, 1).
  insert into test values(1, null);
  \d+ test
                                     Table "public.test"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  tc1    | integer |           | not null |         | plain   |              | 
   tc2    | integer |           |          |         | plain   |              | 
! Distribute By: SHARD(tc1)
  Location Nodes: ALL DATANODES
  
  set enable_oracle_compatible = on;
***************
*** 306,314 ****
       2.0000000000000000 | 0.50000000000000000000 | 1.5000000000000000 |    1 |    2 |    0
       2.5000000000000000 | 0.40000000000000000000 | 1.4000000000000000 |    1 |    2 |    0
                          |                        |                    |      |      |     
!                         |                        |                    |      |      |     
!                         |                        |                    |      |      |     
! (10 rows)
  
  set enable_oracle_compatible = off;
  select tc1 / tc2 as div1,
--- 310,316 ----
       2.0000000000000000 | 0.50000000000000000000 | 1.5000000000000000 |    1 |    2 |    0
       2.5000000000000000 | 0.40000000000000000000 | 1.4000000000000000 |    1 |    2 |    0
                          |                        |                    |      |      |     
! (8 rows)
  
  set enable_oracle_compatible = off;
  select tc1 / tc2 as div1,
***************
*** 329,337 ****
      2 |    0 |    1 |    1 |    2 |    0
      2 |    0 |    1 |    1 |    2 |    0
        |      |      |      |      |     
!       |      |      |      |      |     
!       |      |      |      |      |     
! (10 rows)
  
  drop table test;
  -- test Oracle date
--- 331,337 ----
      2 |    0 |    1 |    1 |    2 |    0
      2 |    0 |    1 |    1 |    2 |    0
        |      |      |      |      |     
! (8 rows)
  
  drop table test;
  -- test Oracle date
***************
*** 342,350 ****
                                               Table "public.test1"
   Column |            Type             | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+-----------------------------+-----------+----------+---------+---------+--------------+-------------
!  tc1    | date                        |           |          |         | plain   |              | 
   tc2    | timestamp without time zone |           |          |         | plain   |              | 
! Distribute By: HASH(tc1)
  Location Nodes: ALL DATANODES
  
  insert into test1 values('2003-08-01 10:12:21.01234', '2003-08-01 10:12:21.09876');
--- 342,350 ----
                                               Table "public.test1"
   Column |            Type             | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+-----------------------------+-----------+----------+---------+---------+--------------+-------------
!  tc1    | date                        |           | not null |         | plain   |              | 
   tc2    | timestamp without time zone |           |          |         | plain   |              | 
! Distribute By: SHARD(tc1)
  Location Nodes: ALL DATANODES
  
  insert into test1 values('2003-08-01 10:12:21.01234', '2003-08-01 10:12:21.09876');
***************
*** 395,403 ****
                                                Table "public.test2"
   Column |              Type              | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+--------------------------------+-----------+----------+---------+---------+--------------+-------------
!  tc1    | timestamp(0) without time zone |           |          |         | plain   |              | 
   tc2    | timestamp without time zone    |           |          |         | plain   |              | 
! Distribute By: HASH(tc1)
  Location Nodes: ALL DATANODES
  
  insert into test2 values('2003-08-01 10:12:21.01234', '2003-08-01 10:12:21.09876');
--- 395,403 ----
                                                Table "public.test2"
   Column |              Type              | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+--------------------------------+-----------+----------+---------+---------+--------------+-------------
!  tc1    | timestamp(0) without time zone |           | not null |         | plain   |              | 
   tc2    | timestamp without time zone    |           |          |         | plain   |              | 
! Distribute By: SHARD(tc1)
  Location Nodes: ALL DATANODES
  
  insert into test2 values('2003-08-01 10:12:21.01234', '2003-08-01 10:12:21.09876');
***************
*** 2014,2020 ****
  
  set enable_oracle_compatible = on;
  select * from test_t where id = 1 order by id asc;
! ERROR:  invalid input syntax for type numeric: "xxx"
  select * from test_t where id = '1' order by id asc;
   id 
  ----
--- 2014,2020 ----
  
  set enable_oracle_compatible = on;
  select * from test_t where id = 1 order by id asc;
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:invalid input syntax for type numeric: "xxx"
  select * from test_t where id = '1' order by id asc;
   id 
  ----
***************
*** 2034,2040 ****
  (1 row)
  
  select * from test_t where id = 1 order by id asc;
! ERROR:  invalid input syntax for type numeric: "xxx"
  select * from test_t where id = '1' order by id asc;
   id 
  ----
--- 2034,2040 ----
  (1 row)
  
  select * from test_t where id = 1 order by id asc;
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:invalid input syntax for type numeric: "xxx"
  select * from test_t where id = '1' order by id asc;
   id 
  ----
***************
*** 2099,2116 ****
  INSERT INTO test_sort VALUES ('red'), ('brown'), ('yellow'), ('Purple');
  INSERT INTO test_sort VALUES ('guangdong'), ('shenzhen'), ('beijing'), ('OpenTenBase');
  SELECT * FROM test_sort ORDER BY NLSSORT(name, 'en_US.utf8');
!     name     
! -------------
!  beijing
!  brown
!  guangdong
!  OpenTenBase
!  Purple
!  red
!  shenzhen
!  yellow
! (8 rows)
! 
  SELECT * FROM test_sort ORDER BY NLSSORT(name, '');
      name     
  -------------
--- 2099,2105 ----
  INSERT INTO test_sort VALUES ('red'), ('brown'), ('yellow'), ('Purple');
  INSERT INTO test_sort VALUES ('guangdong'), ('shenzhen'), ('beijing'), ('OpenTenBase');
  SELECT * FROM test_sort ORDER BY NLSSORT(name, 'en_US.utf8');
! ERROR:  node:datanode_2, backend_pid:381486, nodename:datanode_1,backend_pid:381512,message:failed to set the requested LC_COLLATE value [en_US.utf8]
  SELECT * FROM test_sort ORDER BY NLSSORT(name, '');
      name     
  -------------
***************
*** 2131,2137 ****
  (1 row)
  
  SELECT * FROM test_sort ORDER BY NLSSORT(name);
! ERROR:  failed to set the requested LC_COLLATE value [invalid]
  SELECT set_nls_sort('');
   set_nls_sort 
  --------------
--- 2120,2126 ----
  (1 row)
  
  SELECT * FROM test_sort ORDER BY NLSSORT(name);
! ERROR:  node:datanode_2, backend_pid:381486, nodename:datanode_1,backend_pid:381512,message:failed to set the requested LC_COLLATE value [invalid]
  SELECT set_nls_sort('');
   set_nls_sort 
  --------------
***************
*** 2158,2190 ****
  (1 row)
  
  SELECT * FROM test_sort ORDER BY NLSSORT(name);
!     name     
! -------------
!  beijing
!  brown
!  guangdong
!  OpenTenBase
!  Purple
!  red
!  shenzhen
!  yellow
! (8 rows)
! 
  INSERT INTO test_sort VALUES(NULL);
  SELECT * FROM test_sort ORDER BY NLSSORT(name);
!     name     
! -------------
!  beijing
!  brown
!  guangdong
!  OpenTenBase
!  Purple
!  red
!  shenzhen
!  yellow
!  
! (9 rows)
! 
  SELECT set_nls_sort('nls_sort = russian');
   set_nls_sort 
  --------------
--- 2147,2158 ----
  (1 row)
  
  SELECT * FROM test_sort ORDER BY NLSSORT(name);
! ERROR:  node:datanode_2, backend_pid:381486, nodename:datanode_1,backend_pid:381512,message:failed to set the requested LC_COLLATE value [en_US.utf8]
  INSERT INTO test_sort VALUES(NULL);
+ ERROR:  node:datanode_1, backend_pid:381512, nodename:datanode_1,backend_pid:381512,message:null value in column "name" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  SELECT * FROM test_sort ORDER BY NLSSORT(name);
! ERROR:  node:datanode_2, backend_pid:381486, nodename:datanode_1,backend_pid:381512,message:failed to set the requested LC_COLLATE value [en_US.utf8]
  SELECT set_nls_sort('nls_sort = russian');
   set_nls_sort 
  --------------
***************
*** 2192,2210 ****
  (1 row)
  
  SELECT * FROM test_sort ORDER BY NLSSORT(name);
!     name     
! -------------
!  beijing
!  brown
!  guangdong
!  OpenTenBase
!  Purple
!  red
!  shenzhen
!  yellow
!  
! (9 rows)
! 
  SELECT set_nls_sort('nls_sortr = pt_PT.iso885915@euro');
   set_nls_sort 
  --------------
--- 2160,2166 ----
  (1 row)
  
  SELECT * FROM test_sort ORDER BY NLSSORT(name);
! ERROR:  node:datanode_2, backend_pid:381486, nodename:datanode_1,backend_pid:381512,message:failed to set the requested LC_COLLATE value [russian]
  SELECT set_nls_sort('nls_sortr = pt_PT.iso885915@euro');
   set_nls_sort 
  --------------
***************
*** 2212,2218 ****
  (1 row)
  
  SELECT * FROM test_sort ORDER BY NLSSORT(name);
! ERROR:  failed to set the requested LC_COLLATE value [nls_sortr = pt_PT.iso885915@euro]
  SELECT set_nls_sort('nls_sortr = en_US.iso885915');
   set_nls_sort 
  --------------
--- 2168,2174 ----
  (1 row)
  
  SELECT * FROM test_sort ORDER BY NLSSORT(name);
! ERROR:  node:datanode_2, backend_pid:381486, nodename:datanode_1,backend_pid:381512,message:failed to set the requested LC_COLLATE value [nls_sortr = pt_PT.iso885915@euro]
  SELECT set_nls_sort('nls_sortr = en_US.iso885915');
   set_nls_sort 
  --------------
***************
*** 2230,2286 ****
   red
   shenzhen
   yellow
!  
! (9 rows)
  
  SELECT * FROM test_sort ORDER BY NLSSORT(name, 'Nls_sort =  zh_CN.gb18030 ');
!     name     
! -------------
!  beijing
!  brown
!  guangdong
!  OpenTenBase
!  Purple
!  red
!  shenzhen
!  yellow
!  
! (9 rows)
! 
  SELECT * FROM test_sort ORDER BY NLSSORT(name, 'Nls_sort =  wa_BE.iso885915@euro ');
!     name     
! -------------
!  beijing
!  brown
!  guangdong
!  OpenTenBase
!  Purple
!  red
!  shenzhen
!  yellow
!  
! (9 rows)
! 
  SELECT * FROM test_sort ORDER BY NLSSORT(name, 'NLS_SORT =  tt_RU.utf8@iqtelif ');
!     name     
! -------------
!  beijing
!  brown
!  guangdong
!  OpenTenBase
!  Purple
!  red
!  shenzhen
!  yellow
!  
! (9 rows)
! 
  SELECT * FROM test_sort ORDER BY NLSSORT(name, 'Nls_sortR =  tt_RU.utf8@iqtelif ');
! ERROR:  failed to set the requested LC_COLLATE value [Nls_sortR =  tt_RU.utf8@iqtelif]
  drop table test_sort;
  \c postgres
  DROP DATABASE IF EXISTS regression_sort;
- ERROR:  database "regression_sort" is being accessed by other users
  SET client_encoding to default;
  -- test !=- operator
  set enable_oracle_compatible = off;
--- 2186,2204 ----
   red
   shenzhen
   yellow
! (8 rows)
  
  SELECT * FROM test_sort ORDER BY NLSSORT(name, 'Nls_sort =  zh_CN.gb18030 ');
! ERROR:  node:datanode_2, backend_pid:381486, nodename:datanode_1,backend_pid:381512,message:failed to set the requested LC_COLLATE value [zh_CN.gb18030]
  SELECT * FROM test_sort ORDER BY NLSSORT(name, 'Nls_sort =  wa_BE.iso885915@euro ');
! ERROR:  node:datanode_2, backend_pid:381486, nodename:datanode_1,backend_pid:381512,message:failed to set the requested LC_COLLATE value [wa_BE.iso885915@euro]
  SELECT * FROM test_sort ORDER BY NLSSORT(name, 'NLS_SORT =  tt_RU.utf8@iqtelif ');
! ERROR:  node:datanode_2, backend_pid:381486, nodename:datanode_1,backend_pid:381512,message:failed to set the requested LC_COLLATE value [tt_RU.utf8@iqtelif]
  SELECT * FROM test_sort ORDER BY NLSSORT(name, 'Nls_sortR =  tt_RU.utf8@iqtelif ');
! ERROR:  node:datanode_2, backend_pid:381486, nodename:datanode_1,backend_pid:381512,message:failed to set the requested LC_COLLATE value [Nls_sortR =  tt_RU.utf8@iqtelif]
  drop table test_sort;
  \c postgres
  DROP DATABASE IF EXISTS regression_sort;
  SET client_encoding to default;
  -- test !=- operator
  set enable_oracle_compatible = off;
***************
*** 2288,2302 ****
  NOTICE:  table "test" does not exist, skipping
  create table test(tc1 int);
  insert into test values(1),(-1),(null);
  insert into test values(2),(-2),(null);
  set enable_oracle_compatible = off;
  select * from test where tc1 != -1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  select * from test where tc1 !=-1  order by tc1 asc;	-- error
  ERROR:  operator does not exist: integer !=- integer
--- 2206,2221 ----
  NOTICE:  table "test" does not exist, skipping
  create table test(tc1 int);
  insert into test values(1),(-1),(null);
+ ERROR:  node:datanode_1, backend_pid:381207, nodename:datanode_1,backend_pid:381207,message:null value in column "tc1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  insert into test values(2),(-2),(null);
+ ERROR:  node:datanode_1, backend_pid:381207, nodename:datanode_1,backend_pid:381207,message:null value in column "tc1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  set enable_oracle_compatible = off;
  select * from test where tc1 != -1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  select * from test where tc1 !=-1  order by tc1 asc;	-- error
  ERROR:  operator does not exist: integer !=- integer
***************
*** 2306,2356 ****
  select * from test where tc1 <> -1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  select * from test where tc1 <>-1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  set enable_oracle_compatible to on;
  select * from test where tc1 != -1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  select * from test where tc1 !=-1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  select * from test where tc1 <> -1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  select * from test where tc1 <>-1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  set enable_oracle_compatible = off;
  CREATE OPERATOR pg_oracle.!=- (
--- 2225,2257 ----
  select * from test where tc1 <> -1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  select * from test where tc1 <>-1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  set enable_oracle_compatible to on;
  select * from test where tc1 != -1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  select * from test where tc1 !=-1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  select * from test where tc1 <> -1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  select * from test where tc1 <>-1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  set enable_oracle_compatible = off;
  CREATE OPERATOR pg_oracle.!=- (
***************
*** 2362,2371 ****
  select * from test where tc1 != -1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  select * from test where tc1 !=-1  order by tc1 asc;
  ERROR:  argument of WHERE must be type boolean, not type integer
--- 2263,2269 ----
  select * from test where tc1 != -1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  select * from test where tc1 !=-1  order by tc1 asc;
  ERROR:  argument of WHERE must be type boolean, not type integer
***************
*** 2374,2424 ****
  select * from test where tc1 <> -1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  select * from test where tc1 <>-1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  set enable_oracle_compatible = on;
  select * from test where tc1 != -1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  select * from test where tc1 !=-1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  select * from test where tc1 <> -1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  select * from test where tc1 <>-1  order by tc1 asc;
   tc1 
  -----
!   -2
!    1
!    2
! (3 rows)
  
  set enable_oracle_compatible = on;
  drop operator pg_oracle.!=-(integer, integer);
--- 2272,2304 ----
  select * from test where tc1 <> -1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  select * from test where tc1 <>-1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  set enable_oracle_compatible = on;
  select * from test where tc1 != -1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  select * from test where tc1 !=-1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  select * from test where tc1 <> -1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  select * from test where tc1 <>-1  order by tc1 asc;
   tc1 
  -----
! (0 rows)
  
  set enable_oracle_compatible = on;
  drop operator pg_oracle.!=-(integer, integer);

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/audit.out"	2025-07-31 16:07:14.980068216 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/audit.out"	2025-07-31 16:38:12.411735205 +0800
***************
*** 42,2642 ****
  create materialized view sc_test.tbl_test0_mv as select * from sc_test.tbl_test0;
  -- create and check audit rules 
  \c audit_database audit_admin
! audit all;
! audit all by audit_user;
! audit all on default;
! audit all on tbl_test;
! audit all on tbl_test_v;
! ERROR:  "tbl_test_v" is not a table
! audit all on view tbl_test_v;
! audit all on tbl_test_mv;
! ERROR:  "tbl_test_mv" is not a table
! audit all on view tbl_test_mv;
! ERROR:  "tbl_test_mv" is not a view
! audit all on materialized view tbl_test_mv;
! audit all on tbl_test0;
! audit all on tbl_test0_v;
! ERROR:  "tbl_test0_v" is not a table
! audit all on view tbl_test0_v;
! audit all on tbl_test0_mv;
! ERROR:  "tbl_test0_mv" is not a table
! audit all on view tbl_test0_mv;
! ERROR:  "tbl_test0_mv" is not a view
! audit all on materialized view tbl_test0_mv;
! audit all on sc_test.tbl_test;
! audit all on sc_test.tbl_test_v;
! ERROR:  "tbl_test_v" is not a table
! audit all on view sc_test.tbl_test_v;
! audit all on sc_test.tbl_test_mv;
! ERROR:  "tbl_test_mv" is not a table
! audit all on view sc_test.tbl_test_mv;
! ERROR:  "tbl_test_mv" is not a view
! audit all on materialized view sc_test.tbl_test_mv;
! audit all on sc_test.tbl_test0;
! audit all on sc_test.tbl_test0_v;
! ERROR:  "tbl_test0_v" is not a table
! audit all on view sc_test.tbl_test0_v;
! audit all on sc_test.tbl_test0_mv;
! ERROR:  "tbl_test0_mv" is not a table
! audit all on view sc_test.tbl_test0_mv;
! ERROR:  "tbl_test0_mv" is not a view
! audit all on materialized view sc_test.tbl_test0_mv;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |              object_desc               | action_name | action_mode  | action_ison 
! -------------+--------------+----------------------------------------+-------------+--------------+-------------
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Update      | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Update      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Update      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Update      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Alter       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Audit       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Comment     | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Delete      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Grant       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Insert      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Lock        | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Rename      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Select      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Update      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Alter       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Audit       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Comment     | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Delete      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Grant       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Insert      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Lock        | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Rename      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Select      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Update      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Alter       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Audit       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Comment     | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Delete      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Grant       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Insert      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Rename      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Select      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Update      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Alter       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Audit       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Comment     | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Delete      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Grant       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Insert      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Rename      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Select      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Update      | Audit Always | t
! (104 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!    auditor   | user_name  |       action_name        | action_mode  | action_ison 
! -------------+------------+--------------------------+--------------+-------------
!  audit_admin | audit_user | Add Partitions           | Audit Always | t
!  audit_admin | audit_user | Alter Database           | Audit Always | t
!  audit_admin | audit_user | Alter Extension          | Audit Always | t
!  audit_admin | audit_user | Alter Function           | Audit Always | t
!  audit_admin | audit_user | Alter Index              | Audit Always | t
!  audit_admin | audit_user | Alter Materialized View  | Audit Always | t
!  audit_admin | audit_user | Alter Node               | Audit Always | t
!  audit_admin | audit_user | Alter Role               | Audit Always | t
!  audit_admin | audit_user | Alter Schema             | Audit Always | t
!  audit_admin | audit_user | Alter Sequence           | Audit Always | t
!  audit_admin | audit_user | Alter System             | Audit Always | t
!  audit_admin | audit_user | Alter Table              | Audit Always | t
!  audit_admin | audit_user | Alter Tablespace         | Audit Always | t
!  audit_admin | audit_user | Alter Trigger            | Audit Always | t
!  audit_admin | audit_user | Alter Type               | Audit Always | t
!  audit_admin | audit_user | Alter User               | Audit Always | t
!  audit_admin | audit_user | Alter View               | Audit Always | t
!  audit_admin | audit_user | Comment Table            | Audit Always | t
!  audit_admin | audit_user | Create Database          | Audit Always | t
!  audit_admin | audit_user | Create Extension         | Audit Always | t
!  audit_admin | audit_user | Create Function          | Audit Always | t
!  audit_admin | audit_user | Create Index             | Audit Always | t
!  audit_admin | audit_user | Create Materialized View | Audit Always | t
!  audit_admin | audit_user | Create Node              | Audit Always | t
!  audit_admin | audit_user | Create Node Group        | Audit Always | t
!  audit_admin | audit_user | Create Role              | Audit Always | t
!  audit_admin | audit_user | Create Schema            | Audit Always | t
!  audit_admin | audit_user | Create Sequence          | Audit Always | t
!  audit_admin | audit_user | Create Sharding Group    | Audit Always | t
!  audit_admin | audit_user | Create Table             | Audit Always | t
!  audit_admin | audit_user | Create Tablespace        | Audit Always | t
!  audit_admin | audit_user | Create Trigger           | Audit Always | t
!  audit_admin | audit_user | Create Type              | Audit Always | t
!  audit_admin | audit_user | Create User              | Audit Always | t
!  audit_admin | audit_user | Create View              | Audit Always | t
!  audit_admin | audit_user | Delete Table             | Audit Always | t
!  audit_admin | audit_user | Disable Trigger          | Audit Always | t
!  audit_admin | audit_user | Drop Database            | Audit Always | t
!  audit_admin | audit_user | Drop Extension           | Audit Always | t
!  audit_admin | audit_user | Drop Function            | Audit Always | t
!  audit_admin | audit_user | Drop Index               | Audit Always | t
!  audit_admin | audit_user | Drop Materialized View   | Audit Always | t
!  audit_admin | audit_user | Drop Node                | Audit Always | t
!  audit_admin | audit_user | Drop Node Group          | Audit Always | t
!  audit_admin | audit_user | Drop Role                | Audit Always | t
!  audit_admin | audit_user | Drop Schema              | Audit Always | t
!  audit_admin | audit_user | Drop Sequence            | Audit Always | t
!  audit_admin | audit_user | Drop Sharding in Group   | Audit Always | t
!  audit_admin | audit_user | Drop Table               | Audit Always | t
!  audit_admin | audit_user | Drop Tablespace          | Audit Always | t
!  audit_admin | audit_user | Drop Trigger             | Audit Always | t
!  audit_admin | audit_user | Drop Type                | Audit Always | t
!  audit_admin | audit_user | Drop User                | Audit Always | t
!  audit_admin | audit_user | Drop View                | Audit Always | t
!  audit_admin | audit_user | Enable Trigger           | Audit Always | t
!  audit_admin | audit_user | Grant Function           | Audit Always | t
!  audit_admin | audit_user | Grant Sequence           | Audit Always | t
!  audit_admin | audit_user | Grant Table              | Audit Always | t
!  audit_admin | audit_user | Grant Type               | Audit Always | t
!  audit_admin | audit_user | Insert Table             | Audit Always | t
!  audit_admin | audit_user | Lock Table               | Audit Always | t
!  audit_admin | audit_user | Select Sequence          | Audit Always | t
!  audit_admin | audit_user | Select Table             | Audit Always | t
!  audit_admin | audit_user | Set Role                 | Audit Always | t
!  audit_admin | audit_user | System Audit             | Audit Always | t
!  audit_admin | audit_user | System Grant             | Audit Always | t
!  audit_admin | audit_user | Truncate Table           | Audit Always | t
!  audit_admin | audit_user | Update Table             | Audit Always | t
! (68 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!    auditor   |       action_name        | action_mode  | action_ison 
! -------------+--------------------------+--------------+-------------
!  audit_admin | Add Partitions           | Audit Always | t
!  audit_admin | Alter Database           | Audit Always | t
!  audit_admin | Alter Extension          | Audit Always | t
!  audit_admin | Alter Function           | Audit Always | t
!  audit_admin | Alter Index              | Audit Always | t
!  audit_admin | Alter Materialized View  | Audit Always | t
!  audit_admin | Alter Node               | Audit Always | t
!  audit_admin | Alter Role               | Audit Always | t
!  audit_admin | Alter Schema             | Audit Always | t
!  audit_admin | Alter Sequence           | Audit Always | t
!  audit_admin | Alter System             | Audit Always | t
!  audit_admin | Alter Table              | Audit Always | t
!  audit_admin | Alter Tablespace         | Audit Always | t
!  audit_admin | Alter Trigger            | Audit Always | t
!  audit_admin | Alter Type               | Audit Always | t
!  audit_admin | Alter User               | Audit Always | t
!  audit_admin | Alter View               | Audit Always | t
!  audit_admin | Comment Table            | Audit Always | t
!  audit_admin | Create Database          | Audit Always | t
!  audit_admin | Create Extension         | Audit Always | t
!  audit_admin | Create Function          | Audit Always | t
!  audit_admin | Create Index             | Audit Always | t
!  audit_admin | Create Materialized View | Audit Always | t
!  audit_admin | Create Node              | Audit Always | t
!  audit_admin | Create Node Group        | Audit Always | t
!  audit_admin | Create Role              | Audit Always | t
!  audit_admin | Create Schema            | Audit Always | t
!  audit_admin | Create Sequence          | Audit Always | t
!  audit_admin | Create Sharding Group    | Audit Always | t
!  audit_admin | Create Table             | Audit Always | t
!  audit_admin | Create Tablespace        | Audit Always | t
!  audit_admin | Create Trigger           | Audit Always | t
!  audit_admin | Create Type              | Audit Always | t
!  audit_admin | Create User              | Audit Always | t
!  audit_admin | Create View              | Audit Always | t
!  audit_admin | Delete Table             | Audit Always | t
!  audit_admin | Disable Trigger          | Audit Always | t
!  audit_admin | Drop Database            | Audit Always | t
!  audit_admin | Drop Extension           | Audit Always | t
!  audit_admin | Drop Function            | Audit Always | t
!  audit_admin | Drop Index               | Audit Always | t
!  audit_admin | Drop Materialized View   | Audit Always | t
!  audit_admin | Drop Node                | Audit Always | t
!  audit_admin | Drop Node Group          | Audit Always | t
!  audit_admin | Drop Role                | Audit Always | t
!  audit_admin | Drop Schema              | Audit Always | t
!  audit_admin | Drop Sequence            | Audit Always | t
!  audit_admin | Drop Sharding in Group   | Audit Always | t
!  audit_admin | Drop Table               | Audit Always | t
!  audit_admin | Drop Tablespace          | Audit Always | t
!  audit_admin | Drop Trigger             | Audit Always | t
!  audit_admin | Drop Type                | Audit Always | t
!  audit_admin | Drop User                | Audit Always | t
!  audit_admin | Drop View                | Audit Always | t
!  audit_admin | Enable Trigger           | Audit Always | t
!  audit_admin | Grant Function           | Audit Always | t
!  audit_admin | Grant Sequence           | Audit Always | t
!  audit_admin | Grant Table              | Audit Always | t
!  audit_admin | Grant Type               | Audit Always | t
!  audit_admin | Insert Table             | Audit Always | t
!  audit_admin | Lock Table               | Audit Always | t
!  audit_admin | Select Sequence          | Audit Always | t
!  audit_admin | Select Table             | Audit Always | t
!  audit_admin | Set Role                 | Audit Always | t
!  audit_admin | System Audit             | Audit Always | t
!  audit_admin | System Grant             | Audit Always | t
!  audit_admin | Truncate Table           | Audit Always | t
!  audit_admin | Update Table             | Audit Always | t
! (68 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name | action_mode  | action_ison 
! -------------+-------------+--------------+-------------
!  audit_admin | Alter       | Audit Always | t
!  audit_admin | Audit       | Audit Always | t
!  audit_admin | Comment     | Audit Always | t
!  audit_admin | Delete      | Audit Always | t
!  audit_admin | Grant       | Audit Always | t
!  audit_admin | Insert      | Audit Always | t
!  audit_admin | Lock        | Audit Always | t
!  audit_admin | Rename      | Audit Always | t
!  audit_admin | Select      | Audit Always | t
!  audit_admin | Update      | Audit Always | t
! (10 rows)
! 
! noaudit all WHENEVER NOT SUCCESSFUL;
! noaudit all by audit_user WHENEVER NOT SUCCESSFUL;
! noaudit all on default WHENEVER NOT SUCCESSFUL;
! noaudit all on tbl_test WHENEVER NOT SUCCESSFUL;
! noaudit all on tbl_test_v WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_v" is not a table
! noaudit all on view tbl_test_v WHENEVER NOT SUCCESSFUL;
! noaudit all on tbl_test_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a table
! noaudit all on view tbl_test_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a view
! noaudit all on materialized view tbl_test_mv WHENEVER NOT SUCCESSFUL;
! noaudit all on tbl_test0 WHENEVER NOT SUCCESSFUL;
! noaudit all on tbl_test0_v WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_v" is not a table
! noaudit all on view tbl_test0_v WHENEVER NOT SUCCESSFUL;
! noaudit all on tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a table
! noaudit all on view tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a view
! noaudit all on materialized view tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! noaudit all on sc_test.tbl_test WHENEVER NOT SUCCESSFUL;
! noaudit all on sc_test.tbl_test_v WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_v" is not a table
! noaudit all on view sc_test.tbl_test_v WHENEVER NOT SUCCESSFUL;
! noaudit all on sc_test.tbl_test_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a table
! noaudit all on view sc_test.tbl_test_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a view
! noaudit all on materialized view sc_test.tbl_test_mv WHENEVER NOT SUCCESSFUL;
! noaudit all on sc_test.tbl_test0 WHENEVER NOT SUCCESSFUL;
! noaudit all on sc_test.tbl_test0_v WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_v" is not a table
! noaudit all on view sc_test.tbl_test0_v WHENEVER NOT SUCCESSFUL;
! noaudit all on sc_test.tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a table
! noaudit all on view sc_test.tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a view
! noaudit all on materialized view sc_test.tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |              object_desc               | action_name |    action_mode     | action_ison 
! -------------+--------------+----------------------------------------+-------------+--------------------+-------------
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Alter       | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Audit       | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Comment     | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Grant       | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Rename      | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Select      | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Update      | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Alter       | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Audit       | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Comment     | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Grant       | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Rename      | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Select      | Audit When Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Update      | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Alter       | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Audit       | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Comment     | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Grant       | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Rename      | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Select      | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Update      | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Alter       | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Audit       | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Comment     | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Grant       | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Rename      | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Select      | Audit When Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Update      | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Alter       | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Audit       | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Comment     | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Delete      | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Grant       | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Insert      | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Lock        | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Rename      | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Select      | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Update      | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Alter       | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Audit       | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Comment     | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Delete      | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Grant       | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Insert      | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Lock        | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Rename      | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Select      | Audit When Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Update      | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test                         | Alter       | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test                         | Audit       | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test                         | Comment     | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test                         | Delete      | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test                         | Grant       | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test                         | Insert      | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test                         | Lock        | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test                         | Rename      | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test                         | Select      | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test                         | Update      | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Alter       | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Audit       | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Comment     | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Delete      | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Grant       | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Insert      | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Lock        | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Rename      | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Select      | Audit When Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Update      | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Alter       | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Audit       | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Comment     | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Delete      | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Grant       | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Insert      | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Rename      | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Select      | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Update      | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Alter       | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Audit       | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Comment     | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Delete      | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Grant       | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Insert      | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Rename      | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Select      | Audit When Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Update      | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Alter       | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Audit       | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Comment     | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Delete      | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Grant       | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Insert      | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Rename      | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Select      | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Update      | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Alter       | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Audit       | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Comment     | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Delete      | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Grant       | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Insert      | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Rename      | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Select      | Audit When Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Update      | Audit When Success | t
! (104 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!    auditor   | user_name  |       action_name        |    action_mode     | action_ison 
! -------------+------------+--------------------------+--------------------+-------------
!  audit_admin | audit_user | Add Partitions           | Audit When Success | t
!  audit_admin | audit_user | Alter Database           | Audit When Success | t
!  audit_admin | audit_user | Alter Extension          | Audit When Success | t
!  audit_admin | audit_user | Alter Function           | Audit When Success | t
!  audit_admin | audit_user | Alter Index              | Audit When Success | t
!  audit_admin | audit_user | Alter Materialized View  | Audit When Success | t
!  audit_admin | audit_user | Alter Node               | Audit When Success | t
!  audit_admin | audit_user | Alter Role               | Audit When Success | t
!  audit_admin | audit_user | Alter Schema             | Audit When Success | t
!  audit_admin | audit_user | Alter Sequence           | Audit When Success | t
!  audit_admin | audit_user | Alter System             | Audit When Success | t
!  audit_admin | audit_user | Alter Table              | Audit When Success | t
!  audit_admin | audit_user | Alter Tablespace         | Audit When Success | t
!  audit_admin | audit_user | Alter Trigger            | Audit When Success | t
!  audit_admin | audit_user | Alter Type               | Audit When Success | t
!  audit_admin | audit_user | Alter User               | Audit When Success | t
!  audit_admin | audit_user | Alter View               | Audit When Success | t
!  audit_admin | audit_user | Comment Table            | Audit When Success | t
!  audit_admin | audit_user | Create Database          | Audit When Success | t
!  audit_admin | audit_user | Create Extension         | Audit When Success | t
!  audit_admin | audit_user | Create Function          | Audit When Success | t
!  audit_admin | audit_user | Create Index             | Audit When Success | t
!  audit_admin | audit_user | Create Materialized View | Audit When Success | t
!  audit_admin | audit_user | Create Node              | Audit When Success | t
!  audit_admin | audit_user | Create Node Group        | Audit When Success | t
!  audit_admin | audit_user | Create Role              | Audit When Success | t
!  audit_admin | audit_user | Create Schema            | Audit When Success | t
!  audit_admin | audit_user | Create Sequence          | Audit When Success | t
!  audit_admin | audit_user | Create Sharding Group    | Audit When Success | t
!  audit_admin | audit_user | Create Table             | Audit When Success | t
!  audit_admin | audit_user | Create Tablespace        | Audit When Success | t
!  audit_admin | audit_user | Create Trigger           | Audit When Success | t
!  audit_admin | audit_user | Create Type              | Audit When Success | t
!  audit_admin | audit_user | Create User              | Audit When Success | t
!  audit_admin | audit_user | Create View              | Audit When Success | t
!  audit_admin | audit_user | Delete Table             | Audit When Success | t
!  audit_admin | audit_user | Disable Trigger          | Audit When Success | t
!  audit_admin | audit_user | Drop Database            | Audit When Success | t
!  audit_admin | audit_user | Drop Extension           | Audit When Success | t
!  audit_admin | audit_user | Drop Function            | Audit When Success | t
!  audit_admin | audit_user | Drop Index               | Audit When Success | t
!  audit_admin | audit_user | Drop Materialized View   | Audit When Success | t
!  audit_admin | audit_user | Drop Node                | Audit When Success | t
!  audit_admin | audit_user | Drop Node Group          | Audit When Success | t
!  audit_admin | audit_user | Drop Role                | Audit When Success | t
!  audit_admin | audit_user | Drop Schema              | Audit When Success | t
!  audit_admin | audit_user | Drop Sequence            | Audit When Success | t
!  audit_admin | audit_user | Drop Sharding in Group   | Audit When Success | t
!  audit_admin | audit_user | Drop Table               | Audit When Success | t
!  audit_admin | audit_user | Drop Tablespace          | Audit When Success | t
!  audit_admin | audit_user | Drop Trigger             | Audit When Success | t
!  audit_admin | audit_user | Drop Type                | Audit When Success | t
!  audit_admin | audit_user | Drop User                | Audit When Success | t
!  audit_admin | audit_user | Drop View                | Audit When Success | t
!  audit_admin | audit_user | Enable Trigger           | Audit When Success | t
!  audit_admin | audit_user | Grant Function           | Audit When Success | t
!  audit_admin | audit_user | Grant Sequence           | Audit When Success | t
!  audit_admin | audit_user | Grant Table              | Audit When Success | t
!  audit_admin | audit_user | Grant Type               | Audit When Success | t
!  audit_admin | audit_user | Insert Table             | Audit When Success | t
!  audit_admin | audit_user | Lock Table               | Audit When Success | t
!  audit_admin | audit_user | Select Sequence          | Audit When Success | t
!  audit_admin | audit_user | Select Table             | Audit When Success | t
!  audit_admin | audit_user | Set Role                 | Audit When Success | t
!  audit_admin | audit_user | System Audit             | Audit When Success | t
!  audit_admin | audit_user | System Grant             | Audit When Success | t
!  audit_admin | audit_user | Truncate Table           | Audit When Success | t
!  audit_admin | audit_user | Update Table             | Audit When Success | t
! (68 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!    auditor   |       action_name        |    action_mode     | action_ison 
! -------------+--------------------------+--------------------+-------------
!  audit_admin | Add Partitions           | Audit When Success | t
!  audit_admin | Alter Database           | Audit When Success | t
!  audit_admin | Alter Extension          | Audit When Success | t
!  audit_admin | Alter Function           | Audit When Success | t
!  audit_admin | Alter Index              | Audit When Success | t
!  audit_admin | Alter Materialized View  | Audit When Success | t
!  audit_admin | Alter Node               | Audit When Success | t
!  audit_admin | Alter Role               | Audit When Success | t
!  audit_admin | Alter Schema             | Audit When Success | t
!  audit_admin | Alter Sequence           | Audit When Success | t
!  audit_admin | Alter System             | Audit When Success | t
!  audit_admin | Alter Table              | Audit When Success | t
!  audit_admin | Alter Tablespace         | Audit When Success | t
!  audit_admin | Alter Trigger            | Audit When Success | t
!  audit_admin | Alter Type               | Audit When Success | t
!  audit_admin | Alter User               | Audit When Success | t
!  audit_admin | Alter View               | Audit When Success | t
!  audit_admin | Comment Table            | Audit When Success | t
!  audit_admin | Create Database          | Audit When Success | t
!  audit_admin | Create Extension         | Audit When Success | t
!  audit_admin | Create Function          | Audit When Success | t
!  audit_admin | Create Index             | Audit When Success | t
!  audit_admin | Create Materialized View | Audit When Success | t
!  audit_admin | Create Node              | Audit When Success | t
!  audit_admin | Create Node Group        | Audit When Success | t
!  audit_admin | Create Role              | Audit When Success | t
!  audit_admin | Create Schema            | Audit When Success | t
!  audit_admin | Create Sequence          | Audit When Success | t
!  audit_admin | Create Sharding Group    | Audit When Success | t
!  audit_admin | Create Table             | Audit When Success | t
!  audit_admin | Create Tablespace        | Audit When Success | t
!  audit_admin | Create Trigger           | Audit When Success | t
!  audit_admin | Create Type              | Audit When Success | t
!  audit_admin | Create User              | Audit When Success | t
!  audit_admin | Create View              | Audit When Success | t
!  audit_admin | Delete Table             | Audit When Success | t
!  audit_admin | Disable Trigger          | Audit When Success | t
!  audit_admin | Drop Database            | Audit When Success | t
!  audit_admin | Drop Extension           | Audit When Success | t
!  audit_admin | Drop Function            | Audit When Success | t
!  audit_admin | Drop Index               | Audit When Success | t
!  audit_admin | Drop Materialized View   | Audit When Success | t
!  audit_admin | Drop Node                | Audit When Success | t
!  audit_admin | Drop Node Group          | Audit When Success | t
!  audit_admin | Drop Role                | Audit When Success | t
!  audit_admin | Drop Schema              | Audit When Success | t
!  audit_admin | Drop Sequence            | Audit When Success | t
!  audit_admin | Drop Sharding in Group   | Audit When Success | t
!  audit_admin | Drop Table               | Audit When Success | t
!  audit_admin | Drop Tablespace          | Audit When Success | t
!  audit_admin | Drop Trigger             | Audit When Success | t
!  audit_admin | Drop Type                | Audit When Success | t
!  audit_admin | Drop User                | Audit When Success | t
!  audit_admin | Drop View                | Audit When Success | t
!  audit_admin | Enable Trigger           | Audit When Success | t
!  audit_admin | Grant Function           | Audit When Success | t
!  audit_admin | Grant Sequence           | Audit When Success | t
!  audit_admin | Grant Table              | Audit When Success | t
!  audit_admin | Grant Type               | Audit When Success | t
!  audit_admin | Insert Table             | Audit When Success | t
!  audit_admin | Lock Table               | Audit When Success | t
!  audit_admin | Select Sequence          | Audit When Success | t
!  audit_admin | Select Table             | Audit When Success | t
!  audit_admin | Set Role                 | Audit When Success | t
!  audit_admin | System Audit             | Audit When Success | t
!  audit_admin | System Grant             | Audit When Success | t
!  audit_admin | Truncate Table           | Audit When Success | t
!  audit_admin | Update Table             | Audit When Success | t
! (68 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name |    action_mode     | action_ison 
! -------------+-------------+--------------------+-------------
!  audit_admin | Alter       | Audit When Success | t
!  audit_admin | Audit       | Audit When Success | t
!  audit_admin | Comment     | Audit When Success | t
!  audit_admin | Delete      | Audit When Success | t
!  audit_admin | Grant       | Audit When Success | t
!  audit_admin | Insert      | Audit When Success | t
!  audit_admin | Lock        | Audit When Success | t
!  audit_admin | Rename      | Audit When Success | t
!  audit_admin | Select      | Audit When Success | t
!  audit_admin | Update      | Audit When Success | t
! (10 rows)
! 
! noaudit all WHENEVER SUCCESSFUL;
! noaudit all by audit_user WHENEVER SUCCESSFUL;
! noaudit all on default WHENEVER SUCCESSFUL;
! noaudit all on tbl_test WHENEVER SUCCESSFUL;
! noaudit all on tbl_test_v WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_v" is not a table
! noaudit all on view tbl_test_v WHENEVER SUCCESSFUL;
! noaudit all on tbl_test_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a table
! noaudit all on view tbl_test_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a view
! noaudit all on materialized view tbl_test_mv WHENEVER SUCCESSFUL;
! noaudit all on tbl_test0 WHENEVER SUCCESSFUL;
! noaudit all on tbl_test0_v WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_v" is not a table
! noaudit all on view tbl_test0_v WHENEVER SUCCESSFUL;
! noaudit all on tbl_test0_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a table
! noaudit all on view tbl_test0_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a view
! noaudit all on materialized view tbl_test0_mv WHENEVER SUCCESSFUL;
! noaudit all on sc_test.tbl_test WHENEVER SUCCESSFUL;
! noaudit all on sc_test.tbl_test_v WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_v" is not a table
! noaudit all on view sc_test.tbl_test_v WHENEVER SUCCESSFUL;
! noaudit all on sc_test.tbl_test_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a table
! noaudit all on view sc_test.tbl_test_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a view
! noaudit all on materialized view sc_test.tbl_test_mv WHENEVER SUCCESSFUL;
! noaudit all on sc_test.tbl_test0 WHENEVER SUCCESSFUL;
! noaudit all on sc_test.tbl_test0_v WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_v" is not a table
! noaudit all on view sc_test.tbl_test0_v WHENEVER SUCCESSFUL;
! noaudit all on sc_test.tbl_test0_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a table
! noaudit all on view sc_test.tbl_test0_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a view
! noaudit all on materialized view sc_test.tbl_test0_mv WHENEVER SUCCESSFUL;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |              object_desc               | action_name |    action_mode     | action_ison 
! -------------+--------------+----------------------------------------+-------------+--------------------+-------------
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Alter       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Audit       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Comment     | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Grant       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Rename      | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Select      | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Update      | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Alter       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Audit       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Comment     | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Grant       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Rename      | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Select      | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Update      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Alter       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Audit       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Comment     | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Grant       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Rename      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Select      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Update      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Alter       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Audit       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Comment     | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Grant       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Rename      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Select      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Update      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Alter       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Audit       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Comment     | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Delete      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Grant       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Insert      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Lock        | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Rename      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Select      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Update      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Alter       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Audit       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Comment     | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Delete      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Grant       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Insert      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Lock        | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Rename      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Select      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Update      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Alter       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Audit       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Comment     | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Delete      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Grant       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Insert      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Lock        | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Rename      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Select      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Update      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Alter       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Audit       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Comment     | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Delete      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Grant       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Insert      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Lock        | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Rename      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Select      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Update      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Alter       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Audit       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Comment     | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Delete      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Grant       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Insert      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Rename      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Select      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Update      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Alter       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Audit       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Comment     | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Delete      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Grant       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Insert      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Rename      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Select      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Update      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Alter       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Audit       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Comment     | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Delete      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Grant       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Insert      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Rename      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Select      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Update      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Alter       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Audit       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Comment     | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Delete      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Grant       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Insert      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Rename      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Select      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Update      | Audit When Success | f
! (104 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!    auditor   | user_name  |       action_name        |    action_mode     | action_ison 
! -------------+------------+--------------------------+--------------------+-------------
!  audit_admin | audit_user | Add Partitions           | Audit When Success | f
!  audit_admin | audit_user | Alter Database           | Audit When Success | f
!  audit_admin | audit_user | Alter Extension          | Audit When Success | f
!  audit_admin | audit_user | Alter Function           | Audit When Success | f
!  audit_admin | audit_user | Alter Index              | Audit When Success | f
!  audit_admin | audit_user | Alter Materialized View  | Audit When Success | f
!  audit_admin | audit_user | Alter Node               | Audit When Success | f
!  audit_admin | audit_user | Alter Role               | Audit When Success | f
!  audit_admin | audit_user | Alter Schema             | Audit When Success | f
!  audit_admin | audit_user | Alter Sequence           | Audit When Success | f
!  audit_admin | audit_user | Alter System             | Audit When Success | f
!  audit_admin | audit_user | Alter Table              | Audit When Success | f
!  audit_admin | audit_user | Alter Tablespace         | Audit When Success | f
!  audit_admin | audit_user | Alter Trigger            | Audit When Success | f
!  audit_admin | audit_user | Alter Type               | Audit When Success | f
!  audit_admin | audit_user | Alter User               | Audit When Success | f
!  audit_admin | audit_user | Alter View               | Audit When Success | f
!  audit_admin | audit_user | Comment Table            | Audit When Success | f
!  audit_admin | audit_user | Create Database          | Audit When Success | f
!  audit_admin | audit_user | Create Extension         | Audit When Success | f
!  audit_admin | audit_user | Create Function          | Audit When Success | f
!  audit_admin | audit_user | Create Index             | Audit When Success | f
!  audit_admin | audit_user | Create Materialized View | Audit When Success | f
!  audit_admin | audit_user | Create Node              | Audit When Success | f
!  audit_admin | audit_user | Create Node Group        | Audit When Success | f
!  audit_admin | audit_user | Create Role              | Audit When Success | f
!  audit_admin | audit_user | Create Schema            | Audit When Success | f
!  audit_admin | audit_user | Create Sequence          | Audit When Success | f
!  audit_admin | audit_user | Create Sharding Group    | Audit When Success | f
!  audit_admin | audit_user | Create Table             | Audit When Success | f
!  audit_admin | audit_user | Create Tablespace        | Audit When Success | f
!  audit_admin | audit_user | Create Trigger           | Audit When Success | f
!  audit_admin | audit_user | Create Type              | Audit When Success | f
!  audit_admin | audit_user | Create User              | Audit When Success | f
!  audit_admin | audit_user | Create View              | Audit When Success | f
!  audit_admin | audit_user | Delete Table             | Audit When Success | f
!  audit_admin | audit_user | Disable Trigger          | Audit When Success | f
!  audit_admin | audit_user | Drop Database            | Audit When Success | f
!  audit_admin | audit_user | Drop Extension           | Audit When Success | f
!  audit_admin | audit_user | Drop Function            | Audit When Success | f
!  audit_admin | audit_user | Drop Index               | Audit When Success | f
!  audit_admin | audit_user | Drop Materialized View   | Audit When Success | f
!  audit_admin | audit_user | Drop Node                | Audit When Success | f
!  audit_admin | audit_user | Drop Node Group          | Audit When Success | f
!  audit_admin | audit_user | Drop Role                | Audit When Success | f
!  audit_admin | audit_user | Drop Schema              | Audit When Success | f
!  audit_admin | audit_user | Drop Sequence            | Audit When Success | f
!  audit_admin | audit_user | Drop Sharding in Group   | Audit When Success | f
!  audit_admin | audit_user | Drop Table               | Audit When Success | f
!  audit_admin | audit_user | Drop Tablespace          | Audit When Success | f
!  audit_admin | audit_user | Drop Trigger             | Audit When Success | f
!  audit_admin | audit_user | Drop Type                | Audit When Success | f
!  audit_admin | audit_user | Drop User                | Audit When Success | f
!  audit_admin | audit_user | Drop View                | Audit When Success | f
!  audit_admin | audit_user | Enable Trigger           | Audit When Success | f
!  audit_admin | audit_user | Grant Function           | Audit When Success | f
!  audit_admin | audit_user | Grant Sequence           | Audit When Success | f
!  audit_admin | audit_user | Grant Table              | Audit When Success | f
!  audit_admin | audit_user | Grant Type               | Audit When Success | f
!  audit_admin | audit_user | Insert Table             | Audit When Success | f
!  audit_admin | audit_user | Lock Table               | Audit When Success | f
!  audit_admin | audit_user | Select Sequence          | Audit When Success | f
!  audit_admin | audit_user | Select Table             | Audit When Success | f
!  audit_admin | audit_user | Set Role                 | Audit When Success | f
!  audit_admin | audit_user | System Audit             | Audit When Success | f
!  audit_admin | audit_user | System Grant             | Audit When Success | f
!  audit_admin | audit_user | Truncate Table           | Audit When Success | f
!  audit_admin | audit_user | Update Table             | Audit When Success | f
! (68 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!    auditor   |       action_name        |    action_mode     | action_ison 
! -------------+--------------------------+--------------------+-------------
!  audit_admin | Add Partitions           | Audit When Success | f
!  audit_admin | Alter Database           | Audit When Success | f
!  audit_admin | Alter Extension          | Audit When Success | f
!  audit_admin | Alter Function           | Audit When Success | f
!  audit_admin | Alter Index              | Audit When Success | f
!  audit_admin | Alter Materialized View  | Audit When Success | f
!  audit_admin | Alter Node               | Audit When Success | f
!  audit_admin | Alter Role               | Audit When Success | f
!  audit_admin | Alter Schema             | Audit When Success | f
!  audit_admin | Alter Sequence           | Audit When Success | f
!  audit_admin | Alter System             | Audit When Success | f
!  audit_admin | Alter Table              | Audit When Success | f
!  audit_admin | Alter Tablespace         | Audit When Success | f
!  audit_admin | Alter Trigger            | Audit When Success | f
!  audit_admin | Alter Type               | Audit When Success | f
!  audit_admin | Alter User               | Audit When Success | f
!  audit_admin | Alter View               | Audit When Success | f
!  audit_admin | Comment Table            | Audit When Success | f
!  audit_admin | Create Database          | Audit When Success | f
!  audit_admin | Create Extension         | Audit When Success | f
!  audit_admin | Create Function          | Audit When Success | f
!  audit_admin | Create Index             | Audit When Success | f
!  audit_admin | Create Materialized View | Audit When Success | f
!  audit_admin | Create Node              | Audit When Success | f
!  audit_admin | Create Node Group        | Audit When Success | f
!  audit_admin | Create Role              | Audit When Success | f
!  audit_admin | Create Schema            | Audit When Success | f
!  audit_admin | Create Sequence          | Audit When Success | f
!  audit_admin | Create Sharding Group    | Audit When Success | f
!  audit_admin | Create Table             | Audit When Success | f
!  audit_admin | Create Tablespace        | Audit When Success | f
!  audit_admin | Create Trigger           | Audit When Success | f
!  audit_admin | Create Type              | Audit When Success | f
!  audit_admin | Create User              | Audit When Success | f
!  audit_admin | Create View              | Audit When Success | f
!  audit_admin | Delete Table             | Audit When Success | f
!  audit_admin | Disable Trigger          | Audit When Success | f
!  audit_admin | Drop Database            | Audit When Success | f
!  audit_admin | Drop Extension           | Audit When Success | f
!  audit_admin | Drop Function            | Audit When Success | f
!  audit_admin | Drop Index               | Audit When Success | f
!  audit_admin | Drop Materialized View   | Audit When Success | f
!  audit_admin | Drop Node                | Audit When Success | f
!  audit_admin | Drop Node Group          | Audit When Success | f
!  audit_admin | Drop Role                | Audit When Success | f
!  audit_admin | Drop Schema              | Audit When Success | f
!  audit_admin | Drop Sequence            | Audit When Success | f
!  audit_admin | Drop Sharding in Group   | Audit When Success | f
!  audit_admin | Drop Table               | Audit When Success | f
!  audit_admin | Drop Tablespace          | Audit When Success | f
!  audit_admin | Drop Trigger             | Audit When Success | f
!  audit_admin | Drop Type                | Audit When Success | f
!  audit_admin | Drop User                | Audit When Success | f
!  audit_admin | Drop View                | Audit When Success | f
!  audit_admin | Enable Trigger           | Audit When Success | f
!  audit_admin | Grant Function           | Audit When Success | f
!  audit_admin | Grant Sequence           | Audit When Success | f
!  audit_admin | Grant Table              | Audit When Success | f
!  audit_admin | Grant Type               | Audit When Success | f
!  audit_admin | Insert Table             | Audit When Success | f
!  audit_admin | Lock Table               | Audit When Success | f
!  audit_admin | Select Sequence          | Audit When Success | f
!  audit_admin | Select Table             | Audit When Success | f
!  audit_admin | Set Role                 | Audit When Success | f
!  audit_admin | System Audit             | Audit When Success | f
!  audit_admin | System Grant             | Audit When Success | f
!  audit_admin | Truncate Table           | Audit When Success | f
!  audit_admin | Update Table             | Audit When Success | f
! (68 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name |    action_mode     | action_ison 
! -------------+-------------+--------------------+-------------
!  audit_admin | Alter       | Audit When Success | f
!  audit_admin | Audit       | Audit When Success | f
!  audit_admin | Comment     | Audit When Success | f
!  audit_admin | Delete      | Audit When Success | f
!  audit_admin | Grant       | Audit When Success | f
!  audit_admin | Insert      | Audit When Success | f
!  audit_admin | Lock        | Audit When Success | f
!  audit_admin | Rename      | Audit When Success | f
!  audit_admin | Select      | Audit When Success | f
!  audit_admin | Update      | Audit When Success | f
! (10 rows)
! 
! noaudit all;
! noaudit all by audit_user;
! noaudit all on default;
! noaudit all on tbl_test;
! noaudit all on tbl_test_v;
! ERROR:  "tbl_test_v" is not a table
! noaudit all on view tbl_test_v;
! noaudit all on tbl_test_mv;
! ERROR:  "tbl_test_mv" is not a table
! noaudit all on view tbl_test_mv;
! ERROR:  "tbl_test_mv" is not a view
! noaudit all on materialized view tbl_test_mv;
! noaudit all on tbl_test0;
! noaudit all on tbl_test0_v;
! ERROR:  "tbl_test0_v" is not a table
! noaudit all on view tbl_test0_v;
! noaudit all on tbl_test0_mv;
! ERROR:  "tbl_test0_mv" is not a table
! noaudit all on view tbl_test0_mv;
! ERROR:  "tbl_test0_mv" is not a view
! noaudit all on materialized view tbl_test0_mv;
! noaudit all on sc_test.tbl_test;
! noaudit all on sc_test.tbl_test_v;
! ERROR:  "tbl_test_v" is not a table
! noaudit all on view sc_test.tbl_test_v;
! noaudit all on sc_test.tbl_test_mv;
! ERROR:  "tbl_test_mv" is not a table
! noaudit all on view sc_test.tbl_test_mv;
! ERROR:  "tbl_test_mv" is not a view
! noaudit all on materialized view sc_test.tbl_test_mv;
! noaudit all on sc_test.tbl_test0;
! noaudit all on sc_test.tbl_test0_v;
! ERROR:  "tbl_test0_v" is not a table
! noaudit all on view sc_test.tbl_test0_v;
! noaudit all on sc_test.tbl_test0_mv;
! ERROR:  "tbl_test0_mv" is not a table
! noaudit all on view sc_test.tbl_test0_mv;
! ERROR:  "tbl_test0_mv" is not a view
! noaudit all on materialized view sc_test.tbl_test0_mv;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |              object_desc               | action_name |    action_mode     | action_ison 
! -------------+--------------+----------------------------------------+-------------+--------------------+-------------
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Alter       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Audit       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Comment     | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Grant       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Rename      | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Select      | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Update      | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Alter       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Audit       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Comment     | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Grant       | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Rename      | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Select      | Audit When Success | f
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Update      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Alter       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Audit       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Comment     | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Grant       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Rename      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Select      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Update      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Alter       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Audit       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Comment     | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Grant       | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Rename      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Select      | Audit When Success | f
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Update      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Alter       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Audit       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Comment     | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Delete      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Grant       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Insert      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Lock        | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Rename      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Select      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Update      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Alter       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Audit       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Comment     | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Delete      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Grant       | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Insert      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Lock        | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Rename      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Select      | Audit When Success | f
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Update      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Alter       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Audit       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Comment     | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Delete      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Grant       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Insert      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Lock        | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Rename      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Select      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test                         | Update      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Alter       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Audit       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Comment     | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Delete      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Grant       | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Insert      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Lock        | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Rename      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Select      | Audit When Success | f
!  audit_admin | pg_class     | table tbl_test0                        | Update      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Alter       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Audit       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Comment     | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Delete      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Grant       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Insert      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Rename      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Select      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Update      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Alter       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Audit       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Comment     | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Delete      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Grant       | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Insert      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Rename      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Select      | Audit When Success | f
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Update      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Alter       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Audit       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Comment     | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Delete      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Grant       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Insert      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Rename      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Select      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test0_v                       | Update      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Alter       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Audit       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Comment     | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Delete      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Grant       | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Insert      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Rename      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Select      | Audit When Success | f
!  audit_admin | pg_class     | view tbl_test_v                        | Update      | Audit When Success | f
! (104 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!    auditor   | user_name  |       action_name        |    action_mode     | action_ison 
! -------------+------------+--------------------------+--------------------+-------------
!  audit_admin | audit_user | Add Partitions           | Audit When Success | f
!  audit_admin | audit_user | Alter Database           | Audit When Success | f
!  audit_admin | audit_user | Alter Extension          | Audit When Success | f
!  audit_admin | audit_user | Alter Function           | Audit When Success | f
!  audit_admin | audit_user | Alter Index              | Audit When Success | f
!  audit_admin | audit_user | Alter Materialized View  | Audit When Success | f
!  audit_admin | audit_user | Alter Node               | Audit When Success | f
!  audit_admin | audit_user | Alter Role               | Audit When Success | f
!  audit_admin | audit_user | Alter Schema             | Audit When Success | f
!  audit_admin | audit_user | Alter Sequence           | Audit When Success | f
!  audit_admin | audit_user | Alter System             | Audit When Success | f
!  audit_admin | audit_user | Alter Table              | Audit When Success | f
!  audit_admin | audit_user | Alter Tablespace         | Audit When Success | f
!  audit_admin | audit_user | Alter Trigger            | Audit When Success | f
!  audit_admin | audit_user | Alter Type               | Audit When Success | f
!  audit_admin | audit_user | Alter User               | Audit When Success | f
!  audit_admin | audit_user | Alter View               | Audit When Success | f
!  audit_admin | audit_user | Comment Table            | Audit When Success | f
!  audit_admin | audit_user | Create Database          | Audit When Success | f
!  audit_admin | audit_user | Create Extension         | Audit When Success | f
!  audit_admin | audit_user | Create Function          | Audit When Success | f
!  audit_admin | audit_user | Create Index             | Audit When Success | f
!  audit_admin | audit_user | Create Materialized View | Audit When Success | f
!  audit_admin | audit_user | Create Node              | Audit When Success | f
!  audit_admin | audit_user | Create Node Group        | Audit When Success | f
!  audit_admin | audit_user | Create Role              | Audit When Success | f
!  audit_admin | audit_user | Create Schema            | Audit When Success | f
!  audit_admin | audit_user | Create Sequence          | Audit When Success | f
!  audit_admin | audit_user | Create Sharding Group    | Audit When Success | f
!  audit_admin | audit_user | Create Table             | Audit When Success | f
!  audit_admin | audit_user | Create Tablespace        | Audit When Success | f
!  audit_admin | audit_user | Create Trigger           | Audit When Success | f
!  audit_admin | audit_user | Create Type              | Audit When Success | f
!  audit_admin | audit_user | Create User              | Audit When Success | f
!  audit_admin | audit_user | Create View              | Audit When Success | f
!  audit_admin | audit_user | Delete Table             | Audit When Success | f
!  audit_admin | audit_user | Disable Trigger          | Audit When Success | f
!  audit_admin | audit_user | Drop Database            | Audit When Success | f
!  audit_admin | audit_user | Drop Extension           | Audit When Success | f
!  audit_admin | audit_user | Drop Function            | Audit When Success | f
!  audit_admin | audit_user | Drop Index               | Audit When Success | f
!  audit_admin | audit_user | Drop Materialized View   | Audit When Success | f
!  audit_admin | audit_user | Drop Node                | Audit When Success | f
!  audit_admin | audit_user | Drop Node Group          | Audit When Success | f
!  audit_admin | audit_user | Drop Role                | Audit When Success | f
!  audit_admin | audit_user | Drop Schema              | Audit When Success | f
!  audit_admin | audit_user | Drop Sequence            | Audit When Success | f
!  audit_admin | audit_user | Drop Sharding in Group   | Audit When Success | f
!  audit_admin | audit_user | Drop Table               | Audit When Success | f
!  audit_admin | audit_user | Drop Tablespace          | Audit When Success | f
!  audit_admin | audit_user | Drop Trigger             | Audit When Success | f
!  audit_admin | audit_user | Drop Type                | Audit When Success | f
!  audit_admin | audit_user | Drop User                | Audit When Success | f
!  audit_admin | audit_user | Drop View                | Audit When Success | f
!  audit_admin | audit_user | Enable Trigger           | Audit When Success | f
!  audit_admin | audit_user | Grant Function           | Audit When Success | f
!  audit_admin | audit_user | Grant Sequence           | Audit When Success | f
!  audit_admin | audit_user | Grant Table              | Audit When Success | f
!  audit_admin | audit_user | Grant Type               | Audit When Success | f
!  audit_admin | audit_user | Insert Table             | Audit When Success | f
!  audit_admin | audit_user | Lock Table               | Audit When Success | f
!  audit_admin | audit_user | Select Sequence          | Audit When Success | f
!  audit_admin | audit_user | Select Table             | Audit When Success | f
!  audit_admin | audit_user | Set Role                 | Audit When Success | f
!  audit_admin | audit_user | System Audit             | Audit When Success | f
!  audit_admin | audit_user | System Grant             | Audit When Success | f
!  audit_admin | audit_user | Truncate Table           | Audit When Success | f
!  audit_admin | audit_user | Update Table             | Audit When Success | f
! (68 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!    auditor   |       action_name        |    action_mode     | action_ison 
! -------------+--------------------------+--------------------+-------------
!  audit_admin | Add Partitions           | Audit When Success | f
!  audit_admin | Alter Database           | Audit When Success | f
!  audit_admin | Alter Extension          | Audit When Success | f
!  audit_admin | Alter Function           | Audit When Success | f
!  audit_admin | Alter Index              | Audit When Success | f
!  audit_admin | Alter Materialized View  | Audit When Success | f
!  audit_admin | Alter Node               | Audit When Success | f
!  audit_admin | Alter Role               | Audit When Success | f
!  audit_admin | Alter Schema             | Audit When Success | f
!  audit_admin | Alter Sequence           | Audit When Success | f
!  audit_admin | Alter System             | Audit When Success | f
!  audit_admin | Alter Table              | Audit When Success | f
!  audit_admin | Alter Tablespace         | Audit When Success | f
!  audit_admin | Alter Trigger            | Audit When Success | f
!  audit_admin | Alter Type               | Audit When Success | f
!  audit_admin | Alter User               | Audit When Success | f
!  audit_admin | Alter View               | Audit When Success | f
!  audit_admin | Comment Table            | Audit When Success | f
!  audit_admin | Create Database          | Audit When Success | f
!  audit_admin | Create Extension         | Audit When Success | f
!  audit_admin | Create Function          | Audit When Success | f
!  audit_admin | Create Index             | Audit When Success | f
!  audit_admin | Create Materialized View | Audit When Success | f
!  audit_admin | Create Node              | Audit When Success | f
!  audit_admin | Create Node Group        | Audit When Success | f
!  audit_admin | Create Role              | Audit When Success | f
!  audit_admin | Create Schema            | Audit When Success | f
!  audit_admin | Create Sequence          | Audit When Success | f
!  audit_admin | Create Sharding Group    | Audit When Success | f
!  audit_admin | Create Table             | Audit When Success | f
!  audit_admin | Create Tablespace        | Audit When Success | f
!  audit_admin | Create Trigger           | Audit When Success | f
!  audit_admin | Create Type              | Audit When Success | f
!  audit_admin | Create User              | Audit When Success | f
!  audit_admin | Create View              | Audit When Success | f
!  audit_admin | Delete Table             | Audit When Success | f
!  audit_admin | Disable Trigger          | Audit When Success | f
!  audit_admin | Drop Database            | Audit When Success | f
!  audit_admin | Drop Extension           | Audit When Success | f
!  audit_admin | Drop Function            | Audit When Success | f
!  audit_admin | Drop Index               | Audit When Success | f
!  audit_admin | Drop Materialized View   | Audit When Success | f
!  audit_admin | Drop Node                | Audit When Success | f
!  audit_admin | Drop Node Group          | Audit When Success | f
!  audit_admin | Drop Role                | Audit When Success | f
!  audit_admin | Drop Schema              | Audit When Success | f
!  audit_admin | Drop Sequence            | Audit When Success | f
!  audit_admin | Drop Sharding in Group   | Audit When Success | f
!  audit_admin | Drop Table               | Audit When Success | f
!  audit_admin | Drop Tablespace          | Audit When Success | f
!  audit_admin | Drop Trigger             | Audit When Success | f
!  audit_admin | Drop Type                | Audit When Success | f
!  audit_admin | Drop User                | Audit When Success | f
!  audit_admin | Drop View                | Audit When Success | f
!  audit_admin | Enable Trigger           | Audit When Success | f
!  audit_admin | Grant Function           | Audit When Success | f
!  audit_admin | Grant Sequence           | Audit When Success | f
!  audit_admin | Grant Table              | Audit When Success | f
!  audit_admin | Grant Type               | Audit When Success | f
!  audit_admin | Insert Table             | Audit When Success | f
!  audit_admin | Lock Table               | Audit When Success | f
!  audit_admin | Select Sequence          | Audit When Success | f
!  audit_admin | Select Table             | Audit When Success | f
!  audit_admin | Set Role                 | Audit When Success | f
!  audit_admin | System Audit             | Audit When Success | f
!  audit_admin | System Grant             | Audit When Success | f
!  audit_admin | Truncate Table           | Audit When Success | f
!  audit_admin | Update Table             | Audit When Success | f
! (68 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name |    action_mode     | action_ison 
! -------------+-------------+--------------------+-------------
!  audit_admin | Alter       | Audit When Success | f
!  audit_admin | Audit       | Audit When Success | f
!  audit_admin | Comment     | Audit When Success | f
!  audit_admin | Delete      | Audit When Success | f
!  audit_admin | Grant       | Audit When Success | f
!  audit_admin | Insert      | Audit When Success | f
!  audit_admin | Lock        | Audit When Success | f
!  audit_admin | Rename      | Audit When Success | f
!  audit_admin | Select      | Audit When Success | f
!  audit_admin | Update      | Audit When Success | f
! (10 rows)
! 
! audit all WHENEVER NOT SUCCESSFUL;
! audit all by audit_user WHENEVER NOT SUCCESSFUL;
! audit all on default WHENEVER NOT SUCCESSFUL;
! audit all on tbl_test WHENEVER NOT SUCCESSFUL;
! audit all on tbl_test_v WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_v" is not a table
! audit all on view tbl_test_v WHENEVER NOT SUCCESSFUL;
! audit all on tbl_test_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a table
! audit all on view tbl_test_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a view
! audit all on materialized view tbl_test_mv WHENEVER NOT SUCCESSFUL;
! audit all on tbl_test0 WHENEVER NOT SUCCESSFUL;
! audit all on tbl_test0_v WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_v" is not a table
! audit all on view tbl_test0_v WHENEVER NOT SUCCESSFUL;
! audit all on tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a table
! audit all on view tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a view
! audit all on materialized view tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! audit all on sc_test.tbl_test WHENEVER NOT SUCCESSFUL;
! audit all on sc_test.tbl_test_v WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_v" is not a table
! audit all on view sc_test.tbl_test_v WHENEVER NOT SUCCESSFUL;
! audit all on sc_test.tbl_test_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a table
! audit all on view sc_test.tbl_test_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a view
! audit all on materialized view sc_test.tbl_test_mv WHENEVER NOT SUCCESSFUL;
! audit all on sc_test.tbl_test0 WHENEVER NOT SUCCESSFUL;
! audit all on sc_test.tbl_test0_v WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_v" is not a table
! audit all on view sc_test.tbl_test0_v WHENEVER NOT SUCCESSFUL;
! audit all on sc_test.tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a table
! audit all on view sc_test.tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a view
! audit all on materialized view sc_test.tbl_test0_mv WHENEVER NOT SUCCESSFUL;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |              object_desc               | action_name |      action_mode       | action_ison 
! -------------+--------------+----------------------------------------+-------------+------------------------+-------------
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Update      | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Update      | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Update      | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Update      | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Delete      | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Insert      | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Lock        | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Update      | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Delete      | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Insert      | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Lock        | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Update      | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test                         | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test                         | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test                         | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test                         | Delete      | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test                         | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test                         | Insert      | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test                         | Lock        | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test                         | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test                         | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test                         | Update      | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Delete      | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Insert      | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Lock        | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | table tbl_test0                        | Update      | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Delete      | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Insert      | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Update      | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Delete      | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Insert      | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Update      | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Delete      | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Insert      | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Update      | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Alter       | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Audit       | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Comment     | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Delete      | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Grant       | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Insert      | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Rename      | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Select      | Audit When Not Success | t
!  audit_admin | pg_class     | view tbl_test_v                        | Update      | Audit When Not Success | t
! (104 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!    auditor   | user_name  |       action_name        |      action_mode       | action_ison 
! -------------+------------+--------------------------+------------------------+-------------
!  audit_admin | audit_user | Add Partitions           | Audit When Not Success | t
!  audit_admin | audit_user | Alter Database           | Audit When Not Success | t
!  audit_admin | audit_user | Alter Extension          | Audit When Not Success | t
!  audit_admin | audit_user | Alter Function           | Audit When Not Success | t
!  audit_admin | audit_user | Alter Index              | Audit When Not Success | t
!  audit_admin | audit_user | Alter Materialized View  | Audit When Not Success | t
!  audit_admin | audit_user | Alter Node               | Audit When Not Success | t
!  audit_admin | audit_user | Alter Role               | Audit When Not Success | t
!  audit_admin | audit_user | Alter Schema             | Audit When Not Success | t
!  audit_admin | audit_user | Alter Sequence           | Audit When Not Success | t
!  audit_admin | audit_user | Alter System             | Audit When Not Success | t
!  audit_admin | audit_user | Alter Table              | Audit When Not Success | t
!  audit_admin | audit_user | Alter Tablespace         | Audit When Not Success | t
!  audit_admin | audit_user | Alter Trigger            | Audit When Not Success | t
!  audit_admin | audit_user | Alter Type               | Audit When Not Success | t
!  audit_admin | audit_user | Alter User               | Audit When Not Success | t
!  audit_admin | audit_user | Alter View               | Audit When Not Success | t
!  audit_admin | audit_user | Comment Table            | Audit When Not Success | t
!  audit_admin | audit_user | Create Database          | Audit When Not Success | t
!  audit_admin | audit_user | Create Extension         | Audit When Not Success | t
!  audit_admin | audit_user | Create Function          | Audit When Not Success | t
!  audit_admin | audit_user | Create Index             | Audit When Not Success | t
!  audit_admin | audit_user | Create Materialized View | Audit When Not Success | t
!  audit_admin | audit_user | Create Node              | Audit When Not Success | t
!  audit_admin | audit_user | Create Node Group        | Audit When Not Success | t
!  audit_admin | audit_user | Create Role              | Audit When Not Success | t
!  audit_admin | audit_user | Create Schema            | Audit When Not Success | t
!  audit_admin | audit_user | Create Sequence          | Audit When Not Success | t
!  audit_admin | audit_user | Create Sharding Group    | Audit When Not Success | t
!  audit_admin | audit_user | Create Table             | Audit When Not Success | t
!  audit_admin | audit_user | Create Tablespace        | Audit When Not Success | t
!  audit_admin | audit_user | Create Trigger           | Audit When Not Success | t
!  audit_admin | audit_user | Create Type              | Audit When Not Success | t
!  audit_admin | audit_user | Create User              | Audit When Not Success | t
!  audit_admin | audit_user | Create View              | Audit When Not Success | t
!  audit_admin | audit_user | Delete Table             | Audit When Not Success | t
!  audit_admin | audit_user | Disable Trigger          | Audit When Not Success | t
!  audit_admin | audit_user | Drop Database            | Audit When Not Success | t
!  audit_admin | audit_user | Drop Extension           | Audit When Not Success | t
!  audit_admin | audit_user | Drop Function            | Audit When Not Success | t
!  audit_admin | audit_user | Drop Index               | Audit When Not Success | t
!  audit_admin | audit_user | Drop Materialized View   | Audit When Not Success | t
!  audit_admin | audit_user | Drop Node                | Audit When Not Success | t
!  audit_admin | audit_user | Drop Node Group          | Audit When Not Success | t
!  audit_admin | audit_user | Drop Role                | Audit When Not Success | t
!  audit_admin | audit_user | Drop Schema              | Audit When Not Success | t
!  audit_admin | audit_user | Drop Sequence            | Audit When Not Success | t
!  audit_admin | audit_user | Drop Sharding in Group   | Audit When Not Success | t
!  audit_admin | audit_user | Drop Table               | Audit When Not Success | t
!  audit_admin | audit_user | Drop Tablespace          | Audit When Not Success | t
!  audit_admin | audit_user | Drop Trigger             | Audit When Not Success | t
!  audit_admin | audit_user | Drop Type                | Audit When Not Success | t
!  audit_admin | audit_user | Drop User                | Audit When Not Success | t
!  audit_admin | audit_user | Drop View                | Audit When Not Success | t
!  audit_admin | audit_user | Enable Trigger           | Audit When Not Success | t
!  audit_admin | audit_user | Grant Function           | Audit When Not Success | t
!  audit_admin | audit_user | Grant Sequence           | Audit When Not Success | t
!  audit_admin | audit_user | Grant Table              | Audit When Not Success | t
!  audit_admin | audit_user | Grant Type               | Audit When Not Success | t
!  audit_admin | audit_user | Insert Table             | Audit When Not Success | t
!  audit_admin | audit_user | Lock Table               | Audit When Not Success | t
!  audit_admin | audit_user | Select Sequence          | Audit When Not Success | t
!  audit_admin | audit_user | Select Table             | Audit When Not Success | t
!  audit_admin | audit_user | Set Role                 | Audit When Not Success | t
!  audit_admin | audit_user | System Audit             | Audit When Not Success | t
!  audit_admin | audit_user | System Grant             | Audit When Not Success | t
!  audit_admin | audit_user | Truncate Table           | Audit When Not Success | t
!  audit_admin | audit_user | Update Table             | Audit When Not Success | t
! (68 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!    auditor   |       action_name        |      action_mode       | action_ison 
! -------------+--------------------------+------------------------+-------------
!  audit_admin | Add Partitions           | Audit When Not Success | t
!  audit_admin | Alter Database           | Audit When Not Success | t
!  audit_admin | Alter Extension          | Audit When Not Success | t
!  audit_admin | Alter Function           | Audit When Not Success | t
!  audit_admin | Alter Index              | Audit When Not Success | t
!  audit_admin | Alter Materialized View  | Audit When Not Success | t
!  audit_admin | Alter Node               | Audit When Not Success | t
!  audit_admin | Alter Role               | Audit When Not Success | t
!  audit_admin | Alter Schema             | Audit When Not Success | t
!  audit_admin | Alter Sequence           | Audit When Not Success | t
!  audit_admin | Alter System             | Audit When Not Success | t
!  audit_admin | Alter Table              | Audit When Not Success | t
!  audit_admin | Alter Tablespace         | Audit When Not Success | t
!  audit_admin | Alter Trigger            | Audit When Not Success | t
!  audit_admin | Alter Type               | Audit When Not Success | t
!  audit_admin | Alter User               | Audit When Not Success | t
!  audit_admin | Alter View               | Audit When Not Success | t
!  audit_admin | Comment Table            | Audit When Not Success | t
!  audit_admin | Create Database          | Audit When Not Success | t
!  audit_admin | Create Extension         | Audit When Not Success | t
!  audit_admin | Create Function          | Audit When Not Success | t
!  audit_admin | Create Index             | Audit When Not Success | t
!  audit_admin | Create Materialized View | Audit When Not Success | t
!  audit_admin | Create Node              | Audit When Not Success | t
!  audit_admin | Create Node Group        | Audit When Not Success | t
!  audit_admin | Create Role              | Audit When Not Success | t
!  audit_admin | Create Schema            | Audit When Not Success | t
!  audit_admin | Create Sequence          | Audit When Not Success | t
!  audit_admin | Create Sharding Group    | Audit When Not Success | t
!  audit_admin | Create Table             | Audit When Not Success | t
!  audit_admin | Create Tablespace        | Audit When Not Success | t
!  audit_admin | Create Trigger           | Audit When Not Success | t
!  audit_admin | Create Type              | Audit When Not Success | t
!  audit_admin | Create User              | Audit When Not Success | t
!  audit_admin | Create View              | Audit When Not Success | t
!  audit_admin | Delete Table             | Audit When Not Success | t
!  audit_admin | Disable Trigger          | Audit When Not Success | t
!  audit_admin | Drop Database            | Audit When Not Success | t
!  audit_admin | Drop Extension           | Audit When Not Success | t
!  audit_admin | Drop Function            | Audit When Not Success | t
!  audit_admin | Drop Index               | Audit When Not Success | t
!  audit_admin | Drop Materialized View   | Audit When Not Success | t
!  audit_admin | Drop Node                | Audit When Not Success | t
!  audit_admin | Drop Node Group          | Audit When Not Success | t
!  audit_admin | Drop Role                | Audit When Not Success | t
!  audit_admin | Drop Schema              | Audit When Not Success | t
!  audit_admin | Drop Sequence            | Audit When Not Success | t
!  audit_admin | Drop Sharding in Group   | Audit When Not Success | t
!  audit_admin | Drop Table               | Audit When Not Success | t
!  audit_admin | Drop Tablespace          | Audit When Not Success | t
!  audit_admin | Drop Trigger             | Audit When Not Success | t
!  audit_admin | Drop Type                | Audit When Not Success | t
!  audit_admin | Drop User                | Audit When Not Success | t
!  audit_admin | Drop View                | Audit When Not Success | t
!  audit_admin | Enable Trigger           | Audit When Not Success | t
!  audit_admin | Grant Function           | Audit When Not Success | t
!  audit_admin | Grant Sequence           | Audit When Not Success | t
!  audit_admin | Grant Table              | Audit When Not Success | t
!  audit_admin | Grant Type               | Audit When Not Success | t
!  audit_admin | Insert Table             | Audit When Not Success | t
!  audit_admin | Lock Table               | Audit When Not Success | t
!  audit_admin | Select Sequence          | Audit When Not Success | t
!  audit_admin | Select Table             | Audit When Not Success | t
!  audit_admin | Set Role                 | Audit When Not Success | t
!  audit_admin | System Audit             | Audit When Not Success | t
!  audit_admin | System Grant             | Audit When Not Success | t
!  audit_admin | Truncate Table           | Audit When Not Success | t
!  audit_admin | Update Table             | Audit When Not Success | t
! (68 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name |      action_mode       | action_ison 
! -------------+-------------+------------------------+-------------
!  audit_admin | Alter       | Audit When Not Success | t
!  audit_admin | Audit       | Audit When Not Success | t
!  audit_admin | Comment     | Audit When Not Success | t
!  audit_admin | Delete      | Audit When Not Success | t
!  audit_admin | Grant       | Audit When Not Success | t
!  audit_admin | Insert      | Audit When Not Success | t
!  audit_admin | Lock        | Audit When Not Success | t
!  audit_admin | Rename      | Audit When Not Success | t
!  audit_admin | Select      | Audit When Not Success | t
!  audit_admin | Update      | Audit When Not Success | t
! (10 rows)
! 
! audit all WHENEVER SUCCESSFUL;
! audit all by audit_user WHENEVER SUCCESSFUL;
! audit all on default WHENEVER SUCCESSFUL;
! audit all on tbl_test WHENEVER SUCCESSFUL;
! audit all on tbl_test_v WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_v" is not a table
! audit all on view tbl_test_v WHENEVER SUCCESSFUL;
! audit all on tbl_test_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a table
! audit all on view tbl_test_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a view
! audit all on materialized view tbl_test_mv WHENEVER SUCCESSFUL;
! audit all on tbl_test0 WHENEVER SUCCESSFUL;
! audit all on tbl_test0_v WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_v" is not a table
! audit all on view tbl_test0_v WHENEVER SUCCESSFUL;
! audit all on tbl_test0_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a table
! audit all on view tbl_test0_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a view
! audit all on materialized view tbl_test0_mv WHENEVER SUCCESSFUL;
! audit all on sc_test.tbl_test WHENEVER SUCCESSFUL;
! audit all on sc_test.tbl_test_v WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_v" is not a table
! audit all on view sc_test.tbl_test_v WHENEVER SUCCESSFUL;
! audit all on sc_test.tbl_test_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a table
! audit all on view sc_test.tbl_test_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test_mv" is not a view
! audit all on materialized view sc_test.tbl_test_mv WHENEVER SUCCESSFUL;
! audit all on sc_test.tbl_test0 WHENEVER SUCCESSFUL;
! audit all on sc_test.tbl_test0_v WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_v" is not a table
! audit all on view sc_test.tbl_test0_v WHENEVER SUCCESSFUL;
! audit all on sc_test.tbl_test0_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a table
! audit all on view sc_test.tbl_test0_mv WHENEVER SUCCESSFUL;
! ERROR:  "tbl_test0_mv" is not a view
! audit all on materialized view sc_test.tbl_test0_mv WHENEVER SUCCESSFUL;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |              object_desc               | action_name | action_mode  | action_ison 
! -------------+--------------+----------------------------------------+-------------+--------------+-------------
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test0_mv | Update      | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view sc_test.tbl_test_mv  | Update      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv         | Update      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv          | Update      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Alter       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Audit       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Comment     | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Delete      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Grant       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Insert      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Lock        | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Rename      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Select      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test                 | Update      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Alter       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Audit       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Comment     | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Delete      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Grant       | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Insert      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Lock        | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Rename      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Select      | Audit Always | t
!  audit_admin | pg_class     | table sc_test.tbl_test0                | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                         | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                        | Update      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Alter       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Audit       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Comment     | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Delete      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Grant       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Insert      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Rename      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Select      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test0_v               | Update      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Alter       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Audit       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Comment     | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Delete      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Grant       | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Insert      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Rename      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Select      | Audit Always | t
!  audit_admin | pg_class     | view sc_test.tbl_test_v                | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v                       | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                        | Update      | Audit Always | t
! (104 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!    auditor   | user_name  |       action_name        | action_mode  | action_ison 
! -------------+------------+--------------------------+--------------+-------------
!  audit_admin | audit_user | Add Partitions           | Audit Always | t
!  audit_admin | audit_user | Alter Database           | Audit Always | t
!  audit_admin | audit_user | Alter Extension          | Audit Always | t
!  audit_admin | audit_user | Alter Function           | Audit Always | t
!  audit_admin | audit_user | Alter Index              | Audit Always | t
!  audit_admin | audit_user | Alter Materialized View  | Audit Always | t
!  audit_admin | audit_user | Alter Node               | Audit Always | t
!  audit_admin | audit_user | Alter Role               | Audit Always | t
!  audit_admin | audit_user | Alter Schema             | Audit Always | t
!  audit_admin | audit_user | Alter Sequence           | Audit Always | t
!  audit_admin | audit_user | Alter System             | Audit Always | t
!  audit_admin | audit_user | Alter Table              | Audit Always | t
!  audit_admin | audit_user | Alter Tablespace         | Audit Always | t
!  audit_admin | audit_user | Alter Trigger            | Audit Always | t
!  audit_admin | audit_user | Alter Type               | Audit Always | t
!  audit_admin | audit_user | Alter User               | Audit Always | t
!  audit_admin | audit_user | Alter View               | Audit Always | t
!  audit_admin | audit_user | Comment Table            | Audit Always | t
!  audit_admin | audit_user | Create Database          | Audit Always | t
!  audit_admin | audit_user | Create Extension         | Audit Always | t
!  audit_admin | audit_user | Create Function          | Audit Always | t
!  audit_admin | audit_user | Create Index             | Audit Always | t
!  audit_admin | audit_user | Create Materialized View | Audit Always | t
!  audit_admin | audit_user | Create Node              | Audit Always | t
!  audit_admin | audit_user | Create Node Group        | Audit Always | t
!  audit_admin | audit_user | Create Role              | Audit Always | t
!  audit_admin | audit_user | Create Schema            | Audit Always | t
!  audit_admin | audit_user | Create Sequence          | Audit Always | t
!  audit_admin | audit_user | Create Sharding Group    | Audit Always | t
!  audit_admin | audit_user | Create Table             | Audit Always | t
!  audit_admin | audit_user | Create Tablespace        | Audit Always | t
!  audit_admin | audit_user | Create Trigger           | Audit Always | t
!  audit_admin | audit_user | Create Type              | Audit Always | t
!  audit_admin | audit_user | Create User              | Audit Always | t
!  audit_admin | audit_user | Create View              | Audit Always | t
!  audit_admin | audit_user | Delete Table             | Audit Always | t
!  audit_admin | audit_user | Disable Trigger          | Audit Always | t
!  audit_admin | audit_user | Drop Database            | Audit Always | t
!  audit_admin | audit_user | Drop Extension           | Audit Always | t
!  audit_admin | audit_user | Drop Function            | Audit Always | t
!  audit_admin | audit_user | Drop Index               | Audit Always | t
!  audit_admin | audit_user | Drop Materialized View   | Audit Always | t
!  audit_admin | audit_user | Drop Node                | Audit Always | t
!  audit_admin | audit_user | Drop Node Group          | Audit Always | t
!  audit_admin | audit_user | Drop Role                | Audit Always | t
!  audit_admin | audit_user | Drop Schema              | Audit Always | t
!  audit_admin | audit_user | Drop Sequence            | Audit Always | t
!  audit_admin | audit_user | Drop Sharding in Group   | Audit Always | t
!  audit_admin | audit_user | Drop Table               | Audit Always | t
!  audit_admin | audit_user | Drop Tablespace          | Audit Always | t
!  audit_admin | audit_user | Drop Trigger             | Audit Always | t
!  audit_admin | audit_user | Drop Type                | Audit Always | t
!  audit_admin | audit_user | Drop User                | Audit Always | t
!  audit_admin | audit_user | Drop View                | Audit Always | t
!  audit_admin | audit_user | Enable Trigger           | Audit Always | t
!  audit_admin | audit_user | Grant Function           | Audit Always | t
!  audit_admin | audit_user | Grant Sequence           | Audit Always | t
!  audit_admin | audit_user | Grant Table              | Audit Always | t
!  audit_admin | audit_user | Grant Type               | Audit Always | t
!  audit_admin | audit_user | Insert Table             | Audit Always | t
!  audit_admin | audit_user | Lock Table               | Audit Always | t
!  audit_admin | audit_user | Select Sequence          | Audit Always | t
!  audit_admin | audit_user | Select Table             | Audit Always | t
!  audit_admin | audit_user | Set Role                 | Audit Always | t
!  audit_admin | audit_user | System Audit             | Audit Always | t
!  audit_admin | audit_user | System Grant             | Audit Always | t
!  audit_admin | audit_user | Truncate Table           | Audit Always | t
!  audit_admin | audit_user | Update Table             | Audit Always | t
! (68 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!    auditor   |       action_name        | action_mode  | action_ison 
! -------------+--------------------------+--------------+-------------
!  audit_admin | Add Partitions           | Audit Always | t
!  audit_admin | Alter Database           | Audit Always | t
!  audit_admin | Alter Extension          | Audit Always | t
!  audit_admin | Alter Function           | Audit Always | t
!  audit_admin | Alter Index              | Audit Always | t
!  audit_admin | Alter Materialized View  | Audit Always | t
!  audit_admin | Alter Node               | Audit Always | t
!  audit_admin | Alter Role               | Audit Always | t
!  audit_admin | Alter Schema             | Audit Always | t
!  audit_admin | Alter Sequence           | Audit Always | t
!  audit_admin | Alter System             | Audit Always | t
!  audit_admin | Alter Table              | Audit Always | t
!  audit_admin | Alter Tablespace         | Audit Always | t
!  audit_admin | Alter Trigger            | Audit Always | t
!  audit_admin | Alter Type               | Audit Always | t
!  audit_admin | Alter User               | Audit Always | t
!  audit_admin | Alter View               | Audit Always | t
!  audit_admin | Comment Table            | Audit Always | t
!  audit_admin | Create Database          | Audit Always | t
!  audit_admin | Create Extension         | Audit Always | t
!  audit_admin | Create Function          | Audit Always | t
!  audit_admin | Create Index             | Audit Always | t
!  audit_admin | Create Materialized View | Audit Always | t
!  audit_admin | Create Node              | Audit Always | t
!  audit_admin | Create Node Group        | Audit Always | t
!  audit_admin | Create Role              | Audit Always | t
!  audit_admin | Create Schema            | Audit Always | t
!  audit_admin | Create Sequence          | Audit Always | t
!  audit_admin | Create Sharding Group    | Audit Always | t
!  audit_admin | Create Table             | Audit Always | t
!  audit_admin | Create Tablespace        | Audit Always | t
!  audit_admin | Create Trigger           | Audit Always | t
!  audit_admin | Create Type              | Audit Always | t
!  audit_admin | Create User              | Audit Always | t
!  audit_admin | Create View              | Audit Always | t
!  audit_admin | Delete Table             | Audit Always | t
!  audit_admin | Disable Trigger          | Audit Always | t
!  audit_admin | Drop Database            | Audit Always | t
!  audit_admin | Drop Extension           | Audit Always | t
!  audit_admin | Drop Function            | Audit Always | t
!  audit_admin | Drop Index               | Audit Always | t
!  audit_admin | Drop Materialized View   | Audit Always | t
!  audit_admin | Drop Node                | Audit Always | t
!  audit_admin | Drop Node Group          | Audit Always | t
!  audit_admin | Drop Role                | Audit Always | t
!  audit_admin | Drop Schema              | Audit Always | t
!  audit_admin | Drop Sequence            | Audit Always | t
!  audit_admin | Drop Sharding in Group   | Audit Always | t
!  audit_admin | Drop Table               | Audit Always | t
!  audit_admin | Drop Tablespace          | Audit Always | t
!  audit_admin | Drop Trigger             | Audit Always | t
!  audit_admin | Drop Type                | Audit Always | t
!  audit_admin | Drop User                | Audit Always | t
!  audit_admin | Drop View                | Audit Always | t
!  audit_admin | Enable Trigger           | Audit Always | t
!  audit_admin | Grant Function           | Audit Always | t
!  audit_admin | Grant Sequence           | Audit Always | t
!  audit_admin | Grant Table              | Audit Always | t
!  audit_admin | Grant Type               | Audit Always | t
!  audit_admin | Insert Table             | Audit Always | t
!  audit_admin | Lock Table               | Audit Always | t
!  audit_admin | Select Sequence          | Audit Always | t
!  audit_admin | Select Table             | Audit Always | t
!  audit_admin | Set Role                 | Audit Always | t
!  audit_admin | System Audit             | Audit Always | t
!  audit_admin | System Grant             | Audit Always | t
!  audit_admin | Truncate Table           | Audit Always | t
!  audit_admin | Update Table             | Audit Always | t
! (68 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name | action_mode  | action_ison 
! -------------+-------------+--------------+-------------
!  audit_admin | Alter       | Audit Always | t
!  audit_admin | Audit       | Audit Always | t
!  audit_admin | Comment     | Audit Always | t
!  audit_admin | Delete      | Audit Always | t
!  audit_admin | Grant       | Audit Always | t
!  audit_admin | Insert      | Audit Always | t
!  audit_admin | Lock        | Audit Always | t
!  audit_admin | Rename      | Audit Always | t
!  audit_admin | Select      | Audit Always | t
!  audit_admin | Update      | Audit Always | t
! (10 rows)
! 
! \c audit_database audit_user
! drop schema sc_test cascade;
! NOTICE:  drop cascades to 6 other objects
! DETAIL:  drop cascades to table sc_test.tbl_test
! drop cascades to table sc_test.tbl_test0
! drop cascades to view sc_test.tbl_test_v
! drop cascades to materialized view sc_test.tbl_test_mv
! drop cascades to view sc_test.tbl_test0_v
! drop cascades to materialized view sc_test.tbl_test0_mv
! \c audit_database audit_admin
! clean unknown audit;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |          object_desc           | action_name | action_mode  | action_ison 
! -------------+--------------+--------------------------------+-------------+--------------+-------------
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Update      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Update      | Audit Always | t
! (52 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!    auditor   | user_name  |       action_name        | action_mode  | action_ison 
! -------------+------------+--------------------------+--------------+-------------
!  audit_admin | audit_user | Add Partitions           | Audit Always | t
!  audit_admin | audit_user | Alter Database           | Audit Always | t
!  audit_admin | audit_user | Alter Extension          | Audit Always | t
!  audit_admin | audit_user | Alter Function           | Audit Always | t
!  audit_admin | audit_user | Alter Index              | Audit Always | t
!  audit_admin | audit_user | Alter Materialized View  | Audit Always | t
!  audit_admin | audit_user | Alter Node               | Audit Always | t
!  audit_admin | audit_user | Alter Role               | Audit Always | t
!  audit_admin | audit_user | Alter Schema             | Audit Always | t
!  audit_admin | audit_user | Alter Sequence           | Audit Always | t
!  audit_admin | audit_user | Alter System             | Audit Always | t
!  audit_admin | audit_user | Alter Table              | Audit Always | t
!  audit_admin | audit_user | Alter Tablespace         | Audit Always | t
!  audit_admin | audit_user | Alter Trigger            | Audit Always | t
!  audit_admin | audit_user | Alter Type               | Audit Always | t
!  audit_admin | audit_user | Alter User               | Audit Always | t
!  audit_admin | audit_user | Alter View               | Audit Always | t
!  audit_admin | audit_user | Comment Table            | Audit Always | t
!  audit_admin | audit_user | Create Database          | Audit Always | t
!  audit_admin | audit_user | Create Extension         | Audit Always | t
!  audit_admin | audit_user | Create Function          | Audit Always | t
!  audit_admin | audit_user | Create Index             | Audit Always | t
!  audit_admin | audit_user | Create Materialized View | Audit Always | t
!  audit_admin | audit_user | Create Node              | Audit Always | t
!  audit_admin | audit_user | Create Node Group        | Audit Always | t
!  audit_admin | audit_user | Create Role              | Audit Always | t
!  audit_admin | audit_user | Create Schema            | Audit Always | t
!  audit_admin | audit_user | Create Sequence          | Audit Always | t
!  audit_admin | audit_user | Create Sharding Group    | Audit Always | t
!  audit_admin | audit_user | Create Table             | Audit Always | t
!  audit_admin | audit_user | Create Tablespace        | Audit Always | t
!  audit_admin | audit_user | Create Trigger           | Audit Always | t
!  audit_admin | audit_user | Create Type              | Audit Always | t
!  audit_admin | audit_user | Create User              | Audit Always | t
!  audit_admin | audit_user | Create View              | Audit Always | t
!  audit_admin | audit_user | Delete Table             | Audit Always | t
!  audit_admin | audit_user | Disable Trigger          | Audit Always | t
!  audit_admin | audit_user | Drop Database            | Audit Always | t
!  audit_admin | audit_user | Drop Extension           | Audit Always | t
!  audit_admin | audit_user | Drop Function            | Audit Always | t
!  audit_admin | audit_user | Drop Index               | Audit Always | t
!  audit_admin | audit_user | Drop Materialized View   | Audit Always | t
!  audit_admin | audit_user | Drop Node                | Audit Always | t
!  audit_admin | audit_user | Drop Node Group          | Audit Always | t
!  audit_admin | audit_user | Drop Role                | Audit Always | t
!  audit_admin | audit_user | Drop Schema              | Audit Always | t
!  audit_admin | audit_user | Drop Sequence            | Audit Always | t
!  audit_admin | audit_user | Drop Sharding in Group   | Audit Always | t
!  audit_admin | audit_user | Drop Table               | Audit Always | t
!  audit_admin | audit_user | Drop Tablespace          | Audit Always | t
!  audit_admin | audit_user | Drop Trigger             | Audit Always | t
!  audit_admin | audit_user | Drop Type                | Audit Always | t
!  audit_admin | audit_user | Drop User                | Audit Always | t
!  audit_admin | audit_user | Drop View                | Audit Always | t
!  audit_admin | audit_user | Enable Trigger           | Audit Always | t
!  audit_admin | audit_user | Grant Function           | Audit Always | t
!  audit_admin | audit_user | Grant Sequence           | Audit Always | t
!  audit_admin | audit_user | Grant Table              | Audit Always | t
!  audit_admin | audit_user | Grant Type               | Audit Always | t
!  audit_admin | audit_user | Insert Table             | Audit Always | t
!  audit_admin | audit_user | Lock Table               | Audit Always | t
!  audit_admin | audit_user | Select Sequence          | Audit Always | t
!  audit_admin | audit_user | Select Table             | Audit Always | t
!  audit_admin | audit_user | Set Role                 | Audit Always | t
!  audit_admin | audit_user | System Audit             | Audit Always | t
!  audit_admin | audit_user | System Grant             | Audit Always | t
!  audit_admin | audit_user | Truncate Table           | Audit Always | t
!  audit_admin | audit_user | Update Table             | Audit Always | t
! (68 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!    auditor   |       action_name        | action_mode  | action_ison 
! -------------+--------------------------+--------------+-------------
!  audit_admin | Add Partitions           | Audit Always | t
!  audit_admin | Alter Database           | Audit Always | t
!  audit_admin | Alter Extension          | Audit Always | t
!  audit_admin | Alter Function           | Audit Always | t
!  audit_admin | Alter Index              | Audit Always | t
!  audit_admin | Alter Materialized View  | Audit Always | t
!  audit_admin | Alter Node               | Audit Always | t
!  audit_admin | Alter Role               | Audit Always | t
!  audit_admin | Alter Schema             | Audit Always | t
!  audit_admin | Alter Sequence           | Audit Always | t
!  audit_admin | Alter System             | Audit Always | t
!  audit_admin | Alter Table              | Audit Always | t
!  audit_admin | Alter Tablespace         | Audit Always | t
!  audit_admin | Alter Trigger            | Audit Always | t
!  audit_admin | Alter Type               | Audit Always | t
!  audit_admin | Alter User               | Audit Always | t
!  audit_admin | Alter View               | Audit Always | t
!  audit_admin | Comment Table            | Audit Always | t
!  audit_admin | Create Database          | Audit Always | t
!  audit_admin | Create Extension         | Audit Always | t
!  audit_admin | Create Function          | Audit Always | t
!  audit_admin | Create Index             | Audit Always | t
!  audit_admin | Create Materialized View | Audit Always | t
!  audit_admin | Create Node              | Audit Always | t
!  audit_admin | Create Node Group        | Audit Always | t
!  audit_admin | Create Role              | Audit Always | t
!  audit_admin | Create Schema            | Audit Always | t
!  audit_admin | Create Sequence          | Audit Always | t
!  audit_admin | Create Sharding Group    | Audit Always | t
!  audit_admin | Create Table             | Audit Always | t
!  audit_admin | Create Tablespace        | Audit Always | t
!  audit_admin | Create Trigger           | Audit Always | t
!  audit_admin | Create Type              | Audit Always | t
!  audit_admin | Create User              | Audit Always | t
!  audit_admin | Create View              | Audit Always | t
!  audit_admin | Delete Table             | Audit Always | t
!  audit_admin | Disable Trigger          | Audit Always | t
!  audit_admin | Drop Database            | Audit Always | t
!  audit_admin | Drop Extension           | Audit Always | t
!  audit_admin | Drop Function            | Audit Always | t
!  audit_admin | Drop Index               | Audit Always | t
!  audit_admin | Drop Materialized View   | Audit Always | t
!  audit_admin | Drop Node                | Audit Always | t
!  audit_admin | Drop Node Group          | Audit Always | t
!  audit_admin | Drop Role                | Audit Always | t
!  audit_admin | Drop Schema              | Audit Always | t
!  audit_admin | Drop Sequence            | Audit Always | t
!  audit_admin | Drop Sharding in Group   | Audit Always | t
!  audit_admin | Drop Table               | Audit Always | t
!  audit_admin | Drop Tablespace          | Audit Always | t
!  audit_admin | Drop Trigger             | Audit Always | t
!  audit_admin | Drop Type                | Audit Always | t
!  audit_admin | Drop User                | Audit Always | t
!  audit_admin | Drop View                | Audit Always | t
!  audit_admin | Enable Trigger           | Audit Always | t
!  audit_admin | Grant Function           | Audit Always | t
!  audit_admin | Grant Sequence           | Audit Always | t
!  audit_admin | Grant Table              | Audit Always | t
!  audit_admin | Grant Type               | Audit Always | t
!  audit_admin | Insert Table             | Audit Always | t
!  audit_admin | Lock Table               | Audit Always | t
!  audit_admin | Select Sequence          | Audit Always | t
!  audit_admin | Select Table             | Audit Always | t
!  audit_admin | Set Role                 | Audit Always | t
!  audit_admin | System Audit             | Audit Always | t
!  audit_admin | System Grant             | Audit Always | t
!  audit_admin | Truncate Table           | Audit Always | t
!  audit_admin | Update Table             | Audit Always | t
! (68 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name | action_mode  | action_ison 
! -------------+-------------+--------------+-------------
!  audit_admin | Alter       | Audit Always | t
!  audit_admin | Audit       | Audit Always | t
!  audit_admin | Comment     | Audit Always | t
!  audit_admin | Delete      | Audit Always | t
!  audit_admin | Grant       | Audit Always | t
!  audit_admin | Insert      | Audit Always | t
!  audit_admin | Lock        | Audit Always | t
!  audit_admin | Rename      | Audit Always | t
!  audit_admin | Select      | Audit Always | t
!  audit_admin | Update      | Audit Always | t
! (10 rows)
! 
! clean statement audit;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |          object_desc           | action_name | action_mode  | action_ison 
! -------------+--------------+--------------------------------+-------------+--------------+-------------
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Update      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Update      | Audit Always | t
! (52 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!    auditor   | user_name  |       action_name        | action_mode  | action_ison 
! -------------+------------+--------------------------+--------------+-------------
!  audit_admin | audit_user | Add Partitions           | Audit Always | t
!  audit_admin | audit_user | Alter Database           | Audit Always | t
!  audit_admin | audit_user | Alter Extension          | Audit Always | t
!  audit_admin | audit_user | Alter Function           | Audit Always | t
!  audit_admin | audit_user | Alter Index              | Audit Always | t
!  audit_admin | audit_user | Alter Materialized View  | Audit Always | t
!  audit_admin | audit_user | Alter Node               | Audit Always | t
!  audit_admin | audit_user | Alter Role               | Audit Always | t
!  audit_admin | audit_user | Alter Schema             | Audit Always | t
!  audit_admin | audit_user | Alter Sequence           | Audit Always | t
!  audit_admin | audit_user | Alter System             | Audit Always | t
!  audit_admin | audit_user | Alter Table              | Audit Always | t
!  audit_admin | audit_user | Alter Tablespace         | Audit Always | t
!  audit_admin | audit_user | Alter Trigger            | Audit Always | t
!  audit_admin | audit_user | Alter Type               | Audit Always | t
!  audit_admin | audit_user | Alter User               | Audit Always | t
!  audit_admin | audit_user | Alter View               | Audit Always | t
!  audit_admin | audit_user | Comment Table            | Audit Always | t
!  audit_admin | audit_user | Create Database          | Audit Always | t
!  audit_admin | audit_user | Create Extension         | Audit Always | t
!  audit_admin | audit_user | Create Function          | Audit Always | t
!  audit_admin | audit_user | Create Index             | Audit Always | t
!  audit_admin | audit_user | Create Materialized View | Audit Always | t
!  audit_admin | audit_user | Create Node              | Audit Always | t
!  audit_admin | audit_user | Create Node Group        | Audit Always | t
!  audit_admin | audit_user | Create Role              | Audit Always | t
!  audit_admin | audit_user | Create Schema            | Audit Always | t
!  audit_admin | audit_user | Create Sequence          | Audit Always | t
!  audit_admin | audit_user | Create Sharding Group    | Audit Always | t
!  audit_admin | audit_user | Create Table             | Audit Always | t
!  audit_admin | audit_user | Create Tablespace        | Audit Always | t
!  audit_admin | audit_user | Create Trigger           | Audit Always | t
!  audit_admin | audit_user | Create Type              | Audit Always | t
!  audit_admin | audit_user | Create User              | Audit Always | t
!  audit_admin | audit_user | Create View              | Audit Always | t
!  audit_admin | audit_user | Delete Table             | Audit Always | t
!  audit_admin | audit_user | Disable Trigger          | Audit Always | t
!  audit_admin | audit_user | Drop Database            | Audit Always | t
!  audit_admin | audit_user | Drop Extension           | Audit Always | t
!  audit_admin | audit_user | Drop Function            | Audit Always | t
!  audit_admin | audit_user | Drop Index               | Audit Always | t
!  audit_admin | audit_user | Drop Materialized View   | Audit Always | t
!  audit_admin | audit_user | Drop Node                | Audit Always | t
!  audit_admin | audit_user | Drop Node Group          | Audit Always | t
!  audit_admin | audit_user | Drop Role                | Audit Always | t
!  audit_admin | audit_user | Drop Schema              | Audit Always | t
!  audit_admin | audit_user | Drop Sequence            | Audit Always | t
!  audit_admin | audit_user | Drop Sharding in Group   | Audit Always | t
!  audit_admin | audit_user | Drop Table               | Audit Always | t
!  audit_admin | audit_user | Drop Tablespace          | Audit Always | t
!  audit_admin | audit_user | Drop Trigger             | Audit Always | t
!  audit_admin | audit_user | Drop Type                | Audit Always | t
!  audit_admin | audit_user | Drop User                | Audit Always | t
!  audit_admin | audit_user | Drop View                | Audit Always | t
!  audit_admin | audit_user | Enable Trigger           | Audit Always | t
!  audit_admin | audit_user | Grant Function           | Audit Always | t
!  audit_admin | audit_user | Grant Sequence           | Audit Always | t
!  audit_admin | audit_user | Grant Table              | Audit Always | t
!  audit_admin | audit_user | Grant Type               | Audit Always | t
!  audit_admin | audit_user | Insert Table             | Audit Always | t
!  audit_admin | audit_user | Lock Table               | Audit Always | t
!  audit_admin | audit_user | Select Sequence          | Audit Always | t
!  audit_admin | audit_user | Select Table             | Audit Always | t
!  audit_admin | audit_user | Set Role                 | Audit Always | t
!  audit_admin | audit_user | System Audit             | Audit Always | t
!  audit_admin | audit_user | System Grant             | Audit Always | t
!  audit_admin | audit_user | Truncate Table           | Audit Always | t
!  audit_admin | audit_user | Update Table             | Audit Always | t
! (68 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!  auditor | action_name | action_mode | action_ison 
! ---------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name | action_mode  | action_ison 
! -------------+-------------+--------------+-------------
!  audit_admin | Alter       | Audit Always | t
!  audit_admin | Audit       | Audit Always | t
!  audit_admin | Comment     | Audit Always | t
!  audit_admin | Delete      | Audit Always | t
!  audit_admin | Grant       | Audit Always | t
!  audit_admin | Insert      | Audit Always | t
!  audit_admin | Lock        | Audit Always | t
!  audit_admin | Rename      | Audit Always | t
!  audit_admin | Select      | Audit Always | t
!  audit_admin | Update      | Audit Always | t
! (10 rows)
! 
! clean user audit by audit_user;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |          object_desc           | action_name | action_mode  | action_ison 
! -------------+--------------+--------------------------------+-------------+--------------+-------------
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Update      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test                 | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Update      | Audit Always | t
! (52 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!  auditor | user_name | action_name | action_mode | action_ison 
! ---------+-----------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!  auditor | action_name | action_mode | action_ison 
! ---------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name | action_mode  | action_ison 
! -------------+-------------+--------------+-------------
!  audit_admin | Alter       | Audit Always | t
!  audit_admin | Audit       | Audit Always | t
!  audit_admin | Comment     | Audit Always | t
!  audit_admin | Delete      | Audit Always | t
!  audit_admin | Grant       | Audit Always | t
!  audit_admin | Insert      | Audit Always | t
!  audit_admin | Lock        | Audit Always | t
!  audit_admin | Rename      | Audit Always | t
!  audit_admin | Select      | Audit Always | t
!  audit_admin | Update      | Audit Always | t
! (10 rows)
! 
! clean object audit on table tbl_test;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |          object_desc           | action_name | action_mode  | action_ison 
! -------------+--------------+--------------------------------+-------------+--------------+-------------
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Update      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test_v                | Update      | Audit Always | t
! (42 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!  auditor | user_name | action_name | action_mode | action_ison 
! ---------+-----------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!  auditor | action_name | action_mode | action_ison 
! ---------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name | action_mode  | action_ison 
! -------------+-------------+--------------+-------------
!  audit_admin | Alter       | Audit Always | t
!  audit_admin | Audit       | Audit Always | t
!  audit_admin | Comment     | Audit Always | t
!  audit_admin | Delete      | Audit Always | t
!  audit_admin | Grant       | Audit Always | t
!  audit_admin | Insert      | Audit Always | t
!  audit_admin | Lock        | Audit Always | t
!  audit_admin | Rename      | Audit Always | t
!  audit_admin | Select      | Audit Always | t
!  audit_admin | Update      | Audit Always | t
! (10 rows)
! 
! clean object audit on view tbl_test_v;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |          object_desc           | action_name | action_mode  | action_ison 
! -------------+--------------+--------------------------------+-------------+--------------+-------------
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Update      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test_mv  | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Update      | Audit Always | t
! (33 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!  auditor | user_name | action_name | action_mode | action_ison 
! ---------+-----------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!  auditor | action_name | action_mode | action_ison 
! ---------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name | action_mode  | action_ison 
! -------------+-------------+--------------+-------------
!  audit_admin | Alter       | Audit Always | t
!  audit_admin | Audit       | Audit Always | t
!  audit_admin | Comment     | Audit Always | t
!  audit_admin | Delete      | Audit Always | t
!  audit_admin | Grant       | Audit Always | t
!  audit_admin | Insert      | Audit Always | t
!  audit_admin | Lock        | Audit Always | t
!  audit_admin | Rename      | Audit Always | t
!  audit_admin | Select      | Audit Always | t
!  audit_admin | Update      | Audit Always | t
! (10 rows)
! 
! clean object audit on materialized view tbl_test_mv;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!    auditor   | object_class |          object_desc           | action_name | action_mode  | action_ison 
! -------------+--------------+--------------------------------+-------------+--------------+-------------
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Alter       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Audit       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Comment     | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Grant       | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Rename      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Select      | Audit Always | t
!  audit_admin | pg_class     | materialized view tbl_test0_mv | Update      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Alter       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Audit       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Comment     | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Delete      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Grant       | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Insert      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Lock        | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Rename      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Select      | Audit Always | t
!  audit_admin | pg_class     | table tbl_test0                | Update      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Alter       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Audit       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Comment     | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Delete      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Grant       | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Insert      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Rename      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Select      | Audit Always | t
!  audit_admin | pg_class     | view tbl_test0_v               | Update      | Audit Always | t
! (26 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!  auditor | user_name | action_name | action_mode | action_ison 
! ---------+-----------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!  auditor | action_name | action_mode | action_ison 
! ---------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name | action_mode  | action_ison 
! -------------+-------------+--------------+-------------
!  audit_admin | Alter       | Audit Always | t
!  audit_admin | Audit       | Audit Always | t
!  audit_admin | Comment     | Audit Always | t
!  audit_admin | Delete      | Audit Always | t
!  audit_admin | Grant       | Audit Always | t
!  audit_admin | Insert      | Audit Always | t
!  audit_admin | Lock        | Audit Always | t
!  audit_admin | Rename      | Audit Always | t
!  audit_admin | Select      | Audit Always | t
!  audit_admin | Update      | Audit Always | t
! (10 rows)
! 
! clean object audit;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!  auditor | object_class | object_desc | action_name | action_mode | action_ison 
! ---------+--------------+-------------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!  auditor | user_name | action_name | action_mode | action_ison 
! ---------+-----------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!  auditor | action_name | action_mode | action_ison 
! ---------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!    auditor   | action_name | action_mode  | action_ison 
! -------------+-------------+--------------+-------------
!  audit_admin | Alter       | Audit Always | t
!  audit_admin | Audit       | Audit Always | t
!  audit_admin | Comment     | Audit Always | t
!  audit_admin | Delete      | Audit Always | t
!  audit_admin | Grant       | Audit Always | t
!  audit_admin | Insert      | Audit Always | t
!  audit_admin | Lock        | Audit Always | t
!  audit_admin | Rename      | Audit Always | t
!  audit_admin | Select      | Audit Always | t
!  audit_admin | Update      | Audit Always | t
! (10 rows)
! 
! clean object audit on default;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!  auditor | object_class | object_desc | action_name | action_mode | action_ison 
! ---------+--------------+-------------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!  auditor | user_name | action_name | action_mode | action_ison 
! ---------+-----------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!  auditor | action_name | action_mode | action_ison 
! ---------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!  auditor | action_name | action_mode | action_ison 
! ---------+-------------+-------------+-------------
! (0 rows)
! 
! clean all audit;
! select * from pg_audit_obj_conf_detail order by auditor, object_class, object_desc, action_name, action_mode;
!  auditor | object_class | object_desc | action_name | action_mode | action_ison 
! ---------+--------------+-------------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_user_conf_detail order by auditor, user_name, action_name, action_mode;
!  auditor | user_name | action_name | action_mode | action_ison 
! ---------+-----------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_stmt_conf_detail order by auditor, action_name, action_mode;
!  auditor | action_name | action_mode | action_ison 
! ---------+-------------+-------------+-------------
! (0 rows)
! 
! select * from pg_audit_obj_def_opts_detail order by auditor, action_name;
!  auditor | action_name | action_mode | action_ison 
! ---------+-------------+-------------+-------------
! (0 rows)
! 
! \c audit_database audit_user
! drop table tbl_test cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view tbl_test_v
! drop cascades to materialized view tbl_test_mv
! drop table tbl_test0 cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view tbl_test0_v
! drop cascades to materialized view tbl_test0_mv
! \c regression audit_user
! drop database audit_database;
! reset client_min_messages;
! reset datestyle;
! reset client_encoding;
--- 42,45 ----
  create materialized view sc_test.tbl_test0_mv as select * from sc_test.tbl_test0;
  -- create and check audit rules 
  \c audit_database audit_admin
! \connect: fe_sendauth: no password supplied

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/partition.out"	2025-07-31 16:07:14.994067993 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/partition.out"	2025-07-31 16:38:16.295651127 +0800
***************
*** 2,10 ****
  create table t_day_1(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-09-01') step(interval '1 day') partitions(63)
  distribute by shard(c1);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into t_day_1 values(1, timestamp without time zone '2015-08-31 13:11:00', 1);
! ERROR:  value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_day_1 partition for(timestamp without time zone '2015-08-31 13:11:00');
  ERROR:  the value for locating a partition is out of range.
  insert into t_day_1 values(1, timestamp without time zone '2015-09-01 00:00:00', 1);
--- 2,9 ----
  create table t_day_1(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-09-01') step(interval '1 day') partitions(63)
  distribute by shard(c1);
  insert into t_day_1 values(1, timestamp without time zone '2015-08-31 13:11:00', 1);
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_day_1 partition for(timestamp without time zone '2015-08-31 13:11:00');
  ERROR:  the value for locating a partition is out of range.
  insert into t_day_1 values(1, timestamp without time zone '2015-09-01 00:00:00', 1);
***************
*** 29,35 ****
  (1 row)
  
  insert into t_day_1 values(1, timestamp without time zone '2015-11-03 00:00:00', 1);
! ERROR:  value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_day_1 partition for(timestamp without time zone '2015-11-03 00:00:00');
  ERROR:  the value for locating a partition is out of range.
  delete from t_day_1;
--- 28,34 ----
  (1 row)
  
  insert into t_day_1 values(1, timestamp without time zone '2015-11-03 00:00:00', 1);
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_day_1 partition for(timestamp without time zone '2015-11-03 00:00:00');
  ERROR:  the value for locating a partition is out of range.
  delete from t_day_1;
***************
*** 147,299 ****
  create table t_day_7(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-09-01') step(interval '7 day') partitions(10)
  distribute by shard(c1);
! NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into t_day_7 values(1, timestamp without time zone '2015-08-31 13:11:00', 1);
! ERROR:  value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_day_7 partition for(timestamp without time zone '2015-08-31 13:11:00');
! ERROR:  the value for locating a partition is out of range.
  insert into t_day_7 values(1, timestamp without time zone '2015-09-01 00:00:00', 1);
  select c1,c2,c3 from t_day_7 partition for(timestamp without time zone '2015-09-01 01:00:00');
!  c1 |            c2            | c3 
! ----+--------------------------+----
!   1 | Tue Sep 01 00:00:00 2015 |  1
! (1 row)
! 
  insert into t_day_7 values(1, timestamp without time zone '2015-09-08 00:00:00', 1);
  select c1,c2,c3 from t_day_7 partition for(timestamp without time zone '2015-09-08 01:00:00');
!  c1 |            c2            | c3 
! ----+--------------------------+----
!   1 | Tue Sep 08 00:00:00 2015 |  1
! (1 row)
! 
  insert into t_day_7 values(1, timestamp without time zone '2015-11-09 00:00:00', 1);
  select c1,c2,c3 from t_day_7 partition for(timestamp without time zone '2015-11-09 01:00:00');
!  c1 |            c2            | c3 
! ----+--------------------------+----
!   1 | Mon Nov 09 00:00:00 2015 |  1
! (1 row)
! 
  insert into t_day_7 values(1, timestamp without time zone '2015-11-10 00:00:00', 1);
! ERROR:  value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_day_7 partition for(timestamp without time zone '2015-11-10 00:00:00');
! ERROR:  the value for locating a partition is out of range.
  delete from t_day_7;
  select count(1) from t_day_7;
!  count 
! -------
!      0
! (1 row)
! 
  insert into t_day_7 values(1, timestamp without time zone '2015-09-01 13:11:00', 1);
  insert into t_day_7 select generate_series(2,3), timestamp without time zone '2015-09-08 13:11:00', 1;
  insert into t_day_7 select generate_series(4,7), timestamp without time zone '2015-09-15 13:11:00', 1;
  insert into t_day_7 select generate_series(8,15), timestamp without time zone '2015-09-22 13:11:00', 1;
  insert into t_day_7 select generate_series(16,31), timestamp without time zone '2015-09-29 13:11:00', 1;
  insert into t_day_7 select generate_series(32,63), timestamp without time zone '2015-10-06 13:11:00', 1;
  insert into t_day_7 select generate_series(64,127), timestamp without time zone '2015-10-13 13:11:00', 1;
  insert into t_day_7 select generate_series(128,255), timestamp without time zone '2015-10-20 13:11:00', 1;
  insert into t_day_7 select generate_series(256,511), timestamp without time zone '2015-10-27 13:11:00', 1;
  insert into t_day_7 select generate_series(512,1023), timestamp without time zone '2015-11-03 13:11:00', 1;
  --pruning--                
  select count(1) from t_day_7 where c2 < timestamp without time zone '2015-09-01 00:00:00';
!  count 
! -------
!      0
! (1 row)
! 
  select count(1) from t_day_7 where c2 <= timestamp without time zone '2015-09-01 00:00:00';
!  count 
! -------
!      0
! (1 row)
! 
  select count(1) from t_day_7 where c2 < timestamp without time zone '2015-09-01 14:00:00';
!  count 
! -------
!      1
! (1 row)
! 
  select count(1) from t_day_7 where c2 > timestamp without time zone '2015-09-01 01:00:00' and c2 < timestamp without time zone '2015-09-16 00:00:00';
!  count 
! -------
!      7
! (1 row)
! 
  select count(1) from t_day_7 where c2 > timestamp without time zone '2015-09-01 01:00:00' and c2 <= timestamp without time zone '2015-09-16 00:00:00';
!  count 
! -------
!      7
! (1 row)
! 
                             
  select count(1) from t_day_7 where c2 > timestamp without time zone '2015-11-10 13:00:00';
!  count 
! -------
!      0
! (1 row)
! 
                             
  select count(1) from t_day_7 where c2 > timestamp without time zone '2015-11-10 13:00:00' OR c2 < timestamp without time zone '2015-09-01 00:00:00';
!  count 
! -------
!      0
! (1 row)
! 
                             
  select count(1) from t_day_7 where c2 < timestamp without time zone '2015-09-13 01:00:00' OR c2 > timestamp without time zone '2015-10-27 00:00:00';
!  count 
! -------
!    771
! (1 row)
! 
  --update--
  update t_day_7 set c3=2 where c2 < timestamp without time zone '2015-09-01 00:00:00';
  update t_day_7 set c3=3 where c2 > timestamp without time zone '2015-11-10 13:00:00';
  update t_day_7 set c3=4 where c2 < timestamp without time zone '2015-09-09 00:00:00';
  select * from t_day_7 where c3=2;
!  c1 | c2 | c3 
! ----+----+----
! (0 rows)
! 
  select * from t_day_7 where c3=3;
!  c1 | c2 | c3 
! ----+----+----
! (0 rows)
! 
  select * from t_day_7 where c3=4 order by c1;
!  c1 |            c2            | c3 
! ----+--------------------------+----
!   1 | Tue Sep 01 13:11:00 2015 |  4
!   2 | Tue Sep 08 13:11:00 2015 |  4
!   3 | Tue Sep 08 13:11:00 2015 |  4
! (3 rows)
! 
  --truncate --
  truncate table t_day_7 partition for(timestamp without time zone '2015-08-30 00:00:00');
! ERROR:  the value for locating a partition is out of range
  truncate table t_day_7 partition for(timestamp without time zone '2015-09-09 00:00:00');
  select count(1) from t_day_7 partition for(timestamp without time zone '2015-09-09 00:00:00');
!  count 
! -------
!      0
! (1 row)
! 
  select count(1) from t_day_7;
!  count 
! -------
!   1021
! (1 row)
! 
  truncate table t_day_7 partition for(timestamp without time zone '2015-11-10 00:00:00');
! ERROR:  the value for locating a partition is out of range
  drop table t_day_7;
  -- 1 month interval -- 
  create table t_month_1(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-01-01') step(interval '1 month') partitions(24)
  distribute by shard(c1);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into t_month_1 values(1, timestamp without time zone '2014-12-31 13:11:00', 1);
! ERROR:  value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_month_1 partition for(timestamp without time zone '2014-12-31 13:11:00');
  ERROR:  the value for locating a partition is out of range.
  insert into t_month_1 values(1, timestamp without time zone '2015-01-01 00:00:00', 1);
--- 146,324 ----
  create table t_day_7(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-09-01') step(interval '7 day') partitions(10)
  distribute by shard(c1);
! ERROR:  only support interval partition by one day
  insert into t_day_7 values(1, timestamp without time zone '2015-08-31 13:11:00', 1);
! ERROR:  relation "t_day_7" does not exist
! LINE 1: insert into t_day_7 values(1, timestamp without time zone '2...
!                     ^
  select c1,c2,c3 from t_day_7 partition for(timestamp without time zone '2015-08-31 13:11:00');
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select c1,c2,c3 from t_day_7 partition for(timestamp without...
!                              ^
  insert into t_day_7 values(1, timestamp without time zone '2015-09-01 00:00:00', 1);
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 values(1, timestamp without time zone '2...
+                     ^
  select c1,c2,c3 from t_day_7 partition for(timestamp without time zone '2015-09-01 01:00:00');
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select c1,c2,c3 from t_day_7 partition for(timestamp without...
!                              ^
  insert into t_day_7 values(1, timestamp without time zone '2015-09-08 00:00:00', 1);
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 values(1, timestamp without time zone '2...
+                     ^
  select c1,c2,c3 from t_day_7 partition for(timestamp without time zone '2015-09-08 01:00:00');
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select c1,c2,c3 from t_day_7 partition for(timestamp without...
!                              ^
  insert into t_day_7 values(1, timestamp without time zone '2015-11-09 00:00:00', 1);
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 values(1, timestamp without time zone '2...
+                     ^
  select c1,c2,c3 from t_day_7 partition for(timestamp without time zone '2015-11-09 01:00:00');
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select c1,c2,c3 from t_day_7 partition for(timestamp without...
!                              ^
  insert into t_day_7 values(1, timestamp without time zone '2015-11-10 00:00:00', 1);
! ERROR:  relation "t_day_7" does not exist
! LINE 1: insert into t_day_7 values(1, timestamp without time zone '2...
!                     ^
  select c1,c2,c3 from t_day_7 partition for(timestamp without time zone '2015-11-10 00:00:00');
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select c1,c2,c3 from t_day_7 partition for(timestamp without...
!                              ^
  delete from t_day_7;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: delete from t_day_7;
+                     ^
  select count(1) from t_day_7;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select count(1) from t_day_7;
!                              ^
  insert into t_day_7 values(1, timestamp without time zone '2015-09-01 13:11:00', 1);
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 values(1, timestamp without time zone '2...
+                     ^
  insert into t_day_7 select generate_series(2,3), timestamp without time zone '2015-09-08 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(2,3), timestamp w...
+                     ^
  insert into t_day_7 select generate_series(4,7), timestamp without time zone '2015-09-15 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(4,7), timestamp w...
+                     ^
  insert into t_day_7 select generate_series(8,15), timestamp without time zone '2015-09-22 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(8,15), timestamp ...
+                     ^
  insert into t_day_7 select generate_series(16,31), timestamp without time zone '2015-09-29 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(16,31), timestamp...
+                     ^
  insert into t_day_7 select generate_series(32,63), timestamp without time zone '2015-10-06 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(32,63), timestamp...
+                     ^
  insert into t_day_7 select generate_series(64,127), timestamp without time zone '2015-10-13 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(64,127), timestam...
+                     ^
  insert into t_day_7 select generate_series(128,255), timestamp without time zone '2015-10-20 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(128,255), timesta...
+                     ^
  insert into t_day_7 select generate_series(256,511), timestamp without time zone '2015-10-27 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(256,511), timesta...
+                     ^
  insert into t_day_7 select generate_series(512,1023), timestamp without time zone '2015-11-03 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(512,1023), timest...
+                     ^
  --pruning--                
  select count(1) from t_day_7 where c2 < timestamp without time zone '2015-09-01 00:00:00';
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select count(1) from t_day_7 where c2 < timestamp without ti...
!                              ^
  select count(1) from t_day_7 where c2 <= timestamp without time zone '2015-09-01 00:00:00';
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select count(1) from t_day_7 where c2 <= timestamp without t...
!                              ^
  select count(1) from t_day_7 where c2 < timestamp without time zone '2015-09-01 14:00:00';
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select count(1) from t_day_7 where c2 < timestamp without ti...
!                              ^
  select count(1) from t_day_7 where c2 > timestamp without time zone '2015-09-01 01:00:00' and c2 < timestamp without time zone '2015-09-16 00:00:00';
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select count(1) from t_day_7 where c2 > timestamp without ti...
!                              ^
  select count(1) from t_day_7 where c2 > timestamp without time zone '2015-09-01 01:00:00' and c2 <= timestamp without time zone '2015-09-16 00:00:00';
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select count(1) from t_day_7 where c2 > timestamp without ti...
!                              ^
                             
  select count(1) from t_day_7 where c2 > timestamp without time zone '2015-11-10 13:00:00';
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select count(1) from t_day_7 where c2 > timestamp without ti...
!                              ^
                             
  select count(1) from t_day_7 where c2 > timestamp without time zone '2015-11-10 13:00:00' OR c2 < timestamp without time zone '2015-09-01 00:00:00';
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select count(1) from t_day_7 where c2 > timestamp without ti...
!                              ^
                             
  select count(1) from t_day_7 where c2 < timestamp without time zone '2015-09-13 01:00:00' OR c2 > timestamp without time zone '2015-10-27 00:00:00';
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select count(1) from t_day_7 where c2 < timestamp without ti...
!                              ^
  --update--
  update t_day_7 set c3=2 where c2 < timestamp without time zone '2015-09-01 00:00:00';
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: update t_day_7 set c3=2 where c2 < timestamp without time zo...
+                ^
  update t_day_7 set c3=3 where c2 > timestamp without time zone '2015-11-10 13:00:00';
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: update t_day_7 set c3=3 where c2 > timestamp without time zo...
+                ^
  update t_day_7 set c3=4 where c2 < timestamp without time zone '2015-09-09 00:00:00';
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: update t_day_7 set c3=4 where c2 < timestamp without time zo...
+                ^
  select * from t_day_7 where c3=2;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select * from t_day_7 where c3=2;
!                       ^
  select * from t_day_7 where c3=3;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select * from t_day_7 where c3=3;
!                       ^
  select * from t_day_7 where c3=4 order by c1;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select * from t_day_7 where c3=4 order by c1;
!                       ^
  --truncate --
  truncate table t_day_7 partition for(timestamp without time zone '2015-08-30 00:00:00');
! ERROR:  relation "t_day_7" does not exist
  truncate table t_day_7 partition for(timestamp without time zone '2015-09-09 00:00:00');
+ ERROR:  relation "t_day_7" does not exist
  select count(1) from t_day_7 partition for(timestamp without time zone '2015-09-09 00:00:00');
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select count(1) from t_day_7 partition for(timestamp without...
!                              ^
  select count(1) from t_day_7;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select count(1) from t_day_7;
!                              ^
  truncate table t_day_7 partition for(timestamp without time zone '2015-11-10 00:00:00');
! ERROR:  relation "t_day_7" does not exist
  drop table t_day_7;
+ ERROR:  table "t_day_7" does not exist
  -- 1 month interval -- 
  create table t_month_1(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-01-01') step(interval '1 month') partitions(24)
  distribute by shard(c1);
  insert into t_month_1 values(1, timestamp without time zone '2014-12-31 13:11:00', 1);
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_month_1 partition for(timestamp without time zone '2014-12-31 13:11:00');
  ERROR:  the value for locating a partition is out of range.
  insert into t_month_1 values(1, timestamp without time zone '2015-01-01 00:00:00', 1);
***************
*** 318,324 ****
  (1 row)
  
  insert into t_month_1 values(1, timestamp without time zone '2017-01-01 00:00:00', 1);
! ERROR:  value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_month_1 partition for(timestamp without time zone '2017-01-01 00:00:00');
  ERROR:  the value for locating a partition is out of range.
  delete from t_month_1;
--- 343,349 ----
  (1 row)
  
  insert into t_month_1 values(1, timestamp without time zone '2017-01-01 00:00:00', 1);
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_month_1 partition for(timestamp without time zone '2017-01-01 00:00:00');
  ERROR:  the value for locating a partition is out of range.
  delete from t_month_1;
***************
*** 436,444 ****
  create table t_month_3(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-01-01') step(interval '3 month') partitions(8)
  distribute by shard(c1);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into t_month_3 values(1, timestamp without time zone '2014-12-31 13:11:00', 1);
! ERROR:  value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_month_3 partition for(timestamp without time zone '2014-12-31 13:11:00');
  ERROR:  the value for locating a partition is out of range.
  insert into t_month_3 values(1, timestamp without time zone '2015-01-01 00:00:00', 1);
--- 461,468 ----
  create table t_month_3(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-01-01') step(interval '3 month') partitions(8)
  distribute by shard(c1);
  insert into t_month_3 values(1, timestamp without time zone '2014-12-31 13:11:00', 1);
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_month_3 partition for(timestamp without time zone '2014-12-31 13:11:00');
  ERROR:  the value for locating a partition is out of range.
  insert into t_month_3 values(1, timestamp without time zone '2015-01-01 00:00:00', 1);
***************
*** 463,469 ****
  (1 row)
  
  insert into t_month_3 values(1, timestamp without time zone '2017-01-01 00:00:00', 1);
! ERROR:  value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_month_3 partition for(timestamp without time zone '2017-01-01 00:00:00');
  ERROR:  the value for locating a partition is out of range.
  delete from t_month_3;
--- 487,493 ----
  (1 row)
  
  insert into t_month_3 values(1, timestamp without time zone '2017-01-01 00:00:00', 1);
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  select c1,c2,c3 from t_month_3 partition for(timestamp without time zone '2017-01-01 00:00:00');
  ERROR:  the value for locating a partition is out of range.
  delete from t_month_3;
***************
*** 591,599 ****
  create table t_year_1(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-01-01') step(interval '1 year') partitions(5)
  distribute by shard(c1);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into t_year_1 values(1, timestamp without time zone '2014-12-31 13:11:00', 1);
! ERROR:  value to inserted execeed range of partitioned table
  explain verbose select c1,c2,c3 from t_year_1 partition for(timestamp without time zone '2014-12-31 13:11:00');
  ERROR:  the value for locating a partition is out of range.
  select c1,c2,c3 from t_year_1 partition for(timestamp without time zone '2014-12-31 13:11:00');
--- 615,622 ----
  create table t_year_1(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-01-01') step(interval '1 year') partitions(5)
  distribute by shard(c1);
  insert into t_year_1 values(1, timestamp without time zone '2014-12-31 13:11:00', 1);
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  explain verbose select c1,c2,c3 from t_year_1 partition for(timestamp without time zone '2014-12-31 13:11:00');
  ERROR:  the value for locating a partition is out of range.
  select c1,c2,c3 from t_year_1 partition for(timestamp without time zone '2014-12-31 13:11:00');
***************
*** 653,659 ****
  (1 row)
  
  insert into t_year_1 values(1, timestamp without time zone '2020-01-01 00:00:00', 1);
! ERROR:  value to inserted execeed range of partitioned table
  explain verbose select c1,c2,c3 from t_year_1 partition for(timestamp without time zone '2020-01-01 00:00:00');
  ERROR:  the value for locating a partition is out of range.
  select c1,c2,c3 from t_year_1 partition for(timestamp without time zone '2020-01-01 00:00:00');
--- 676,682 ----
  (1 row)
  
  insert into t_year_1 values(1, timestamp without time zone '2020-01-01 00:00:00', 1);
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  explain verbose select c1,c2,c3 from t_year_1 partition for(timestamp without time zone '2020-01-01 00:00:00');
  ERROR:  the value for locating a partition is out of range.
  select c1,c2,c3 from t_year_1 partition for(timestamp without time zone '2020-01-01 00:00:00');
***************
*** 772,778 ****
  drop table t_year_1;
  --date partition: add partition & drop partiton--
  create table t_drop(f1 int not null,f2 timestamp not null,f3 varchar(10),primary key(f1)) partition by range (f2) begin (timestamp without time zone '2019-01-01 0:0:0') step (interval '1 month') partitions (2) distribute by shard(f1) to group default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  ALTER TABLE t_drop ADD PARTITIONS 2; 
  insert into t_drop select generate_series(1,10), timestamp without time zone '2019-01-31 23:23:59', 'aaa';
  insert into t_drop select generate_series(11,30), timestamp without time zone '2019-02-01 10:23:59', 'aaa';
--- 795,800 ----
***************
*** 853,862 ****
  delete from t_drop where f2 = timestamp without time zone '2019-02-01 00:00:00';
  delete from t_drop where f2 >= timestamp without time zone '2019-05-01 00:00:00' and f2< timestamp without time zone '2019-06-01 00:00:00';
  insert into t_drop values(130,'2019-02-01','a');
! ERROR:  value to inserted execeed range of partitioned table
  insert into t_drop values(130,'2019-03-01','multi-value'),(140,'2019-05-01','multi-value'),(150,'2019-06-01','multi-value');
  insert into t_drop select generate_series(200, 2226),'2019-02-01','a';
! ERROR:  inserted value is not in range of partitioned table, please check the value of paritition key
  insert into t_drop select generate_series(200, 2226),'2019-06-01','ffffff';
  copy t_drop from stdin;
  copy (select * from t_drop where f2 = timestamp without time zone '2019-07-01 00:00:00' order by 1,2,3) to stdout;
--- 875,884 ----
  delete from t_drop where f2 = timestamp without time zone '2019-02-01 00:00:00';
  delete from t_drop where f2 >= timestamp without time zone '2019-05-01 00:00:00' and f2< timestamp without time zone '2019-06-01 00:00:00';
  insert into t_drop values(130,'2019-02-01','a');
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  insert into t_drop values(130,'2019-03-01','multi-value'),(140,'2019-05-01','multi-value'),(150,'2019-06-01','multi-value');
  insert into t_drop select generate_series(200, 2226),'2019-02-01','a';
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_1,backend_pid:381309,message:inserted value is not in range of partitioned table, please check the value of paritition key
  insert into t_drop select generate_series(200, 2226),'2019-06-01','ffffff';
  copy t_drop from stdin;
  copy (select * from t_drop where f2 = timestamp without time zone '2019-07-01 00:00:00' order by 1,2,3) to stdout;
***************
*** 873,879 ****
  drop table t_drop;
  --int partition: add partition & drop partiton--
  create table int_drop(f1 bigint,f2 timestamp default now(), f3 integer) partition by range (f3) begin (1) step (50) partitions (2) distribute by shard(f1) to group default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  ALTER TABLE int_drop ADD PARTITIONS 2; 
  insert into int_drop select generate_series(1,10), null, 10;
  insert into int_drop select generate_series(51,70), null, 80;
--- 895,900 ----
***************
*** 958,968 ****
  delete from int_drop where f3 = 10;
  delete from int_drop where f3 >= 1 and f3< 201;
  insert into int_drop values(140,'2019-03-01',140,'aaa');
! ERROR:  value to inserted execeed range of partitioned table
  insert into int_drop values(90,'2019-02-01',90,'single-value-insert');
  insert into int_drop values(240,'2019-05-01',240,'multi-value-insert'),(280,'2019-06-01',280,'multi-value-insert'),(330,'2019-07-01',330,'multi-value-insert');
  insert into int_drop select generate_series(500, 2526),'2019-03-01',145,'a';
! ERROR:  inserted value is not in range of partitioned table, please check the value of paritition key
  insert into int_drop select generate_series(500, 2526),'2019-07-01',345,'ffffff';
  copy int_drop from stdin;
  copy (select * from int_drop where f3 > 400 order by f1) to stdout;
--- 979,989 ----
  delete from int_drop where f3 = 10;
  delete from int_drop where f3 >= 1 and f3< 201;
  insert into int_drop values(140,'2019-03-01',140,'aaa');
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:value to inserted execeed range of partitioned table
  insert into int_drop values(90,'2019-02-01',90,'single-value-insert');
  insert into int_drop values(240,'2019-05-01',240,'multi-value-insert'),(280,'2019-06-01',280,'multi-value-insert'),(330,'2019-07-01',330,'multi-value-insert');
  insert into int_drop select generate_series(500, 2526),'2019-03-01',145,'a';
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_2,backend_pid:381336,message:inserted value is not in range of partitioned table, please check the value of paritition key
  insert into int_drop select generate_series(500, 2526),'2019-07-01',345,'ffffff';
  copy int_drop from stdin;
  copy (select * from int_drop where f3 > 400 order by f1) to stdout;
***************
*** 985,991 ****
  step (interval '1 month') partitions (12)
  distribute by shard (a)
  to group default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into t_in_test values(1,1,'20170901');
  insert into t_in_test values(2,2,'20171001');
  insert into t_in_test values(3,3,'20171101');
--- 1006,1011 ----
***************
*** 1023,1032 ****
  step (interval '1 day') partitions (3)
  distribute by shard(a)
  to group default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into t_time_range values(1, 1, '2022-02-28');
  insert into t_time_range values(1, 1, '2022-03-1');
! ERROR:  value to inserted execeed range of partitioned table
  ALTER TABLE t_time_range ADD PARTITIONS 1;
  insert into t_time_range values(1, 1, '2022-03-1');
  drop table t_time_range;
--- 1043,1051 ----
  step (interval '1 day') partitions (3)
  distribute by shard(a)
  to group default_group;
  insert into t_time_range values(1, 1, '2022-02-28');
  insert into t_time_range values(1, 1, '2022-03-1');
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  ALTER TABLE t_time_range ADD PARTITIONS 1;
  insert into t_time_range values(1, 1, '2022-03-1');
  drop table t_time_range;
***************
*** 1036,1047 ****
  step (interval '1 day') partitions (1)
  distribute by shard(a)
  to group default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into t_time_range values(1, 1, '2022-02-26');
  ALTER TABLE t_time_range ADD PARTITIONS 2;
  insert into t_time_range values(1, 1, '2022-02-28');
  insert into t_time_range values(1, 1, '2022-03-1');
! ERROR:  value to inserted execeed range of partitioned table
  ALTER TABLE t_time_range ADD PARTITIONS 1;
  insert into t_time_range values(1, 1, '2022-03-1');
  drop table t_time_range;
--- 1055,1065 ----
  step (interval '1 day') partitions (1)
  distribute by shard(a)
  to group default_group;
  insert into t_time_range values(1, 1, '2022-02-26');
  ALTER TABLE t_time_range ADD PARTITIONS 2;
  insert into t_time_range values(1, 1, '2022-02-28');
  insert into t_time_range values(1, 1, '2022-03-1');
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  ALTER TABLE t_time_range ADD PARTITIONS 1;
  insert into t_time_range values(1, 1, '2022-03-1');
  drop table t_time_range;
***************
*** 1052,1063 ****
  step (interval '1 day') partitions (3)
  distribute by shard(a)
  to group default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into t_time_range values(1, 1, '2020-02-26');
  insert into t_time_range values(1, 1, '2020-02-27');
  insert into t_time_range values(1, 1, '2020-02-28');
  insert into t_time_range values(1, 1, '2020-02-29');
! ERROR:  value to inserted execeed range of partitioned table
  ALTER TABLE t_time_range ADD PARTITIONS 2;
  insert into t_time_range values(1, 1, '2020-02-29');
  insert into t_time_range values(1, 1, '2020-03-01');
--- 1070,1080 ----
  step (interval '1 day') partitions (3)
  distribute by shard(a)
  to group default_group;
  insert into t_time_range values(1, 1, '2020-02-26');
  insert into t_time_range values(1, 1, '2020-02-27');
  insert into t_time_range values(1, 1, '2020-02-28');
  insert into t_time_range values(1, 1, '2020-02-29');
! ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:value to inserted execeed range of partitioned table
  ALTER TABLE t_time_range ADD PARTITIONS 2;
  insert into t_time_range values(1, 1, '2020-02-29');
  insert into t_time_range values(1, 1, '2020-03-01');

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/partition_index.out"	2025-07-31 16:07:14.994067993 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/partition_index.out"	2025-07-31 16:38:17.445626245 +0800
***************
*** 2,8 ****
  create table t_day_1(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-09-01') step(interval '1 day') partitions(23)
  distribute by shard(c1);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  create index t_day_1_c1 on t_day_1(c1);
  create index t_day_1_c2 on t_day_1(c2);
  insert into t_day_1 values(1, timestamp without time zone '2015-09-01 13:11:00', 1);
--- 2,7 ----
***************
*** 142,286 ****
  create table t_day_7(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-09-01') step(interval '7 day') partitions(10)
  distribute by shard(c1);
! NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  create index t_day_7_c1 on t_day_7(c1);
  create index t_day_7_c2 on t_day_7(c2);
  insert into t_day_7 values(1, timestamp without time zone '2015-09-01 13:11:00', 1);
  insert into t_day_7 select generate_series(2,3), timestamp without time zone '2015-09-08 13:11:00', 1;
  insert into t_day_7 select generate_series(4,7), timestamp without time zone '2015-09-15 13:11:00', 1;
  insert into t_day_7 select generate_series(8,15), timestamp without time zone '2015-09-22 13:11:00', 1;
  insert into t_day_7 select generate_series(16,31), timestamp without time zone '2015-09-29 13:11:00', 1;
  insert into t_day_7 select generate_series(32,63), timestamp without time zone '2015-10-06 13:11:00', 1;
  insert into t_day_7 select generate_series(64,127), timestamp without time zone '2015-10-13 13:11:00', 1;
  insert into t_day_7 select generate_series(128,255), timestamp without time zone '2015-10-20 13:11:00', 1;
  insert into t_day_7 select generate_series(256,511), timestamp without time zone '2015-10-27 13:11:00', 1;
  insert into t_day_7 select generate_series(512,1023), timestamp without time zone '2015-11-03 13:11:00', 1;
  --create index when table is not empty--
  create index t_day_7_c3_c2 on t_day_7(c3,c2);
  --not-partition key --
   
  select c1,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c1;
!  c1 |            c2            
! ----+--------------------------
!   1 | Tue Sep 01 13:11:00 2015
!   2 | Tue Sep 08 13:11:00 2015
!   3 | Tue Sep 08 13:11:00 2015
!   4 | Tue Sep 15 13:11:00 2015
!   5 | Tue Sep 15 13:11:00 2015
!   6 | Tue Sep 15 13:11:00 2015
!   7 | Tue Sep 15 13:11:00 2015
! (7 rows)
! 
   
  select c1,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c1 limit 5;
!  c1 |            c2            
! ----+--------------------------
!   1 | Tue Sep 01 13:11:00 2015
!   2 | Tue Sep 08 13:11:00 2015
!   3 | Tue Sep 08 13:11:00 2015
!   4 | Tue Sep 15 13:11:00 2015
!   5 | Tue Sep 15 13:11:00 2015
! (5 rows)
! 
  select shardid,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c1 limit 5;
!  shardid |            c2            
! ---------+--------------------------
!     2234 | Tue Sep 01 13:11:00 2015
!     3318 | Tue Sep 08 13:11:00 2015
!      105 | Tue Sep 08 13:11:00 2015
!      213 | Tue Sep 15 13:11:00 2015
!     2692 | Tue Sep 15 13:11:00 2015
! (5 rows)
! 
  select shardid,c1+c3 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c1 limit 5;
!  shardid | ?column? 
! ---------+----------
!     2234 |        2
!     3318 |        3
!      105 |        4
!      213 |        5
!     2692 |        6
! (5 rows)
! 
  --partition key --
  select c1,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c2;
!  c1 |            c2            
! ----+--------------------------
!   1 | Tue Sep 01 13:11:00 2015
!   2 | Tue Sep 08 13:11:00 2015
!   3 | Tue Sep 08 13:11:00 2015
!   4 | Tue Sep 15 13:11:00 2015
!   7 | Tue Sep 15 13:11:00 2015
!   5 | Tue Sep 15 13:11:00 2015
!   6 | Tue Sep 15 13:11:00 2015
! (7 rows)
! 
  select c1,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c2 limit 5;
!  c1 |            c2            
! ----+--------------------------
!   1 | Tue Sep 01 13:11:00 2015
!   2 | Tue Sep 08 13:11:00 2015
!   3 | Tue Sep 08 13:11:00 2015
!   4 | Tue Sep 15 13:11:00 2015
!   7 | Tue Sep 15 13:11:00 2015
! (5 rows)
! 
  select c1,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c2 desc limit 5;
!  c1 |            c2            
! ----+--------------------------
!   5 | Tue Sep 15 13:11:00 2015
!   6 | Tue Sep 15 13:11:00 2015
!   4 | Tue Sep 15 13:11:00 2015
!   7 | Tue Sep 15 13:11:00 2015
!   3 | Tue Sep 08 13:11:00 2015
! (5 rows)
! 
  select shardid,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c2 limit 5;
!  shardid |            c2            
! ---------+--------------------------
!     2234 | Tue Sep 01 13:11:00 2015
!     3318 | Tue Sep 08 13:11:00 2015
!      105 | Tue Sep 08 13:11:00 2015
!      213 | Tue Sep 15 13:11:00 2015
!     1025 | Tue Sep 15 13:11:00 2015
! (5 rows)
! 
  select shardid,c1+c3 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c2 limit 5;
!  shardid | ?column? 
! ---------+----------
!     2234 |        2
!     3318 |        3
!      105 |        4
!      213 |        5
!     1025 |        8
! (5 rows)
! 
  select shardid,c1+c3 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c3,c2 limit 5;
!  shardid | ?column? 
! ---------+----------
!     2234 |        2
!     3318 |        3
!      105 |        4
!      213 |        5
!     1025 |        8
! (5 rows)
! 
  select shardid,c1 from t_day_7 where c2 < timestamp without time zone '2015-09-20' and mod(c1,2) = 1 order by c1 desc limit 5;
!  shardid | c1 
! ---------+----
!     1025 |  7
!     2692 |  5
!      105 |  3
!     2234 |  1
! (4 rows)
! 
  drop index t_day_7_c3_c2;
  drop table t_day_7;
  -- 3 month interval --
  create table t_month_3(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-01-01') step(interval '3 month') partitions(8)
  distribute by shard(c1);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  create index t_month_3_c1 on t_month_3(c1);
  create index t_month_3_c2 on t_month_3(c2);
  insert into t_month_3 values(1, timestamp without time zone '2015-01-01 13:11:00', 1);
--- 141,250 ----
  create table t_day_7(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-09-01') step(interval '7 day') partitions(10)
  distribute by shard(c1);
! ERROR:  only support interval partition by one day
  create index t_day_7_c1 on t_day_7(c1);
+ ERROR:  relation "t_day_7" does not exist
  create index t_day_7_c2 on t_day_7(c2);
+ ERROR:  relation "t_day_7" does not exist
  insert into t_day_7 values(1, timestamp without time zone '2015-09-01 13:11:00', 1);
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 values(1, timestamp without time zone '2...
+                     ^
  insert into t_day_7 select generate_series(2,3), timestamp without time zone '2015-09-08 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(2,3), timestamp w...
+                     ^
  insert into t_day_7 select generate_series(4,7), timestamp without time zone '2015-09-15 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(4,7), timestamp w...
+                     ^
  insert into t_day_7 select generate_series(8,15), timestamp without time zone '2015-09-22 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(8,15), timestamp ...
+                     ^
  insert into t_day_7 select generate_series(16,31), timestamp without time zone '2015-09-29 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(16,31), timestamp...
+                     ^
  insert into t_day_7 select generate_series(32,63), timestamp without time zone '2015-10-06 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(32,63), timestamp...
+                     ^
  insert into t_day_7 select generate_series(64,127), timestamp without time zone '2015-10-13 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(64,127), timestam...
+                     ^
  insert into t_day_7 select generate_series(128,255), timestamp without time zone '2015-10-20 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(128,255), timesta...
+                     ^
  insert into t_day_7 select generate_series(256,511), timestamp without time zone '2015-10-27 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(256,511), timesta...
+                     ^
  insert into t_day_7 select generate_series(512,1023), timestamp without time zone '2015-11-03 13:11:00', 1;
+ ERROR:  relation "t_day_7" does not exist
+ LINE 1: insert into t_day_7 select generate_series(512,1023), timest...
+                     ^
  --create index when table is not empty--
  create index t_day_7_c3_c2 on t_day_7(c3,c2);
+ ERROR:  relation "t_day_7" does not exist
  --not-partition key --
   
  select c1,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c1;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select c1,c2 from t_day_7 where c2 < timestamp without time ...
!                           ^
   
  select c1,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c1 limit 5;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select c1,c2 from t_day_7 where c2 < timestamp without time ...
!                           ^
  select shardid,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c1 limit 5;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select shardid,c2 from t_day_7 where c2 < timestamp without ...
!                                ^
  select shardid,c1+c3 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c1 limit 5;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select shardid,c1+c3 from t_day_7 where c2 < timestamp witho...
!                                   ^
  --partition key --
  select c1,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c2;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select c1,c2 from t_day_7 where c2 < timestamp without time ...
!                           ^
  select c1,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c2 limit 5;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select c1,c2 from t_day_7 where c2 < timestamp without time ...
!                           ^
  select c1,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c2 desc limit 5;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select c1,c2 from t_day_7 where c2 < timestamp without time ...
!                           ^
  select shardid,c2 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c2 limit 5;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select shardid,c2 from t_day_7 where c2 < timestamp without ...
!                                ^
  select shardid,c1+c3 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c2 limit 5;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select shardid,c1+c3 from t_day_7 where c2 < timestamp witho...
!                                   ^
  select shardid,c1+c3 from t_day_7 where c2 < timestamp without time zone '2015-09-20' order by c3,c2 limit 5;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select shardid,c1+c3 from t_day_7 where c2 < timestamp witho...
!                                   ^
  select shardid,c1 from t_day_7 where c2 < timestamp without time zone '2015-09-20' and mod(c1,2) = 1 order by c1 desc limit 5;
! ERROR:  relation "t_day_7" does not exist
! LINE 1: select shardid,c1 from t_day_7 where c2 < timestamp without ...
!                                ^
  drop index t_day_7_c3_c2;
+ ERROR:  index "t_day_7_c3_c2" does not exist
  drop table t_day_7;
+ ERROR:  table "t_day_7" does not exist
  -- 3 month interval --
  create table t_month_3(c1 int, c2 timestamp without time zone, c3 int)
  partition by range(c2) begin(timestamp without time zone '2015-01-01') step(interval '3 month') partitions(8)
  distribute by shard(c1);
  create index t_month_3_c1 on t_month_3(c1);
  create index t_month_3_c2 on t_month_3(c2);
  insert into t_month_3 values(1, timestamp without time zone '2015-01-01 13:11:00', 1);
***************
*** 439,445 ****
  drop table t_month_3;
  --add partition & drop partiton--
  create table t_drop(f1 int not null,f2 timestamp not null,f3 varchar(10),primary key(f1)) partition by range (f2) begin (timestamp without time zone '2019-01-01 0:0:0') step (interval '1 month') partitions (2) distribute by shard(f1) to group default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  ALTER TABLE t_drop ADD PARTITIONS 2; 
  insert into t_drop select generate_series(1,10), timestamp without time zone '2019-01-31 23:23:59', 'aaa';
  insert into t_drop select generate_series(11,30), timestamp without time zone '2019-02-01 10:23:59', 'aaa';
--- 403,408 ----
***************
*** 502,508 ****
  drop table t_drop;
  --int add partition & drop partiton--
  create table int_drop(f1 bigint,f2 timestamp default now(), f3 integer) partition by range (f3) begin (1) step (50) partitions (2) distribute by shard(f1) to group default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  ALTER TABLE int_drop ADD PARTITIONS 2; 
  insert into int_drop select generate_series(1,10), null, 10;
  insert into int_drop select generate_series(51,70), null, 80;
--- 465,470 ----

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/alter_node.out"	2025-07-31 16:07:14.977847998 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/alter_node.out"	2025-07-31 16:38:17.478364165 +0800
***************
*** 40,45 ****
--- 40,46 ----
  
  --case_4:
  drop node cn01;
+ WARNING:  this node[17341] is not exist in any group.
  --expect:
  --only cn01 in opentenbase_cluster dropped.
  select node_name,node_type,node_port,node_host,node_cluster_name from pgxc_node where node_name in ('cn01', 'cn01_1')order by oid;
***************
*** 51,57 ****
--- 52,60 ----
  
  --case_5:
  drop node cn01_1 in opentenbase_cluster;
+ WARNING:  this node[17340] is not exist in any group.
  drop node cn01 in pgxc_cluster_slave;
+ WARNING:  this node[17342] is not exist in any group.
  --expect
  --cn01 in pgxc_cluster_slave dropped, cn01_1 dropped.
  select node_name,node_type,node_port,node_host,node_cluster_name from pgxc_node where node_name in ('cn01', 'cn01_1')order by oid;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/tablespace.out"	2025-07-31 16:37:23.179023441 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/tablespace.out"	2025-07-31 16:38:18.598601304 +0800
***************
*** 171,176 ****
--- 171,177 ----
  SET default_tablespace TO regress_tblspace;
  -- tablespace should not change if no rewrite
  ALTER TABLE testschema.test_default_tab ALTER id TYPE bigint;
+ ERROR:  cannot alter type of column named in distributed key
  \d testschema.test_index1
  Index "testschema.test_index1"
   Column |  Type  | Definition 
***************
*** 194,211 ****
  
  -- tablespace should not change even if there is an index rewrite
  ALTER TABLE testschema.test_default_tab ALTER id TYPE int;
  \d testschema.test_index1
  Index "testschema.test_index1"
!  Column |  Type   | Definition 
! --------+---------+------------
!  id     | integer | id
  btree, for table "testschema.test_default_tab"
  
  \d testschema.test_index2
  Index "testschema.test_index2"
!  Column |  Type   | Definition 
! --------+---------+------------
!  id     | integer | id
  btree, for table "testschema.test_default_tab"
  Tablespace: "regress_tblspace"
  
--- 195,213 ----
  
  -- tablespace should not change even if there is an index rewrite
  ALTER TABLE testschema.test_default_tab ALTER id TYPE int;
+ ERROR:  cannot alter type of column named in distributed key
  \d testschema.test_index1
  Index "testschema.test_index1"
!  Column |  Type  | Definition 
! --------+--------+------------
!  id     | bigint | id
  btree, for table "testschema.test_default_tab"
  
  \d testschema.test_index2
  Index "testschema.test_index2"
!  Column |  Type  | Definition 
! --------+--------+------------
!  id     | bigint | id
  btree, for table "testschema.test_default_tab"
  Tablespace: "regress_tblspace"
  
***************
*** 219,241 ****
  SET default_tablespace TO '';
  -- tablespace should not change if no rewrite
  ALTER TABLE testschema.test_default_tab ALTER id TYPE int;
  \d testschema.test_index1
  Index "testschema.test_index1"
!  Column |  Type   | Definition 
! --------+---------+------------
!  id     | integer | id
  btree, for table "testschema.test_default_tab"
  
  \d testschema.test_index2
  Index "testschema.test_index2"
!  Column |  Type   | Definition 
! --------+---------+------------
!  id     | integer | id
  btree, for table "testschema.test_default_tab"
  Tablespace: "regress_tblspace"
  
  -- tablespace should not change even if there is an index rewrite
  ALTER TABLE testschema.test_default_tab ALTER id TYPE bigint;
  \d testschema.test_index1
  Index "testschema.test_index1"
   Column |  Type  | Definition 
--- 221,245 ----
  SET default_tablespace TO '';
  -- tablespace should not change if no rewrite
  ALTER TABLE testschema.test_default_tab ALTER id TYPE int;
+ ERROR:  cannot alter type of column named in distributed key
  \d testschema.test_index1
  Index "testschema.test_index1"
!  Column |  Type  | Definition 
! --------+--------+------------
!  id     | bigint | id
  btree, for table "testschema.test_default_tab"
  
  \d testschema.test_index2
  Index "testschema.test_index2"
!  Column |  Type  | Definition 
! --------+--------+------------
!  id     | bigint | id
  btree, for table "testschema.test_default_tab"
  Tablespace: "regress_tblspace"
  
  -- tablespace should not change even if there is an index rewrite
  ALTER TABLE testschema.test_default_tab ALTER id TYPE bigint;
+ ERROR:  cannot alter type of column named in distributed key
  \d testschema.test_index1
  Index "testschema.test_index1"
   Column |  Type  | Definition 
***************
*** 427,449 ****
  DROP TABLE testschema.test_tab;
  -- let's try moving a table from one place to another
  CREATE TABLE testschema.atable AS VALUES (1), (2);
  CREATE UNIQUE INDEX anindex ON testschema.atable(column1);
  ALTER TABLE testschema.atable SET TABLESPACE regress_tblspace;
  ALTER INDEX testschema.anindex SET TABLESPACE regress_tblspace;
  ALTER INDEX testschema.part_a_idx SET TABLESPACE pg_global;
  ERROR:  only shared relations can be placed in pg_global tablespace
  ALTER INDEX testschema.part_a_idx SET TABLESPACE pg_default;
  ALTER INDEX testschema.part_a_idx SET TABLESPACE regress_tblspace;
  INSERT INTO testschema.atable VALUES(3);	-- ok
  INSERT INTO testschema.atable VALUES(1);	-- fail (checks index)
! ERROR:  duplicate key value violates unique constraint "anindex"
! DETAIL:  Key (column1)=(1) already exists.
  SELECT COUNT(*) FROM testschema.atable;		-- checks heap
!  count 
! -------
!      3
! (1 row)
! 
  -- Will fail with bad path
  CREATE TABLESPACE regress_badspace LOCATION '/no/such/location';
  ERROR:  directory "/no/such/location" does not exist
--- 431,460 ----
  DROP TABLE testschema.test_tab;
  -- let's try moving a table from one place to another
  CREATE TABLE testschema.atable AS VALUES (1), (2);
+ ERROR:  node:datanode_1, backend_pid:381309, nodename:datanode_1,backend_pid:381309,message:null value in column "column1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  CREATE UNIQUE INDEX anindex ON testschema.atable(column1);
+ ERROR:  relation "testschema.atable" does not exist
  ALTER TABLE testschema.atable SET TABLESPACE regress_tblspace;
+ ERROR:  relation "testschema.atable" does not exist
  ALTER INDEX testschema.anindex SET TABLESPACE regress_tblspace;
+ ERROR:  relation "testschema.anindex" does not exist
  ALTER INDEX testschema.part_a_idx SET TABLESPACE pg_global;
  ERROR:  only shared relations can be placed in pg_global tablespace
  ALTER INDEX testschema.part_a_idx SET TABLESPACE pg_default;
  ALTER INDEX testschema.part_a_idx SET TABLESPACE regress_tblspace;
  INSERT INTO testschema.atable VALUES(3);	-- ok
+ ERROR:  relation "testschema.atable" does not exist
+ LINE 1: INSERT INTO testschema.atable VALUES(3);
+                     ^
  INSERT INTO testschema.atable VALUES(1);	-- fail (checks index)
! ERROR:  relation "testschema.atable" does not exist
! LINE 1: INSERT INTO testschema.atable VALUES(1);
!                     ^
  SELECT COUNT(*) FROM testschema.atable;		-- checks heap
! ERROR:  relation "testschema.atable" does not exist
! LINE 1: SELECT COUNT(*) FROM testschema.atable;
!                              ^
  -- Will fail with bad path
  CREATE TABLESPACE regress_badspace LOCATION '/no/such/location';
  ERROR:  directory "/no/such/location" does not exist
***************
*** 465,470 ****
--- 476,482 ----
  CREATE TABLE tablespace_table (i int) TABLESPACE regress_tblspace; -- fail
  ERROR:  permission denied for tablespace regress_tblspace
  ALTER TABLE testschema.tablespace_acl ALTER c TYPE bigint;
+ ERROR:  cannot alter type of column named in distributed key
  RESET ROLE;
  ALTER TABLESPACE regress_tblspace RENAME TO regress_tblspace_renamed;
  ALTER TABLE ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
***************
*** 475,485 ****
  -- Should succeed
  DROP TABLESPACE regress_tblspace_renamed;
  DROP SCHEMA testschema CASCADE;
! NOTICE:  drop cascades to 5 other objects
  DETAIL:  drop cascades to table testschema.foo
  drop cascades to table testschema.asselect
  drop cascades to table testschema.part
- drop cascades to table testschema.atable
  drop cascades to table testschema.tablespace_acl
  DROP ROLE regress_tablespace_user1;
  DROP ROLE regress_tablespace_user2;
--- 487,496 ----
  -- Should succeed
  DROP TABLESPACE regress_tblspace_renamed;
  DROP SCHEMA testschema CASCADE;
! NOTICE:  drop cascades to 4 other objects
  DETAIL:  drop cascades to table testschema.foo
  drop cascades to table testschema.asselect
  drop cascades to table testschema.part
  drop cascades to table testschema.tablespace_acl
  DROP ROLE regress_tablespace_user1;
  DROP ROLE regress_tablespace_user2;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/text.out"	2025-07-31 16:07:15.004067834 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/text.out"	2025-07-31 16:38:19.126175271 +0800
***************
*** 47,56 ****
  
  -- but not this:
  select 3 || 4.0;
! ERROR:  operator does not exist: integer || numeric
! LINE 1: select 3 || 4.0;
!                  ^
! HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
  /*
   * various string functions
   */
--- 47,57 ----
  
  -- but not this:
  select 3 || 4.0;
!  ?column? 
! ----------
!  34.0
! (1 row)
! 
  /*
   * various string functions
   */

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/int2.out"	2025-07-31 16:07:14.986068121 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/int2.out"	2025-07-31 16:38:19.810575094 +0800
***************
*** 158,164 ****
  (3 rows)
  
  SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i ORDER BY f1;
! ERROR:  smallint out of range
  SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i
  WHERE abs(f1) < 16384 ORDER BY f1;
   five |  f1   |   x   
--- 158,164 ----
  (3 rows)
  
  SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i ORDER BY f1;
! ERROR:  node:datanode_2, backend_pid:381934, nodename:datanode_1,backend_pid:381319,message:smallint out of range
  SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i
  WHERE abs(f1) < 16384 ORDER BY f1;
   five |  f1   |   x   
***************
*** 179,185 ****
  (5 rows)
  
  SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i ORDER BY f1;
! ERROR:  smallint out of range
  SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i
  WHERE f1 < 32766 ORDER BY f1;
   five |   f1   |   x    
--- 179,185 ----
  (5 rows)
  
  SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i ORDER BY f1;
! ERROR:  node:datanode_1, backend_pid:381326, nodename:datanode_1,backend_pid:381326,message:smallint out of range
  SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i
  WHERE f1 < 32766 ORDER BY f1;
   five |   f1   |   x    
***************
*** 201,207 ****
  (5 rows)
  
  SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i ORDER BY f1;
! ERROR:  smallint out of range
  SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i
  WHERE f1 > -32767 ORDER BY f1;
   five |  f1   |   x   
--- 201,207 ----
  (5 rows)
  
  SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i ORDER BY f1;
! ERROR:  node:datanode_2, backend_pid:381328, nodename:datanode_2,backend_pid:381328,message:smallint out of range
  SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i
  WHERE f1 > -32767 ORDER BY f1;
   five |  f1   |   x   

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/int4.out"	2025-07-31 16:07:14.986068121 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/int4.out"	2025-07-31 16:38:19.777575807 +0800
***************
*** 160,166 ****
  (3 rows)
  
  SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  integer out of range
  SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i
  WHERE abs(f1) < 1073741824 ORDER BY f1;
   five |   f1    |    x    
--- 160,166 ----
  (3 rows)
  
  SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  node:datanode_1, backend_pid:381937, nodename:datanode_1,backend_pid:381937,message:integer out of range
  SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i
  WHERE abs(f1) < 1073741824 ORDER BY f1;
   five |   f1    |    x    
***************
*** 171,177 ****
  (3 rows)
  
  SELECT '' AS five, i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  integer out of range
  SELECT '' AS five, i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i
  WHERE abs(f1) < 1073741824 ORDER BY f1;
   five |   f1    |    x    
--- 171,177 ----
  (3 rows)
  
  SELECT '' AS five, i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  node:datanode_1, backend_pid:381914, nodename:datanode_1,backend_pid:381914,message:integer out of range
  SELECT '' AS five, i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i
  WHERE abs(f1) < 1073741824 ORDER BY f1;
   five |   f1    |    x    
***************
*** 182,188 ****
  (3 rows)
  
  SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  integer out of range
  SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i
  WHERE f1 < 2147483646 ORDER BY f1;
   five |     f1      |      x      
--- 182,188 ----
  (3 rows)
  
  SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  node:datanode_1, backend_pid:381913, nodename:datanode_1,backend_pid:381913,message:integer out of range
  SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i
  WHERE f1 < 2147483646 ORDER BY f1;
   five |     f1      |      x      
***************
*** 194,200 ****
  (4 rows)
  
  SELECT '' AS five, i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  integer out of range
  SELECT '' AS five, i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i
  WHERE f1 < 2147483646 ORDER BY f1;
   five |     f1      |      x      
--- 194,200 ----
  (4 rows)
  
  SELECT '' AS five, i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  node:datanode_1, backend_pid:381317, nodename:datanode_1,backend_pid:381317,message:integer out of range
  SELECT '' AS five, i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i
  WHERE f1 < 2147483646 ORDER BY f1;
   five |     f1      |      x      
***************
*** 206,212 ****
  (4 rows)
  
  SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  integer out of range
  SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i
  WHERE f1 > -2147483647 ORDER BY f1;
   five |     f1     |     x      
--- 206,212 ----
  (4 rows)
  
  SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  node:datanode_1, backend_pid:381319, nodename:datanode_1,backend_pid:381319,message:integer out of range
  SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i
  WHERE f1 > -2147483647 ORDER BY f1;
   five |     f1     |     x      
***************
*** 218,224 ****
  (4 rows)
  
  SELECT '' AS five, i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  integer out of range
  SELECT '' AS five, i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i
  WHERE f1 > -2147483647 ORDER BY f1;
   five |     f1     |     x      
--- 218,224 ----
  (4 rows)
  
  SELECT '' AS five, i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i ORDER BY f1;
! ERROR:  node:datanode_1, backend_pid:381932, nodename:datanode_1,backend_pid:381932,message:integer out of range
  SELECT '' AS five, i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i
  WHERE f1 > -2147483647 ORDER BY f1;
   five |     f1     |     x      

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/int8.out"	2025-07-31 16:07:14.986068121 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/int8.out"	2025-07-31 16:38:20.035570228 +0800
***************
*** 310,316 ****
  (5 rows)
  
  SELECT '' AS three, q1, q2, q1 * q2 AS multiply FROM INT8_TBL ORDER BY q1,q2;
! ERROR:  bigint out of range
  SELECT '' AS three, q1, q2, q1 * q2 AS multiply FROM INT8_TBL
   WHERE q1 < 1000 or (q2 > 0 and q2 < 1000) ORDER BY q1,q2;
   three |        q1        |        q2        |      multiply      
--- 310,316 ----
  (5 rows)
  
  SELECT '' AS three, q1, q2, q1 * q2 AS multiply FROM INT8_TBL ORDER BY q1,q2;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:bigint out of range
  SELECT '' AS three, q1, q2, q1 * q2 AS multiply FROM INT8_TBL
   WHERE q1 < 1000 or (q2 > 0 and q2 < 1000) ORDER BY q1,q2;
   three |        q1        |        q2        |      multiply      
***************
*** 712,718 ****
  (1 row)
  
  SELECT CAST(q1 AS int4) FROM int8_tbl WHERE q2 <> 456 ORDER BY q1;
! ERROR:  integer out of range
  SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 = 456 ORDER BY q1;
   q1  
  -----
--- 712,718 ----
  (1 row)
  
  SELECT CAST(q1 AS int4) FROM int8_tbl WHERE q2 <> 456 ORDER BY q1;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:integer out of range
  SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 = 456 ORDER BY q1;
   q1  
  -----
***************
*** 720,726 ****
  (1 row)
  
  SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 <> 456 ORDER BY q1;
! ERROR:  smallint out of range
  SELECT CAST('42'::int2 AS int8), CAST('-37'::int2 AS int8);
   int8 | int8 
  ------+------
--- 720,726 ----
  (1 row)
  
  SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 <> 456 ORDER BY q1;
! ERROR:  node:datanode_1, backend_pid:381319, nodename:datanode_1,backend_pid:381319,message:smallint out of range
  SELECT CAST('42'::int2 AS int8), CAST('-37'::int2 AS int8);
   int8 | int8 
  ------+------
***************
*** 746,752 ****
  SELECT CAST('922337203685477580700.0'::float8 AS int8);
  ERROR:  bigint out of range
  SELECT CAST(q1 AS oid) FROM INT8_TBL ORDER BY q1;
! ERROR:  OID out of range
  SELECT oid::int8 FROM pg_class WHERE relname = 'pg_class' ORDER BY oid;
   oid  
  ------
--- 746,752 ----
  SELECT CAST('922337203685477580700.0'::float8 AS int8);
  ERROR:  bigint out of range
  SELECT CAST(q1 AS oid) FROM INT8_TBL ORDER BY q1;
! ERROR:  node:datanode_1, backend_pid:381319, nodename:datanode_1,backend_pid:381319,message:OID out of range
  SELECT oid::int8 FROM pg_class WHERE relname = 'pg_class' ORDER BY oid;
   oid  
  ------

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/float4_1.out"	2025-07-31 16:07:14.982068184 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/float4.out"	2025-07-31 16:38:19.685577796 +0800
***************
*** 222,228 ****
  
  -- test divide by zero
  SELECT '' AS bad, f.f1 / '0.0' from FLOAT4_TBL f;
! ERROR:  division by zero
  SELECT '' AS five, * FROM FLOAT4_TBL ORDER BY f1;
   five |     f1      
  ------+-------------
--- 222,228 ----
  
  -- test divide by zero
  SELECT '' AS bad, f.f1 / '0.0' from FLOAT4_TBL f;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_1,backend_pid:381315,message:division by zero
  SELECT '' AS five, * FROM FLOAT4_TBL ORDER BY f1;
   five |     f1      
  ------+-------------

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/float8.out"	2025-07-31 16:07:14.983068168 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/float8.out"	2025-07-31 16:38:19.911572909 +0800
***************
*** 383,391 ****
     WHERE FLOAT8_TBL.f1 > '0.0';
     
  SELECT '' AS bad, f.f1 * '1e200' from FLOAT8_TBL f ORDER BY f1;
! ERROR:  value out of range: overflow
  SELECT '' AS bad, f.f1 ^ '1e200' from FLOAT8_TBL f ORDER BY f1;
! ERROR:  value out of range: overflow
  SELECT 0 ^ 0 + 0 ^ 1 + 0 ^ 0.0 + 0 ^ 0.5;
   ?column? 
  ----------
--- 383,391 ----
     WHERE FLOAT8_TBL.f1 > '0.0';
     
  SELECT '' AS bad, f.f1 * '1e200' from FLOAT8_TBL f ORDER BY f1;
! ERROR:  node:datanode_1, backend_pid:381913, nodename:datanode_1,backend_pid:381913,message:value out of range: overflow
  SELECT '' AS bad, f.f1 ^ '1e200' from FLOAT8_TBL f ORDER BY f1;
! ERROR:  node:datanode_1, backend_pid:381319, nodename:datanode_1,backend_pid:381319,message:value out of range: overflow
  SELECT 0 ^ 0 + 0 ^ 1 + 0 ^ 0.0 + 0 ^ 0.5;
   ?column? 
  ----------
***************
*** 393,405 ****
  (1 row)
  
  SELECT '' AS bad, ln(f.f1) from FLOAT8_TBL f where f.f1 = '0.0' ;
! ERROR:  cannot take logarithm of zero
  SELECT '' AS bad, ln(f.f1) from FLOAT8_TBL f where f.f1 < '0.0';
! ERROR:  cannot take logarithm of a negative number
  SELECT '' AS bad, exp(f.f1) from FLOAT8_TBL f ORDER BY f1;
! ERROR:  value out of range: underflow
  SELECT '' AS bad, f.f1 / '0.0' from FLOAT8_TBL f;
! ERROR:  division by zero
  SELECT '' AS five, * FROM FLOAT8_TBL ORDER BY f1;
   five |          f1           
  ------+-----------------------
--- 393,405 ----
  (1 row)
  
  SELECT '' AS bad, ln(f.f1) from FLOAT8_TBL f where f.f1 = '0.0' ;
! ERROR:  node:datanode_1, backend_pid:381917, nodename:datanode_1,backend_pid:381917,message:cannot take logarithm of zero
  SELECT '' AS bad, ln(f.f1) from FLOAT8_TBL f where f.f1 < '0.0';
! ERROR:  node:datanode_1, backend_pid:381932, nodename:datanode_1,backend_pid:381932,message:cannot take logarithm of a negative number
  SELECT '' AS bad, exp(f.f1) from FLOAT8_TBL f ORDER BY f1;
! ERROR:  node:datanode_1, backend_pid:381937, nodename:datanode_1,backend_pid:381937,message:value out of range: underflow
  SELECT '' AS bad, f.f1 / '0.0' from FLOAT8_TBL f;
! ERROR:  node:datanode_1, backend_pid:381937, nodename:datanode_1,backend_pid:381937,message:division by zero
  SELECT '' AS five, * FROM FLOAT8_TBL ORDER BY f1;
   five |          f1           
  ------+-----------------------

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/bit.out"	2025-07-31 16:07:14.980068216 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/bit.out"	2025-07-31 16:38:19.485582121 +0800
***************
*** 5,215 ****
  -- Build tables for testing
  --
  CREATE TABLE BIT_TABLE(b BIT(11));
  INSERT INTO BIT_TABLE VALUES (B'10'); -- too short
! ERROR:  bit string length 2 does not match type bit(11)
  INSERT INTO BIT_TABLE VALUES (B'00000000000');
  INSERT INTO BIT_TABLE VALUES (B'11011000000');
  INSERT INTO BIT_TABLE VALUES (B'01010101010');
  INSERT INTO BIT_TABLE VALUES (B'101011111010'); -- too long
! ERROR:  bit string length 12 does not match type bit(11)
  --INSERT INTO BIT_TABLE VALUES ('X554');
  --INSERT INTO BIT_TABLE VALUES ('X555');
  SELECT * FROM BIT_TABLE ORDER BY b; 
!       b      
! -------------
!  00000000000
!  01010101010
!  11011000000
! (3 rows)
! 
  CREATE TABLE VARBIT_TABLE(v BIT VARYING(11));
  INSERT INTO VARBIT_TABLE VALUES (B'');
  INSERT INTO VARBIT_TABLE VALUES (B'0');
  INSERT INTO VARBIT_TABLE VALUES (B'010101');
  INSERT INTO VARBIT_TABLE VALUES (B'01010101010');
  INSERT INTO VARBIT_TABLE VALUES (B'101011111010'); -- too long
! ERROR:  bit string too long for type bit varying(11)
  --INSERT INTO VARBIT_TABLE VALUES ('X554');
  --INSERT INTO VARBIT_TABLE VALUES ('X555');
  SELECT * FROM VARBIT_TABLE ORDER BY v; 
!       v      
! -------------
!  
!  0
!  010101
!  01010101010
! (4 rows)
! 
  -- Concatenation
  SELECT v, b, (v || b) AS concat
         FROM BIT_TABLE, VARBIT_TABLE
         ORDER BY 3;
!       v      |      b      |         concat         
! -------------+-------------+------------------------
!              | 00000000000 | 00000000000
!  0           | 00000000000 | 000000000000
!  0           | 01010101010 | 001010101010
!  010101      | 00000000000 | 01010100000000000
!              | 01010101010 | 01010101010
!  01010101010 | 00000000000 | 0101010101000000000000
!  01010101010 | 01010101010 | 0101010101001010101010
!  010101      | 01010101010 | 01010101010101010
!  01010101010 | 11011000000 | 0101010101011011000000
!  010101      | 11011000000 | 01010111011000000
!  0           | 11011000000 | 011011000000
!              | 11011000000 | 11011000000
! (12 rows)
! 
  -- Length
  SELECT b, length(b) AS lb
         FROM BIT_TABLE ORDER BY b;
!       b      | lb 
! -------------+----
!  00000000000 | 11
!  01010101010 | 11
!  11011000000 | 11
! (3 rows)
! 
  SELECT v, length(v) AS lv
         FROM VARBIT_TABLE ORDER BY v;
!       v      | lv 
! -------------+----
!              |  0
!  0           |  1
!  010101      |  6
!  01010101010 | 11
! (4 rows)
! 
  -- Substring
  SELECT b,
         SUBSTRING(b FROM 2 FOR 4) AS sub_2_4,
         SUBSTRING(b FROM 7 FOR 13) AS sub_7_13,
         SUBSTRING(b FROM 6) AS sub_6
         FROM BIT_TABLE ORDER BY b;
!       b      | sub_2_4 | sub_7_13 | sub_6  
! -------------+---------+----------+--------
!  00000000000 | 0000    | 00000    | 000000
!  01010101010 | 1010    | 01010    | 101010
!  11011000000 | 1011    | 00000    | 000000
! (3 rows)
! 
  SELECT v,
         SUBSTRING(v FROM 2 FOR 4) AS sub_2_4,
         SUBSTRING(v FROM 7 FOR 13) AS sub_7_13,
         SUBSTRING(v FROM 6) AS sub_6
         FROM VARBIT_TABLE ORDER BY v;
!       v      | sub_2_4 | sub_7_13 | sub_6  
! -------------+---------+----------+--------
!              |         |          | 
!  0           |         |          | 
!  010101      | 1010    |          | 1
!  01010101010 | 1010    | 01010    | 101010
! (4 rows)
! 
  --- Bit operations
  DROP TABLE varbit_table;
  CREATE TABLE varbit_table (a BIT VARYING(16), b BIT VARYING(16));
  COPY varbit_table FROM stdin;
  SELECT a, b, ~a AS "~ a", a & b AS "a & b", 
         a | b AS "a | b", a # b AS "a # b" FROM varbit_table ORDER BY a,b;
!         a         |        b         |       ~ a        |      a & b       |      a | b       |      a # b       
! ------------------+------------------+------------------+------------------+------------------+------------------
!  0000000000001111 | 0000000000010000 | 1111111111110000 | 0000000000000000 | 0000000000011111 | 0000000000011111
!  0000000100100011 | 1111111111111111 | 1111111011011100 | 0000000100100011 | 1111111111111111 | 1111111011011100
!  00001111         | 00010000         | 11110000         | 00000000         | 00011111         | 00011111
!  0001001000110100 | 1111111111110101 | 1110110111001011 | 0001001000110100 | 1111111111110101 | 1110110111000001
!  00011111         | 00010001         | 11100000         | 00010001         | 00011111         | 00001110
!  0010010001101000 | 0010010001101000 | 1101101110010111 | 0010010001101000 | 0010010001101000 | 0000000000000000
!  00101111         | 00010010         | 11010000         | 00000010         | 00111111         | 00111101
!  00111111         | 00010011         | 11000000         | 00010011         | 00111111         | 00101100
!  10001111         | 00000100         | 01110000         | 00000100         | 10001111         | 10001011
!  1111101001010000 | 0000010110101111 | 0000010110101111 | 0000000000000000 | 1111111111111111 | 1111111111111111
! (10 rows)
! 
  SELECT a,b,a<b AS "a<b",a<=b AS "a<=b",a=b AS "a=b",
          a>=b AS "a>=b",a>b AS "a>b",a<>b AS "a<>b" FROM varbit_table ORDER BY a,b;
!         a         |        b         | a<b | a<=b | a=b | a>=b | a>b | a<>b 
! ------------------+------------------+-----+------+-----+------+-----+------
!  0000000000001111 | 0000000000010000 | t   | t    | f   | f    | f   | t
!  0000000100100011 | 1111111111111111 | t   | t    | f   | f    | f   | t
!  00001111         | 00010000         | t   | t    | f   | f    | f   | t
!  0001001000110100 | 1111111111110101 | t   | t    | f   | f    | f   | t
!  00011111         | 00010001         | f   | f    | f   | t    | t   | t
!  0010010001101000 | 0010010001101000 | f   | t    | t   | t    | f   | f
!  00101111         | 00010010         | f   | f    | f   | t    | t   | t
!  00111111         | 00010011         | f   | f    | f   | t    | t   | t
!  10001111         | 00000100         | f   | f    | f   | t    | t   | t
!  1111101001010000 | 0000010110101111 | f   | f    | f   | t    | t   | t
! (10 rows)
! 
  SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM varbit_table ORDER BY a,b;
!         a         |       a<<4       |        b         |       b>>2       
! ------------------+------------------+------------------+------------------
!  0000000000001111 | 0000000011110000 | 0000000000010000 | 0000000000000100
!  0000000100100011 | 0001001000110000 | 1111111111111111 | 0011111111111111
!  00001111         | 11110000         | 00010000         | 00000100
!  0001001000110100 | 0010001101000000 | 1111111111110101 | 0011111111111101
!  00011111         | 11110000         | 00010001         | 00000100
!  0010010001101000 | 0100011010000000 | 0010010001101000 | 0000100100011010
!  00101111         | 11110000         | 00010010         | 00000100
!  00111111         | 11110000         | 00010011         | 00000100
!  10001111         | 11110000         | 00000100         | 00000001
!  1111101001010000 | 1010010100000000 | 0000010110101111 | 0000000101101011
! (10 rows)
! 
  DROP TABLE varbit_table;
  --- Bit operations
  DROP TABLE bit_table;
  CREATE TABLE bit_table (a BIT(16), b BIT(16));
  COPY bit_table FROM stdin;
  SELECT a,b,~a AS "~ a",a & b AS "a & b", 
  	a|b AS "a | b", a # b AS "a # b" FROM bit_table ORDER BY a,b;
!         a         |        b         |       ~ a        |      a & b       |      a | b       |      a # b       
! ------------------+------------------+------------------+------------------+------------------+------------------
!  0000000000001111 | 0000000000010000 | 1111111111110000 | 0000000000000000 | 0000000000011111 | 0000000000011111
!  0000000100100011 | 1111111111111111 | 1111111011011100 | 0000000100100011 | 1111111111111111 | 1111111011011100
!  0000111100000000 | 0001000000000000 | 1111000011111111 | 0000000000000000 | 0001111100000000 | 0001111100000000
!  0001001000110100 | 1111111111110101 | 1110110111001011 | 0001001000110100 | 1111111111110101 | 1110110111000001
!  0001111100000000 | 0001000100000000 | 1110000011111111 | 0001000100000000 | 0001111100000000 | 0000111000000000
!  0010010001101000 | 0010010001101000 | 1101101110010111 | 0010010001101000 | 0010010001101000 | 0000000000000000
!  0010111100000000 | 0001001000000000 | 1101000011111111 | 0000001000000000 | 0011111100000000 | 0011110100000000
!  0011111100000000 | 0001001100000000 | 1100000011111111 | 0001001100000000 | 0011111100000000 | 0010110000000000
!  1000111100000000 | 0000010000000000 | 0111000011111111 | 0000010000000000 | 1000111100000000 | 1000101100000000
!  1111101001010000 | 0000010110101111 | 0000010110101111 | 0000000000000000 | 1111111111111111 | 1111111111111111
! (10 rows)
! 
  SELECT a,b,a<b AS "a<b",a<=b AS "a<=b",a=b AS "a=b",
          a>=b AS "a>=b",a>b AS "a>b",a<>b AS "a<>b" FROM bit_table ORDER BY a,b;
!         a         |        b         | a<b | a<=b | a=b | a>=b | a>b | a<>b 
! ------------------+------------------+-----+------+-----+------+-----+------
!  0000000000001111 | 0000000000010000 | t   | t    | f   | f    | f   | t
!  0000000100100011 | 1111111111111111 | t   | t    | f   | f    | f   | t
!  0000111100000000 | 0001000000000000 | t   | t    | f   | f    | f   | t
!  0001001000110100 | 1111111111110101 | t   | t    | f   | f    | f   | t
!  0001111100000000 | 0001000100000000 | f   | f    | f   | t    | t   | t
!  0010010001101000 | 0010010001101000 | f   | t    | t   | t    | f   | f
!  0010111100000000 | 0001001000000000 | f   | f    | f   | t    | t   | t
!  0011111100000000 | 0001001100000000 | f   | f    | f   | t    | t   | t
!  1000111100000000 | 0000010000000000 | f   | f    | f   | t    | t   | t
!  1111101001010000 | 0000010110101111 | f   | f    | f   | t    | t   | t
! (10 rows)
! 
  SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM bit_table ORDER BY a,b;
!         a         |       a<<4       |        b         |       b>>2       
! ------------------+------------------+------------------+------------------
!  0000000000001111 | 0000000011110000 | 0000000000010000 | 0000000000000100
!  0000000100100011 | 0001001000110000 | 1111111111111111 | 0011111111111111
!  0000111100000000 | 1111000000000000 | 0001000000000000 | 0000010000000000
!  0001001000110100 | 0010001101000000 | 1111111111110101 | 0011111111111101
!  0001111100000000 | 1111000000000000 | 0001000100000000 | 0000010001000000
!  0010010001101000 | 0100011010000000 | 0010010001101000 | 0000100100011010
!  0010111100000000 | 1111000000000000 | 0001001000000000 | 0000010010000000
!  0011111100000000 | 1111000000000000 | 0001001100000000 | 0000010011000000
!  1000111100000000 | 1111000000000000 | 0000010000000000 | 0000000100000000
!  1111101001010000 | 1010010100000000 | 0000010110101111 | 0000000101101011
! (10 rows)
! 
  DROP TABLE bit_table;
  -- The following should fail
  select B'001' & B'10';
  ERROR:  cannot AND bit strings of different sizes
--- 5,170 ----
  -- Build tables for testing
  --
  CREATE TABLE BIT_TABLE(b BIT(11));
+ ERROR:  Column b is not a shard distributable data type
  INSERT INTO BIT_TABLE VALUES (B'10'); -- too short
! ERROR:  relation "bit_table" does not exist
! LINE 1: INSERT INTO BIT_TABLE VALUES (B'10');
!                     ^
  INSERT INTO BIT_TABLE VALUES (B'00000000000');
+ ERROR:  relation "bit_table" does not exist
+ LINE 1: INSERT INTO BIT_TABLE VALUES (B'00000000000');
+                     ^
  INSERT INTO BIT_TABLE VALUES (B'11011000000');
+ ERROR:  relation "bit_table" does not exist
+ LINE 1: INSERT INTO BIT_TABLE VALUES (B'11011000000');
+                     ^
  INSERT INTO BIT_TABLE VALUES (B'01010101010');
+ ERROR:  relation "bit_table" does not exist
+ LINE 1: INSERT INTO BIT_TABLE VALUES (B'01010101010');
+                     ^
  INSERT INTO BIT_TABLE VALUES (B'101011111010'); -- too long
! ERROR:  relation "bit_table" does not exist
! LINE 1: INSERT INTO BIT_TABLE VALUES (B'101011111010');
!                     ^
  --INSERT INTO BIT_TABLE VALUES ('X554');
  --INSERT INTO BIT_TABLE VALUES ('X555');
  SELECT * FROM BIT_TABLE ORDER BY b; 
! ERROR:  relation "bit_table" does not exist
! LINE 1: SELECT * FROM BIT_TABLE ORDER BY b;
!                       ^
  CREATE TABLE VARBIT_TABLE(v BIT VARYING(11));
+ ERROR:  Column v is not a shard distributable data type
  INSERT INTO VARBIT_TABLE VALUES (B'');
+ ERROR:  relation "varbit_table" does not exist
+ LINE 1: INSERT INTO VARBIT_TABLE VALUES (B'');
+                     ^
  INSERT INTO VARBIT_TABLE VALUES (B'0');
+ ERROR:  relation "varbit_table" does not exist
+ LINE 1: INSERT INTO VARBIT_TABLE VALUES (B'0');
+                     ^
  INSERT INTO VARBIT_TABLE VALUES (B'010101');
+ ERROR:  relation "varbit_table" does not exist
+ LINE 1: INSERT INTO VARBIT_TABLE VALUES (B'010101');
+                     ^
  INSERT INTO VARBIT_TABLE VALUES (B'01010101010');
+ ERROR:  relation "varbit_table" does not exist
+ LINE 1: INSERT INTO VARBIT_TABLE VALUES (B'01010101010');
+                     ^
  INSERT INTO VARBIT_TABLE VALUES (B'101011111010'); -- too long
! ERROR:  relation "varbit_table" does not exist
! LINE 1: INSERT INTO VARBIT_TABLE VALUES (B'101011111010');
!                     ^
  --INSERT INTO VARBIT_TABLE VALUES ('X554');
  --INSERT INTO VARBIT_TABLE VALUES ('X555');
  SELECT * FROM VARBIT_TABLE ORDER BY v; 
! ERROR:  relation "varbit_table" does not exist
! LINE 1: SELECT * FROM VARBIT_TABLE ORDER BY v;
!                       ^
  -- Concatenation
  SELECT v, b, (v || b) AS concat
         FROM BIT_TABLE, VARBIT_TABLE
         ORDER BY 3;
! ERROR:  relation "bit_table" does not exist
! LINE 2:        FROM BIT_TABLE, VARBIT_TABLE
!                     ^
  -- Length
  SELECT b, length(b) AS lb
         FROM BIT_TABLE ORDER BY b;
! ERROR:  relation "bit_table" does not exist
! LINE 2:        FROM BIT_TABLE ORDER BY b;
!                     ^
  SELECT v, length(v) AS lv
         FROM VARBIT_TABLE ORDER BY v;
! ERROR:  relation "varbit_table" does not exist
! LINE 2:        FROM VARBIT_TABLE ORDER BY v;
!                     ^
  -- Substring
  SELECT b,
         SUBSTRING(b FROM 2 FOR 4) AS sub_2_4,
         SUBSTRING(b FROM 7 FOR 13) AS sub_7_13,
         SUBSTRING(b FROM 6) AS sub_6
         FROM BIT_TABLE ORDER BY b;
! ERROR:  relation "bit_table" does not exist
! LINE 5:        FROM BIT_TABLE ORDER BY b;
!                     ^
  SELECT v,
         SUBSTRING(v FROM 2 FOR 4) AS sub_2_4,
         SUBSTRING(v FROM 7 FOR 13) AS sub_7_13,
         SUBSTRING(v FROM 6) AS sub_6
         FROM VARBIT_TABLE ORDER BY v;
! ERROR:  relation "varbit_table" does not exist
! LINE 5:        FROM VARBIT_TABLE ORDER BY v;
!                     ^
  --- Bit operations
  DROP TABLE varbit_table;
+ ERROR:  table "varbit_table" does not exist
  CREATE TABLE varbit_table (a BIT VARYING(16), b BIT VARYING(16));
+ ERROR:  Column a is not a shard distributable data type
  COPY varbit_table FROM stdin;
+ ERROR:  relation "varbit_table" does not exist
+ X0F	X10
+ X1F	X11
+ X2F	X12
+ X3F	X13
+ X8F	X04
+ X000F	X0010
+ X0123	XFFFF
+ X2468	X2468
+ XFA50	X05AF
+ X1234	XFFF5
+ \.
+ invalid command \.
  SELECT a, b, ~a AS "~ a", a & b AS "a & b", 
         a | b AS "a | b", a # b AS "a # b" FROM varbit_table ORDER BY a,b;
! ERROR:  syntax error at or near "X0F"
! LINE 1: X0F X10
!         ^
  SELECT a,b,a<b AS "a<b",a<=b AS "a<=b",a=b AS "a=b",
          a>=b AS "a>=b",a>b AS "a>b",a<>b AS "a<>b" FROM varbit_table ORDER BY a,b;
! ERROR:  relation "varbit_table" does not exist
! LINE 2: ...  a>=b AS "a>=b",a>b AS "a>b",a<>b AS "a<>b" FROM varbit_tab...
!                                                              ^
  SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM varbit_table ORDER BY a,b;
! ERROR:  relation "varbit_table" does not exist
! LINE 1: SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM varbit_table O...
!                                                       ^
  DROP TABLE varbit_table;
+ ERROR:  table "varbit_table" does not exist
  --- Bit operations
  DROP TABLE bit_table;
+ ERROR:  table "bit_table" does not exist
  CREATE TABLE bit_table (a BIT(16), b BIT(16));
+ ERROR:  Column a is not a shard distributable data type
  COPY bit_table FROM stdin;
+ ERROR:  relation "bit_table" does not exist
+ X0F00	X1000
+ X1F00	X1100
+ X2F00	X1200
+ X3F00	X1300
+ X8F00	X0400
+ X000F	X0010
+ X0123	XFFFF
+ X2468	X2468
+ XFA50	X05AF
+ X1234	XFFF5
+ \.
+ invalid command \.
  SELECT a,b,~a AS "~ a",a & b AS "a & b", 
  	a|b AS "a | b", a # b AS "a # b" FROM bit_table ORDER BY a,b;
! ERROR:  syntax error at or near "X0F00"
! LINE 1: X0F00 X1000
!         ^
  SELECT a,b,a<b AS "a<b",a<=b AS "a<=b",a=b AS "a=b",
          a>=b AS "a>=b",a>b AS "a>b",a<>b AS "a<>b" FROM bit_table ORDER BY a,b;
! ERROR:  relation "bit_table" does not exist
! LINE 2: ...  a>=b AS "a>=b",a>b AS "a>b",a<>b AS "a<>b" FROM bit_table ...
!                                                              ^
  SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM bit_table ORDER BY a,b;
! ERROR:  relation "bit_table" does not exist
! LINE 1: SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM bit_table ORDE...
!                                                       ^
  DROP TABLE bit_table;
+ ERROR:  table "bit_table" does not exist
  -- The following should fail
  select B'001' & B'10';
  ERROR:  cannot AND bit strings of different sizes
***************
*** 448,514 ****
  
  -- Shifting
  CREATE TABLE BIT_SHIFT_TABLE(b BIT(16));
  INSERT INTO BIT_SHIFT_TABLE VALUES (B'1101100000000000');
  INSERT INTO BIT_SHIFT_TABLE SELECT b>>1 FROM BIT_SHIFT_TABLE;
  INSERT INTO BIT_SHIFT_TABLE SELECT b>>2 FROM BIT_SHIFT_TABLE;
  INSERT INTO BIT_SHIFT_TABLE SELECT b>>4 FROM BIT_SHIFT_TABLE;
  INSERT INTO BIT_SHIFT_TABLE SELECT b>>8 FROM BIT_SHIFT_TABLE;
  SELECT POSITION(B'1101' IN b),
         POSITION(B'11011' IN b),
         b 
         FROM BIT_SHIFT_TABLE  ORDER BY b;
!  position | position |        b         
! ----------+----------+------------------
!         0 |        0 | 0000000000000001
!         0 |        0 | 0000000000000011
!         0 |        0 | 0000000000000110
!        13 |        0 | 0000000000001101
!        12 |       12 | 0000000000011011
!        11 |       11 | 0000000000110110
!        10 |       10 | 0000000001101100
!         9 |        9 | 0000000011011000
!         8 |        8 | 0000000110110000
!         7 |        7 | 0000001101100000
!         6 |        6 | 0000011011000000
!         5 |        5 | 0000110110000000
!         4 |        4 | 0001101100000000
!         3 |        3 | 0011011000000000
!         2 |        2 | 0110110000000000
!         1 |        1 | 1101100000000000
! (16 rows)
! 
  CREATE TABLE VARBIT_SHIFT_TABLE(v BIT VARYING(20));
  INSERT INTO VARBIT_SHIFT_TABLE VALUES (B'11011');
  INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0' AS BIT VARYING(6)) >>1 FROM VARBIT_SHIFT_TABLE;
  INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00' AS BIT VARYING(8)) >>2 FROM VARBIT_SHIFT_TABLE;
  INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0000' AS BIT VARYING(12)) >>4 FROM VARBIT_SHIFT_TABLE;
  INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00000000' AS BIT VARYING(20)) >>8 FROM VARBIT_SHIFT_TABLE;
  SELECT POSITION(B'1101' IN v),
         POSITION(B'11011' IN v),
         v 
         FROM VARBIT_SHIFT_TABLE  ORDER BY v;
!  position | position |          v           
! ----------+----------+----------------------
!        16 |       16 | 00000000000000011011
!        15 |       15 | 0000000000000011011
!        14 |       14 | 000000000000011011
!        13 |       13 | 00000000000011011
!        12 |       12 | 0000000000011011
!        11 |       11 | 000000000011011
!        10 |       10 | 00000000011011
!         9 |        9 | 0000000011011
!         8 |        8 | 000000011011
!         7 |        7 | 00000011011
!         6 |        6 | 0000011011
!         5 |        5 | 000011011
!         4 |        4 | 00011011
!         3 |        3 | 0011011
!         2 |        2 | 011011
!         1 |        1 | 11011
! (16 rows)
! 
  DROP TABLE BIT_SHIFT_TABLE;
  DROP TABLE VARBIT_SHIFT_TABLE;
  -- Get/Set bit
  SELECT get_bit(B'0101011000100', 10);
   get_bit 
--- 403,469 ----
  
  -- Shifting
  CREATE TABLE BIT_SHIFT_TABLE(b BIT(16));
+ ERROR:  Column b is not a shard distributable data type
  INSERT INTO BIT_SHIFT_TABLE VALUES (B'1101100000000000');
+ ERROR:  relation "bit_shift_table" does not exist
+ LINE 1: INSERT INTO BIT_SHIFT_TABLE VALUES (B'1101100000000000');
+                     ^
  INSERT INTO BIT_SHIFT_TABLE SELECT b>>1 FROM BIT_SHIFT_TABLE;
+ ERROR:  relation "bit_shift_table" does not exist
+ LINE 1: INSERT INTO BIT_SHIFT_TABLE SELECT b>>1 FROM BIT_SHIFT_TABLE...
+                     ^
  INSERT INTO BIT_SHIFT_TABLE SELECT b>>2 FROM BIT_SHIFT_TABLE;
+ ERROR:  relation "bit_shift_table" does not exist
+ LINE 1: INSERT INTO BIT_SHIFT_TABLE SELECT b>>2 FROM BIT_SHIFT_TABLE...
+                     ^
  INSERT INTO BIT_SHIFT_TABLE SELECT b>>4 FROM BIT_SHIFT_TABLE;
+ ERROR:  relation "bit_shift_table" does not exist
+ LINE 1: INSERT INTO BIT_SHIFT_TABLE SELECT b>>4 FROM BIT_SHIFT_TABLE...
+                     ^
  INSERT INTO BIT_SHIFT_TABLE SELECT b>>8 FROM BIT_SHIFT_TABLE;
+ ERROR:  relation "bit_shift_table" does not exist
+ LINE 1: INSERT INTO BIT_SHIFT_TABLE SELECT b>>8 FROM BIT_SHIFT_TABLE...
+                     ^
  SELECT POSITION(B'1101' IN b),
         POSITION(B'11011' IN b),
         b 
         FROM BIT_SHIFT_TABLE  ORDER BY b;
! ERROR:  relation "bit_shift_table" does not exist
! LINE 4:        FROM BIT_SHIFT_TABLE  ORDER BY b;
!                     ^
  CREATE TABLE VARBIT_SHIFT_TABLE(v BIT VARYING(20));
+ ERROR:  Column v is not a shard distributable data type
  INSERT INTO VARBIT_SHIFT_TABLE VALUES (B'11011');
+ ERROR:  relation "varbit_shift_table" does not exist
+ LINE 1: INSERT INTO VARBIT_SHIFT_TABLE VALUES (B'11011');
+                     ^
  INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0' AS BIT VARYING(6)) >>1 FROM VARBIT_SHIFT_TABLE;
+ ERROR:  relation "varbit_shift_table" does not exist
+ LINE 1: INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0' AS BIT ...
+                     ^
  INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00' AS BIT VARYING(8)) >>2 FROM VARBIT_SHIFT_TABLE;
+ ERROR:  relation "varbit_shift_table" does not exist
+ LINE 1: INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00' AS BIT...
+                     ^
  INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0000' AS BIT VARYING(12)) >>4 FROM VARBIT_SHIFT_TABLE;
+ ERROR:  relation "varbit_shift_table" does not exist
+ LINE 1: INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0000' AS B...
+                     ^
  INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00000000' AS BIT VARYING(20)) >>8 FROM VARBIT_SHIFT_TABLE;
+ ERROR:  relation "varbit_shift_table" does not exist
+ LINE 1: INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00000000' ...
+                     ^
  SELECT POSITION(B'1101' IN v),
         POSITION(B'11011' IN v),
         v 
         FROM VARBIT_SHIFT_TABLE  ORDER BY v;
! ERROR:  relation "varbit_shift_table" does not exist
! LINE 4:        FROM VARBIT_SHIFT_TABLE  ORDER BY v;
!                     ^
  DROP TABLE BIT_SHIFT_TABLE;
+ ERROR:  table "bit_shift_table" does not exist
  DROP TABLE VARBIT_SHIFT_TABLE;
+ ERROR:  table "varbit_shift_table" does not exist
  -- Get/Set bit
  SELECT get_bit(B'0101011000100', 10);
   get_bit 

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/numeric.out"	2025-07-31 16:07:14.991068041 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/numeric.out"	2025-07-31 16:38:21.385541045 +0800
***************
*** 687,698 ****
  INSERT INTO fract_only VALUES (1, '0.0');
  INSERT INTO fract_only VALUES (2, '0.1');
  INSERT INTO fract_only VALUES (3, '1.0');	-- should fail
! ERROR:  numeric field overflow
  DETAIL:  A field with precision 4, scale 4 must round to an absolute value less than 1.
  INSERT INTO fract_only VALUES (4, '-0.9999');
  INSERT INTO fract_only VALUES (5, '0.99994');
  INSERT INTO fract_only VALUES (6, '0.99995');  -- should fail
! ERROR:  numeric field overflow
  DETAIL:  A field with precision 4, scale 4 must round to an absolute value less than 1.
  INSERT INTO fract_only VALUES (7, '0.00001');
  INSERT INTO fract_only VALUES (8, '0.00017');
--- 687,698 ----
  INSERT INTO fract_only VALUES (1, '0.0');
  INSERT INTO fract_only VALUES (2, '0.1');
  INSERT INTO fract_only VALUES (3, '1.0');	-- should fail
! ERROR:  node:datanode_2, backend_pid:381312, nodename:datanode_2,backend_pid:381312,message:numeric field overflow
  DETAIL:  A field with precision 4, scale 4 must round to an absolute value less than 1.
  INSERT INTO fract_only VALUES (4, '-0.9999');
  INSERT INTO fract_only VALUES (5, '0.99994');
  INSERT INTO fract_only VALUES (6, '0.99995');  -- should fail
! ERROR:  node:datanode_1, backend_pid:381315, nodename:datanode_1,backend_pid:381315,message:numeric field overflow
  DETAIL:  A field with precision 4, scale 4 must round to an absolute value less than 1.
  INSERT INTO fract_only VALUES (7, '0.00001');
  INSERT INTO fract_only VALUES (8, '0.00017');

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/uuid.out"	2025-07-31 16:07:15.006067803 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/uuid.out"	2025-07-31 16:38:19.157589214 +0800
***************
*** 5,149 ****
  	guid_field UUID,
  	text_field TEXT DEFAULT(now())
  );
  CREATE TABLE guid2
  (
  	guid_field UUID,
  	text_field TEXT DEFAULT(now())
  );
  -- inserting invalid data tests
  -- too long
  INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-1111-111111111111F');
! ERROR:  invalid input syntax for type uuid: "11111111-1111-1111-1111-111111111111F"
  LINE 1: INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-111...
!                                              ^
  -- too short
  INSERT INTO guid1(guid_field) VALUES('{11111111-1111-1111-1111-11111111111}');
! ERROR:  invalid input syntax for type uuid: "{11111111-1111-1111-1111-11111111111}"
  LINE 1: INSERT INTO guid1(guid_field) VALUES('{11111111-1111-1111-11...
!                                              ^
  -- valid data but invalid format
  INSERT INTO guid1(guid_field) VALUES('111-11111-1111-1111-1111-111111111111');
! ERROR:  invalid input syntax for type uuid: "111-11111-1111-1111-1111-111111111111"
  LINE 1: INSERT INTO guid1(guid_field) VALUES('111-11111-1111-1111-11...
!                                              ^
  INSERT INTO guid1(guid_field) VALUES('{22222222-2222-2222-2222-222222222222 ');
! ERROR:  invalid input syntax for type uuid: "{22222222-2222-2222-2222-222222222222 "
  LINE 1: INSERT INTO guid1(guid_field) VALUES('{22222222-2222-2222-22...
!                                              ^
  -- invalid data
  INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-G111-111111111111');
! ERROR:  invalid input syntax for type uuid: "11111111-1111-1111-G111-111111111111"
  LINE 1: INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-G11...
!                                              ^
  INSERT INTO guid1(guid_field) VALUES('11+11111-1111-1111-1111-111111111111');
! ERROR:  invalid input syntax for type uuid: "11+11111-1111-1111-1111-111111111111"
  LINE 1: INSERT INTO guid1(guid_field) VALUES('11+11111-1111-1111-111...
!                                              ^
  --inserting three input formats
  INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-1111-111111111111');
  INSERT INTO guid1(guid_field) VALUES('{22222222-2222-2222-2222-222222222222}');
  INSERT INTO guid1(guid_field) VALUES('3f3e3c3b3a3039383736353433a2313e');
  -- retrieving the inserted data
  SELECT guid_field FROM guid1 ORDER BY guid_field;
!               guid_field              
! --------------------------------------
!  11111111-1111-1111-1111-111111111111
!  22222222-2222-2222-2222-222222222222
!  3f3e3c3b-3a30-3938-3736-353433a2313e
! (3 rows)
! 
  -- ordering test
  SELECT guid_field FROM guid1 ORDER BY guid_field ASC;
!               guid_field              
! --------------------------------------
!  11111111-1111-1111-1111-111111111111
!  22222222-2222-2222-2222-222222222222
!  3f3e3c3b-3a30-3938-3736-353433a2313e
! (3 rows)
! 
  SELECT guid_field FROM guid1 ORDER BY guid_field DESC;
!               guid_field              
! --------------------------------------
!  3f3e3c3b-3a30-3938-3736-353433a2313e
!  22222222-2222-2222-2222-222222222222
!  11111111-1111-1111-1111-111111111111
! (3 rows)
! 
  -- = operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field = '3f3e3c3b-3a30-3938-3736-353433a2313e';
!  count 
! -------
!      1
! (1 row)
! 
  -- <> operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field <> '11111111111111111111111111111111';
!  count 
! -------
!      2
! (1 row)
! 
  -- < operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field < '22222222-2222-2222-2222-222222222222';
!  count 
! -------
!      1
! (1 row)
! 
  -- <= operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field <= '22222222-2222-2222-2222-222222222222';
!  count 
! -------
!      2
! (1 row)
! 
  -- > operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field > '22222222-2222-2222-2222-222222222222';
!  count 
! -------
!      1
! (1 row)
! 
  -- >= operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field >= '22222222-2222-2222-2222-222222222222';
!  count 
! -------
!      2
! (1 row)
! 
  -- btree and hash index creation test
  CREATE INDEX guid1_btree ON guid1 USING BTREE (guid_field);
  CREATE INDEX guid1_hash  ON guid1 USING HASH  (guid_field);
  -- unique index test
  CREATE UNIQUE INDEX guid1_unique_BTREE ON guid1 USING BTREE (guid_field);
  -- should fail
  INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-1111-111111111111');
! ERROR:  duplicate key value violates unique constraint "guid1_unique_btree"
! DETAIL:  Key (guid_field)=(11111111-1111-1111-1111-111111111111) already exists.
  -- check to see whether the new indexes are actually there
  SELECT count(*) FROM pg_class WHERE relkind='i' AND relname LIKE 'guid%';
   count 
  -------
!      3
  (1 row)
  
  -- populating the test tables with additional records
  INSERT INTO guid1(guid_field) VALUES('44444444-4444-4444-4444-444444444444');
  INSERT INTO guid2(guid_field) VALUES('11111111-1111-1111-1111-111111111111');
  INSERT INTO guid2(guid_field) VALUES('{22222222-2222-2222-2222-222222222222}');
  INSERT INTO guid2(guid_field) VALUES('3f3e3c3b3a3039383736353433a2313e');
  -- join test
  SELECT COUNT(*) FROM guid1 g1 INNER JOIN guid2 g2 ON g1.guid_field = g2.guid_field;
!  count 
! -------
!      3
! (1 row)
! 
  SELECT COUNT(*) FROM guid1 g1 LEFT JOIN guid2 g2 ON g1.guid_field = g2.guid_field WHERE g2.guid_field IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
  -- clean up
  DROP TABLE guid1, guid2 CASCADE;
--- 5,149 ----
  	guid_field UUID,
  	text_field TEXT DEFAULT(now())
  );
+ ERROR:  Column guid_field is not a shard distributable data type
  CREATE TABLE guid2
  (
  	guid_field UUID,
  	text_field TEXT DEFAULT(now())
  );
+ ERROR:  Column guid_field is not a shard distributable data type
  -- inserting invalid data tests
  -- too long
  INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-1111-111111111111F');
! ERROR:  relation "guid1" does not exist
  LINE 1: INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-111...
!                     ^
  -- too short
  INSERT INTO guid1(guid_field) VALUES('{11111111-1111-1111-1111-11111111111}');
! ERROR:  relation "guid1" does not exist
  LINE 1: INSERT INTO guid1(guid_field) VALUES('{11111111-1111-1111-11...
!                     ^
  -- valid data but invalid format
  INSERT INTO guid1(guid_field) VALUES('111-11111-1111-1111-1111-111111111111');
! ERROR:  relation "guid1" does not exist
  LINE 1: INSERT INTO guid1(guid_field) VALUES('111-11111-1111-1111-11...
!                     ^
  INSERT INTO guid1(guid_field) VALUES('{22222222-2222-2222-2222-222222222222 ');
! ERROR:  relation "guid1" does not exist
  LINE 1: INSERT INTO guid1(guid_field) VALUES('{22222222-2222-2222-22...
!                     ^
  -- invalid data
  INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-G111-111111111111');
! ERROR:  relation "guid1" does not exist
  LINE 1: INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-G11...
!                     ^
  INSERT INTO guid1(guid_field) VALUES('11+11111-1111-1111-1111-111111111111');
! ERROR:  relation "guid1" does not exist
  LINE 1: INSERT INTO guid1(guid_field) VALUES('11+11111-1111-1111-111...
!                     ^
  --inserting three input formats
  INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-1111-111111111111');
+ ERROR:  relation "guid1" does not exist
+ LINE 1: INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-111...
+                     ^
  INSERT INTO guid1(guid_field) VALUES('{22222222-2222-2222-2222-222222222222}');
+ ERROR:  relation "guid1" does not exist
+ LINE 1: INSERT INTO guid1(guid_field) VALUES('{22222222-2222-2222-22...
+                     ^
  INSERT INTO guid1(guid_field) VALUES('3f3e3c3b3a3039383736353433a2313e');
+ ERROR:  relation "guid1" does not exist
+ LINE 1: INSERT INTO guid1(guid_field) VALUES('3f3e3c3b3a303938373635...
+                     ^
  -- retrieving the inserted data
  SELECT guid_field FROM guid1 ORDER BY guid_field;
! ERROR:  relation "guid1" does not exist
! LINE 1: SELECT guid_field FROM guid1 ORDER BY guid_field;
!                                ^
  -- ordering test
  SELECT guid_field FROM guid1 ORDER BY guid_field ASC;
! ERROR:  relation "guid1" does not exist
! LINE 1: SELECT guid_field FROM guid1 ORDER BY guid_field ASC;
!                                ^
  SELECT guid_field FROM guid1 ORDER BY guid_field DESC;
! ERROR:  relation "guid1" does not exist
! LINE 1: SELECT guid_field FROM guid1 ORDER BY guid_field DESC;
!                                ^
  -- = operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field = '3f3e3c3b-3a30-3938-3736-353433a2313e';
! ERROR:  relation "guid1" does not exist
! LINE 1: SELECT COUNT(*) FROM guid1 WHERE guid_field = '3f3e3c3b-3a30...
!                              ^
  -- <> operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field <> '11111111111111111111111111111111';
! ERROR:  relation "guid1" does not exist
! LINE 1: SELECT COUNT(*) FROM guid1 WHERE guid_field <> '111111111111...
!                              ^
  -- < operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field < '22222222-2222-2222-2222-222222222222';
! ERROR:  relation "guid1" does not exist
! LINE 1: SELECT COUNT(*) FROM guid1 WHERE guid_field < '22222222-2222...
!                              ^
  -- <= operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field <= '22222222-2222-2222-2222-222222222222';
! ERROR:  relation "guid1" does not exist
! LINE 1: SELECT COUNT(*) FROM guid1 WHERE guid_field <= '22222222-222...
!                              ^
  -- > operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field > '22222222-2222-2222-2222-222222222222';
! ERROR:  relation "guid1" does not exist
! LINE 1: SELECT COUNT(*) FROM guid1 WHERE guid_field > '22222222-2222...
!                              ^
  -- >= operator test
  SELECT COUNT(*) FROM guid1 WHERE guid_field >= '22222222-2222-2222-2222-222222222222';
! ERROR:  relation "guid1" does not exist
! LINE 1: SELECT COUNT(*) FROM guid1 WHERE guid_field >= '22222222-222...
!                              ^
  -- btree and hash index creation test
  CREATE INDEX guid1_btree ON guid1 USING BTREE (guid_field);
+ ERROR:  relation "guid1" does not exist
  CREATE INDEX guid1_hash  ON guid1 USING HASH  (guid_field);
+ ERROR:  relation "guid1" does not exist
  -- unique index test
  CREATE UNIQUE INDEX guid1_unique_BTREE ON guid1 USING BTREE (guid_field);
+ ERROR:  relation "guid1" does not exist
  -- should fail
  INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-1111-111111111111');
! ERROR:  relation "guid1" does not exist
! LINE 1: INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-111...
!                     ^
  -- check to see whether the new indexes are actually there
  SELECT count(*) FROM pg_class WHERE relkind='i' AND relname LIKE 'guid%';
   count 
  -------
!      0
  (1 row)
  
  -- populating the test tables with additional records
  INSERT INTO guid1(guid_field) VALUES('44444444-4444-4444-4444-444444444444');
+ ERROR:  relation "guid1" does not exist
+ LINE 1: INSERT INTO guid1(guid_field) VALUES('44444444-4444-4444-444...
+                     ^
  INSERT INTO guid2(guid_field) VALUES('11111111-1111-1111-1111-111111111111');
+ ERROR:  relation "guid2" does not exist
+ LINE 1: INSERT INTO guid2(guid_field) VALUES('11111111-1111-1111-111...
+                     ^
  INSERT INTO guid2(guid_field) VALUES('{22222222-2222-2222-2222-222222222222}');
+ ERROR:  relation "guid2" does not exist
+ LINE 1: INSERT INTO guid2(guid_field) VALUES('{22222222-2222-2222-22...
+                     ^
  INSERT INTO guid2(guid_field) VALUES('3f3e3c3b3a3039383736353433a2313e');
+ ERROR:  relation "guid2" does not exist
+ LINE 1: INSERT INTO guid2(guid_field) VALUES('3f3e3c3b3a303938373635...
+                     ^
  -- join test
  SELECT COUNT(*) FROM guid1 g1 INNER JOIN guid2 g2 ON g1.guid_field = g2.guid_field;
! ERROR:  relation "guid1" does not exist
! LINE 1: SELECT COUNT(*) FROM guid1 g1 INNER JOIN guid2 g2 ON g1.guid...
!                              ^
  SELECT COUNT(*) FROM guid1 g1 LEFT JOIN guid2 g2 ON g1.guid_field = g2.guid_field WHERE g2.guid_field IS NULL;
! ERROR:  relation "guid1" does not exist
! LINE 1: SELECT COUNT(*) FROM guid1 g1 LEFT JOIN guid2 g2 ON g1.guid_...
!                              ^
  -- clean up
  DROP TABLE guid1, guid2 CASCADE;
+ ERROR:  table "guid1" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/enum.out"	2025-07-31 16:07:14.982068184 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/enum.out"	2025-07-31 16:38:20.450561257 +0800
***************
*** 539,559 ****
  --
  CREATE TABLE enumtest_parent (id rainbow PRIMARY KEY);
  CREATE TABLE enumtest_child (parent rainbow REFERENCES enumtest_parent);
  INSERT INTO enumtest_parent VALUES ('red');
  INSERT INTO enumtest_child VALUES ('red');
  INSERT INTO enumtest_child VALUES ('blue');  -- fail
! ERROR:  insert or update on table "enumtest_child" violates foreign key constraint "enumtest_child_parent_fkey"
! DETAIL:  Key (parent)=(blue) is not present in table "enumtest_parent".
  DELETE FROM enumtest_parent;  -- fail
- ERROR:  update or delete on table "enumtest_parent" violates foreign key constraint "enumtest_child_parent_fkey" on table "enumtest_child"
- DETAIL:  Key (id)=(red) is still referenced from table "enumtest_child".
  --
  -- cross-type RI should fail
  --
  CREATE TYPE bogus AS ENUM('good', 'bad', 'ugly');
  CREATE TABLE enumtest_bogus_child(parent bogus REFERENCES enumtest_parent);
! ERROR:  foreign key constraint "enumtest_bogus_child_parent_fkey" cannot be implemented
! DETAIL:  Key columns "parent" and "id" are of incompatible types: bogus and rainbow.
  DROP TYPE bogus;
  -- check renaming a value
  ALTER TYPE rainbow RENAME VALUE 'red' TO 'crimson';
--- 539,561 ----
  --
  CREATE TABLE enumtest_parent (id rainbow PRIMARY KEY);
  CREATE TABLE enumtest_child (parent rainbow REFERENCES enumtest_parent);
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  INSERT INTO enumtest_parent VALUES ('red');
  INSERT INTO enumtest_child VALUES ('red');
+ ERROR:  relation "enumtest_child" does not exist
+ LINE 1: INSERT INTO enumtest_child VALUES ('red');
+                     ^
  INSERT INTO enumtest_child VALUES ('blue');  -- fail
! ERROR:  relation "enumtest_child" does not exist
! LINE 1: INSERT INTO enumtest_child VALUES ('blue');
!                     ^
  DELETE FROM enumtest_parent;  -- fail
  --
  -- cross-type RI should fail
  --
  CREATE TYPE bogus AS ENUM('good', 'bad', 'ugly');
  CREATE TABLE enumtest_bogus_child(parent bogus REFERENCES enumtest_parent);
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  DROP TYPE bogus;
  -- check renaming a value
  ALTER TYPE rainbow RENAME VALUE 'red' TO 'crimson';
***************
*** 651,656 ****
--- 653,659 ----
  -- Cleanup
  --
  DROP TABLE enumtest_child;
+ ERROR:  table "enumtest_child" does not exist
  DROP TABLE enumtest_parent;
  DROP TABLE enumtest;
  DROP TYPE rainbow;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/rangetypes.out"	2025-07-31 16:07:14.998067930 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/rangetypes.out"	2025-07-31 16:38:21.023548870 +0800
***************
*** 1095,1101 ****
  select ir from test_range_spgist where ir -|- int4range(10,20) order by ir;
                                    QUERY PLAN                                  
  ------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
     ->  Sort
           Sort Key: ir
           ->  Index Only Scan using test_range_spgist_idx on test_range_spgist
--- 1095,1101 ----
  select ir from test_range_spgist where ir -|- int4range(10,20) order by ir;
                                    QUERY PLAN                                  
  ------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1)
     ->  Sort
           Sort Key: ir
           ->  Index Only Scan using test_range_spgist_idx on test_range_spgist
***************
*** 1142,1154 ****
    values(int4range(123, 123, '[]'), int4range(2, 2, '[]'), '[2010-01-02 11:00, 2010-01-02 12:00)');
  insert into test_range_excl
    values(int4range(123, 123, '[]'), int4range(3, 3, '[]'), '[2010-01-02 10:10, 2010-01-02 11:00)');
! ERROR:  conflicting key value violates exclusion constraint "test_range_excl_room_during_excl"
  DETAIL:  Key (room, during)=([123,124), ["Sat Jan 02 10:10:00 2010","Sat Jan 02 11:00:00 2010")) conflicts with existing key (room, during)=([123,124), ["Sat Jan 02 10:00:00 2010","Sat Jan 02 11:00:00 2010")).
  insert into test_range_excl
    values(int4range(124, 124, '[]'), int4range(3, 3, '[]'), '[2010-01-02 10:10, 2010-01-02 11:10)');
  insert into test_range_excl
    values(int4range(125, 125, '[]'), int4range(1, 1, '[]'), '[2010-01-02 10:10, 2010-01-02 11:00)');
! ERROR:  conflicting key value violates exclusion constraint "test_range_excl_speaker_during_excl"
  DETAIL:  Key (speaker, during)=([1,2), ["Sat Jan 02 10:10:00 2010","Sat Jan 02 11:00:00 2010")) conflicts with existing key (speaker, during)=([1,2), ["Sat Jan 02 10:00:00 2010","Sat Jan 02 11:00:00 2010")).
  -- test bigint ranges
  select int8range(10000000000::int8, 20000000000::int8,'(]');
--- 1142,1154 ----
    values(int4range(123, 123, '[]'), int4range(2, 2, '[]'), '[2010-01-02 11:00, 2010-01-02 12:00)');
  insert into test_range_excl
    values(int4range(123, 123, '[]'), int4range(3, 3, '[]'), '[2010-01-02 10:10, 2010-01-02 11:00)');
! ERROR:  node:datanode_2, backend_pid:381330, nodename:datanode_1,backend_pid:381304,message:conflicting key value violates exclusion constraint "test_range_excl_room_during_excl"
  DETAIL:  Key (room, during)=([123,124), ["Sat Jan 02 10:10:00 2010","Sat Jan 02 11:00:00 2010")) conflicts with existing key (room, during)=([123,124), ["Sat Jan 02 10:00:00 2010","Sat Jan 02 11:00:00 2010")).
  insert into test_range_excl
    values(int4range(124, 124, '[]'), int4range(3, 3, '[]'), '[2010-01-02 10:10, 2010-01-02 11:10)');
  insert into test_range_excl
    values(int4range(125, 125, '[]'), int4range(1, 1, '[]'), '[2010-01-02 10:10, 2010-01-02 11:00)');
! ERROR:  node:datanode_2, backend_pid:381312, nodename:datanode_1,backend_pid:381315,message:conflicting key value violates exclusion constraint "test_range_excl_speaker_during_excl"
  DETAIL:  Key (speaker, during)=([1,2), ["Sat Jan 02 10:10:00 2010","Sat Jan 02 11:00:00 2010")) conflicts with existing key (speaker, during)=([1,2), ["Sat Jan 02 10:00:00 2010","Sat Jan 02 11:00:00 2010")).
  -- test bigint ranges
  select int8range(10000000000::int8, 20000000000::int8,'(]');

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/zhcn_utf8.out"	2025-07-31 16:07:15.012067707 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/zhcn_utf8.out"	2025-07-31 16:38:19.219587873 +0800
***************
*** 2,264 ****
  -- gbk
  --
  CREATE DATABASE db_gbk template template0 encoding = gbk LC_COLLATE = 'zh_CN.gbk' LC_CTYPE = 'zh_CN.gbk';
  \c db_gbk;
! CREATE TABLE tbl_gbk(f1 varchar(3));
! INSERT INTO tbl_gbk (f1) VALUES ('');
! INSERT INTO tbl_gbk (f1) VALUES ('');
! --  is not support by euc_cn, but support on gbk
! INSERT INTO tbl_gbk (f1) VALUES ('');
! INSERT INTO tbl_gbk (f1) VALUES ('');
! INSERT INTO tbl_gbk (f1) VALUES ('');
! INSERT INTO tbl_gbk (f1) VALUES ('');
! -- error
! INSERT INTO tbl_gbk (f1) VALUES ('2');
! ERROR:  value too long for type character varying(3)
! -- order by
! SELECT * FROM tbl_gbk ORDER BY f1;
!    f1   
! --------
!  
!  
!  
!  
!  
!  
! (6 rows)
! 
! -- regular expression query
! SELECT * FROM tbl_gbk WHERE f1 ~ '^' ORDER BY f1;
!    f1   
! --------
!  
!  
! (2 rows)
! 
! -- query encoding length
! SELECT OCTET_LENGTH(f1) FROM tbl_gbk ORDER BY f1;
!  octet_length 
! --------------
!             6
!             6
!             6
!             6
!             4
!             6
! (6 rows)
! 
! -- MATERIALIZED VIEW join
! CREATE TABLE T_PERSON(i int, n varchar(32));
! INSERT INTO T_PERSON VALUES (1, '');
! INSERT INTO T_PERSON VALUES (2, '');
! CREATE TABLE T_NICK(id int, name varchar(32));
! INSERT INTO T_NICK VALUES (1, '');
! INSERT INTO T_NICK VALUES (2, '');
! CREATE MATERIALIZED VIEW T_MATER AS SELECT * FROM T_PERSON  WITH NO DATA;
! REFRESH MATERIALIZED VIEW T_MATER;
! SELECT * FROM T_MATER p JOIN T_NICK n on p.i = n.id order by i;
!  i |   n    | id | name 
! ---+--------+----+------
!  1 |  |  1 | 
!  2 |    |  2 | 
! (2 rows)
! 
! SELECT * FROM T_MATER p JOIN T_NICK n on p.i = n.id order by name;
!  i |   n    | id | name 
! ---+--------+----+------
!  2 |    |  2 | 
!  1 |  |  1 | 
! (2 rows)
! 
! SELECT * FROM T_MATER p JOIN T_NICK n on p.i = n.id order by n;
!  i |   n    | id | name 
! ---+--------+----+------
!  1 |  |  1 | 
!  2 |    |  2 | 
! (2 rows)
! 
! DROP MATERIALIZED VIEW T_MATER;
! DROP TABLE T_PERSON;
! DROP TABLE T_NICK;
! --
! -- gb18030
! --
! CREATE DATABASE db_gb18030 template template0 encoding = gb18030 LC_COLLATE = 'zh_CN.gb18030' LC_CTYPE = 'zh_CN.gb18030';
! \c db_gb18030;
! CREATE TABLE tbl_gb18030(f1 varchar(3));
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! --  is not support by euc_cn, but support on gb18030
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! -- which not support by gbk, but support on gb18030
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! -- out of bound error
! INSERT INTO tbl_gb18030 (f1) VALUES ('2');
! ERROR:  value too long for type character varying(3)
! INSERT INTO tbl_gb18030 (f1) VALUES ('2');
! ERROR:  value too long for type character varying(3)
! -- text
! CREATE TABLE tbl_text(i int, f1 text);
! INSERT INTO tbl_text (f1) VALUES ('');
! INSERT INTO tbl_text (f1) VALUES ('');
! --  is not support by euc_cn, but support on gb18030
! INSERT INTO tbl_text (f1) VALUES ('');
! INSERT INTO tbl_text (f1) VALUES ('');
! INSERT INTO tbl_text (f1) VALUES ('');
! INSERT INTO tbl_text (f1) VALUES ('');
! -- which not support by gbk, but support on gb18030
! INSERT INTO tbl_text (f1) VALUES ('');
! SELECT * FROM tbl_text ORDER BY f1;
!  i |     f1     
! ---+------------
!    | \u0080
!    | 
!    | 
!    | 
!    | 
!    | 
!    | 
! (7 rows)
! 
! -- nvarchar2
! CREATE TABLE tbl_nvarchar2(i int, f1 nvarchar2(3) );
! INSERT INTO tbl_nvarchar2 (f1) VALUES ('');
! INSERT INTO tbl_nvarchar2 (f1) VALUES ('');
! --  is not support by euc_cn, but support on gb18030
! INSERT INTO tbl_nvarchar2 (f1) VALUES ('');
! INSERT INTO tbl_nvarchar2 (f1) VALUES ('');
! INSERT INTO tbl_nvarchar2 (f1) VALUES ('');
! INSERT INTO tbl_nvarchar2 (f1) VALUES ('');
! -- which not support by gbk, but support on gb18030
! INSERT INTO tbl_nvarchar2 (f1) VALUES ('');
! SELECT * FROM tbl_nvarchar2 ORDER BY f1;
!  i |     f1     
! ---+------------
!    | \u0080
!    | 
!    | 
!    | 
!    | 
!    | 
!    | 
! (7 rows)
! 
! -- bpchar
! CREATE TABLE tbl_bpchar(i int, f1 bpchar(3) );
! INSERT INTO tbl_bpchar (f1) VALUES ('');
! INSERT INTO tbl_bpchar (f1) VALUES ('');
! --  is not support by euc_cn, but support on gb18030
! INSERT INTO tbl_bpchar (f1) VALUES ('');
! INSERT INTO tbl_bpchar (f1) VALUES ('');
! INSERT INTO tbl_bpchar (f1) VALUES ('');
! INSERT INTO tbl_bpchar (f1) VALUES ('');
! -- which not support by gbk, but support on gb18030
! INSERT INTO tbl_bpchar (f1) VALUES ('');
! SELECT * FROM tbl_bpchar ORDER BY f1;
!  i |     f1     
! ---+------------
!    | \u0080
!    | 
!    | 
!    | 
!    | 
!    |  
!    | 
! (7 rows)
! 
! -- char
! CREATE TABLE tbl_char(i int, f1 char(3) );
! INSERT INTO tbl_char (f1) VALUES ('');
! INSERT INTO tbl_char (f1) VALUES ('');
! --  is not support by euc_cn, but support on gb18030
! INSERT INTO tbl_char (f1) VALUES ('');
! INSERT INTO tbl_char (f1) VALUES ('');
! INSERT INTO tbl_char (f1) VALUES ('1');
! INSERT INTO tbl_char (f1) VALUES ('2');
! INSERT INTO tbl_char (f1) VALUES ('');
! INSERT INTO tbl_char (f1) VALUES ('');
! -- which not support by gbk, but support on gb18030
! INSERT INTO tbl_char (f1) VALUES ('');
! SELECT * FROM tbl_char ORDER BY f1;
!  i |     f1     
! ---+------------
!    | \u0080
!    | 
!    | 
!    | 1
!    | 2
!    | 
!    | 
!    |  
!    | 
! (9 rows)
! 
! -- order by
! SELECT * FROM tbl_gb18030 ORDER BY f1;
!      f1     
! ------------
!  \u0080
!  
!  
!  
!  
!  
!  
! (7 rows)
! 
! -- regular expression query
! SELECT * FROM tbl_gb18030 WHERE f1 ~ '^' ORDER BY f1;
!    f1   
! --------
!  
!  
! (2 rows)
! 
! -- query encoding length
! SELECT OCTET_LENGTH(f1) FROM tbl_gb18030 ORDER BY f1;
!  octet_length 
! --------------
!            12
!             6
!             6
!             6
!             6
!             4
!             6
! (7 rows)
! 
! -- MATERIALIZED VIEW join
! CREATE TABLE T_PERSON(i int, n varchar(32));
! INSERT INTO T_PERSON VALUES (1, '');
! INSERT INTO T_PERSON VALUES (2, '');
! CREATE TABLE T_NICK(id int, name varchar(32));
! INSERT INTO T_NICK VALUES (1, '');
! INSERT INTO T_NICK VALUES (2, '');
! CREATE MATERIALIZED VIEW T_MATER AS SELECT * FROM T_PERSON  WITH NO DATA;
! REFRESH MATERIALIZED VIEW T_MATER;
! SELECT * FROM T_NICK n JOIN T_MATER p on n.id=p.i order by i;
!  id | name | i |   n    
! ----+------+---+--------
!   1 |  | 1 | 
!   2 |  | 2 | 
! (2 rows)
! 
! SELECT * FROM T_NICK n JOIN T_MATER p on n.id=p.i order by name;
!  id | name | i |   n    
! ----+------+---+--------
!   2 |  | 2 | 
!   1 |  | 1 | 
! (2 rows)
! 
! SELECT * FROM T_NICK n JOIN T_MATER p on n.id=p.i order by n;
!  id | name | i |   n    
! ----+------+---+--------
!   1 |  | 1 | 
!   2 |  | 2 | 
! (2 rows)
! 
! DROP MATERIALIZED VIEW T_MATER;
! DROP TABLE T_PERSON;
! DROP TABLE T_NICK;
--- 2,7 ----
  -- gbk
  --
  CREATE DATABASE db_gbk template template0 encoding = gbk LC_COLLATE = 'zh_CN.gbk' LC_CTYPE = 'zh_CN.gbk';
+ ERROR:  invalid locale name: "zh_CN.gbk"
  \c db_gbk;
! \connect: FATAL:  database "db_gbk" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/strings.out"	2025-07-31 16:07:15.003067850 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/strings.out"	2025-07-31 16:38:21.703534172 +0800
***************
*** 1143,1149 ****
  
  -- If the length is less than zero, an ERROR is thrown.
  SELECT substr(f1, 5, -1) from toasttest;
! ERROR:  negative substring length not allowed
  -- If no third argument (length) is provided, the length to the end of the
  -- string is assumed.
  SELECT substr(f1, 99995) from toasttest;
--- 1143,1149 ----
  
  -- If the length is less than zero, an ERROR is thrown.
  SELECT substr(f1, 5, -1) from toasttest;
! ERROR:  node:datanode_1, backend_pid:381315, nodename:datanode_1,backend_pid:381315,message:negative substring length not allowed
  -- If no third argument (length) is provided, the length to the end of the
  -- string is assumed.
  SELECT substr(f1, 99995) from toasttest;
***************
*** 1193,1199 ****
  
  -- If the length is less than zero, an ERROR is thrown.
  SELECT substr(f1, 5, -1) from toasttest;
! ERROR:  negative substring length not allowed
  -- If no third argument (length) is provided, the length to the end of the
  -- string is assumed.
  SELECT substr(f1, 99995) from toasttest;
--- 1193,1199 ----
  
  -- If the length is less than zero, an ERROR is thrown.
  SELECT substr(f1, 5, -1) from toasttest;
! ERROR:  node:datanode_1, backend_pid:381315, nodename:datanode_1,backend_pid:381315,message:negative substring length not allowed
  -- If no third argument (length) is provided, the length to the end of the
  -- string is assumed.
  SELECT substr(f1, 99995) from toasttest;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/zhcn_gb18030.out"	2025-07-31 16:07:15.012067707 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/zhcn_gb18030.out"	2025-07-31 16:38:21.517138503 +0800
***************
*** 2,132 ****
  -- gbk
  --
  \c db_gbk;
! SET client_encoding = gbk;
! -- regular expression query
! SELECT * FROM tbl_gbk WHERE f1 ~ '^' ORDER BY f1;
!    f1   
! --------
!  
!  
! (2 rows)
! 
! DROP TABLE tbl_gbk;
! CREATE TABLE tbl_gbk(f1 varchar(3));
! INSERT INTO tbl_gbk (f1) VALUES ('');
! INSERT INTO tbl_gbk (f1) VALUES ('');
! -- F is not support by euc_cn, but support on gbk
! INSERT INTO tbl_gbk (f1) VALUES ('F');
! INSERT INTO tbl_gbk (f1) VALUES ('');
! INSERT INTO tbl_gbk (f1) VALUES ('');
! INSERT INTO tbl_gbk (f1) VALUES ('');
! -- error
! INSERT INTO tbl_gbk (f1) VALUES ('2');
! ERROR:  value too long for type character varying(3)
! -- order by
! SELECT * FROM tbl_gbk ORDER BY f1;
!    f1   
! --------
!  
!  
!  
!  
!  
!  F
! (6 rows)
! 
! -- regular expression query
! SELECT * FROM tbl_gbk WHERE f1 ~ '^' ORDER BY f1;
!    f1   
! --------
!  
!  
! (2 rows)
! 
! -- query encoding length
! SELECT OCTET_LENGTH(f1) FROM tbl_gbk ORDER BY f1;
!  octet_length 
! --------------
!             6
!             6
!             6
!             6
!             4
!             6
! (6 rows)
! 
! --
! -- gb18030
! --
! \c db_gb18030;
! SET client_encoding = gb18030;
! -- regular expression query
! SELECT * FROM tbl_gb18030 WHERE f1 ~ '^' ORDER BY f1;
!    f1   
! --------
!  
!  
! (2 rows)
! 
! SELECT * FROM tbl_gb18030 WHERE f1 ~ '^00' ORDER BY f1;
!    f1   
! --------
!  003353
! (1 row)
! 
! DROP TABLE tbl_gb18030;
! CREATE TABLE tbl_gb18030(f1 varchar(3));
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! -- F is not support by euc_cn, but support on gb18030
! INSERT INTO tbl_gb18030 (f1) VALUES ('F');
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! INSERT INTO tbl_gb18030 (f1) VALUES ('');
! -- which not support by gbk, but support on gb18030
! INSERT INTO tbl_gb18030 (f1) VALUES ('003353');
! -- out of bound error
! INSERT INTO tbl_gb18030 (f1) VALUES ('2');
! ERROR:  value too long for type character varying(3)
! INSERT INTO tbl_gb18030 (f1) VALUES ('0033532');
! ERROR:  value too long for type character varying(3)
! -- order by
! SELECT * FROM tbl_gb18030 ORDER BY f1;
!    f1   
! --------
!  003353
!  
!  
!  
!  
!  
!  F
! (7 rows)
! 
! -- regular expression query
! SELECT * FROM tbl_gb18030 WHERE f1 ~ '^' ORDER BY f1;
!    f1   
! --------
!  
!  
! (2 rows)
! 
! SELECT * FROM tbl_gb18030 WHERE f1 ~ '^00' ORDER BY f1;
!    f1   
! --------
!  003353
! (1 row)
! 
! -- query encoding length
! SELECT OCTET_LENGTH(f1) FROM tbl_gb18030 ORDER BY f1;
!  octet_length 
! --------------
!            12
!             6
!             6
!             6
!             6
!             4
!             6
! (7 rows)
! 
--- 2,5 ----
  -- gbk
  --
  \c db_gbk;
! \connect: FATAL:  database "db_gbk" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/time.out"	2025-07-31 16:07:15.004067834 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/time.out"	2025-07-31 16:38:22.655513599 +0800
***************
*** 88,94 ****
  HINT:  Could not choose a best candidate operator. You might need to add explicit type casts.
  --test now(), expect now() in transaction block keep a const value crossing node.
  create table tbl_now_cross_node(i int, t timestamp) distribute by shard(i);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --we are sure that distribute key i with value 1 and 3 would be scattered on different nodes.
  --expect select get nothing
  begin;
--- 88,93 ----

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/inet.out"	2025-07-31 16:07:14.985068136 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/inet.out"	2025-07-31 16:38:23.303499597 +0800
***************
*** 398,404 ****
  SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
                         QUERY PLAN                        
  ---------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
     ->  Sort
           Sort Key: i
           ->  Index Only Scan using inet_idx2 on inet_tbl
--- 398,404 ----
  SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
                         QUERY PLAN                        
  ---------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1)
     ->  Sort
           Sort Key: i
           ->  Index Only Scan using inet_idx2 on inet_tbl
***************
*** 548,554 ****
  SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
                         QUERY PLAN                        
  ---------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
     ->  Sort
           Sort Key: i
           ->  Index Only Scan using inet_idx3 on inet_tbl
--- 548,554 ----
  SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
                         QUERY PLAN                        
  ---------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1)
     ->  Sort
           Sort Key: i
           ->  Index Only Scan using inet_idx3 on inet_tbl
***************
*** 772,778 ****
  INSERT INTO INET_TBL (c, i) VALUES ('10', '10::/8');
  -- now, this one should fail
  SELECT inet_merge(c, i) FROM INET_TBL;
! ERROR:  cannot merge addresses from different families
  -- fix it by inet_same_family() condition
  SELECT inet_merge(c, i) FROM INET_TBL WHERE inet_same_family(c, i) ORDER BY 1;
     inet_merge    
--- 772,778 ----
  INSERT INTO INET_TBL (c, i) VALUES ('10', '10::/8');
  -- now, this one should fail
  SELECT inet_merge(c, i) FROM INET_TBL;
! ERROR:  node:datanode_1, backend_pid:381937, nodename:datanode_1,backend_pid:381937,message:cannot merge addresses from different families
  -- fix it by inet_same_family() condition
  SELECT inet_merge(c, i) FROM INET_TBL WHERE inet_same_family(c, i) ORDER BY 1;
     inet_merge    

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/horology.out"	2025-07-31 16:07:14.984068152 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/horology.out"	2025-07-31 16:38:24.082482768 +0800
***************
*** 2182,2188 ****
  
  SELECT '' AS three, f1 as abstime, cast(f1 as timestamp) AS "timestamp"
    FROM ABSTIME_TBL WHERE NOT isfinite(f1) ORDER BY f1;
! ERROR:  cannot convert abstime "invalid" to timestamp
  SELECT '' AS ten, f1 AS interval, reltime(f1) AS reltime
    FROM INTERVAL_TBL ORDER BY f1;
   ten |           interval            |            reltime            
--- 2182,2188 ----
  
  SELECT '' AS three, f1 as abstime, cast(f1 as timestamp) AS "timestamp"
    FROM ABSTIME_TBL WHERE NOT isfinite(f1) ORDER BY f1;
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:cannot convert abstime "invalid" to timestamp
  SELECT '' AS ten, f1 AS interval, reltime(f1) AS reltime
    FROM INTERVAL_TBL ORDER BY f1;
   ten |           interval            |            reltime            

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/opr_sanity_1.out"	2025-07-31 16:07:14.993068009 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/opr_sanity.out"	2025-07-31 16:38:24.304477972 +0800
***************
*** 837,846 ****
               OR (c.castsource = 'character'::regtype AND
                   p.proargtypes[0] = 'text'::regtype))
       OR NOT binary_coercible(p.prorettype, c.casttarget));
!  castsource | casttarget | castfunc | castcontext | castmethod 
! ------------+------------+----------+-------------+------------
! (0 rows)
! 
  SELECT c.*
  FROM pg_cast c, pg_proc p
  WHERE c.castfunc = p.oid AND
--- 837,843 ----
               OR (c.castsource = 'character'::regtype AND
                   p.proargtypes[0] = 'text'::regtype))
       OR NOT binary_coercible(p.prorettype, c.casttarget));
! ERROR:  remote qualification must exist in target list
  SELECT c.*
  FROM pg_cast c, pg_proc p
  WHERE c.castfunc = p.oid AND
***************
*** 1142,1151 ****
       OR NOT binary_coercible(p2.prorettype, p1.oprresult)
       OR NOT binary_coercible(p1.oprleft, p2.proargtypes[0])
       OR NOT binary_coercible(p1.oprright, p2.proargtypes[1]));
!  oid | oprname | oid | proname 
! -----+---------+-----+---------
! (0 rows)
! 
  SELECT p1.oid, p1.oprname, p2.oid, p2.proname
  FROM pg_operator AS p1, pg_proc AS p2
  WHERE p1.oprcode = p2.oid AND
--- 1139,1145 ----
       OR NOT binary_coercible(p2.prorettype, p1.oprresult)
       OR NOT binary_coercible(p1.oprleft, p2.proargtypes[0])
       OR NOT binary_coercible(p1.oprright, p2.proargtypes[1]));
! ERROR:  remote qualification must exist in target list
  SELECT p1.oid, p1.oprname, p2.oid, p2.proname
  FROM pg_operator AS p1, pg_proc AS p2
  WHERE p1.oprcode = p2.oid AND
***************
*** 1154,1163 ****
       OR NOT binary_coercible(p2.prorettype, p1.oprresult)
       OR NOT binary_coercible(p1.oprright, p2.proargtypes[0])
       OR p1.oprleft != 0);
!  oid | oprname | oid | proname 
! -----+---------+-----+---------
! (0 rows)
! 
  SELECT p1.oid, p1.oprname, p2.oid, p2.proname
  FROM pg_operator AS p1, pg_proc AS p2
  WHERE p1.oprcode = p2.oid AND
--- 1148,1154 ----
       OR NOT binary_coercible(p2.prorettype, p1.oprresult)
       OR NOT binary_coercible(p1.oprright, p2.proargtypes[0])
       OR p1.oprleft != 0);
! ERROR:  remote qualification must exist in target list
  SELECT p1.oid, p1.oprname, p2.oid, p2.proname
  FROM pg_operator AS p1, pg_proc AS p2
  WHERE p1.oprcode = p2.oid AND
***************
*** 1166,1175 ****
       OR NOT binary_coercible(p2.prorettype, p1.oprresult)
       OR NOT binary_coercible(p1.oprleft, p2.proargtypes[0])
       OR p1.oprright != 0);
!  oid | oprname | oid | proname 
! -----+---------+-----+---------
! (0 rows)
! 
  -- If the operator is mergejoinable or hashjoinable, its underlying function
  -- should not be volatile.
  SELECT p1.oid, p1.oprname, p2.oid, p2.proname
--- 1157,1163 ----
       OR NOT binary_coercible(p2.prorettype, p1.oprresult)
       OR NOT binary_coercible(p1.oprleft, p2.proargtypes[0])
       OR p1.oprright != 0);
! ERROR:  remote qualification must exist in target list
  -- If the operator is mergejoinable or hashjoinable, its underlying function
  -- should not be volatile.
  SELECT p1.oid, p1.oprname, p2.oid, p2.proname
***************
*** 1351,1360 ****
           NOT physically_coercible(p.proargtypes[2], ptr.proargtypes[3]))
       -- we could carry the check further, but 3 args is enough for now
      );
!  aggfnoid | proname | oid | proname 
! ----------+---------+-----+---------
! (0 rows)
! 
  -- Cross-check finalfn (if present) against its entry in pg_proc.
  SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.proname
  FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfn
--- 1339,1345 ----
           NOT physically_coercible(p.proargtypes[2], ptr.proargtypes[3]))
       -- we could carry the check further, but 3 args is enough for now
      );
! ERROR:  remote qualification must exist in target list
  -- Cross-check finalfn (if present) against its entry in pg_proc.
  SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.proname
  FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfn
***************
*** 1373,1382 ****
           NOT binary_coercible(p.proargtypes[2], pfn.proargtypes[3]))
       -- we could carry the check further, but 3 args is enough for now
      );
!  aggfnoid | proname | oid | proname 
! ----------+---------+-----+---------
! (0 rows)
! 
  -- If transfn is strict then either initval should be non-NULL, or
  -- input type should match transtype so that the first non-null input
  -- can be assigned as the state value.
--- 1358,1364 ----
           NOT binary_coercible(p.proargtypes[2], pfn.proargtypes[3]))
       -- we could carry the check further, but 3 args is enough for now
      );
! ERROR:  remote qualification must exist in target list
  -- If transfn is strict then either initval should be non-NULL, or
  -- input type should match transtype so that the first non-null input
  -- can be assigned as the state value.
***************
*** 1386,1395 ****
      a.aggtransfn = ptr.oid AND ptr.proisstrict AND
      a.agginitval IS NULL AND
      NOT binary_coercible(p.proargtypes[0], a.aggtranstype);
!  aggfnoid | proname | oid | proname 
! ----------+---------+-----+---------
! (0 rows)
! 
  -- Check for inconsistent specifications of moving-aggregate columns.
  SELECT ctid, aggfnoid::oid
  FROM pg_aggregate as p1
--- 1368,1374 ----
      a.aggtransfn = ptr.oid AND ptr.proisstrict AND
      a.agginitval IS NULL AND
      NOT binary_coercible(p.proargtypes[0], a.aggtranstype);
! ERROR:  remote qualification must exist in target list
  -- Check for inconsistent specifications of moving-aggregate columns.
  SELECT ctid, aggfnoid::oid
  FROM pg_aggregate as p1
***************
*** 1437,1446 ****
           NOT physically_coercible(p.proargtypes[2], ptr.proargtypes[3]))
       -- we could carry the check further, but 3 args is enough for now
      );
!  aggfnoid | proname | oid | proname 
! ----------+---------+-----+---------
! (0 rows)
! 
  -- Cross-check minvtransfn (if present) against its entry in pg_proc.
  SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
  FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
--- 1416,1422 ----
           NOT physically_coercible(p.proargtypes[2], ptr.proargtypes[3]))
       -- we could carry the check further, but 3 args is enough for now
      );
! ERROR:  remote qualification must exist in target list
  -- Cross-check minvtransfn (if present) against its entry in pg_proc.
  SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
  FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
***************
*** 1460,1469 ****
           NOT physically_coercible(p.proargtypes[2], ptr.proargtypes[3]))
       -- we could carry the check further, but 3 args is enough for now
      );
!  aggfnoid | proname | oid | proname 
! ----------+---------+-----+---------
! (0 rows)
! 
  -- Cross-check mfinalfn (if present) against its entry in pg_proc.
  SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.proname
  FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfn
--- 1436,1442 ----
           NOT physically_coercible(p.proargtypes[2], ptr.proargtypes[3]))
       -- we could carry the check further, but 3 args is enough for now
      );
! ERROR:  remote qualification must exist in target list
  -- Cross-check mfinalfn (if present) against its entry in pg_proc.
  SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.proname
  FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfn
***************
*** 1482,1491 ****
           NOT binary_coercible(p.proargtypes[2], pfn.proargtypes[3]))
       -- we could carry the check further, but 3 args is enough for now
      );
!  aggfnoid | proname | oid | proname 
! ----------+---------+-----+---------
! (0 rows)
! 
  -- If mtransfn is strict then either minitval should be non-NULL, or
  -- input type should match mtranstype so that the first non-null input
  -- can be assigned as the state value.
--- 1455,1461 ----
           NOT binary_coercible(p.proargtypes[2], pfn.proargtypes[3]))
       -- we could carry the check further, but 3 args is enough for now
      );
! ERROR:  remote qualification must exist in target list
  -- If mtransfn is strict then either minitval should be non-NULL, or
  -- input type should match mtranstype so that the first non-null input
  -- can be assigned as the state value.
***************
*** 1495,1504 ****
      a.aggmtransfn = ptr.oid AND ptr.proisstrict AND
      a.aggminitval IS NULL AND
      NOT binary_coercible(p.proargtypes[0], a.aggmtranstype);
!  aggfnoid | proname | oid | proname 
! ----------+---------+-----+---------
! (0 rows)
! 
  -- mtransfn and minvtransfn should have same strictness setting.
  SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname, iptr.oid, iptr.proname
  FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr, pg_proc AS iptr
--- 1465,1471 ----
      a.aggmtransfn = ptr.oid AND ptr.proisstrict AND
      a.aggminitval IS NULL AND
      NOT binary_coercible(p.proargtypes[0], a.aggmtranstype);
! ERROR:  remote qualification must exist in target list
  -- mtransfn and minvtransfn should have same strictness setting.
  SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname, iptr.oid, iptr.proname
  FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr, pg_proc AS iptr
***************
*** 1521,1530 ****
       p.prorettype != p.proargtypes[0] OR
       p.prorettype != p.proargtypes[1] OR
       NOT physically_coercible(a.aggtranstype, p.proargtypes[0]));
!  aggfnoid | proname 
! ----------+---------
! (0 rows)
! 
  -- Check that no combine function for an INTERNAL transtype is strict.
  SELECT a.aggfnoid, p.proname
  FROM pg_aggregate as a, pg_proc as p
--- 1488,1494 ----
       p.prorettype != p.proargtypes[0] OR
       p.prorettype != p.proargtypes[1] OR
       NOT physically_coercible(a.aggtranstype, p.proargtypes[0]));
! ERROR:  remote qualification must exist in target list
  -- Check that no combine function for an INTERNAL transtype is strict.
  SELECT a.aggfnoid, p.proname
  FROM pg_aggregate as a, pg_proc as p
***************
*** 1921,1930 ****
  WHERE NOT EXISTS(SELECT 1 FROM pg_amop AS p2
                   WHERE p2.amopfamily = p1.opcfamily
                     AND binary_coercible(p1.opcintype, p2.amoplefttype));
!  opcname | opcfamily 
! ---------+-----------
! (0 rows)
! 
  -- Check that each operator listed in pg_amop has an associated opclass,
  -- that is one whose opcintype matches oprleft (possibly by coercion).
  -- Otherwise the operator is useless because it cannot be matched to an index.
--- 1885,1891 ----
  WHERE NOT EXISTS(SELECT 1 FROM pg_amop AS p2
                   WHERE p2.amopfamily = p1.opcfamily
                     AND binary_coercible(p1.opcintype, p2.amoplefttype));
! ERROR:  remote qualification must exist in target list
  -- Check that each operator listed in pg_amop has an associated opclass,
  -- that is one whose opcintype matches oprleft (possibly by coercion).
  -- Otherwise the operator is useless because it cannot be matched to an index.
***************
*** 1936,1945 ****
  WHERE NOT EXISTS(SELECT 1 FROM pg_opclass AS p2
                   WHERE p2.opcfamily = p1.amopfamily
                     AND binary_coercible(p2.opcintype, p1.amoplefttype));
!  amopfamily | amopstrategy | amopopr 
! ------------+--------------+---------
! (0 rows)
! 
  -- Operators that are primary members of opclasses must be immutable (else
  -- it suggests that the index ordering isn't fixed).  Operators that are
  -- cross-type members need only be stable, since they are just shorthands
--- 1897,1903 ----
  WHERE NOT EXISTS(SELECT 1 FROM pg_opclass AS p2
                   WHERE p2.opcfamily = p1.amopfamily
                     AND binary_coercible(p2.opcintype, p1.amoplefttype));
! ERROR:  remote qualification must exist in target list
  -- Operators that are primary members of opclasses must be immutable (else
  -- it suggests that the index ordering isn't fixed).  Operators that are
  -- cross-type members need only be stable, since they are just shorthands
***************
*** 2025,2034 ****
        pg_opclass opc
  WHERE a.attrelid = indrelid AND a.attnum = ikey AND opc.oid = iclass AND
        (NOT binary_coercible(atttypid, opcintype) OR icoll != attcollation);
!  indexrelid | indrelid | attname | atttypid | opcname 
! ------------+----------+---------+----------+---------
! (0 rows)
! 
  -- For system catalogs, be even tighter: nearly all indexes should be
  -- exact type matches not binary-coercible matches.  At this writing
  -- the only exception is an OID index on a regproc column.
--- 1983,1989 ----
        pg_opclass opc
  WHERE a.attrelid = indrelid AND a.attnum = ikey AND opc.oid = iclass AND
        (NOT binary_coercible(atttypid, opcintype) OR icoll != attcollation);
! ERROR:  remote qualification must exist in target list
  -- For system catalogs, be even tighter: nearly all indexes should be
  -- exact type matches not binary-coercible matches.  At this writing
  -- the only exception is an OID index on a regproc column.

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/misc_sanity_1.out"	2025-07-31 16:07:14.991068041 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/misc_sanity.out"	2025-07-31 16:39:06.986647809 +0800
***************
*** 44,80 ****
  -- in initdb, where it intentionally isn't pinned.  Legitimate exceptions
  -- to that rule are listed in the comments in setup_depend().
  \c - audit_admin
! do $$
! declare relnm text;
!   reloid oid;
!   shared bool;
!   lowoid oid;
!   pinned bool;
! begin
! for relnm, reloid, shared in
!   select relname, oid, relisshared from pg_class
!   where relhasoids and oid < 16384 order by 1
! loop
!   execute 'select min(oid) from ' || relnm into lowoid;
!   continue when lowoid is null or lowoid >= 16384;
!   if shared then
!     pinned := exists(select 1 from pg_shdepend
!                      where refclassid = reloid and refobjid = lowoid
!                      and deptype = 'p');
!   else
!     pinned := exists(select 1 from pg_depend
!                      where refclassid = reloid and refobjid = lowoid
!                      and deptype = 'p');
!   end if;
!   if not pinned then
!     raise notice '% contains unpinned initdb-created object(s)', relnm;
!   end if;
! end loop;
! end$$;
! NOTICE:  pg_constraint contains unpinned initdb-created object(s)
! NOTICE:  pg_conversion contains unpinned initdb-created object(s)
! NOTICE:  pg_database contains unpinned initdb-created object(s)
! NOTICE:  pg_extension contains unpinned initdb-created object(s)
! NOTICE:  pg_rewrite contains unpinned initdb-created object(s)
! NOTICE:  pg_tablespace contains unpinned initdb-created object(s)
! NOTICE:  pgxc_node contains unpinned initdb-created object(s)
--- 44,47 ----
  -- in initdb, where it intentionally isn't pinned.  Legitimate exceptions
  -- to that rule are listed in the comments in setup_depend().
  \c - audit_admin
! \connect: fe_sendauth: no password supplied

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/insert.out"	2025-07-31 16:07:14.986068121 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/insert.out"	2025-07-31 16:39:08.779801455 +0800
***************
*** 3,22 ****
  --
  create table inserttest (col1 int4, col2 int4 NOT NULL, col3 text default 'testing');
  insert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT, DEFAULT);
! ERROR:  null value in column "col2" violates not-null constraint
  DETAIL:  Failing row contains (null, null, testing).
  insert into inserttest (col2, col3) values (3, DEFAULT);
  insert into inserttest (col1, col2, col3) values (DEFAULT, 5, DEFAULT);
  insert into inserttest values (DEFAULT, 5, 'test');
  insert into inserttest values (DEFAULT, 7);
  select * from inserttest;
!  col1 | col2 |  col3   
! ------+------+---------
!       |    3 | testing
!       |    5 | testing
!       |    5 | test
!       |    7 | testing
! (4 rows)
  
  --
  -- insert with similar expression / target_list values (all fail)
--- 3,26 ----
  --
  create table inserttest (col1 int4, col2 int4 NOT NULL, col3 text default 'testing');
  insert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT, DEFAULT);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "col1" violates not-null constraint
  DETAIL:  Failing row contains (null, null, testing).
  insert into inserttest (col2, col3) values (3, DEFAULT);
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null, 3, testing).
  insert into inserttest (col1, col2, col3) values (DEFAULT, 5, DEFAULT);
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null, 5, testing).
  insert into inserttest values (DEFAULT, 5, 'test');
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null, 5, test).
  insert into inserttest values (DEFAULT, 7);
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null, 7, testing).
  select * from inserttest;
!  col1 | col2 | col3 
! ------+------+------
! (0 rows)
  
  --
  -- insert with similar expression / target_list values (all fail)
***************
*** 38,50 ****
  LINE 1: insert into inserttest (col1) values (DEFAULT, DEFAULT);
                                                         ^
  select * from inserttest;
!  col1 | col2 |  col3   
! ------+------+---------
!       |    3 | testing
!       |    5 | testing
!       |    5 | test
!       |    7 | testing
! (4 rows)
  
  --
  -- VALUES test
--- 42,50 ----
  LINE 1: insert into inserttest (col1) values (DEFAULT, DEFAULT);
                                                         ^
  select * from inserttest;
!  col1 | col2 | col3 
! ------+------+------
! (0 rows)
  
  --
  -- VALUES test
***************
*** 57,67 ****
     -1 |    2 | testing
      2 |    3 | values are fun!
     10 |   20 | 40
!       |    3 | testing
!       |    5 | test
!       |    5 | testing
!       |    7 | testing
! (7 rows)
  
  --
  -- TOASTed value test
--- 57,63 ----
     -1 |    2 | testing
      2 |    3 | values are fun!
     10 |   20 | 40
! (3 rows)
  
  --
  -- TOASTed value test
***************
*** 74,84 ****
      2 |    3 |          15
     10 |   20 |           2
     30 |   50 |       10000
!       |    3 |           7
!       |    5 |           4
!       |    5 |           7
!       |    7 |           7
! (8 rows)
  
  drop table inserttest;
  --
--- 70,76 ----
      2 |    3 |          15
     10 |   20 |           2
     30 |   50 |       10000
! (4 rows)
  
  drop table inserttest;
  --
***************
*** 90,134 ****
  create table inserttest (f1 int, f2 int[],
                           f3 insert_test_type, f4 insert_test_type[]);
  insert into inserttest (f2[1], f2[2]) values (1,2);
  insert into inserttest (f2[1], f2[2]) values (3,4), (5,6);
  insert into inserttest (f2[1], f2[2]) select 7,8;
  insert into inserttest (f2[1], f2[2]) values (1,default);  -- not supported
  ERROR:  cannot set an array element to DEFAULT
  LINE 1: insert into inserttest (f2[1], f2[2]) values (1,default);
                                         ^
  insert into inserttest (f3.if1, f3.if2) values (1,array['foo']);
  insert into inserttest (f3.if1, f3.if2) values (1,'{foo}'), (2,'{bar}');
  insert into inserttest (f3.if1, f3.if2) select 3, '{baz,quux}';
  insert into inserttest (f3.if1, f3.if2) values (1,default);  -- not supported
  ERROR:  cannot set a subfield to DEFAULT
  LINE 1: insert into inserttest (f3.if1, f3.if2) values (1,default);
                                          ^
  insert into inserttest (f3.if2[1], f3.if2[2]) values ('foo', 'bar');
  insert into inserttest (f3.if2[1], f3.if2[2]) values ('foo', 'bar'), ('baz', 'quux');
  insert into inserttest (f3.if2[1], f3.if2[2]) select 'bear', 'beer';
  insert into inserttest (f4[1].if2[1], f4[1].if2[2]) values ('foo', 'bar');
  insert into inserttest (f4[1].if2[1], f4[1].if2[2]) values ('foo', 'bar'), ('baz', 'quux');
  insert into inserttest (f4[1].if2[1], f4[1].if2[2]) select 'bear', 'beer';
  select * from inserttest;
!  f1 |  f2   |        f3        |           f4           
! ----+-------+------------------+------------------------
!     | {1,2} |                  | 
!     | {3,4} |                  | 
!     | {5,6} |                  | 
!     | {7,8} |                  | 
!     |       | (1,{foo})        | 
!     |       | (1,{foo})        | 
!     |       | (2,{bar})        | 
!     |       | (3,"{baz,quux}") | 
!     |       | (,"{foo,bar}")   | 
!     |       | (,"{foo,bar}")   | 
!     |       | (,"{baz,quux}")  | 
!     |       | (,"{bear,beer}") | 
!     |       |                  | {"(,\"{foo,bar}\")"}
!     |       |                  | {"(,\"{foo,bar}\")"}
!     |       |                  | {"(,\"{baz,quux}\")"}
!     |       |                  | {"(,\"{bear,beer}\")"}
! (16 rows)
  
  -- also check reverse-listing
  create table inserttest2 (f1 bigint, f2 text);
--- 82,130 ----
  create table inserttest (f1 int, f2 int[],
                           f3 insert_test_type, f4 insert_test_type[]);
  insert into inserttest (f2[1], f2[2]) values (1,2);
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "f1" violates not-null constraint
+ DETAIL:  Failing row contains (null, {1,2}, null, null).
  insert into inserttest (f2[1], f2[2]) values (3,4), (5,6);
+ ERROR:  column "f2" specified more than once
  insert into inserttest (f2[1], f2[2]) select 7,8;
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "f1" violates not-null constraint
+ DETAIL:  Failing row contains (null, {7,8}, null, null).
  insert into inserttest (f2[1], f2[2]) values (1,default);  -- not supported
  ERROR:  cannot set an array element to DEFAULT
  LINE 1: insert into inserttest (f2[1], f2[2]) values (1,default);
                                         ^
  insert into inserttest (f3.if1, f3.if2) values (1,array['foo']);
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "f1" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, (1,{foo}), null).
  insert into inserttest (f3.if1, f3.if2) values (1,'{foo}'), (2,'{bar}');
+ ERROR:  column "f3" specified more than once
  insert into inserttest (f3.if1, f3.if2) select 3, '{baz,quux}';
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "f1" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, (3,"{baz,quux}"), null).
  insert into inserttest (f3.if1, f3.if2) values (1,default);  -- not supported
  ERROR:  cannot set a subfield to DEFAULT
  LINE 1: insert into inserttest (f3.if1, f3.if2) values (1,default);
                                          ^
  insert into inserttest (f3.if2[1], f3.if2[2]) values ('foo', 'bar');
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "f1" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, (,"{foo,bar}"), null).
  insert into inserttest (f3.if2[1], f3.if2[2]) values ('foo', 'bar'), ('baz', 'quux');
+ ERROR:  column "f3" specified more than once
  insert into inserttest (f3.if2[1], f3.if2[2]) select 'bear', 'beer';
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "f1" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, (,"{bear,beer}"), null).
  insert into inserttest (f4[1].if2[1], f4[1].if2[2]) values ('foo', 'bar');
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "f1" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, null, {"(,\"{foo,bar}\")"}).
  insert into inserttest (f4[1].if2[1], f4[1].if2[2]) values ('foo', 'bar'), ('baz', 'quux');
+ ERROR:  column "f4" specified more than once
  insert into inserttest (f4[1].if2[1], f4[1].if2[2]) select 'bear', 'beer';
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "f1" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, null, {"(,\"{bear,beer}\")"}).
  select * from inserttest;
!  f1 | f2 | f3 | f4 
! ----+----+----+----
! (0 rows)
  
  -- also check reverse-listing
  create table inserttest2 (f1 bigint, f2 text);
***************
*** 145,151 ****
                                  Table "public.inserttest2"
   Column |  Type  | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+--------+-----------+----------+---------+----------+--------------+-------------
!  f1     | bigint |           |          |         | plain    |              | 
   f2     | text   |           |          |         | extended |              | 
  Rules:
      irule1 AS
--- 141,147 ----
                                  Table "public.inserttest2"
   Column |  Type  | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+--------+-----------+----------+---------+----------+--------------+-------------
!  f1     | bigint |           | not null |         | plain    |              | 
   f2     | text   |           |          |         | extended |              | 
  Rules:
      irule1 AS
***************
*** 156,162 ****
      irule3 AS
      ON INSERT TO inserttest2 DO  INSERT INTO inserttest (f4[1].if1, f4[1].if2[2])  SELECT new.f1,
              new.f2
! Distribute By: HASH(f1)
  Location Nodes: ALL DATANODES
  
  drop table inserttest2;
--- 152,158 ----
      irule3 AS
      ON INSERT TO inserttest2 DO  INSERT INTO inserttest (f4[1].if1, f4[1].if2[2])  SELECT new.f1,
              new.f2
! Distribute By: SHARD(f1)
  Location Nodes: ALL DATANODES
  
  drop table inserttest2;
***************
*** 169,175 ****
  ) partition by range (a, (b+0));
  -- no partitions, so fail
  insert into range_parted values ('a', 11);
! ERROR:  no partition of relation "range_parted" found for row
  DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 11).
  create table part1 partition of range_parted for values from ('a', 1) to ('a', 10);
  create table part2 partition of range_parted for values from ('a', 10) to ('a', 20);
--- 165,171 ----
  ) partition by range (a, (b+0));
  -- no partitions, so fail
  insert into range_parted values ('a', 11);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:no partition of relation "range_parted" found for row
  DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 11).
  create table part1 partition of range_parted for values from ('a', 1) to ('a', 10);
  create table part2 partition of range_parted for values from ('a', 10) to ('a', 20);
***************
*** 177,205 ****
  create table part4 partition of range_parted for values from ('b', 10) to ('b', 20);
  -- fail
  insert into part1 values ('a', 11);
! ERROR:  new row for relation "part1" violates partition constraint
  DETAIL:  Failing row contains (a, 11).
  insert into part1 values ('b', 1);
! ERROR:  new row for relation "part1" violates partition constraint
  DETAIL:  Failing row contains (b, 1).
  -- ok
  insert into part1 values ('a', 1);
  -- fail
  insert into part4 values ('b', 21);
! ERROR:  new row for relation "part4" violates partition constraint
  DETAIL:  Failing row contains (b, 21).
  insert into part4 values ('a', 10);
! ERROR:  new row for relation "part4" violates partition constraint
  DETAIL:  Failing row contains (a, 10).
  -- ok
  insert into part4 values ('b', 10);
  -- fail (partition key a has a NOT NULL constraint)
  insert into part1 values (null);
! ERROR:  new row for relation "part1" violates partition constraint
  DETAIL:  Failing row contains (null, null).
  -- fail (expression key (b+0) cannot be null either)
  insert into part1 values (1);
! ERROR:  new row for relation "part1" violates partition constraint
  DETAIL:  Failing row contains (1, null).
  create table list_parted (
  	a text,
--- 173,201 ----
  create table part4 partition of range_parted for values from ('b', 10) to ('b', 20);
  -- fail
  insert into part1 values ('a', 11);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "part1" violates partition constraint
  DETAIL:  Failing row contains (a, 11).
  insert into part1 values ('b', 1);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:new row for relation "part1" violates partition constraint
  DETAIL:  Failing row contains (b, 1).
  -- ok
  insert into part1 values ('a', 1);
  -- fail
  insert into part4 values ('b', 21);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:new row for relation "part4" violates partition constraint
  DETAIL:  Failing row contains (b, 21).
  insert into part4 values ('a', 10);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "part4" violates partition constraint
  DETAIL:  Failing row contains (a, 10).
  -- ok
  insert into part4 values ('b', 10);
  -- fail (partition key a has a NOT NULL constraint)
  insert into part1 values (null);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null, null).
  -- fail (expression key (b+0) cannot be null either)
  insert into part1 values (1);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "part1" violates partition constraint
  DETAIL:  Failing row contains (1, null).
  create table list_parted (
  	a text,
***************
*** 210,226 ****
  create table part_null partition of list_parted FOR VALUES IN (null);
  -- fail
  insert into part_aa_bb values ('cc', 1);
! ERROR:  new row for relation "part_aa_bb" violates partition constraint
  DETAIL:  Failing row contains (cc, 1).
  insert into part_aa_bb values ('AAa', 1);
! ERROR:  new row for relation "part_aa_bb" violates partition constraint
  DETAIL:  Failing row contains (AAa, 1).
  insert into part_aa_bb values (null);
! ERROR:  new row for relation "part_aa_bb" violates partition constraint
  DETAIL:  Failing row contains (null, null).
  -- ok
  insert into part_cc_dd values ('cC', 1);
  insert into part_null values (null, 0);
  -- check in case of multi-level partitioned table
  create table part_ee_ff partition of list_parted for values in ('ee', 'ff') partition by range (b);
  create table part_ee_ff1 partition of part_ee_ff for values from (1) to (10);
--- 206,224 ----
  create table part_null partition of list_parted FOR VALUES IN (null);
  -- fail
  insert into part_aa_bb values ('cc', 1);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "part_aa_bb" violates partition constraint
  DETAIL:  Failing row contains (cc, 1).
  insert into part_aa_bb values ('AAa', 1);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "part_aa_bb" violates partition constraint
  DETAIL:  Failing row contains (AAa, 1).
  insert into part_aa_bb values (null);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null, null).
  -- ok
  insert into part_cc_dd values ('cC', 1);
  insert into part_null values (null, 0);
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, 0).
  -- check in case of multi-level partitioned table
  create table part_ee_ff partition of list_parted for values in ('ee', 'ff') partition by range (b);
  create table part_ee_ff1 partition of part_ee_ff for values from (1) to (10);
***************
*** 230,239 ****
  -- Negative test: a row, which would fit in other partition, does not fit
  -- default partition, even when inserted directly
  insert into part_default values ('aa', 2);
! ERROR:  new row for relation "part_default" violates partition constraint
  DETAIL:  Failing row contains (aa, 2).
  insert into part_default values (null, 2);
! ERROR:  new row for relation "part_default" violates partition constraint
  DETAIL:  Failing row contains (null, 2).
  -- ok
  insert into part_default values ('Zz', 2);
--- 228,237 ----
  -- Negative test: a row, which would fit in other partition, does not fit
  -- default partition, even when inserted directly
  insert into part_default values ('aa', 2);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "part_default" violates partition constraint
  DETAIL:  Failing row contains (aa, 2).
  insert into part_default values (null, 2);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null, 2).
  -- ok
  insert into part_default values ('Zz', 2);
***************
*** 248,264 ****
  create table part_default_p2 partition of part_default for values from (30) to (40);
  -- fail
  insert into part_ee_ff1 values ('EE', 11);
! ERROR:  new row for relation "part_ee_ff1" violates partition constraint
  DETAIL:  Failing row contains (EE, 11).
  insert into part_default_p2 values ('gg', 43);
! ERROR:  new row for relation "part_default_p2" violates partition constraint
  DETAIL:  Failing row contains (gg, 43).
  -- fail (even the parent's, ie, part_ee_ff's partition constraint applies)
  insert into part_ee_ff1 values ('cc', 1);
! ERROR:  new row for relation "part_ee_ff1" violates partition constraint
  DETAIL:  Failing row contains (cc, 1).
  insert into part_default values ('gg', 43);
! ERROR:  no partition of relation "part_default" found for row
  DETAIL:  Partition key of the failing row contains (b) = (43).
  -- ok
  insert into part_ee_ff1 values ('ff', 1);
--- 246,262 ----
  create table part_default_p2 partition of part_default for values from (30) to (40);
  -- fail
  insert into part_ee_ff1 values ('EE', 11);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "part_ee_ff1" violates partition constraint
  DETAIL:  Failing row contains (EE, 11).
  insert into part_default_p2 values ('gg', 43);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:new row for relation "part_default_p2" violates partition constraint
  DETAIL:  Failing row contains (gg, 43).
  -- fail (even the parent's, ie, part_ee_ff's partition constraint applies)
  insert into part_ee_ff1 values ('cc', 1);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "part_ee_ff1" violates partition constraint
  DETAIL:  Failing row contains (cc, 1).
  insert into part_default values ('gg', 43);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:no partition of relation "part_default" found for row
  DETAIL:  Partition key of the failing row contains (b) = (43).
  -- ok
  insert into part_ee_ff1 values ('ff', 1);
***************
*** 272,278 ****
        tableoid      | a  | b  
  --------------------+----+----
   part_cc_dd         | cC |  1
-  part_null          |    |  0
   part_ee_ff1        | ff |  1
   part_ee_ff2        | ff | 11
   part_xx_yy_p1      | xx |  1
--- 270,275 ----
***************
*** 280,317 ****
   part_default_p1    | ab | 21
   part_default_p1    | cd | 25
   part_default_p2    | de | 35
! (9 rows)
  
  -- Check tuple routing for partitioned tables
  -- fail
  insert into range_parted values ('a', 0);
! ERROR:  no partition of relation "range_parted" found for row
  DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 0).
  -- ok
  insert into range_parted values ('a', 1);
  insert into range_parted values ('a', 10);
  -- fail
  insert into range_parted values ('a', 20);
! ERROR:  no partition of relation "range_parted" found for row
  DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 20).
  -- ok
  insert into range_parted values ('b', 1);
  insert into range_parted values ('b', 10);
  -- fail (partition key (b+0) is null)
  insert into range_parted values ('a');
! ERROR:  no partition of relation "range_parted" found for row
  DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, null).
  -- Check default partition
  create table part_def partition of range_parted default;
  -- fail
  insert into part_def values ('b', 10);
! ERROR:  new row for relation "part_def" violates partition constraint
  DETAIL:  Failing row contains (b, 10).
  -- ok
  insert into part_def values ('c', 10);
  insert into range_parted values (null, null);
  insert into range_parted values ('a', null);
  insert into range_parted values (null, 19);
  insert into range_parted values ('b', 20);
  select tableoid::regclass, * from range_parted order by 1, 2, 3;
   tableoid | a | b  
--- 277,318 ----
   part_default_p1    | ab | 21
   part_default_p1    | cd | 25
   part_default_p2    | de | 35
! (8 rows)
  
  -- Check tuple routing for partitioned tables
  -- fail
  insert into range_parted values ('a', 0);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:no partition of relation "range_parted" found for row
  DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 0).
  -- ok
  insert into range_parted values ('a', 1);
  insert into range_parted values ('a', 10);
  -- fail
  insert into range_parted values ('a', 20);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:no partition of relation "range_parted" found for row
  DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 20).
  -- ok
  insert into range_parted values ('b', 1);
  insert into range_parted values ('b', 10);
  -- fail (partition key (b+0) is null)
  insert into range_parted values ('a');
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:no partition of relation "range_parted" found for row
  DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, null).
  -- Check default partition
  create table part_def partition of range_parted default;
  -- fail
  insert into part_def values ('b', 10);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:new row for relation "part_def" violates partition constraint
  DETAIL:  Failing row contains (b, 10).
  -- ok
  insert into part_def values ('c', 10);
  insert into range_parted values (null, null);
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, null).
  insert into range_parted values ('a', null);
  insert into range_parted values (null, 19);
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, 19).
  insert into range_parted values ('b', 20);
  select tableoid::regclass, * from range_parted order by 1, 2, 3;
   tableoid | a | b  
***************
*** 325,343 ****
   part_def | a |   
   part_def | b | 20
   part_def | c | 10
!  part_def |   | 19
!  part_def |   |   
! (11 rows)
  
  -- ok
  insert into list_parted values (null, 1);
  insert into list_parted (a) values ('aA');
  -- fail (partition of part_ee_ff not found in both cases)
  insert into list_parted values ('EE', 0);
! ERROR:  no partition of relation "part_ee_ff" found for row
  DETAIL:  Partition key of the failing row contains (b) = (0).
  insert into part_ee_ff values ('EE', 0);
! ERROR:  no partition of relation "part_ee_ff" found for row
  DETAIL:  Partition key of the failing row contains (b) = (0).
  -- ok
  insert into list_parted values ('EE', 1);
--- 326,344 ----
   part_def | a |   
   part_def | b | 20
   part_def | c | 10
! (9 rows)
  
  -- ok
  insert into list_parted values (null, 1);
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, 1).
  insert into list_parted (a) values ('aA');
  -- fail (partition of part_ee_ff not found in both cases)
  insert into list_parted values ('EE', 0);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:no partition of relation "part_ee_ff" found for row
  DETAIL:  Partition key of the failing row contains (b) = (0).
  insert into part_ee_ff values ('EE', 0);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:no partition of relation "part_ee_ff" found for row
  DETAIL:  Partition key of the failing row contains (b) = (0).
  -- ok
  insert into list_parted values ('EE', 1);
***************
*** 347,354 ****
  --------------------+----+----
   part_aa_bb         | aA |   
   part_cc_dd         | cC |  1
-  part_null          |    |  0
-  part_null          |    |  1
   part_ee_ff1        | EE |  1
   part_ee_ff1        | ff |  1
   part_ee_ff2        | EE | 10
--- 348,353 ----
***************
*** 358,364 ****
   part_default_p1    | ab | 21
   part_default_p1    | cd | 25
   part_default_p2    | de | 35
! (13 rows)
  
  -- some more tests to exercise tuple-routing with multi-level partitioning
  create table part_gg partition of list_parted for values in ('gg') partition by range (b);
--- 357,363 ----
   part_default_p1    | ab | 21
   part_default_p1    | cd | 25
   part_default_p2    | de | 35
! (11 rows)
  
  -- some more tests to exercise tuple-routing with multi-level partitioning
  create table part_gg partition of list_parted for values in ('gg') partition by range (b);
***************
*** 374,379 ****
--- 373,380 ----
  insert into list_parted select 'Ff', s.a from generate_series(1, 29) s(a);
  insert into list_parted select 'gg', s.a from generate_series(1, 9) s(a);
  insert into list_parted (b) values (1);
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, 1).
  select tableoid::regclass::text, a, min(b) as min_b, max(b) as max_b from list_parted group by 1, 2 order by 1;
     tableoid    | a  | min_b | max_b 
  ---------------+----+-------+-------
***************
*** 385,392 ****
   part_ee_ff3_2 | Ff |    25 |    29
   part_gg2_1    | gg |     1 |     4
   part_gg2_2    | gg |     5 |     9
!  part_null     |    |     1 |     1
! (9 rows)
  
  -- direct partition inserts should check hash partition bound constraint
  -- create custom operator class and hash function, for the same reason
--- 386,392 ----
   part_ee_ff3_2 | Ff |    25 |    29
   part_gg2_1    | gg |     1 |     4
   part_gg2_2    | gg |     5 |     9
! (8 rows)
  
  -- direct partition inserts should check hash partition bound constraint
  -- create custom operator class and hash function, for the same reason
***************
*** 407,413 ****
  insert into hpart0 values(12),(16);
  -- fail;
  insert into hpart0 values(11);
! ERROR:  new row for relation "hpart0" violates partition constraint
  DETAIL:  Failing row contains (11).
  -- 11 % 4 -> 3 remainder i.e. valid data for hpart3 partition
  insert into hpart3 values(11);
--- 407,413 ----
  insert into hpart0 values(12),(16);
  -- fail;
  insert into hpart0 values(11);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "hpart0" violates partition constraint
  DETAIL:  Failing row contains (11).
  -- 11 % 4 -> 3 remainder i.e. valid data for hpart3 partition
  insert into hpart3 values(11);
***************
*** 437,443 ****
                                  Table "public.list_parted"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition key: LIST (lower(a))
  Partitions: part_aa_bb FOR VALUES IN ('aa', 'bb'),
--- 437,443 ----
                                  Table "public.list_parted"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition key: LIST (lower(a))
  Partitions: part_aa_bb FOR VALUES IN ('aa', 'bb'),
***************
*** 447,453 ****
              part_null FOR VALUES IN (NULL),
              part_xx_yy FOR VALUES IN ('xx', 'yy'), PARTITIONED,
              part_default DEFAULT, PARTITIONED
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  -- cleanup
--- 447,453 ----
              part_null FOR VALUES IN (NULL),
              part_xx_yy FOR VALUES IN ('xx', 'yy'), PARTITIONED,
              part_default DEFAULT, PARTITIONED
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  -- cleanup
***************
*** 463,484 ****
                                 Table "public.part_default"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
  Partition of: list_parted DEFAULT
  No partition constraint
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  insert into part_default values (null);
  insert into part_default values (1);
  insert into part_default values (-1);
  select tableoid::regclass, a from list_parted;
     tableoid   | a  
  --------------+----
-  part_default |   
   part_default |  1
   part_default | -1
! (3 rows)
  
  -- cleanup
  drop table list_parted;
--- 463,485 ----
                                 Table "public.part_default"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
  Partition of: list_parted DEFAULT
  No partition constraint
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  insert into part_default values (null);
+ ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  insert into part_default values (1);
  insert into part_default values (-1);
  select tableoid::regclass, a from list_parted;
     tableoid   | a  
  --------------+----
   part_default |  1
   part_default | -1
! (2 rows)
  
  -- cleanup
  drop table list_parted;
***************
*** 513,519 ****
  
  -- check that proper message is shown after failure to route through mlparted1
  insert into mlparted (a, b) values (1, 5);
! ERROR:  no partition of relation "mlparted1" found for row
  DETAIL:  Partition key of the failing row contains ((b + 0)) = (5).
  truncate mlparted;
  alter table mlparted add constraint check_b check (b = 3);
--- 514,520 ----
  
  -- check that proper message is shown after failure to route through mlparted1
  insert into mlparted (a, b) values (1, 5);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:no partition of relation "mlparted1" found for row
  DETAIL:  Partition key of the failing row contains ((b + 0)) = (5).
  truncate mlparted;
  alter table mlparted add constraint check_b check (b = 3);
***************
*** 529,557 ****
  language plpgsql;
  create trigger mlparted11_trig before insert ON mlparted11
    for each row execute procedure mlparted11_trig_fn();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- check that the correct row is shown when constraint check_b fails after
  -- "(1, 2)" is routed to mlparted11 (actually "(1, 4)" would be shown due
  -- to the BR trigger mlparted11_trig_fn)
  -- XXX since trigger are not supported in XL, "(1, 2)" would be shown
  insert into mlparted values (1, 2);
! ERROR:  new row for relation "mlparted11" violates check constraint "check_b"
  DETAIL:  Failing row contains (1, 2).
  drop trigger mlparted11_trig on mlparted11;
- ERROR:  trigger "mlparted11_trig" for table "mlparted11" does not exist
  drop function mlparted11_trig_fn();
  -- check that inserting into an internal partition successfully results in
  -- checking its partition constraint before inserting into the leaf partition
  -- selected by tuple-routing
  insert into mlparted1 (a, b) values (2, 3);
! ERROR:  new row for relation "mlparted1" violates partition constraint
  DETAIL:  Failing row contains (2, 3).
  -- check routing error through a list partitioned table when the key is null
  create table lparted_nonullpart (a int, b char) partition by list (b);
  create table lparted_nonullpart_a partition of lparted_nonullpart for values in ('a');
  insert into lparted_nonullpart values (1);
! ERROR:  no partition of relation "lparted_nonullpart" found for row
  DETAIL:  Partition key of the failing row contains (b) = (null).
  drop table lparted_nonullpart;
  -- check that RETURNING works correctly with tuple-routing
--- 530,555 ----
  language plpgsql;
  create trigger mlparted11_trig before insert ON mlparted11
    for each row execute procedure mlparted11_trig_fn();
  -- check that the correct row is shown when constraint check_b fails after
  -- "(1, 2)" is routed to mlparted11 (actually "(1, 4)" would be shown due
  -- to the BR trigger mlparted11_trig_fn)
  -- XXX since trigger are not supported in XL, "(1, 2)" would be shown
  insert into mlparted values (1, 2);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:new row for relation "mlparted11" violates check constraint "check_b"
  DETAIL:  Failing row contains (1, 2).
  drop trigger mlparted11_trig on mlparted11;
  drop function mlparted11_trig_fn();
  -- check that inserting into an internal partition successfully results in
  -- checking its partition constraint before inserting into the leaf partition
  -- selected by tuple-routing
  insert into mlparted1 (a, b) values (2, 3);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:new row for relation "mlparted1" violates partition constraint
  DETAIL:  Failing row contains (2, 3).
  -- check routing error through a list partitioned table when the key is null
  create table lparted_nonullpart (a int, b char) partition by list (b);
  create table lparted_nonullpart_a partition of lparted_nonullpart for values in ('a');
  insert into lparted_nonullpart values (1);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:no partition of relation "lparted_nonullpart" found for row
  DETAIL:  Partition key of the failing row contains (b) = (null).
  drop table lparted_nonullpart;
  -- check that RETURNING works correctly with tuple-routing
***************
*** 614,625 ****
  alter table mlparted attach partition mlparted5 for values from (1, 40) to (1, 50);
  alter table mlparted add constraint check_b check (a = 1 and b < 45);
  insert into mlparted values (1, 45, 'a');
! ERROR:  new row for relation "mlparted5a" violates check constraint "check_b"
  DETAIL:  Failing row contains (1, 45, a).
  create function mlparted5abrtrig_func() returns trigger as $$ begin new.c = 'b'; return new; end; $$ language plpgsql;
  create trigger mlparted5abrtrig before insert on mlparted5a for each row execute procedure mlparted5abrtrig_func();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  insert into mlparted5 (a, b, c) values (1, 40, 'a');
  drop table mlparted5;
  alter table mlparted drop constraint check_b;
--- 612,621 ----
  alter table mlparted attach partition mlparted5 for values from (1, 40) to (1, 50);
  alter table mlparted add constraint check_b check (a = 1 and b < 45);
  insert into mlparted values (1, 45, 'a');
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:new row for relation "mlparted5a" violates check constraint "check_b"
  DETAIL:  Failing row contains (1, 45, a).
  create function mlparted5abrtrig_func() returns trigger as $$ begin new.c = 'b'; return new; end; $$ language plpgsql;
  create trigger mlparted5abrtrig before insert on mlparted5a for each row execute procedure mlparted5abrtrig_func();
  insert into mlparted5 (a, b, c) values (1, 40, 'a');
  drop table mlparted5;
  alter table mlparted drop constraint check_b;
***************
*** 632,644 ****
  insert into mlparted_def2 values (54, 50);
  -- fail
  insert into mlparted values (70, 100);
! ERROR:  no partition of relation "mlparted_def" found for row
  DETAIL:  Partition key of the failing row contains (a) = (70).
  insert into mlparted_def1 values (52, 50);
! ERROR:  new row for relation "mlparted_def1" violates partition constraint
  DETAIL:  Failing row contains (52, 50, null).
  insert into mlparted_def2 values (34, 50);
! ERROR:  new row for relation "mlparted_def2" violates partition constraint
  DETAIL:  Failing row contains (34, 50, null).
  -- ok
  create table mlparted_defd partition of mlparted_def default;
--- 628,640 ----
  insert into mlparted_def2 values (54, 50);
  -- fail
  insert into mlparted values (70, 100);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:no partition of relation "mlparted_def" found for row
  DETAIL:  Partition key of the failing row contains (a) = (70).
  insert into mlparted_def1 values (52, 50);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:new row for relation "mlparted_def1" violates partition constraint
  DETAIL:  Failing row contains (52, 50, null).
  insert into mlparted_def2 values (34, 50);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "mlparted_def2" violates partition constraint
  DETAIL:  Failing row contains (34, 50, null).
  -- ok
  create table mlparted_defd partition of mlparted_def default;
***************
*** 662,678 ****
  set role someone_else;
  -- no key description is shown
  insert into key_desc values (1, 1);
! ERROR:  no partition of relation "key_desc_1" found for row
  reset role;
  grant select (b) on key_desc_1 to someone_else;
  set role someone_else;
  -- key description (b)=(1) is now shown
  insert into key_desc values (1, 1);
! ERROR:  no partition of relation "key_desc_1" found for row
  DETAIL:  Partition key of the failing row contains (b) = (1).
  -- key description is not shown if key contains expression
  insert into key_desc values (2, 1);
! ERROR:  no partition of relation "key_desc" found for row
  reset role;
  revoke all on key_desc from someone_else;
  revoke all on key_desc_1 from someone_else;
--- 658,674 ----
  set role someone_else;
  -- no key description is shown
  insert into key_desc values (1, 1);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:no partition of relation "key_desc_1" found for row
  reset role;
  grant select (b) on key_desc_1 to someone_else;
  set role someone_else;
  -- key description (b)=(1) is now shown
  insert into key_desc values (1, 1);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:no partition of relation "key_desc_1" found for row
  DETAIL:  Partition key of the failing row contains (b) = (1).
  -- key description is not shown if key contains expression
  insert into key_desc values (2, 1);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:no partition of relation "key_desc" found for row
  reset role;
  revoke all on key_desc from someone_else;
  revoke all on key_desc_1 from someone_else;
***************
*** 702,708 ****
  create table mcrparted5 partition of mcrparted for values from (30, 21, 20) to (maxvalue, maxvalue, maxvalue);
  -- null not allowed in range partition
  insert into mcrparted values (null, null, null);
! ERROR:  no partition of relation "mcrparted" found for row
  DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (null, null, null).
  -- routed to mcrparted0
  insert into mcrparted values (0, 1, 1);
--- 698,704 ----
  create table mcrparted5 partition of mcrparted for values from (30, 21, 20) to (maxvalue, maxvalue, maxvalue);
  -- null not allowed in range partition
  insert into mcrparted values (null, null, null);
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:no partition of relation "mcrparted" found for row
  DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (null, null, null).
  -- routed to mcrparted0
  insert into mcrparted values (0, 1, 1);
***************
*** 721,736 ****
  insert into mcrparted2 values (10, 1000, 1000);
  -- no partition exists, nor does mcrparted3 accept it
  insert into mcrparted values (11, 1, -1);
! ERROR:  no partition of relation "mcrparted" found for row
  DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (11, 1, -1).
  insert into mcrparted3 values (11, 1, -1);
! ERROR:  new row for relation "mcrparted3" violates partition constraint
  DETAIL:  Failing row contains (11, 1, -1).
  -- routed to mcrparted5
  insert into mcrparted values (30, 21, 20);
  insert into mcrparted5 values (30, 21, 20);
  insert into mcrparted4 values (30, 21, 20);	-- error
! ERROR:  new row for relation "mcrparted4" violates partition constraint
  DETAIL:  Failing row contains (30, 21, 20).
  -- check rows
  select tableoid::regclass::text, * from mcrparted order by 1, 2, 3, 4;
--- 717,732 ----
  insert into mcrparted2 values (10, 1000, 1000);
  -- no partition exists, nor does mcrparted3 accept it
  insert into mcrparted values (11, 1, -1);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:no partition of relation "mcrparted" found for row
  DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (11, 1, -1).
  insert into mcrparted3 values (11, 1, -1);
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "mcrparted3" violates partition constraint
  DETAIL:  Failing row contains (11, 1, -1).
  -- routed to mcrparted5
  insert into mcrparted values (30, 21, 20);
  insert into mcrparted5 values (30, 21, 20);
  insert into mcrparted4 values (30, 21, 20);	-- error
! ERROR:  node:datanode_2, backend_pid:381336, nodename:datanode_2,backend_pid:381336,message:new row for relation "mcrparted4" violates partition constraint
  DETAIL:  Failing row contains (30, 21, 20).
  -- check rows
  select tableoid::regclass::text, * from mcrparted order by 1, 2, 3, 4;
***************
*** 759,768 ****
  create table brtrigpartcon1 partition of brtrigpartcon for values in (1);
  create or replace function brtrigpartcon1trigf() returns trigger as $$begin new.a := 2; return new; end$$ language plpgsql;
  create trigger brtrigpartcon1trig before insert on brtrigpartcon1 for each row execute procedure brtrigpartcon1trigf();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  insert into brtrigpartcon values (1, 'hi there');
  insert into brtrigpartcon1 values (1, 'hi there');
  -- check that the message shows the appropriate column description in a
  -- situation where the partitioned table is not the primary ModifyTable node
  create table inserttest3 (f1 text default 'foo', f2 text default 'bar', f3 int);
--- 755,764 ----
  create table brtrigpartcon1 partition of brtrigpartcon for values in (1);
  create or replace function brtrigpartcon1trigf() returns trigger as $$begin new.a := 2; return new; end$$ language plpgsql;
  create trigger brtrigpartcon1trig before insert on brtrigpartcon1 for each row execute procedure brtrigpartcon1trigf();
  insert into brtrigpartcon values (1, 'hi there');
  insert into brtrigpartcon1 values (1, 'hi there');
+ ERROR:  new row for relation "brtrigpartcon1" violates partition constraint
+ DETAIL:  Failing row contains (2, hi there).
  -- check that the message shows the appropriate column description in a
  -- situation where the partitioned table is not the primary ModifyTable node
  create table inserttest3 (f1 text default 'foo', f2 text default 'bar', f3 int);
***************
*** 792,814 ****
  ERROR:  Distribution column cannot be dropped
  create or replace function donothingbrtrig_func() returns trigger as $$begin raise notice 'b: %', new.b; return NULL; end$$ language plpgsql;
  create trigger donothingbrtrig1 before insert on donothingbrtrig_test1 for each row execute procedure donothingbrtrig_func();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger donothingbrtrig2 before insert on donothingbrtrig_test2 for each row execute procedure donothingbrtrig_func();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  alter table donothingbrtrig_test attach partition donothingbrtrig_test1 for values in (1);
! ERROR:  table "donothingbrtrig_test1" contains column "a" at position 2, but parent "donothingbrtrig_test" has it at position 1
! DETAIL:  Postgres-XL requires attribute positions to match
! HINT:  Check for column ordering and dropped columns, if any
  alter table donothingbrtrig_test attach partition donothingbrtrig_test2 for values in (2);
  ERROR:  table "donothingbrtrig_test2" contains column "c" not found in parent "donothingbrtrig_test"
  DETAIL:  New partition should contain only the columns present in parent.
  insert into donothingbrtrig_test values (1, 'foo'), (2, 'bar');
! ERROR:  no partition of relation "donothingbrtrig_test" found for row
  DETAIL:  Partition key of the failing row contains (a) = (1).
  copy donothingbrtrig_test from stdout;
! ERROR:  no partition of relation "donothingbrtrig_test" found for row
  DETAIL:  Partition key of the failing row contains (a) = (1).
  select tableoid::regclass, * from donothingbrtrig_test;
   tableoid | a | b 
--- 788,804 ----
  ERROR:  Distribution column cannot be dropped
  create or replace function donothingbrtrig_func() returns trigger as $$begin raise notice 'b: %', new.b; return NULL; end$$ language plpgsql;
  create trigger donothingbrtrig1 before insert on donothingbrtrig_test1 for each row execute procedure donothingbrtrig_func();
  create trigger donothingbrtrig2 before insert on donothingbrtrig_test2 for each row execute procedure donothingbrtrig_func();
  alter table donothingbrtrig_test attach partition donothingbrtrig_test1 for values in (1);
! ERROR:  column "a" in child table must be marked NOT NULL
  alter table donothingbrtrig_test attach partition donothingbrtrig_test2 for values in (2);
  ERROR:  table "donothingbrtrig_test2" contains column "c" not found in parent "donothingbrtrig_test"
  DETAIL:  New partition should contain only the columns present in parent.
  insert into donothingbrtrig_test values (1, 'foo'), (2, 'bar');
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:no partition of relation "donothingbrtrig_test" found for row
  DETAIL:  Partition key of the failing row contains (a) = (1).
  copy donothingbrtrig_test from stdout;
! ERROR:  node:datanode_1, backend_pid:381925, nodename:datanode_1,backend_pid:381925,message:no partition of relation "donothingbrtrig_test" found for row
  DETAIL:  Partition key of the failing row contains (a) = (1).
  select tableoid::regclass, * from donothingbrtrig_test;
   tableoid | a | b 
***************
*** 818,823 ****
--- 808,817 ----
  -- cleanup
  drop table donothingbrtrig_test;
  drop function donothingbrtrig_func();
+ ERROR:  cannot drop function donothingbrtrig_func() because other objects depend on it
+ DETAIL:  trigger donothingbrtrig1 on table donothingbrtrig_test1 depends on function donothingbrtrig_func()
+ trigger donothingbrtrig2 on table donothingbrtrig_test2 depends on function donothingbrtrig_func()
+ HINT:  Use DROP ... CASCADE to drop the dependent objects too.
  -- check multi-column range partitioning with minvalue/maxvalue constraints
  create table mcrparted (a text, b int) partition by range(a, b);
  create table mcrparted1_lt_b partition of mcrparted for values from (minvalue, minvalue) to ('b', minvalue);
***************
*** 832,838 ****
                                   Table "public.mcrparted"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition key: RANGE (a, b)
  Partitions: mcrparted1_lt_b FOR VALUES FROM (MINVALUE, MINVALUE) TO ('b', MINVALUE),
--- 826,832 ----
                                   Table "public.mcrparted"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition key: RANGE (a, b)
  Partitions: mcrparted1_lt_b FOR VALUES FROM (MINVALUE, MINVALUE) TO ('b', MINVALUE),
***************
*** 843,937 ****
              mcrparted6_common_ge_10 FOR VALUES FROM ('common', 10) TO ('common', MAXVALUE),
              mcrparted7_gt_common_lt_d FOR VALUES FROM ('common', MAXVALUE) TO ('d', MINVALUE),
              mcrparted8_ge_d FOR VALUES FROM ('d', MINVALUE) TO (MAXVALUE, MAXVALUE)
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted1_lt_b
                                Table "public.mcrparted1_lt_b"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM (MINVALUE, MINVALUE) TO ('b', MINVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a < 'b'::text))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted2_b
                                  Table "public.mcrparted2_b"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('b', MINVALUE) TO ('c', MINVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'b'::text) AND (a < 'c'::text))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted3_c_to_common
                             Table "public.mcrparted3_c_to_common"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('c', MINVALUE) TO ('common', MINVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'c'::text) AND (a < 'common'::text))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted4_common_lt_0
                             Table "public.mcrparted4_common_lt_0"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('common', MINVALUE) TO ('common', 0)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b < 0))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted5_common_0_to_10
                           Table "public.mcrparted5_common_0_to_10"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('common', 0) TO ('common', 10)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b >= 0) AND (b < 10))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted6_common_ge_10
                            Table "public.mcrparted6_common_ge_10"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('common', 10) TO ('common', MAXVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b >= 10))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted7_gt_common_lt_d
                           Table "public.mcrparted7_gt_common_lt_d"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('common', MAXVALUE) TO ('d', MINVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a > 'common'::text) AND (a < 'd'::text))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted8_ge_d
                                Table "public.mcrparted8_ge_d"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('d', MINVALUE) TO (MAXVALUE, MAXVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'd'::text))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  insert into mcrparted values ('aaa', 0), ('b', 0), ('bz', 10), ('c', -10),
--- 837,931 ----
              mcrparted6_common_ge_10 FOR VALUES FROM ('common', 10) TO ('common', MAXVALUE),
              mcrparted7_gt_common_lt_d FOR VALUES FROM ('common', MAXVALUE) TO ('d', MINVALUE),
              mcrparted8_ge_d FOR VALUES FROM ('d', MINVALUE) TO (MAXVALUE, MAXVALUE)
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted1_lt_b
                                Table "public.mcrparted1_lt_b"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM (MINVALUE, MINVALUE) TO ('b', MINVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a < 'b'::text))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted2_b
                                  Table "public.mcrparted2_b"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('b', MINVALUE) TO ('c', MINVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'b'::text) AND (a < 'c'::text))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted3_c_to_common
                             Table "public.mcrparted3_c_to_common"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('c', MINVALUE) TO ('common', MINVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'c'::text) AND (a < 'common'::text))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted4_common_lt_0
                             Table "public.mcrparted4_common_lt_0"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('common', MINVALUE) TO ('common', 0)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b < 0))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted5_common_0_to_10
                           Table "public.mcrparted5_common_0_to_10"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('common', 0) TO ('common', 10)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b >= 0) AND (b < 10))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted6_common_ge_10
                            Table "public.mcrparted6_common_ge_10"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('common', 10) TO ('common', MAXVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b >= 10))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted7_gt_common_lt_d
                           Table "public.mcrparted7_gt_common_lt_d"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('common', MAXVALUE) TO ('d', MINVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a > 'common'::text) AND (a < 'd'::text))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  \d+ mcrparted8_ge_d
                                Table "public.mcrparted8_ge_d"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           |          |         | plain    |              | 
  Partition of: mcrparted FOR VALUES FROM ('d', MINVALUE) TO (MAXVALUE, MAXVALUE)
  Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'd'::text))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  insert into mcrparted values ('aaa', 0), ('b', 0), ('bz', 10), ('c', -10),
***************
*** 977,985 ****
  drop table returningwrtest;
  -- check insert into a shard table from a CTE table
  create table t1(f1 int,f2 int) distribute by shard(f1);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  create table t2(f1 int,f2 int) distribute by shard(f1);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into t1 values(1,1);
  insert into t1 values(2,2);
  with baseInfo as(select * from t1)
--- 971,977 ----
***************
*** 995,1001 ****
  drop table if exists t2_new;
  NOTICE:  table "t2_new" does not exist, skipping
  create table t2(f1 int,f2 int);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  create table t2_rep(f1 int,f2 int) distribute by replication;
  insert into t2_rep values(1,1),(2,2);
  insert into t2 select * from t2_rep;
--- 987,992 ----
***************
*** 1012,1018 ****
  (1 row)
  
  create table t2_new as select * from t2_rep;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  select count(*) from t2_new;
   count 
  -------
--- 1003,1008 ----
***************
*** 1060,1066 ****
      total numeric(255,0)
  )
  DISTRIBUTE BY SHARD (id) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  CREATE TABLE ods_today_st_river_r (
      stcd character(8) NOT NULL,
      tm timestamp(6) without time zone NOT NULL,
--- 1050,1055 ----
***************
*** 1077,1083 ****
      moditime timestamp(6) without time zone
  )
  DISTRIBUTE BY SHARD (stcd) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  COPY ods_time_record (id, mintime, describe, systemtime, remarks, total) FROM stdin;
  COPY ods_today_st_river_r (stcd, tm, z, q, xsa, xsavv, xsmxv, flwchrcd, wptn, msqmt, msamt, msvmt, moditime) FROM stdin;
  ALTER TABLE ONLY ods_today_st_river_r
--- 1066,1071 ----

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/insert_conflict_1.out"	2025-07-31 16:07:14.986068121 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/insert_conflict.out"	2025-07-31 16:39:09.514463855 +0800
***************
*** 12,20 ****
  create unique index both_index_expr_key on insertconflicttest(key, lower(fruit) collate "C" text_pattern_ops);
  -- fails
  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key) do nothing;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit) do nothing;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  -- succeeds
  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit) do nothing;
                                       QUERY PLAN                                      
--- 12,20 ----
  create unique index both_index_expr_key on insertconflicttest(key, lower(fruit) collate "C" text_pattern_ops);
  -- fails
  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key) do nothing;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit) do nothing;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  -- succeeds
  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit) do nothing;
                                       QUERY PLAN                                      
***************
*** 167,176 ****
  ERROR:  Unique index of partitioned table must contain the hash/modulo distribution column.
  -- fails:
  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) text_pattern_ops, upper(fruit) collate "C") do nothing;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  -- works:
  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C", upper(fruit) text_pattern_ops) do nothing;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index cross_match;
  ERROR:  index "cross_match" does not exist
  --
--- 167,176 ----
  ERROR:  Unique index of partitioned table must contain the hash/modulo distribution column.
  -- fails:
  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) text_pattern_ops, upper(fruit) collate "C") do nothing;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  -- works:
  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C", upper(fruit) text_pattern_ops) do nothing;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index cross_match;
  ERROR:  index "cross_match" does not exist
  --
***************
*** 288,300 ****
  HINT:  Perhaps you meant to reference the column "excluded.fruit".
  -- inference fails:
  insert into insertconflicttest values (3, 'Kiwi') on conflict (key, fruit) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (4, 'Mango') on conflict (fruit, key) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (5, 'Lemon') on conflict (fruit) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (6, 'Passionfruit') on conflict (lower(fruit)) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  -- Check the target relation can be aliased
  insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = excluded.fruit; -- ok, no reference to target table
  insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = ict.fruit; -- ok, alias
--- 288,300 ----
  HINT:  Perhaps you meant to reference the column "excluded.fruit".
  -- inference fails:
  insert into insertconflicttest values (3, 'Kiwi') on conflict (key, fruit) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (4, 'Mango') on conflict (fruit, key) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (5, 'Lemon') on conflict (fruit) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (6, 'Passionfruit') on conflict (lower(fruit)) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  -- Check the target relation can be aliased
  insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = excluded.fruit; -- ok, no reference to target table
  insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = ict.fruit; -- ok, alias
***************
*** 313,325 ****
  insert into insertconflicttest values (8, 'Lime') on conflict (fruit, key) do update set fruit = excluded.fruit;
  -- inference fails:
  insert into insertconflicttest values (9, 'Banana') on conflict (key) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (10, 'Blueberry') on conflict (key, key, key) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (11, 'Cherry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (12, 'Date') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index comp_key_index;
  --
  -- Partial index tests, no inference predicate specified
--- 313,325 ----
  insert into insertconflicttest values (8, 'Lime') on conflict (fruit, key) do update set fruit = excluded.fruit;
  -- inference fails:
  insert into insertconflicttest values (9, 'Banana') on conflict (key) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (10, 'Blueberry') on conflict (key, key, key) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (11, 'Cherry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (12, 'Date') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index comp_key_index;
  --
  -- Partial index tests, no inference predicate specified
***************
*** 328,344 ****
  create unique index expr_part_comp_key_index on insertconflicttest(key, lower(fruit)) where key < 5;
  -- inference fails:
  insert into insertconflicttest values (13, 'Grape') on conflict (key, fruit) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (14, 'Raisin') on conflict (fruit, key) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (15, 'Cranberry') on conflict (key) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (16, 'Melon') on conflict (key, key, key) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (17, 'Mulberry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (18, 'Pineapple') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index part_comp_key_index;
  drop index expr_part_comp_key_index;
  --
--- 328,344 ----
  create unique index expr_part_comp_key_index on insertconflicttest(key, lower(fruit)) where key < 5;
  -- inference fails:
  insert into insertconflicttest values (13, 'Grape') on conflict (key, fruit) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (14, 'Raisin') on conflict (fruit, key) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (15, 'Cranberry') on conflict (key) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (16, 'Melon') on conflict (key, key, key) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (17, 'Mulberry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (18, 'Pineapple') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index part_comp_key_index;
  drop index expr_part_comp_key_index;
  --
***************
*** 348,361 ****
  ERROR:  Unique index of partitioned table must contain the hash/modulo distribution column.
  -- inference succeeds:
  insert into insertconflicttest values (20, 'Quince') on conflict (lower(fruit)) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (21, 'Pomegranate') on conflict (lower(fruit), lower(fruit)) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  -- inference fails:
  insert into insertconflicttest values (22, 'Apricot') on conflict (upper(fruit)) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index expr_key_index;
  ERROR:  index "expr_key_index" does not exist
  --
--- 348,361 ----
  ERROR:  Unique index of partitioned table must contain the hash/modulo distribution column.
  -- inference succeeds:
  insert into insertconflicttest values (20, 'Quince') on conflict (lower(fruit)) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (21, 'Pomegranate') on conflict (lower(fruit), lower(fruit)) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  -- inference fails:
  insert into insertconflicttest values (22, 'Apricot') on conflict (upper(fruit)) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index expr_key_index;
  ERROR:  index "expr_key_index" does not exist
  --
***************
*** 380,390 ****
  
  -- inference fails:
  insert into insertconflicttest values (27, 'Prune') on conflict (key, upper(fruit)) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (28, 'Redcurrant') on conflict (fruit, key) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (29, 'Nectarine') on conflict (key) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index expr_comp_key_index;
  drop index tricky_expr_comp_key_index;
  --
--- 380,390 ----
  
  -- inference fails:
  insert into insertconflicttest values (27, 'Prune') on conflict (key, upper(fruit)) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (28, 'Redcurrant') on conflict (fruit, key) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (29, 'Nectarine') on conflict (key) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index expr_comp_key_index;
  drop index tricky_expr_comp_key_index;
  --
***************
*** 401,407 ****
  -- succeeds, since "key" isn't repeated/referenced in UPDATE, and "fruit"
  -- arbitrates that statement updates existing "Fig" row:
  insert into insertconflicttest values (25, 'Fig') on conflict (fruit) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index key_index;
  drop index fruit_index;
  ERROR:  index "fruit_index" does not exist
--- 401,407 ----
  -- succeeds, since "key" isn't repeated/referenced in UPDATE, and "fruit"
  -- arbitrates that statement updates existing "Fig" row:
  insert into insertconflicttest values (25, 'Fig') on conflict (fruit) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index key_index;
  drop index fruit_index;
  ERROR:  index "fruit_index" does not exist
***************
*** 414,424 ****
  insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' and fruit = 'inconsequential' do nothing;
  -- fails
  insert into insertconflicttest values (23, 'Blackberry') on conflict (key) do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' or fruit = 'consequential' do nothing;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) where fruit like '%berry' do update set fruit = excluded.fruit;
! ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index partial_key_index;
  --
  -- Test that wholerow references to ON CONFLICT's EXCLUDED work
--- 414,424 ----
  insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' and fruit = 'inconsequential' do nothing;
  -- fails
  insert into insertconflicttest values (23, 'Blackberry') on conflict (key) do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' or fruit = 'consequential' do nothing;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) where fruit like '%berry' do update set fruit = excluded.fruit;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:there is no unique or exclusion constraint matching the ON CONFLICT specification
  drop index partial_key_index;
  --
  -- Test that wholerow references to ON CONFLICT's EXCLUDED work
***************
*** 777,790 ****
                               exclude using gist(f2 with &&));
  insert into twoconstraints values(1, '((0,0),(1,1))');
  insert into twoconstraints values(1, '((2,2),(3,3))');  -- fail on f1
! ERROR:  duplicate key value violates unique constraint "twoconstraints_f1_key"
  DETAIL:  Key (f1)=(1) already exists.
  insert into twoconstraints values(2, '((0,0),(1,2))');  -- fail on f2
! ERROR:  conflicting key value violates exclusion constraint "twoconstraints_f2_excl"
  DETAIL:  Key (f2)=((1,2),(0,0)) conflicts with existing key (f2)=((1,1),(0,0)).
  insert into twoconstraints values(2, '((0,0),(1,2))')
    on conflict on constraint twoconstraints_f1_key do nothing;  -- fail on f2
! ERROR:  conflicting key value violates exclusion constraint "twoconstraints_f2_excl"
  DETAIL:  Key (f2)=((1,2),(0,0)) conflicts with existing key (f2)=((1,1),(0,0)).
  insert into twoconstraints values(2, '((0,0),(1,2))')
    on conflict on constraint twoconstraints_f2_excl do nothing;  -- do nothing
--- 777,790 ----
                               exclude using gist(f2 with &&));
  insert into twoconstraints values(1, '((0,0),(1,1))');
  insert into twoconstraints values(1, '((2,2),(3,3))');  -- fail on f1
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:duplicate key value violates unique constraint "twoconstraints_f1_key"
  DETAIL:  Key (f1)=(1) already exists.
  insert into twoconstraints values(2, '((0,0),(1,2))');  -- fail on f2
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:conflicting key value violates exclusion constraint "twoconstraints_f2_excl"
  DETAIL:  Key (f2)=((1,2),(0,0)) conflicts with existing key (f2)=((1,1),(0,0)).
  insert into twoconstraints values(2, '((0,0),(1,2))')
    on conflict on constraint twoconstraints_f1_key do nothing;  -- fail on f2
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:conflicting key value violates exclusion constraint "twoconstraints_f2_excl"
  DETAIL:  Key (f2)=((1,2),(0,0)) conflicts with existing key (f2)=((1,1),(0,0)).
  insert into twoconstraints values(2, '((0,0),(1,2))')
    on conflict on constraint twoconstraints_f2_excl do nothing;  -- do nothing
***************
*** 808,824 ****
  commit;
  begin transaction isolation level read committed;
  insert into selfconflict values (4,1), (4,2) on conflict(f1) do update set f2 = 0;
! ERROR:  ON CONFLICT DO UPDATE command cannot affect row a second time
  HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
  commit;
  begin transaction isolation level repeatable read;
  insert into selfconflict values (5,1), (5,2) on conflict(f1) do update set f2 = 0;
! ERROR:  ON CONFLICT DO UPDATE command cannot affect row a second time
  HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
  commit;
  begin transaction isolation level serializable;
  insert into selfconflict values (6,1), (6,2) on conflict(f1) do update set f2 = 0;
! ERROR:  ON CONFLICT DO UPDATE command cannot affect row a second time
  HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
  commit;
  select * from selfconflict order by 1;
--- 808,824 ----
  commit;
  begin transaction isolation level read committed;
  insert into selfconflict values (4,1), (4,2) on conflict(f1) do update set f2 = 0;
! ERROR:  node:datanode_2, backend_pid:381334, nodename:datanode_2,backend_pid:381334,message:ON CONFLICT DO UPDATE command cannot affect row a second time
  HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
  commit;
  begin transaction isolation level repeatable read;
  insert into selfconflict values (5,1), (5,2) on conflict(f1) do update set f2 = 0;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:ON CONFLICT DO UPDATE command cannot affect row a second time
  HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
  commit;
  begin transaction isolation level serializable;
  insert into selfconflict values (6,1), (6,2) on conflict(f1) do update set f2 = 0;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:ON CONFLICT DO UPDATE command cannot affect row a second time
  HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
  commit;
  select * from selfconflict order by 1;
***************
*** 836,845 ****
  create table parted_conflict_test_1 partition of parted_conflict_test (b unique) for values in (1);
  ERROR:  Unique index of partitioned table must contain the hash/modulo distribution column.
  insert into parted_conflict_test values (1, 'a') on conflict do nothing;
! ERROR:  no partition of relation "parted_conflict_test" found for row
  DETAIL:  Partition key of the failing row contains (a) = (1).
  insert into parted_conflict_test values (1, 'a') on conflict do nothing;
! ERROR:  no partition of relation "parted_conflict_test" found for row
  DETAIL:  Partition key of the failing row contains (a) = (1).
  -- however, on conflict do update is not supported yet
  insert into parted_conflict_test values (1) on conflict (b) do update set a = excluded.a;
--- 836,845 ----
  create table parted_conflict_test_1 partition of parted_conflict_test (b unique) for values in (1);
  ERROR:  Unique index of partitioned table must contain the hash/modulo distribution column.
  insert into parted_conflict_test values (1, 'a') on conflict do nothing;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:no partition of relation "parted_conflict_test" found for row
  DETAIL:  Partition key of the failing row contains (a) = (1).
  insert into parted_conflict_test values (1, 'a') on conflict do nothing;
! ERROR:  node:datanode_1, backend_pid:381304, nodename:datanode_1,backend_pid:381304,message:no partition of relation "parted_conflict_test" found for row
  DETAIL:  Partition key of the failing row contains (a) = (1).
  -- however, on conflict do update is not supported yet
  insert into parted_conflict_test values (1) on conflict (b) do update set a = excluded.a;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/create_table.out"	2025-07-31 16:07:14.981068200 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/create_table.out"	2025-07-31 16:39:11.073472478 +0800
***************
*** 199,204 ****
--- 199,205 ----
  CREATE TABLE testjsonb (
         j jsonb
  );
+ ERROR:  Column j is not a shard distributable data type
  CREATE TABLE unknowntab (
  	u unknown    -- fail
  );
***************
*** 419,425 ****
              Table "public.partitioned"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
   c      | text    |           |          | 
   d      | text    |           |          | 
--- 420,426 ----
              Table "public.partitioned"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
   c      | text    |           |          | 
   d      | text    |           |          | 
***************
*** 430,455 ****
                                  Table "public.partitioned2"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | integer |           |          |         | plain    |              | 
   b      | text    |           |          |         | extended |              | 
  Partition key: RANGE (((a + 1)), substr(b, 1, 5))
  Number of partitions: 0
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO partitioned2 VALUES (1, 'hello');
! ERROR:  no partition of relation "partitioned2" found for row
  DETAIL:  Partition key of the failing row contains ((a + 1), substr(b, 1, 5)) = (2, hello).
  CREATE TABLE part2_1 PARTITION OF partitioned2 FOR VALUES FROM (-1, 'aaaaa') TO (100, 'ccccc');
  \d+ part2_1
                                    Table "public.part2_1"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | integer |           |          |         | plain    |              | 
   b      | text    |           |          |         | extended |              | 
  Partition of: partitioned2 FOR VALUES FROM ('-1', 'aaaaa') TO (100, 'ccccc')
  Partition constraint: (((a + 1) IS NOT NULL) AND (substr(b, 1, 5) IS NOT NULL) AND (((a + 1) > '-1'::integer) OR (((a + 1) = '-1'::integer) AND (substr(b, 1, 5) >= 'aaaaa'::text))) AND (((a + 1) < 100) OR (((a + 1) = 100) AND (substr(b, 1, 5) < 'ccccc'::text))))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  DROP TABLE partitioned, partitioned2;
--- 431,456 ----
                                  Table "public.partitioned2"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | integer |           | not null |         | plain    |              | 
   b      | text    |           |          |         | extended |              | 
  Partition key: RANGE (((a + 1)), substr(b, 1, 5))
  Number of partitions: 0
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO partitioned2 VALUES (1, 'hello');
! ERROR:  node:datanode_1, backend_pid:381924, nodename:datanode_1,backend_pid:381924,message:no partition of relation "partitioned2" found for row
  DETAIL:  Partition key of the failing row contains ((a + 1), substr(b, 1, 5)) = (2, hello).
  CREATE TABLE part2_1 PARTITION OF partitioned2 FOR VALUES FROM (-1, 'aaaaa') TO (100, 'ccccc');
  \d+ part2_1
                                    Table "public.part2_1"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | integer |           | not null |         | plain    |              | 
   b      | text    |           |          |         | extended |              | 
  Partition of: partitioned2 FOR VALUES FROM ('-1', 'aaaaa') TO (100, 'ccccc')
  Partition constraint: (((a + 1) IS NOT NULL) AND (substr(b, 1, 5) IS NOT NULL) AND (((a + 1) > '-1'::integer) OR (((a + 1) = '-1'::integer) AND (substr(b, 1, 5) >= 'aaaaa'::text))) AND (((a + 1) < 100) OR (((a + 1) = 100) AND (substr(b, 1, 5) < 'ccccc'::text))))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  DROP TABLE partitioned, partitioned2;
***************
*** 645,655 ****
                               Table "public.part_forced_oids"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
  Partition of: oids_parted FOR VALUES FROM (1) TO (10)
  Partition constraint: ((a IS NOT NULL) AND (a >= 1) AND (a < 10))
  Has OIDs: yes
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  DROP TABLE oids_parted, part_forced_oids;
--- 646,656 ----
                               Table "public.part_forced_oids"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
  Partition of: oids_parted FOR VALUES FROM (1) TO (10)
  Partition constraint: ((a IS NOT NULL) AND (a >= 1) AND (a < 10))
  Has OIDs: yes
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  DROP TABLE oids_parted, part_forced_oids;
***************
*** 667,673 ****
  -- check default partition overlap
  INSERT INTO list_parted2 VALUES('X');
  CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('W', 'X', 'Y');
! ERROR:  updated partition constraint for default partition "list_parted2_def" would be violated by some row
  CREATE TABLE range_parted2 (
  	a int
  ) PARTITION BY RANGE (a);
--- 668,674 ----
  -- check default partition overlap
  INSERT INTO list_parted2 VALUES('X');
  CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('W', 'X', 'Y');
! ERROR:  node:datanode_1, backend_pid:381924, nodename:datanode_1,backend_pid:381924,message:updated partition constraint for default partition "list_parted2_def" would be violated by some row
  CREATE TABLE range_parted2 (
  	a int
  ) PARTITION BY RANGE (a);
***************
*** 699,705 ****
  -- Check if the range for default partitions overlap
  INSERT INTO range_parted2 VALUES (85);
  CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (80) TO (90);
! ERROR:  updated partition constraint for default partition "range2_default" would be violated by some row
  CREATE TABLE part4 PARTITION OF range_parted2 FOR VALUES FROM (90) TO (100);
  -- now check for multi-column range partition key
  CREATE TABLE range_parted3 (
--- 700,706 ----
  -- Check if the range for default partitions overlap
  INSERT INTO range_parted2 VALUES (85);
  CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (80) TO (90);
! ERROR:  node:datanode_1, backend_pid:381924, nodename:datanode_1,backend_pid:381924,message:updated partition constraint for default partition "range2_default" would be violated by some row
  CREATE TABLE part4 PARTITION OF range_parted2 FOR VALUES FROM (90) TO (100);
  -- now check for multi-column range partition key
  CREATE TABLE range_parted3 (
***************
*** 788,801 ****
                                     Table "public.part_b"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           | not null | 1       | plain    |              | 
  Partition of: parted FOR VALUES IN ('b')
  Partition constraint: ((a IS NOT NULL) AND (a = ANY (ARRAY['b'::text])))
  Check constraints:
      "check_a" CHECK (length(a) > 0)
      "part_b_b_check" CHECK (b >= 0)
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  -- Both partition bound and partition key in describe output
--- 789,802 ----
                                     Table "public.part_b"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           | not null | 1       | plain    |              | 
  Partition of: parted FOR VALUES IN ('b')
  Partition constraint: ((a IS NOT NULL) AND (a = ANY (ARRAY['b'::text])))
  Check constraints:
      "check_a" CHECK (length(a) > 0)
      "part_b_b_check" CHECK (b >= 0)
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  -- Both partition bound and partition key in describe output
***************
*** 803,809 ****
                                     Table "public.part_c"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           | not null | 0       | plain    |              | 
  Partition of: parted FOR VALUES IN ('c')
  Partition constraint: ((a IS NOT NULL) AND (a = ANY (ARRAY['c'::text])))
--- 804,810 ----
                                     Table "public.part_c"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           | not null | 0       | plain    |              | 
  Partition of: parted FOR VALUES IN ('c')
  Partition constraint: ((a IS NOT NULL) AND (a = ANY (ARRAY['c'::text])))
***************
*** 811,817 ****
  Check constraints:
      "check_a" CHECK (length(a) > 0)
  Partitions: part_c_1_10 FOR VALUES FROM (1) TO (10)
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  -- a level-2 partition's constraint will include the parent's expressions
--- 812,818 ----
  Check constraints:
      "check_a" CHECK (length(a) > 0)
  Partitions: part_c_1_10 FOR VALUES FROM (1) TO (10)
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  -- a level-2 partition's constraint will include the parent's expressions
***************
*** 819,831 ****
                                  Table "public.part_c_1_10"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           |          |         | extended |              | 
   b      | integer |           | not null | 0       | plain    |              | 
  Partition of: part_c FOR VALUES FROM (1) TO (10)
  Partition constraint: ((a IS NOT NULL) AND (a = ANY (ARRAY['c'::text])) AND (b IS NOT NULL) AND (b >= 1) AND (b < 10))
  Check constraints:
      "check_a" CHECK (length(a) > 0)
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  -- Show partition count in the parent's describe output
--- 820,832 ----
                                  Table "public.part_c_1_10"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  --------+---------+-----------+----------+---------+----------+--------------+-------------
!  a      | text    |           | not null |         | extended |              | 
   b      | integer |           | not null | 0       | plain    |              | 
  Partition of: part_c FOR VALUES FROM (1) TO (10)
  Partition constraint: ((a IS NOT NULL) AND (a = ANY (ARRAY['c'::text])) AND (b IS NOT NULL) AND (b >= 1) AND (b < 10))
  Check constraints:
      "check_a" CHECK (length(a) > 0)
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  -- Show partition count in the parent's describe output
***************
*** 836,842 ****
                 Table "public.parted"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | text    |           |          | 
   b      | integer |           | not null | 0
  Partition key: LIST (a)
  Check constraints:
--- 837,843 ----
                 Table "public.parted"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | text    |           | not null | 
   b      | integer |           | not null | 0
  Partition key: LIST (a)
  Check constraints:
***************
*** 847,853 ****
              Table "public.hash_parted"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
  Partition key: HASH (a)
  Number of partitions: 3 (Use \d+ to list them.)
  
--- 848,854 ----
              Table "public.hash_parted"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
  Partition key: HASH (a)
  Number of partitions: 3 (Use \d+ to list them.)
  
***************
*** 858,869 ****
                             Table "public.unbounded_range_part"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
   b      | integer |           |          |         | plain   |              | 
   c      | integer |           |          |         | plain   |              | 
  Partition of: range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (MAXVALUE, MAXVALUE, MAXVALUE)
  Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  DROP TABLE unbounded_range_part;
--- 859,870 ----
                             Table "public.unbounded_range_part"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
   b      | integer |           |          |         | plain   |              | 
   c      | integer |           |          |         | plain   |              | 
  Partition of: range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (MAXVALUE, MAXVALUE, MAXVALUE)
  Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  DROP TABLE unbounded_range_part;
***************
*** 872,883 ****
                                Table "public.range_parted4_1"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
   b      | integer |           |          |         | plain   |              | 
   c      | integer |           |          |         | plain   |              | 
  Partition of: range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE)
  Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND (abs(a) <= 1))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  CREATE TABLE range_parted4_2 PARTITION OF range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE);
--- 873,884 ----
                                Table "public.range_parted4_1"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
   b      | integer |           |          |         | plain   |              | 
   c      | integer |           |          |         | plain   |              | 
  Partition of: range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE)
  Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND (abs(a) <= 1))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  CREATE TABLE range_parted4_2 PARTITION OF range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE);
***************
*** 885,896 ****
                                Table "public.range_parted4_2"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
   b      | integer |           |          |         | plain   |              | 
   c      | integer |           |          |         | plain   |              | 
  Partition of: range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE)
  Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND ((abs(a) > 3) OR ((abs(a) = 3) AND (abs(b) > 4)) OR ((abs(a) = 3) AND (abs(b) = 4) AND (c >= 5))) AND ((abs(a) < 6) OR ((abs(a) = 6) AND (abs(b) <= 7))))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  CREATE TABLE range_parted4_3 PARTITION OF range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE);
--- 886,897 ----
                                Table "public.range_parted4_2"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
   b      | integer |           |          |         | plain   |              | 
   c      | integer |           |          |         | plain   |              | 
  Partition of: range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE)
  Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND ((abs(a) > 3) OR ((abs(a) = 3) AND (abs(b) > 4)) OR ((abs(a) = 3) AND (abs(b) = 4) AND (c >= 5))) AND ((abs(a) < 6) OR ((abs(a) = 6) AND (abs(b) <= 7))))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  CREATE TABLE range_parted4_3 PARTITION OF range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE);
***************
*** 898,909 ****
                                Table "public.range_parted4_3"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
   b      | integer |           |          |         | plain   |              | 
   c      | integer |           |          |         | plain   |              | 
  Partition of: range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE)
  Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND ((abs(a) > 6) OR ((abs(a) = 6) AND (abs(b) >= 8))) AND (abs(a) <= 9))
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  DROP TABLE range_parted4;
--- 899,910 ----
                                Table "public.range_parted4_3"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
   b      | integer |           |          |         | plain   |              | 
   c      | integer |           |          |         | plain   |              | 
  Partition of: range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE)
  Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND ((abs(a) > 6) OR ((abs(a) = 6) AND (abs(b) >= 8))) AND (abs(a) <= 9))
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  DROP TABLE range_parted4;
***************
*** 925,935 ****
                                Table "public.parted_col_comment"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target |  Description  
  --------+---------+-----------+----------+---------+----------+--------------+---------------
!  a      | integer |           |          |         | plain    |              | Partition key
   b      | text    |           |          |         | extended |              | 
  Partition key: LIST (a)
  Number of partitions: 0
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  DROP TABLE parted_col_comment;
--- 926,936 ----
                                Table "public.parted_col_comment"
   Column |  Type   | Collation | Nullable | Default | Storage  | Stats target |  Description  
  --------+---------+-----------+----------+---------+----------+--------------+---------------
!  a      | integer |           | not null |         | plain    |              | Partition key
   b      | text    |           |          |         | extended |              | 
  Partition key: LIST (a)
  Number of partitions: 0
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  DROP TABLE parted_col_comment;
***************
*** 941,951 ****
                                   Table "public.boolspart"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | boolean |           |          |         | plain   |              | 
  Partition key: LIST (a)
  Partitions: boolspart_f FOR VALUES IN (false),
              boolspart_t FOR VALUES IN (true)
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  drop table boolspart;
--- 942,952 ----
                                   Table "public.boolspart"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | boolean |           | not null |         | plain   |              | 
  Partition key: LIST (a)
  Partitions: boolspart_f FOR VALUES IN (false),
              boolspart_t FOR VALUES IN (true)
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  drop table boolspart;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/copy.out"	2025-07-31 16:37:23.183105236 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/copy.out"	2025-07-31 16:39:12.543033929 +0800
***************
*** 23,28 ****
--- 23,29 ----
  COPY hash_f8_heap FROM '/home/wyx//opentenbase/src/test/regress/data/hash.data';
  COPY test_tsvector FROM '/home/wyx//opentenbase/src/test/regress/data/tsearch.data';
  COPY testjsonb FROM '/home/wyx//opentenbase/src/test/regress/data/jsonb.data';
+ ERROR:  relation "testjsonb" does not exist
  -- the data in this file has a lot of duplicates in the index key
  -- fields, leading to long bucket chains and lots of table expansion.
  -- this is therefore a stress test of the bucket overflow code (unlike

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/copydml.out"	2025-07-31 16:07:14.981068200 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/copydml.out"	2025-07-31 16:39:11.625460667 +0800
***************
*** 94,110 ****
  $$ language plpgsql;
  create trigger qqqbef before insert or update or delete on copydml_test
      for each row execute procedure qqq_trig();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger qqqaf after insert or update or delete on copydml_test
      for each row execute procedure qqq_trig();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  copy (insert into copydml_test (t) values ('f') returning id) to stdout;
  8
  copy (update copydml_test set t = 'g' where t = 'f' returning id) to stdout;
  8
  copy (delete from copydml_test where t = 'g' returning id) to stdout;
  8
  drop table copydml_test;
  drop function qqq_trig();
--- 94,112 ----
  $$ language plpgsql;
  create trigger qqqbef before insert or update or delete on copydml_test
      for each row execute procedure qqq_trig();
  create trigger qqqaf after insert or update or delete on copydml_test
      for each row execute procedure qqq_trig();
  copy (insert into copydml_test (t) values ('f') returning id) to stdout;
+ NOTICE:  INSERT 8
  8
+ NOTICE:  INSERT 8
  copy (update copydml_test set t = 'g' where t = 'f' returning id) to stdout;
+ NOTICE:  UPDATE 8
  8
+ NOTICE:  UPDATE 8
  copy (delete from copydml_test where t = 'g' returning id) to stdout;
+ NOTICE:  DELETE 8
  8
+ NOTICE:  DELETE 8
  drop table copydml_test;
  drop function qqq_trig();

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/create_index.out"	2025-07-31 16:07:14.981068200 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/create_index.out"	2025-07-31 16:39:27.982111227 +0800
***************
*** 430,443 ****
  
  EXPLAIN (COSTS OFF, NODES OFF)
  SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using grect2ind on fast_emp4000
!                      Index Cond: (home_base && '(1000,1000),(0,0)'::box)
! (5 rows)
  
  SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
   count 
--- 430,442 ----
  
  EXPLAIN (COSTS OFF, NODES OFF)
  SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using grect2ind on fast_emp4000
!                Index Cond: (home_base && '(1000,1000),(0,0)'::box)
! (4 rows)
  
  SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
   count 
***************
*** 447,460 ****
  
  EXPLAIN (COSTS OFF, NODES OFF)
  SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using grect2ind on fast_emp4000
!                      Index Cond: (home_base IS NULL)
! (5 rows)
  
  SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
   count 
--- 446,458 ----
  
  EXPLAIN (COSTS OFF, NODES OFF)
  SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using grect2ind on fast_emp4000
!                Index Cond: (home_base IS NULL)
! (4 rows)
  
  SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
   count 
***************
*** 505,518 ****
  
  EXPLAIN (COSTS OFF, NODES OFF)
  SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Scan using ggpolygonind on gpolygon_tbl
!                      Index Cond: (f1 && '((1000,1000),(0,0))'::polygon)
! (5 rows)
  
  SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
   count 
--- 503,515 ----
  
  EXPLAIN (COSTS OFF, NODES OFF)
  SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Scan using ggpolygonind on gpolygon_tbl
!                Index Cond: (f1 && '((1000,1000),(0,0))'::polygon)
! (4 rows)
  
  SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
   count 
***************
*** 522,535 ****
  
  EXPLAIN (COSTS OFF, NODES OFF)
  SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Scan using ggcircleind on gcircle_tbl
!                      Index Cond: (f1 && '<(500,500),500>'::circle)
! (5 rows)
  
  SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
   count 
--- 519,531 ----
  
  EXPLAIN (COSTS OFF, NODES OFF)
  SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Scan using ggcircleind on gcircle_tbl
!                Index Cond: (f1 && '<(500,500),500>'::circle)
! (4 rows)
  
  SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
   count 
***************
*** 759,772 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                      Index Cond: (p IS NULL)
! (5 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
   count 
--- 755,767 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                Index Cond: (p IS NULL)
! (4 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
   count 
***************
*** 776,789 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                      Index Cond: (p IS NOT NULL)
! (5 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
   count 
--- 771,783 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                Index Cond: (p IS NOT NULL)
! (4 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
   count 
***************
*** 793,805 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl;
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_quad_ind on quad_point_tbl
! (4 rows)
  
  SELECT count(*) FROM quad_point_tbl;
   count 
--- 787,798 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_quad_ind on quad_point_tbl
! (3 rows)
  
  SELECT count(*) FROM quad_point_tbl;
   count 
***************
*** 809,822 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                      Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (5 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
   count 
--- 802,814 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (4 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
   count 
***************
*** 826,839 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                      Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (5 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
   count 
--- 818,830 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (4 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
   count 
***************
*** 843,856 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                      Index Cond: (p << '(5000,4000)'::point)
! (5 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
   count 
--- 834,846 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                Index Cond: (p << '(5000,4000)'::point)
! (4 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
   count 
***************
*** 860,873 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                      Index Cond: (p >> '(5000,4000)'::point)
! (5 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
   count 
--- 850,862 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                Index Cond: (p >> '(5000,4000)'::point)
! (4 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
   count 
***************
*** 877,890 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                      Index Cond: (p <^ '(5000,4000)'::point)
! (5 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
   count 
--- 866,878 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                Index Cond: (p <^ '(5000,4000)'::point)
! (4 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
   count 
***************
*** 894,907 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                      Index Cond: (p >^ '(5000,4000)'::point)
! (5 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
   count 
--- 882,894 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                Index Cond: (p >^ '(5000,4000)'::point)
! (4 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
   count 
***************
*** 911,924 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                      Index Cond: (p ~= '(4585,365)'::point)
! (5 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
   count 
--- 898,910 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_quad_ind on quad_point_tbl
!                Index Cond: (p ~= '(4585,365)'::point)
! (4 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
   count 
***************
*** 928,941 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                      Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (5 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
   count 
--- 914,926 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (4 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
   count 
***************
*** 945,958 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                      Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (5 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
   count 
--- 930,942 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (4 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
   count 
***************
*** 962,975 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                      Index Cond: (p << '(5000,4000)'::point)
! (5 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
   count 
--- 946,958 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                Index Cond: (p << '(5000,4000)'::point)
! (4 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
   count 
***************
*** 979,992 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                      Index Cond: (p >> '(5000,4000)'::point)
! (5 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
   count 
--- 962,974 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                Index Cond: (p >> '(5000,4000)'::point)
! (4 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
   count 
***************
*** 996,1009 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                      Index Cond: (p <^ '(5000,4000)'::point)
! (5 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
   count 
--- 978,990 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                Index Cond: (p <^ '(5000,4000)'::point)
! (4 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
   count 
***************
*** 1013,1026 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                      Index Cond: (p >^ '(5000,4000)'::point)
! (5 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
   count 
--- 994,1006 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                Index Cond: (p >^ '(5000,4000)'::point)
! (4 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
   count 
***************
*** 1030,1043 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                      Index Cond: (p ~= '(4585,365)'::point)
! (5 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
   count 
--- 1010,1022 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Index Only Scan using sp_kd_ind on kd_point_tbl
!                Index Cond: (p ~= '(4585,365)'::point)
! (4 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
   count 
***************
*** 1266,1272 ****
                             QUERY PLAN                            
  -----------------------------------------------------------------
   Limit
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
           ->  Limit
                 ->  Index Scan using ggpolygonind on gpolygon_tbl
                       Order By: (f1 <-> '(0,0)'::point)
--- 1245,1251 ----
                             QUERY PLAN                            
  -----------------------------------------------------------------
   Limit
!    ->  Remote Subquery Scan on all (datanode_1)
           ->  Limit
                 ->  Index Scan using ggpolygonind on gpolygon_tbl
                       Order By: (f1 <-> '(0,0)'::point)
***************
*** 1292,1298 ****
                            QUERY PLAN                           
  ---------------------------------------------------------------
   Limit
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
           ->  Limit
                 ->  Index Scan using ggcircleind on gcircle_tbl
                       Order By: (f1 <-> '(200,300)'::point)
--- 1271,1277 ----
                            QUERY PLAN                           
  ---------------------------------------------------------------
   Limit
!    ->  Remote Subquery Scan on all (datanode_1)
           ->  Limit
                 ->  Index Scan using ggcircleind on gcircle_tbl
                       Order By: (f1 <-> '(200,300)'::point)
***************
*** 1341,1356 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on quad_point_tbl
!                      Recheck Cond: (p IS NULL)
!                      ->  Bitmap Index Scan on sp_quad_ind
!                            Index Cond: (p IS NULL)
! (7 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
   count 
--- 1320,1334 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
!                      QUERY PLAN                     
! ----------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on quad_point_tbl
!                Recheck Cond: (p IS NULL)
!                ->  Bitmap Index Scan on sp_quad_ind
!                      Index Cond: (p IS NULL)
! (6 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
   count 
***************
*** 1360,1375 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on quad_point_tbl
!                      Recheck Cond: (p IS NOT NULL)
!                      ->  Bitmap Index Scan on sp_quad_ind
!                            Index Cond: (p IS NOT NULL)
! (7 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
   count 
--- 1338,1352 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
!                      QUERY PLAN                     
! ----------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on quad_point_tbl
!                Recheck Cond: (p IS NOT NULL)
!                ->  Bitmap Index Scan on sp_quad_ind
!                      Index Cond: (p IS NOT NULL)
! (6 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
   count 
***************
*** 1379,1392 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl;
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on quad_point_tbl
!                      ->  Bitmap Index Scan on sp_quad_ind
! (5 rows)
  
  SELECT count(*) FROM quad_point_tbl;
   count 
--- 1356,1368 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl;
!                      QUERY PLAN                     
! ----------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on quad_point_tbl
!                ->  Bitmap Index Scan on sp_quad_ind
! (4 rows)
  
  SELECT count(*) FROM quad_point_tbl;
   count 
***************
*** 1396,1411 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on quad_point_tbl
!                      Recheck Cond: (p <@ '(1000,1000),(200,200)'::box)
!                      ->  Bitmap Index Scan on sp_quad_ind
!                            Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (7 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
   count 
--- 1372,1386 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on quad_point_tbl
!                Recheck Cond: (p <@ '(1000,1000),(200,200)'::box)
!                ->  Bitmap Index Scan on sp_quad_ind
!                      Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (6 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
   count 
***************
*** 1415,1430 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on quad_point_tbl
!                      Recheck Cond: ('(1000,1000),(200,200)'::box @> p)
!                      ->  Bitmap Index Scan on sp_quad_ind
!                            Index Cond: ('(1000,1000),(200,200)'::box @> p)
! (7 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
   count 
--- 1390,1404 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on quad_point_tbl
!                Recheck Cond: ('(1000,1000),(200,200)'::box @> p)
!                ->  Bitmap Index Scan on sp_quad_ind
!                      Index Cond: ('(1000,1000),(200,200)'::box @> p)
! (6 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
   count 
***************
*** 1434,1449 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on quad_point_tbl
!                      Recheck Cond: (p << '(5000,4000)'::point)
!                      ->  Bitmap Index Scan on sp_quad_ind
!                            Index Cond: (p << '(5000,4000)'::point)
! (7 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
   count 
--- 1408,1422 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on quad_point_tbl
!                Recheck Cond: (p << '(5000,4000)'::point)
!                ->  Bitmap Index Scan on sp_quad_ind
!                      Index Cond: (p << '(5000,4000)'::point)
! (6 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
   count 
***************
*** 1453,1468 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on quad_point_tbl
!                      Recheck Cond: (p >> '(5000,4000)'::point)
!                      ->  Bitmap Index Scan on sp_quad_ind
!                            Index Cond: (p >> '(5000,4000)'::point)
! (7 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
   count 
--- 1426,1440 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on quad_point_tbl
!                Recheck Cond: (p >> '(5000,4000)'::point)
!                ->  Bitmap Index Scan on sp_quad_ind
!                      Index Cond: (p >> '(5000,4000)'::point)
! (6 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
   count 
***************
*** 1472,1487 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on quad_point_tbl
!                      Recheck Cond: (p <^ '(5000,4000)'::point)
!                      ->  Bitmap Index Scan on sp_quad_ind
!                            Index Cond: (p <^ '(5000,4000)'::point)
! (7 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
   count 
--- 1444,1458 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on quad_point_tbl
!                Recheck Cond: (p <^ '(5000,4000)'::point)
!                ->  Bitmap Index Scan on sp_quad_ind
!                      Index Cond: (p <^ '(5000,4000)'::point)
! (6 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
   count 
***************
*** 1491,1506 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on quad_point_tbl
!                      Recheck Cond: (p >^ '(5000,4000)'::point)
!                      ->  Bitmap Index Scan on sp_quad_ind
!                            Index Cond: (p >^ '(5000,4000)'::point)
! (7 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
   count 
--- 1462,1476 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on quad_point_tbl
!                Recheck Cond: (p >^ '(5000,4000)'::point)
!                ->  Bitmap Index Scan on sp_quad_ind
!                      Index Cond: (p >^ '(5000,4000)'::point)
! (6 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
   count 
***************
*** 1510,1525 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on quad_point_tbl
!                      Recheck Cond: (p ~= '(4585,365)'::point)
!                      ->  Bitmap Index Scan on sp_quad_ind
!                            Index Cond: (p ~= '(4585,365)'::point)
! (7 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
   count 
--- 1480,1494 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on quad_point_tbl
!                Recheck Cond: (p ~= '(4585,365)'::point)
!                ->  Bitmap Index Scan on sp_quad_ind
!                      Index Cond: (p ~= '(4585,365)'::point)
! (6 rows)
  
  SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
   count 
***************
*** 1529,1544 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on kd_point_tbl
!                      Recheck Cond: (p <@ '(1000,1000),(200,200)'::box)
!                      ->  Bitmap Index Scan on sp_kd_ind
!                            Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (7 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
   count 
--- 1498,1512 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on kd_point_tbl
!                Recheck Cond: (p <@ '(1000,1000),(200,200)'::box)
!                ->  Bitmap Index Scan on sp_kd_ind
!                      Index Cond: (p <@ '(1000,1000),(200,200)'::box)
! (6 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
   count 
***************
*** 1548,1563 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on kd_point_tbl
!                      Recheck Cond: ('(1000,1000),(200,200)'::box @> p)
!                      ->  Bitmap Index Scan on sp_kd_ind
!                            Index Cond: ('(1000,1000),(200,200)'::box @> p)
! (7 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
   count 
--- 1516,1530 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on kd_point_tbl
!                Recheck Cond: ('(1000,1000),(200,200)'::box @> p)
!                ->  Bitmap Index Scan on sp_kd_ind
!                      Index Cond: ('(1000,1000),(200,200)'::box @> p)
! (6 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
   count 
***************
*** 1567,1582 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on kd_point_tbl
!                      Recheck Cond: (p << '(5000,4000)'::point)
!                      ->  Bitmap Index Scan on sp_kd_ind
!                            Index Cond: (p << '(5000,4000)'::point)
! (7 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
   count 
--- 1534,1548 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on kd_point_tbl
!                Recheck Cond: (p << '(5000,4000)'::point)
!                ->  Bitmap Index Scan on sp_kd_ind
!                      Index Cond: (p << '(5000,4000)'::point)
! (6 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
   count 
***************
*** 1586,1601 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on kd_point_tbl
!                      Recheck Cond: (p >> '(5000,4000)'::point)
!                      ->  Bitmap Index Scan on sp_kd_ind
!                            Index Cond: (p >> '(5000,4000)'::point)
! (7 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
   count 
--- 1552,1566 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on kd_point_tbl
!                Recheck Cond: (p >> '(5000,4000)'::point)
!                ->  Bitmap Index Scan on sp_kd_ind
!                      Index Cond: (p >> '(5000,4000)'::point)
! (6 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
   count 
***************
*** 1605,1620 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on kd_point_tbl
!                      Recheck Cond: (p <^ '(5000,4000)'::point)
!                      ->  Bitmap Index Scan on sp_kd_ind
!                            Index Cond: (p <^ '(5000,4000)'::point)
! (7 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
   count 
--- 1570,1584 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on kd_point_tbl
!                Recheck Cond: (p <^ '(5000,4000)'::point)
!                ->  Bitmap Index Scan on sp_kd_ind
!                      Index Cond: (p <^ '(5000,4000)'::point)
! (6 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
   count 
***************
*** 1624,1639 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on kd_point_tbl
!                      Recheck Cond: (p >^ '(5000,4000)'::point)
!                      ->  Bitmap Index Scan on sp_kd_ind
!                            Index Cond: (p >^ '(5000,4000)'::point)
! (7 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
   count 
--- 1588,1602 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on kd_point_tbl
!                Recheck Cond: (p >^ '(5000,4000)'::point)
!                ->  Bitmap Index Scan on sp_kd_ind
!                      Index Cond: (p >^ '(5000,4000)'::point)
! (6 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
   count 
***************
*** 1643,1658 ****
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on kd_point_tbl
!                      Recheck Cond: (p ~= '(4585,365)'::point)
!                      ->  Bitmap Index Scan on sp_kd_ind
!                            Index Cond: (p ~= '(4585,365)'::point)
! (7 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
   count 
--- 1606,1620 ----
  
  EXPLAIN (NODES OFF, COSTS OFF)
  SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Aggregate
!          ->  Bitmap Heap Scan on kd_point_tbl
!                Recheck Cond: (p ~= '(4585,365)'::point)
!                ->  Bitmap Index Scan on sp_kd_ind
!                      Index Cond: (p ~= '(4585,365)'::point)
! (6 rows)
  
  SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
   count 
***************
*** 2548,3183 ****
  CREATE TABLE concur_heap (f1 text, f2 text);
  -- empty table
  CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
- ERROR:  PGXC does not support concurrent INDEX yet
- DETAIL:  The feature is not currently supported
  CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
! ERROR:  PGXC does not support concurrent INDEX yet
! DETAIL:  The feature is not currently supported
  INSERT INTO concur_heap VALUES  ('a','b');
  INSERT INTO concur_heap VALUES  ('b','b');
  -- unique index
  CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
- ERROR:  PGXC does not support concurrent INDEX yet
- DETAIL:  The feature is not currently supported
  CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
! ERROR:  PGXC does not support concurrent INDEX yet
! DETAIL:  The feature is not currently supported
  -- check if constraint is set up properly to be enforced
  INSERT INTO concur_heap VALUES ('b','x');
  -- check if constraint is enforced properly at build time
  CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
! ERROR:  PGXC does not support concurrent INDEX yet
! DETAIL:  The feature is not currently supported
  -- test that expression indexes and partial indexes work concurrently
  CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
- ERROR:  PGXC does not support concurrent INDEX yet
- DETAIL:  The feature is not currently supported
  CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
- ERROR:  PGXC does not support concurrent INDEX yet
- DETAIL:  The feature is not currently supported
  -- here we also check that you can default the index name
  CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
! ERROR:  PGXC does not support concurrent INDEX yet
! DETAIL:  The feature is not currently supported
! -- You can't do a concurrent index build in a transaction
! BEGIN;
! CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
! ERROR:  PGXC does not support concurrent INDEX yet
! DETAIL:  The feature is not currently supported
! COMMIT;
! -- But you can do a regular index build in a transaction
! BEGIN;
! CREATE INDEX std_index on concur_heap(f2);
! COMMIT;
! -- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
! VACUUM FULL concur_heap;
! REINDEX TABLE concur_heap;
! DELETE FROM concur_heap WHERE f1 = 'b';
! VACUUM FULL concur_heap;
! \d concur_heap
!            Table "public.concur_heap"
!  Column | Type | Collation | Nullable | Default 
! --------+------+-----------+----------+---------
!  f1     | text |           |          | 
!  f2     | text |           |          | 
! Indexes:
!     "std_index" btree (f2)
! 
! REINDEX TABLE concur_heap;
! \d concur_heap
!            Table "public.concur_heap"
!  Column | Type | Collation | Nullable | Default 
! --------+------+-----------+----------+---------
!  f1     | text |           |          | 
!  f2     | text |           |          | 
! Indexes:
!     "std_index" btree (f2)
! 
! --
! -- Try some concurrent index drops
! --
! DROP INDEX CONCURRENTLY "concur_index2";				-- works
! ERROR:  index "concur_index2" does not exist
! DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
! NOTICE:  index "concur_index2" does not exist, skipping
! -- failures
! DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
! ERROR:  index "concur_index2" does not exist
! BEGIN;
! DROP INDEX CONCURRENTLY "concur_index5";
! ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
! ROLLBACK;
! -- successes
! DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
! NOTICE:  index "concur_index3" does not exist, skipping
! DROP INDEX CONCURRENTLY "concur_index4";
! ERROR:  index "concur_index4" does not exist
! DROP INDEX CONCURRENTLY "concur_index5";
! ERROR:  index "concur_index5" does not exist
! DROP INDEX CONCURRENTLY "concur_index1";
! ERROR:  index "concur_index1" does not exist
! DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
! ERROR:  index "concur_heap_expr_idx" does not exist
! \d concur_heap
!            Table "public.concur_heap"
!  Column | Type | Collation | Nullable | Default 
! --------+------+-----------+----------+---------
!  f1     | text |           |          | 
!  f2     | text |           |          | 
! Indexes:
!     "std_index" btree (f2)
! 
! DROP TABLE concur_heap;
! --
! -- Test ADD CONSTRAINT USING INDEX
! --
! CREATE TABLE cwi_test( a int , b varchar(10), c char);
! -- add some data so that all tests have something to work with.
! INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
! CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
! ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
! \d cwi_test
!                      Table "public.cwi_test"
!  Column |         Type          | Collation | Nullable | Default 
! --------+-----------------------+-----------+----------+---------
!  a      | integer               |           | not null | 
!  b      | character varying(10) |           | not null | 
!  c      | character(1)          |           |          | 
! Indexes:
!     "cwi_uniq_idx" PRIMARY KEY, btree (a, b)
! 
! \d cwi_uniq_idx
!          Index "public.cwi_uniq_idx"
!  Column |         Type          | Definition 
! --------+-----------------------+------------
!  a      | integer               | a
!  b      | character varying(10) | b
! primary key, btree, for table "public.cwi_test"
! 
! CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
! ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
! 	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
! 		USING INDEX cwi_uniq2_idx;
! NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "cwi_uniq2_idx" to "cwi_replaced_pkey"
! \d cwi_test
!                      Table "public.cwi_test"
!  Column |         Type          | Collation | Nullable | Default 
! --------+-----------------------+-----------+----------+---------
!  a      | integer               |           | not null | 
!  b      | character varying(10) |           | not null | 
!  c      | character(1)          |           |          | 
! Indexes:
!     "cwi_replaced_pkey" PRIMARY KEY, btree (b, a)
! 
! \d cwi_replaced_pkey
!       Index "public.cwi_replaced_pkey"
!  Column |         Type          | Definition 
! --------+-----------------------+------------
!  b      | character varying(10) | b
!  a      | integer               | a
! primary key, btree, for table "public.cwi_test"
! 
! DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on it
! ERROR:  cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
! HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
! DROP TABLE cwi_test;
! -- ADD CONSTRAINT USING INDEX is forbidden on partitioned tables
! CREATE TABLE cwi_test(a int) PARTITION BY hash (a);
! create unique index on cwi_test (a);
! alter table cwi_test add primary key using index cwi_test_a_idx ;
! ERROR:  ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables
! DROP TABLE cwi_test;
! --
! -- Check handling of indexes on system columns
! --
! CREATE TABLE oid_table (a INT) WITH OIDS;
! -- An index on the OID column should be allowed
! CREATE INDEX ON oid_table (oid);
! -- Other system columns cannot be indexed
! CREATE INDEX ON oid_table (ctid);
! ERROR:  index creation on system columns is not supported
! -- nor used in expressions
! CREATE INDEX ON oid_table ((ctid >= '(1000,0)'));
! ERROR:  index creation on system columns is not supported
! -- nor used in predicates
! CREATE INDEX ON oid_table (a) WHERE ctid >= '(1000,0)';
! ERROR:  index creation on system columns is not supported
! DROP TABLE oid_table;
! --
! -- Tests for IS NULL/IS NOT NULL with b-tree indexes
! --
! SELECT unique1, unique2 INTO onek_with_null FROM onek;
! INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2,unique1);
! SET enable_seqscan = OFF;
! SET enable_indexscan = ON;
! SET enable_bitmapscan = ON;
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! DROP INDEX onek_nulltest;
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc,unique1);
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! DROP INDEX onek_nulltest;
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! DROP INDEX onek_nulltest;
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
!  count 
! -------
!      2
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
!  count 
! -------
!      1
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
!  count 
! -------
!   1000
! (1 row)
! 
! SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
!  count 
! -------
!      1
! (1 row)
! 
! DROP INDEX onek_nulltest;
! -- Check initial-positioning logic too
! CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2);
! ERROR:  Unique index of partitioned table must contain the hash/modulo distribution column.
! SET enable_seqscan = OFF;
! SET enable_indexscan = ON;
! SET enable_bitmapscan = OFF;
! SELECT unique1, unique2 FROM onek_with_null
!   ORDER BY unique2 LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!          |      -1
!      147 |       0
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
!   ORDER BY unique2 LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!          |      -1
!      147 |       0
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
!   ORDER BY unique2 LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!      147 |       0
!      931 |       1
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null
!   ORDER BY unique2 DESC LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!          |        
!      278 |     999
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
!   ORDER BY unique2 DESC LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!      278 |     999
!        0 |     998
! (2 rows)
! 
! SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
!   ORDER BY unique2 DESC LIMIT 2;
!  unique1 | unique2 
! ---------+---------
!        0 |     998
!      744 |     997
! (2 rows)
! 
! RESET enable_seqscan;
! RESET enable_indexscan;
! RESET enable_bitmapscan;
! DROP TABLE onek_with_null;
! --
! -- Check bitmap index path planning
! --
! EXPLAIN (NODES OFF, COSTS OFF)
! SELECT * FROM tenk1
!   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
!                                                                   QUERY PLAN                                                                   
! -----------------------------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    ->  Bitmap Heap Scan on tenk1
!          Recheck Cond: (((thousand = 42) AND (tenthous = 1)) OR ((thousand = 42) AND (tenthous = 3)) OR ((thousand = 42) AND (tenthous = 42)))
!          ->  BitmapOr
!                ->  Bitmap Index Scan on tenk1_thous_tenthous
!                      Index Cond: ((thousand = 42) AND (tenthous = 1))
!                ->  Bitmap Index Scan on tenk1_thous_tenthous
!                      Index Cond: ((thousand = 42) AND (tenthous = 3))
!                ->  Bitmap Index Scan on tenk1_thous_tenthous
!                      Index Cond: ((thousand = 42) AND (tenthous = 42))
! (10 rows)
! 
! SELECT * FROM tenk1
!   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       42 |    5530 |   0 |    2 |   2 |      2 |      42 |       42 |          42 |        42 |       42 |  84 |   85 | QBAAAA   | SEIAAA   | OOOOxx
! (1 row)
! 
! EXPLAIN (NODES OFF, COSTS OFF)
! SELECT count(*) FROM tenk1
!   WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
!                                          QUERY PLAN                                          
! ---------------------------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on tenk1
!                      Recheck Cond: ((hundred = 42) AND ((thousand = 42) OR (thousand = 99)))
!                      ->  BitmapAnd
!                            ->  Bitmap Index Scan on tenk1_hundred
!                                  Index Cond: (hundred = 42)
!                            ->  BitmapOr
!                                  ->  Bitmap Index Scan on tenk1_thous_tenthous
!                                        Index Cond: (thousand = 42)
!                                  ->  Bitmap Index Scan on tenk1_thous_tenthous
!                                        Index Cond: (thousand = 99)
! (13 rows)
! 
! SELECT count(*) FROM tenk1
!   WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
!  count 
! -------
!     10
! (1 row)
! 
! --
! -- Check behavior with duplicate index column contents
! --
! CREATE TABLE dupindexcols AS
!   SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
! CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
! ANALYZE dupindexcols;
! EXPLAIN (NODES OFF, COSTS OFF)
!   SELECT count(*) FROM dupindexcols
!     WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
!                                                          QUERY PLAN                                                         
! ----------------------------------------------------------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Bitmap Heap Scan on dupindexcols
!                      Recheck Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
!                      ->  Bitmap Index Scan on dupindexcols_i
!                            Index Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
! (7 rows)
! 
! SELECT count(*) FROM dupindexcols
!   WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
!  count 
! -------
!     97
! (1 row)
! 
! --
! -- Check ordering of =ANY indexqual results (bug in 9.2.0)
! --
! select pg_sleep(5);	-- sleep for 5s to allow cluster monitor to advance OldestXmin
!  pg_sleep 
! ----------
!  
! (1 row)
! 
! vacuum tenk1;		-- ensure we get consistent plans here
! explain (costs off)
! SELECT unique1 FROM tenk1
! WHERE unique1 IN (1,42,7)
! ORDER BY unique1;
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Index Only Scan using tenk1_unique1 on tenk1
!          Index Cond: (unique1 = ANY ('{1,42,7}'::integer[]))
! (3 rows)
! 
! SELECT unique1 FROM tenk1
! WHERE unique1 IN (1,42,7)
! ORDER BY unique1;
!  unique1 
! ---------
!        1
!        7
!       42
! (3 rows)
! 
! explain (costs off)
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!                                          QUERY PLAN                                         
! --------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Sort
!          Sort Key: thousand
!          ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!                Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
! (5 rows)
! 
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!  thousand | tenthous 
! ----------+----------
!         0 |     3000
!         1 |     1001
! (2 rows)
! 
! SET enable_indexonlyscan = OFF;
! explain (costs off)
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!                                          QUERY PLAN                                         
! --------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Sort
!          Sort Key: thousand
!          ->  Index Scan using tenk1_thous_tenthous on tenk1
!                Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
! (5 rows)
! 
! SELECT thousand, tenthous FROM tenk1
! WHERE thousand < 2 AND tenthous IN (1001,3000)
! ORDER BY thousand;
!  thousand | tenthous 
! ----------+----------
!         0 |     3000
!         1 |     1001
! (2 rows)
! 
! RESET enable_indexonlyscan;
! --
! -- Check elimination of constant-NULL subexpressions
! --
! explain (costs off)
!   select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Index Scan using tenk1_thous_tenthous on tenk1
!          Index Cond: ((thousand = 1) AND (tenthous = 1001))
! (4 rows)
! 
! --
! -- Check matching of boolean index columns to WHERE conditions and sort keys
! --
! create temp table boolindex (b bool, i int, unique(b, i), junk float);
! explain (costs off)
!   select * from boolindex order by b, i limit 10;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Limit
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          ->  Limit
!                ->  Index Scan using boolindex_b_i_key on boolindex
! (4 rows)
! 
! explain (costs off)
!   select * from boolindex where b order by i limit 10;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Limit
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          ->  Limit
!                ->  Index Scan using boolindex_b_i_key on boolindex
!                      Index Cond: (b = true)
!                      Filter: b
! (6 rows)
! 
! explain (costs off)
!   select * from boolindex where b = true order by i desc limit 10;
!                               QUERY PLAN                              
! ----------------------------------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1
!    ->  Limit
!          ->  Index Scan Backward using boolindex_b_i_key on boolindex
!                Index Cond: (b = true)
!                Filter: b
! (6 rows)
! 
! explain (costs off)
!   select * from boolindex where not b order by i limit 10;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Limit
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          ->  Limit
!                ->  Index Scan using boolindex_b_i_key on boolindex
!                      Index Cond: (b = false)
!                      Filter: (NOT b)
! (6 rows)
! 
! --
! -- REINDEX (VERBOSE)
! --
! CREATE TABLE reindex_verbose(id integer primary key);
! \set VERBOSITY terse
! REINDEX (VERBOSE) TABLE reindex_verbose;
! INFO:  index "reindex_verbose_pkey" was reindexed
! DROP TABLE reindex_verbose;
! --
! -- REINDEX SCHEMA
! --
! REINDEX SCHEMA schema_to_reindex; -- failure, schema does not exist
! ERROR:  schema "schema_to_reindex" does not exist
! CREATE SCHEMA schema_to_reindex;
! SET search_path = 'schema_to_reindex';
! CREATE TABLE table1(col1 SERIAL PRIMARY KEY);
! INSERT INTO table1 SELECT generate_series(1,400);
! CREATE TABLE table2(col1 SERIAL PRIMARY KEY, col2 TEXT NOT NULL);
! INSERT INTO table2 SELECT generate_series(1,400), 'abc';
! CREATE INDEX ON table2(col2);
! CREATE MATERIALIZED VIEW matview AS SELECT col1 FROM table2;
! CREATE INDEX ON matview(col1);
! CREATE VIEW view AS SELECT col2 FROM table2;
! CREATE TABLE reindex_before AS
! SELECT oid, relname, relfilenode, relkind, reltoastrelid
! 	FROM pg_class
! 	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
! INSERT INTO reindex_before
! SELECT oid, 'pg_toast_TABLE', relfilenode, relkind, reltoastrelid
! FROM pg_class WHERE oid IN
! 	(SELECT reltoastrelid FROM reindex_before WHERE reltoastrelid > 0);
! INSERT INTO reindex_before
! SELECT oid, 'pg_toast_TABLE_index', relfilenode, relkind, reltoastrelid
! FROM pg_class where oid in
! 	(select indexrelid from pg_index where indrelid in
! 		(select reltoastrelid from reindex_before where reltoastrelid > 0));
! REINDEX SCHEMA schema_to_reindex;
! CREATE TABLE reindex_after AS SELECT oid, relname, relfilenode, relkind
! 	FROM pg_class
! 	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
! SELECT  b.relname,
!         b.relkind,
!         CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
!         ELSE 'relfilenode has changed' END
!   FROM reindex_before b JOIN pg_class a ON b.oid = a.oid
!   ORDER BY 1;
!  relname | relkind | case 
! ---------+---------+------
! (0 rows)
! 
! REINDEX SCHEMA schema_to_reindex;
! BEGIN;
! REINDEX SCHEMA schema_to_reindex; -- failure, cannot run in a transaction
! ERROR:  REINDEX SCHEMA cannot run inside a transaction block
! END;
! -- Failure for unauthorized user
! CREATE ROLE regress_reindexuser NOLOGIN;
! SET SESSION ROLE regress_reindexuser;
! REINDEX SCHEMA schema_to_reindex;
! ERROR:  must be owner of schema schema_to_reindex
! -- Clean up
! RESET ROLE;
! DROP ROLE regress_reindexuser;
! \set VERBOSITY terse \\ -- suppress cascade details
! DROP SCHEMA schema_to_reindex CASCADE;
! NOTICE:  drop cascades to 6 other objects
--- 2510,2538 ----
  CREATE TABLE concur_heap (f1 text, f2 text);
  -- empty table
  CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
  CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
! NOTICE:  relation "concur_index1" already exists, skipping
! WARNING:  snapshot 0x58271fc4da78 still active
  INSERT INTO concur_heap VALUES  ('a','b');
  INSERT INTO concur_heap VALUES  ('b','b');
  -- unique index
  CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
  CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
! NOTICE:  relation "concur_index2" already exists, skipping
! WARNING:  snapshot 0x58271fc4da78 still active
  -- check if constraint is set up properly to be enforced
  INSERT INTO concur_heap VALUES ('b','x');
+ ERROR:  node:datanode_1, backend_pid:381313, nodename:datanode_1,backend_pid:381313,message:duplicate key value violates unique constraint "concur_index2"
+ DETAIL:  Key (f1)=(b) already exists.
  -- check if constraint is enforced properly at build time
  CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
! ERROR:  Unique index of partitioned table must contain the hash/modulo distribution column.
  -- test that expression indexes and partial indexes work concurrently
  CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
  CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
  -- here we also check that you can default the index name
  CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
! server closed the connection unexpectedly
! 	This probably means the server terminated abnormally
! 	before or while processing the request.
! connection to server was lost

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/create_view.out"	2025-07-31 16:07:14.982068184 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/create_view.out"	2025-07-31 16:39:14.481399575 +0800
***************
*** 1716,1722 ****
  -- check plan without sort operator, but need merge sort
  set enable_seqscan = off;
  create table test(v int primary key, w int) distribute by shard(v); 
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into test values(generate_series(1,50), generate_series(1,50));
  create view test_sort as select * from test where v in (select v from test where w < 20) order by v asc;
  select * from test_sort order by 1;
--- 1716,1721 ----

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/create_aggregate.out"	2025-07-31 16:07:14.981068200 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/create_aggregate.out"	2025-07-31 16:39:29.066088107 +0800
***************
*** 1,194 ****
! --
! -- CREATE_AGGREGATE
! --
! -- all functions CREATEd
! CREATE AGGREGATE newavg (
!    sfunc = int4_avg_accum, basetype = int4, stype = _int8,
!    finalfunc = int8_avg,
!    initcond1 = '{0,0}'
! );
! -- test comments
! COMMENT ON AGGREGATE newavg_wrong (int4) IS 'an agg comment';
! ERROR:  aggregate newavg_wrong(integer) does not exist
! COMMENT ON AGGREGATE newavg (int4) IS 'an agg comment';
! COMMENT ON AGGREGATE newavg (int4) IS NULL;
! -- without finalfunc; test obsolete spellings 'sfunc1' etc
! CREATE AGGREGATE newsum (
!    sfunc1 = int4pl, basetype = int4, stype1 = int4,
!    initcond1 = '0'
! );
! -- zero-argument aggregate
! CREATE AGGREGATE newcnt (*) (
!    sfunc = int8inc, stype = int8,
!    initcond = '0', parallel = safe
! );
! -- old-style spelling of same (except without parallel-safe; that's too new)
! CREATE AGGREGATE oldcnt (
!    sfunc = int8inc, basetype = 'ANY', stype = int8,
!    initcond = '0'
! );
! -- aggregate that only cares about null/nonnull input
! CREATE AGGREGATE newcnt ("any") (
!    sfunc = int8inc_any, stype = int8,
!    initcond = '0'
! );
! COMMENT ON AGGREGATE nosuchagg (*) IS 'should fail';
! ERROR:  aggregate nosuchagg(*) does not exist
! COMMENT ON AGGREGATE newcnt (*) IS 'an agg(*) comment';
! COMMENT ON AGGREGATE newcnt ("any") IS 'an agg(any) comment';
! -- multi-argument aggregate
! create function sum3(int8,int8,int8) returns int8 as
! 'select $1 + $2 + $3' language sql strict immutable;
! create aggregate sum2(int8,int8) (
!    sfunc = sum3, stype = int8,
!    initcond = '0'
! );
! -- multi-argument aggregates sensitive to distinct/order, strict/nonstrict
! create type aggtype as (a integer, b integer, c text);
! create function aggf_trans(aggtype[],integer,integer,text) returns aggtype[]
! as 'select array_append($1,ROW($2,$3,$4)::aggtype)'
! language sql strict immutable;
! create function aggfns_trans(aggtype[],integer,integer,text) returns aggtype[]
! as 'select array_append($1,ROW($2,$3,$4)::aggtype)'
! language sql immutable;
! create aggregate aggfstr(integer,integer,text) (
!    sfunc = aggf_trans, stype = aggtype[],
!    initcond = '{}'
! );
! create aggregate aggfns(integer,integer,text) (
!    sfunc = aggfns_trans, stype = aggtype[], sspace = 10000,
!    initcond = '{}'
! );
! -- variadic aggregate
! create function least_accum(anyelement, variadic anyarray)
! returns anyelement language sql as
!   'select least($1, min($2[i])) from generate_subscripts($2,1) g(i)';
! create aggregate least_agg(variadic items anyarray) (
!   stype = anyelement, sfunc = least_accum
! );
! -- test ordered-set aggs using built-in support functions
! create aggregate my_percentile_disc(float8 ORDER BY anyelement) (
!   stype = internal,
!   sfunc = ordered_set_transition,
!   finalfunc = percentile_disc_final,
!   finalfunc_extra = true
! );
! create aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any") (
!   stype = internal,
!   sfunc = ordered_set_transition_multi,
!   finalfunc = rank_final,
!   finalfunc_extra = true,
!   hypothetical
! );
! alter aggregate my_percentile_disc(float8 ORDER BY anyelement)
!   rename to test_percentile_disc;
! alter aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any")
!   rename to test_rank;
! \da test_*
!                                        List of aggregate functions
!  Schema |         Name         | Result data type |          Argument data types           | Description 
! --------+----------------------+------------------+----------------------------------------+-------------
!  public | test_percentile_disc | anyelement       | double precision ORDER BY anyelement   | 
!  public | test_rank            | bigint           | VARIADIC "any" ORDER BY VARIADIC "any" | 
! (2 rows)
! 
! -- moving-aggregate options
! CREATE AGGREGATE sumdouble (float8)
! (
!     stype = float8,
!     sfunc = float8pl,
!     mstype = float8,
!     msfunc = float8pl,
!     minvfunc = float8mi
! );
! -- aggregate combine and serialization functions
! -- can't specify just one of serialfunc and deserialfunc
! CREATE AGGREGATE myavg (numeric)
! (
! 	stype = internal,
! 	sfunc = numeric_avg_accum,
! 	serialfunc = numeric_avg_serialize
! );
! ERROR:  must specify both or neither of serialization and deserialization functions
! -- serialfunc must have correct parameters
! CREATE AGGREGATE myavg (numeric)
! (
! 	stype = internal,
! 	sfunc = numeric_avg_accum,
! 	serialfunc = numeric_avg_deserialize,
! 	deserialfunc = numeric_avg_deserialize
! );
! ERROR:  function numeric_avg_deserialize(internal) does not exist
! -- deserialfunc must have correct parameters
! CREATE AGGREGATE myavg (numeric)
! (
! 	stype = internal,
! 	sfunc = numeric_avg_accum,
! 	serialfunc = numeric_avg_serialize,
! 	deserialfunc = numeric_avg_serialize
! );
! ERROR:  function numeric_avg_serialize(bytea, internal) does not exist
! -- ensure combine function parameters are checked
! CREATE AGGREGATE myavg (numeric)
! (
! 	stype = internal,
! 	sfunc = numeric_avg_accum,
! 	serialfunc = numeric_avg_serialize,
! 	deserialfunc = numeric_avg_deserialize,
! 	combinefunc = int4larger
! );
! ERROR:  function int4larger(internal, internal) does not exist
! -- ensure create aggregate works.
! CREATE AGGREGATE myavg (numeric)
! (
! 	stype = internal,
! 	sfunc = numeric_avg_accum,
! 	finalfunc = numeric_avg,
! 	serialfunc = numeric_avg_serialize,
! 	deserialfunc = numeric_avg_deserialize,
! 	combinefunc = numeric_avg_combine
! );
! -- Ensure all these functions made it into the catalog
! SELECT aggfnoid,aggtransfn,aggcombinefn,aggtranstype,aggserialfn,aggdeserialfn
! FROM pg_aggregate
! WHERE aggfnoid = 'myavg'::REGPROC;
!  aggfnoid |    aggtransfn     |    aggcombinefn     | aggtranstype |      aggserialfn      |      aggdeserialfn      
! ----------+-------------------+---------------------+--------------+-----------------------+-------------------------
!  myavg    | numeric_avg_accum | numeric_avg_combine |         2281 | numeric_avg_serialize | numeric_avg_deserialize
! (1 row)
! 
! DROP AGGREGATE myavg (numeric);
! -- invalid: bad parallel-safety marking
! CREATE AGGREGATE mysum (int)
! (
! 	stype = int,
! 	sfunc = int4pl,
! 	parallel = pear
! );
! ERROR:  parameter "parallel" must be SAFE, RESTRICTED, or UNSAFE
! -- invalid: nonstrict inverse with strict forward function
! CREATE FUNCTION float8mi_n(float8, float8) RETURNS float8 AS
! $$ SELECT $1 - $2; $$
! LANGUAGE SQL;
! CREATE AGGREGATE invalidsumdouble (float8)
! (
!     stype = float8,
!     sfunc = float8pl,
!     mstype = float8,
!     msfunc = float8pl,
!     minvfunc = float8mi_n
! );
! ERROR:  strictness of aggregate's forward and inverse transition functions must match
! -- invalid: non-matching result types
! CREATE FUNCTION float8mi_int(float8, float8) RETURNS int AS
! $$ SELECT CAST($1 - $2 AS INT); $$
! LANGUAGE SQL;
! CREATE AGGREGATE wrongreturntype (float8)
! (
!     stype = float8,
!     sfunc = float8pl,
!     mstype = float8,
!     msfunc = float8pl,
!     minvfunc = float8mi_int
! );
! ERROR:  return type of inverse transition function float8mi_int is not double precision
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/create_function_3.out"	2025-07-31 16:07:14.981068200 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/create_function_3.out"	2025-07-31 16:39:29.052088406 +0800
***************
*** 1,250 ****
! --
! -- CREATE FUNCTION
! --
! -- sanity check of pg_proc catalog to the given parameters
! --
! CREATE USER regress_unpriv_user;
! CREATE SCHEMA temp_func_test;
! GRANT ALL ON SCHEMA temp_func_test TO public;
! SET search_path TO temp_func_test, public;
! --
! -- ARGUMENT and RETURN TYPES
! --
! CREATE FUNCTION functest_A_1(text, date) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 = ''abcd'' AND $2 > ''2001-01-01''';
! CREATE FUNCTION functest_A_2(text[]) RETURNS int LANGUAGE 'sql'
!        AS 'SELECT $1[0]::int';
! CREATE FUNCTION functest_A_3() RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT false';
! SELECT proname, prorettype::regtype, proargtypes::regtype[] FROM pg_proc
!        WHERE oid in ('functest_A_1'::regproc,
!                      'functest_A_2'::regproc,
!                      'functest_A_3'::regproc) ORDER BY proname;
!    proname    | prorettype |    proargtypes    
! --------------+------------+-------------------
!  functest_a_1 | boolean    | [0:1]={text,date}
!  functest_a_2 | integer    | [0:0]={text[]}
!  functest_a_3 | boolean    | {}
! (3 rows)
! 
! --
! -- IMMUTABLE | STABLE | VOLATILE
! --
! CREATE FUNCTION functest_B_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 0';
! CREATE FUNCTION functest_B_2(int) RETURNS bool LANGUAGE 'sql'
!        IMMUTABLE AS 'SELECT $1 > 0';
! CREATE FUNCTION functest_B_3(int) RETURNS bool LANGUAGE 'sql'
!        STABLE AS 'SELECT $1 = 0';
! CREATE FUNCTION functest_B_4(int) RETURNS bool LANGUAGE 'sql'
!        VOLATILE AS 'SELECT $1 < 0';
! SELECT proname, provolatile FROM pg_proc
!        WHERE oid in ('functest_B_1'::regproc,
!                      'functest_B_2'::regproc,
!                      'functest_B_3'::regproc,
! 		     'functest_B_4'::regproc) ORDER BY proname;
!    proname    | provolatile 
! --------------+-------------
!  functest_b_1 | v
!  functest_b_2 | i
!  functest_b_3 | s
!  functest_b_4 | v
! (4 rows)
! 
! ALTER FUNCTION functest_B_2(int) VOLATILE;
! ALTER FUNCTION functest_B_3(int) COST 100;	-- unrelated change, no effect
! SELECT proname, provolatile FROM pg_proc
!        WHERE oid in ('functest_B_1'::regproc,
!                      'functest_B_2'::regproc,
!                      'functest_B_3'::regproc,
! 		     'functest_B_4'::regproc) ORDER BY proname;
!    proname    | provolatile 
! --------------+-------------
!  functest_b_1 | v
!  functest_b_2 | v
!  functest_b_3 | s
!  functest_b_4 | v
! (4 rows)
! 
! --
! -- SECURITY DEFINER | INVOKER
! --
! CREATE FUNCTION functext_C_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 0';
! CREATE FUNCTION functext_C_2(int) RETURNS bool LANGUAGE 'sql'
!        SECURITY DEFINER AS 'SELECT $1 = 0';
! CREATE FUNCTION functext_C_3(int) RETURNS bool LANGUAGE 'sql'
!        SECURITY INVOKER AS 'SELECT $1 < 0';
! SELECT proname, prosecdef FROM pg_proc
!        WHERE oid in ('functext_C_1'::regproc,
!                      'functext_C_2'::regproc,
!                      'functext_C_3'::regproc) ORDER BY proname;
!    proname    | prosecdef 
! --------------+-----------
!  functext_c_1 | f
!  functext_c_2 | t
!  functext_c_3 | f
! (3 rows)
! 
! ALTER FUNCTION functext_C_1(int) IMMUTABLE;	-- unrelated change, no effect
! ALTER FUNCTION functext_C_2(int) SECURITY INVOKER;
! ALTER FUNCTION functext_C_3(int) SECURITY DEFINER;
! SELECT proname, prosecdef FROM pg_proc
!        WHERE oid in ('functext_C_1'::regproc,
!                      'functext_C_2'::regproc,
!                      'functext_C_3'::regproc) ORDER BY proname;
!    proname    | prosecdef 
! --------------+-----------
!  functext_c_1 | f
!  functext_c_2 | f
!  functext_c_3 | t
! (3 rows)
! 
! --
! -- LEAKPROOF
! --
! CREATE FUNCTION functext_E_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 100';
! CREATE FUNCTION functext_E_2(int) RETURNS bool LANGUAGE 'sql'
!        LEAKPROOF AS 'SELECT $1 > 100';
! SELECT proname, proleakproof FROM pg_proc
!        WHERE oid in ('functext_E_1'::regproc,
!                      'functext_E_2'::regproc) ORDER BY proname;
!    proname    | proleakproof 
! --------------+--------------
!  functext_e_1 | f
!  functext_e_2 | t
! (2 rows)
! 
! ALTER FUNCTION functext_E_1(int) LEAKPROOF;
! ALTER FUNCTION functext_E_2(int) STABLE;	-- unrelated change, no effect
! SELECT proname, proleakproof FROM pg_proc
!        WHERE oid in ('functext_E_1'::regproc,
!                      'functext_E_2'::regproc) ORDER BY proname;
!    proname    | proleakproof 
! --------------+--------------
!  functext_e_1 | t
!  functext_e_2 | t
! (2 rows)
! 
! ALTER FUNCTION functext_E_2(int) NOT LEAKPROOF;	-- remove leakproog attribute
! SELECT proname, proleakproof FROM pg_proc
!        WHERE oid in ('functext_E_1'::regproc,
!                      'functext_E_2'::regproc) ORDER BY proname;
!    proname    | proleakproof 
! --------------+--------------
!  functext_e_1 | t
!  functext_e_2 | f
! (2 rows)
! 
! -- it takes superuser privilege to turn on leakproof, but not for turn off
! ALTER FUNCTION functext_E_1(int) OWNER TO regress_unpriv_user;
! ALTER FUNCTION functext_E_2(int) OWNER TO regress_unpriv_user;
! SET SESSION AUTHORIZATION regress_unpriv_user;
! SET search_path TO temp_func_test, public;
! ALTER FUNCTION functext_E_1(int) NOT LEAKPROOF;
! ALTER FUNCTION functext_E_2(int) LEAKPROOF;
! ERROR:  only superuser can define a leakproof function
! CREATE FUNCTION functext_E_3(int) RETURNS bool LANGUAGE 'sql'
!        LEAKPROOF AS 'SELECT $1 < 200';	-- failed
! ERROR:  only superuser can define a leakproof function
! RESET SESSION AUTHORIZATION;
! --
! -- CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
! --
! CREATE FUNCTION functext_F_1(int) RETURNS bool LANGUAGE 'sql'
!        AS 'SELECT $1 > 50';
! CREATE FUNCTION functext_F_2(int) RETURNS bool LANGUAGE 'sql'
!        CALLED ON NULL INPUT AS 'SELECT $1 = 50';
! CREATE FUNCTION functext_F_3(int) RETURNS bool LANGUAGE 'sql'
!        RETURNS NULL ON NULL INPUT AS 'SELECT $1 < 50';
! CREATE FUNCTION functext_F_4(int) RETURNS bool LANGUAGE 'sql'
!        STRICT AS 'SELECT $1 = 50';
! SELECT proname, proisstrict FROM pg_proc
!        WHERE oid in ('functext_F_1'::regproc,
!                      'functext_F_2'::regproc,
!                      'functext_F_3'::regproc,
!                      'functext_F_4'::regproc) ORDER BY proname;
!    proname    | proisstrict 
! --------------+-------------
!  functext_f_1 | f
!  functext_f_2 | f
!  functext_f_3 | t
!  functext_f_4 | t
! (4 rows)
! 
! ALTER FUNCTION functext_F_1(int) IMMUTABLE;	-- unrelated change, no effect
! ALTER FUNCTION functext_F_2(int) STRICT;
! ALTER FUNCTION functext_F_3(int) CALLED ON NULL INPUT;
! SELECT proname, proisstrict FROM pg_proc
!        WHERE oid in ('functext_F_1'::regproc,
!                      'functext_F_2'::regproc,
!                      'functext_F_3'::regproc,
!                      'functext_F_4'::regproc) ORDER BY proname;
!    proname    | proisstrict 
! --------------+-------------
!  functext_f_1 | f
!  functext_f_2 | t
!  functext_f_3 | f
!  functext_f_4 | t
! (4 rows)
! 
! -- information_schema tests
! CREATE FUNCTION functest_IS_1(a int, b int default 1, c text default 'foo')
!     RETURNS int
!     LANGUAGE SQL
!     AS 'SELECT $1 + $2';
! CREATE FUNCTION functest_IS_2(out a int, b int default 1)
!     RETURNS int
!     LANGUAGE SQL
!     AS 'SELECT $1';
! CREATE FUNCTION functest_IS_3(a int default 1, out b int)
!     RETURNS int
!     LANGUAGE SQL
!     AS 'SELECT $1';
! SELECT routine_name, ordinal_position, parameter_name, parameter_default
!     FROM information_schema.parameters JOIN information_schema.routines USING (specific_schema, specific_name)
!     WHERE routine_schema = 'temp_func_test' AND routine_name ~ '^functest_is_'
!     ORDER BY 1, 2;
!  routine_name  | ordinal_position | parameter_name | parameter_default 
! ---------------+------------------+----------------+-------------------
!  functest_is_1 |                1 | a              | 
!  functest_is_1 |                2 | b              | 1
!  functest_is_1 |                3 | c              | 'foo'::text
!  functest_is_2 |                1 | a              | 
!  functest_is_2 |                2 | b              | 1
!  functest_is_3 |                1 | a              | 1
!  functest_is_3 |                2 | b              | 
! (7 rows)
! 
! DROP FUNCTION functest_IS_1(int, int, text), functest_IS_2(int), functest_IS_3(int);
! -- overload
! CREATE FUNCTION functest_B_2(bigint) RETURNS bool LANGUAGE 'sql'
!        IMMUTABLE AS 'SELECT $1 > 0';
! DROP FUNCTION functest_b_1;
! DROP FUNCTION functest_b_1;  -- error, not found
! ERROR:  could not find a function named "functest_b_1"
! DROP FUNCTION functest_b_2;  -- error, ambiguous
! ERROR:  function name "functest_b_2" is not unique
! HINT:  Specify the argument list to select the function unambiguously.
! -- Cleanups
! DROP SCHEMA temp_func_test CASCADE;
! NOTICE:  drop cascades to 16 other objects
! DETAIL:  drop cascades to function functest_a_1(text,date)
! drop cascades to function functest_a_2(text[])
! drop cascades to function functest_a_3()
! drop cascades to function functest_b_2(integer)
! drop cascades to function functest_b_3(integer)
! drop cascades to function functest_b_4(integer)
! drop cascades to function functext_c_1(integer)
! drop cascades to function functext_c_2(integer)
! drop cascades to function functext_c_3(integer)
! drop cascades to function functext_e_1(integer)
! drop cascades to function functext_e_2(integer)
! drop cascades to function functext_f_1(integer)
! drop cascades to function functext_f_2(integer)
! drop cascades to function functext_f_3(integer)
! drop cascades to function functext_f_4(integer)
! drop cascades to function functest_b_2(bigint)
! DROP USER regress_unpriv_user;
! RESET search_path;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/create_cast.out"	2025-07-31 16:07:14.981068200 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/create_cast.out"	2025-07-31 16:39:29.065088128 +0800
***************
*** 1,74 ****
! --
! -- CREATE_CAST
! --
! -- Create some types to test with
! CREATE TYPE casttesttype;
! CREATE FUNCTION casttesttype_in(cstring)
!    RETURNS casttesttype
!    AS 'textin'
!    LANGUAGE internal STRICT IMMUTABLE;
! NOTICE:  return type casttesttype is only a shell
! CREATE FUNCTION casttesttype_out(casttesttype)
!    RETURNS cstring
!    AS 'textout'
!    LANGUAGE internal STRICT IMMUTABLE;
! NOTICE:  argument type casttesttype is only a shell
! CREATE TYPE casttesttype (
!    internallength = variable,
!    input = casttesttype_in,
!    output = casttesttype_out,
!    alignment = int4
! );
! -- a dummy function to test with
! CREATE FUNCTION casttestfunc(casttesttype) RETURNS int4 LANGUAGE SQL AS
! $$ SELECT 1; $$;
! SELECT casttestfunc('foo'::text); -- fails, as there's no cast
! ERROR:  function casttestfunc(text) does not exist
! LINE 1: SELECT casttestfunc('foo'::text);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! -- Try binary coercion cast
! CREATE CAST (text AS casttesttype) WITHOUT FUNCTION;
! SELECT casttestfunc('foo'::text); -- doesn't work, as the cast is explicit
! ERROR:  function casttestfunc(text) does not exist
! LINE 1: SELECT casttestfunc('foo'::text);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! SELECT casttestfunc('foo'::text::casttesttype); -- should work
!  casttestfunc 
! --------------
!             1
! (1 row)
! 
! DROP CAST (text AS casttesttype); -- cleanup
! -- Try IMPLICIT binary coercion cast
! CREATE CAST (text AS casttesttype) WITHOUT FUNCTION AS IMPLICIT;
! SELECT casttestfunc('foo'::text); -- Should work now
!  casttestfunc 
! --------------
!             1
! (1 row)
! 
! -- Try I/O conversion cast.
! SELECT 1234::int4::casttesttype; -- No cast yet, should fail
! ERROR:  cannot cast type integer to casttesttype
! LINE 1: SELECT 1234::int4::casttesttype;
!                          ^
! CREATE CAST (int4 AS casttesttype) WITH INOUT;
! SELECT 1234::int4::casttesttype; -- Should work now
!  casttesttype 
! --------------
!  1234
! (1 row)
! 
! DROP CAST (int4 AS casttesttype);
! -- Try cast with a function
! CREATE FUNCTION int4_casttesttype(int4) RETURNS casttesttype LANGUAGE SQL AS
! $$ SELECT ('foo'::text || $1::text)::casttesttype; $$;
! CREATE CAST (int4 AS casttesttype) WITH FUNCTION int4_casttesttype(int4) AS IMPLICIT;
! SELECT 1234::int4::casttesttype; -- Should work now
!  casttesttype 
! --------------
!  foo1234
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/constraints_1.out"	2025-07-31 16:37:23.180194792 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/constraints.out"	2025-07-31 16:39:29.065088128 +0800
***************
*** 1,635 ****
! --
! -- CONSTRAINTS
! -- Constraints can be specified with:
! --  - DEFAULT clause
! --  - CHECK clauses
! --  - PRIMARY KEY clauses
! --  - UNIQUE clauses
! --  - EXCLUDE clauses
! --
! --
! -- DEFAULT syntax
! --
! CREATE TABLE DEFAULT_TBL (i int DEFAULT 100,
! 	x text DEFAULT 'vadim', f float8 DEFAULT 123.456);
! INSERT INTO DEFAULT_TBL VALUES (1, 'thomas', 57.0613);
! INSERT INTO DEFAULT_TBL VALUES (1, 'bruce');
! INSERT INTO DEFAULT_TBL (i, f) VALUES (2, 987.654);
! INSERT INTO DEFAULT_TBL (x) VALUES ('marc');
! INSERT INTO DEFAULT_TBL VALUES (3, null, 1.0);
! SELECT '' AS five, * FROM DEFAULT_TBL ORDER BY i,x,f;
!  five |  i  |   x    |    f    
! ------+-----+--------+---------
!       |   1 | bruce  | 123.456
!       |   1 | thomas | 57.0613
!       |   2 | vadim  | 987.654
!       |   3 |        |       1
!       | 100 | marc   | 123.456
! (5 rows)
! 
! CREATE SEQUENCE DEFAULT_SEQ;
! CREATE TABLE DEFAULTEXPR_TBL (i1 int DEFAULT 100 + (200-199) * 2,
! 	i2 int DEFAULT nextval('default_seq'));
! INSERT INTO DEFAULTEXPR_TBL VALUES (-1, -2);
! INSERT INTO DEFAULTEXPR_TBL (i1) VALUES (-3);
! INSERT INTO DEFAULTEXPR_TBL (i2) VALUES (-4);
! INSERT INTO DEFAULTEXPR_TBL (i2) VALUES (NULL);
! SELECT '' AS four, * FROM DEFAULTEXPR_TBL ORDER BY i1,i2;
!  four | i1  | i2 
! ------+-----+----
!       |  -3 |  1
!       |  -1 | -2
!       | 102 | -4
!       | 102 |   
! (4 rows)
! 
! -- syntax errors
! --  test for extraneous comma
! CREATE TABLE error_tbl (i int DEFAULT (100, ));
! ERROR:  syntax error at or near ")"
! LINE 1: CREATE TABLE error_tbl (i int DEFAULT (100, ));
!                                                     ^
! --  this will fail because gram.y uses b_expr not a_expr for defaults,
! --  to avoid a shift/reduce conflict that arises from NOT NULL being
! --  part of the column definition syntax:
! CREATE TABLE error_tbl (b1 bool DEFAULT 1 IN (1, 2));
! ERROR:  syntax error at or near "IN"
! LINE 1: CREATE TABLE error_tbl (b1 bool DEFAULT 1 IN (1, 2));
!                                                   ^
! --  this should work, however:
! CREATE TABLE error_tbl (b1 bool DEFAULT (1 IN (1, 2)));
! DROP TABLE error_tbl;
! --
! -- CHECK syntax
! --
! CREATE TABLE CHECK_TBL (x int,
! 	CONSTRAINT CHECK_CON CHECK (x > 3));
! INSERT INTO CHECK_TBL VALUES (5);
! INSERT INTO CHECK_TBL VALUES (4);
! INSERT INTO CHECK_TBL VALUES (3);
! ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
! DETAIL:  Failing row contains (3).
! INSERT INTO CHECK_TBL VALUES (2);
! ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
! DETAIL:  Failing row contains (2).
! INSERT INTO CHECK_TBL VALUES (6);
! INSERT INTO CHECK_TBL VALUES (1);
! ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
! DETAIL:  Failing row contains (1).
! SELECT '' AS three, * FROM CHECK_TBL ORDER BY x;
!  three | x 
! -------+---
!        | 4
!        | 5
!        | 6
! (3 rows)
! 
! CREATE SEQUENCE CHECK_SEQ;
! CREATE TABLE CHECK2_TBL (x int, y text, z int,
! 	CONSTRAINT SEQUENCE_CON
! 	CHECK (x > 3 and y <> 'check failed' and z < 8));
! INSERT INTO CHECK2_TBL VALUES (4, 'check ok', -2);
! INSERT INTO CHECK2_TBL VALUES (1, 'x check failed', -2);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (1, x check failed, -2).
! INSERT INTO CHECK2_TBL VALUES (5, 'z check failed', 10);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (5, z check failed, 10).
! INSERT INTO CHECK2_TBL VALUES (0, 'check failed', -2);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (0, check failed, -2).
! INSERT INTO CHECK2_TBL VALUES (6, 'check failed', 11);
! ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
! DETAIL:  Failing row contains (6, check failed, 11).
! INSERT INTO CHECK2_TBL VALUES (7, 'check ok', 7);
! SELECT '' AS two, * from CHECK2_TBL ORDER BY x,y,z;
!  two | x |    y     | z  
! -----+---+----------+----
!      | 4 | check ok | -2
!      | 7 | check ok |  7
! (2 rows)
! 
! --
! -- Check constraints on INSERT
! --
! CREATE SEQUENCE INSERT_SEQ;
! -- PGXCTODO : Feature ID 3520518
! CREATE TABLE INSERT_TBL (x INT DEFAULT nextval('insert_seq'),
! 	y TEXT DEFAULT '-NULL-',
! 	z INT DEFAULT -1 * currval('insert_seq'),
! 	CONSTRAINT INSERT_CON CHECK (x >= 3 AND y <> 'check failed' AND x < 8),
! 	CHECK (x + z = 0)) DISTRIBUTE BY REPLICATION;
! INSERT INTO INSERT_TBL(x,z) VALUES (2, -2);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (2, -NULL-, -2).
! SELECT '' AS zero, * FROM INSERT_TBL order by x,y,z;
!  zero | x | y | z 
! ------+---+---+---
! (0 rows)
! 
! SELECT 'one' AS one, nextval('insert_seq');
!  one | nextval 
! -----+---------
!  one |       1
! (1 row)
! 
! INSERT INTO INSERT_TBL(y) VALUES ('Y');
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (2, Y, -2).
! INSERT INTO INSERT_TBL(y) VALUES ('Y');
! INSERT INTO INSERT_TBL(x,z) VALUES (1, -2);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_check"
! DETAIL:  Failing row contains (1, -NULL-, -2).
! INSERT INTO INSERT_TBL(z,x) VALUES (-7,  7);
! INSERT INTO INSERT_TBL VALUES (5, 'check failed', -5);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (5, check failed, -5).
! INSERT INTO INSERT_TBL VALUES (7, '!check failed', -7);
! INSERT INTO INSERT_TBL(y) VALUES ('-!NULL-');
! SELECT '' AS four, * FROM INSERT_TBL order by x,y,z;
!  four | x |       y       | z  
! ------+---+---------------+----
!       | 3 | Y             | -3
!       | 4 | -!NULL-       | -4
!       | 7 | !check failed | -7
!       | 7 | -NULL-        | -7
! (4 rows)
! 
! INSERT INTO INSERT_TBL(y,z) VALUES ('check failed', 4);
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_check"
! DETAIL:  Failing row contains (5, check failed, 4).
! INSERT INTO INSERT_TBL(x,y) VALUES (5, 'check failed');
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (5, check failed, -5).
! INSERT INTO INSERT_TBL(x,y) VALUES (5, '!check failed');
! INSERT INTO INSERT_TBL(y) VALUES ('-!NULL-');
! SELECT '' AS six, * FROM INSERT_TBL order by x,y,z;
!  six | x |       y       | z  
! -----+---+---------------+----
!      | 3 | Y             | -3
!      | 4 | -!NULL-       | -4
!      | 5 | !check failed | -5
!      | 6 | -!NULL-       | -6
!      | 7 | !check failed | -7
!      | 7 | -NULL-        | -7
! (6 rows)
! 
! SELECT 'seven' AS one, nextval('insert_seq');
!   one  | nextval 
! -------+---------
!  seven |       7
! (1 row)
! 
! INSERT INTO INSERT_TBL(y) VALUES ('Y');
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (8, Y, -8).
! SELECT 'eight' AS one, currval('insert_seq');
!   one  | currval 
! -------+---------
!  eight |       8
! (1 row)
! 
! -- According to SQL92, it is OK to insert a record that gives rise to NULL
! -- constraint-condition results.  Postgres used to reject this, but it
! -- was wrong:
! INSERT INTO INSERT_TBL VALUES (null, null, null);
! SELECT '' AS nine, * FROM INSERT_TBL order by x,y,z;
!  nine | x |       y       | z  
! ------+---+---------------+----
!       | 3 | Y             | -3
!       | 4 | -!NULL-       | -4
!       | 5 | !check failed | -5
!       | 6 | -!NULL-       | -6
!       | 7 | !check failed | -7
!       | 7 | -NULL-        | -7
!       |   |               |   
! (7 rows)
! 
! --
! -- Check inheritance of defaults and constraints
! --
! CREATE TABLE INSERT_CHILD (cx INT default 42,
! 	cy INT CHECK (cy > x))
! 	INHERITS (INSERT_TBL);
! INSERT INTO INSERT_CHILD(x,z,cy) VALUES (7,-7,11);
! INSERT INTO INSERT_CHILD(x,z,cy) VALUES (7,-7,6);
! ERROR:  new row for relation "insert_child" violates check constraint "insert_child_check"
! DETAIL:  Failing row contains (7, -NULL-, -7, 42, 6).
! INSERT INTO INSERT_CHILD(x,z,cy) VALUES (6,-7,7);
! ERROR:  new row for relation "insert_child" violates check constraint "insert_tbl_check"
! DETAIL:  Failing row contains (6, -NULL-, -7, 42, 7).
! INSERT INTO INSERT_CHILD(x,y,z,cy) VALUES (6,'check failed',-6,7);
! ERROR:  new row for relation "insert_child" violates check constraint "insert_con"
! DETAIL:  Failing row contains (6, check failed, -6, 42, 7).
! SELECT * FROM INSERT_CHILD order by 1,2,3;
!  x |   y    | z  | cx | cy 
! ---+--------+----+----+----
!  7 | -NULL- | -7 | 42 | 11
! (1 row)
! 
! DROP TABLE INSERT_CHILD;
! --
! -- Check NO INHERIT type of constraints and inheritance
! --
! CREATE TABLE ATACC1 (TEST INT
! 	CHECK (TEST > 0) NO INHERIT);
! CREATE TABLE ATACC2 (TEST2 INT) INHERITS (ATACC1);
! -- check constraint is not there on child
! INSERT INTO ATACC2 (TEST) VALUES (-3);
! -- check constraint is there on parent
! INSERT INTO ATACC1 (TEST) VALUES (-3);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test_check"
! DETAIL:  Failing row contains (-3).
! DROP TABLE ATACC1 CASCADE;
! NOTICE:  drop cascades to table atacc2
! CREATE TABLE ATACC1 (TEST INT, TEST2 INT
! 	CHECK (TEST > 0), CHECK (TEST2 > 10) NO INHERIT);
! CREATE TABLE ATACC2 () INHERITS (ATACC1);
! -- check constraint is there on child
! INSERT INTO ATACC2 (TEST) VALUES (-3);
! ERROR:  new row for relation "atacc2" violates check constraint "atacc1_test_check"
! DETAIL:  Failing row contains (-3, null).
! -- check constraint is there on parent
! INSERT INTO ATACC1 (TEST) VALUES (-3);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test_check"
! DETAIL:  Failing row contains (-3, null).
! -- check constraint is not there on child
! INSERT INTO ATACC2 (TEST2) VALUES (3);
! -- check constraint is there on parent
! INSERT INTO ATACC1 (TEST2) VALUES (3);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test2_check"
! DETAIL:  Failing row contains (null, 3).
! DROP TABLE ATACC1 CASCADE;
! NOTICE:  drop cascades to table atacc2
! --
! -- Check constraints on INSERT INTO
! --
! DELETE FROM INSERT_TBL;
! ALTER SEQUENCE INSERT_SEQ RESTART WITH 4;
! CREATE TABLE tmp (xd INT, yd TEXT, zd INT);
! INSERT INTO tmp VALUES (null, 'Y', null);
! INSERT INTO tmp VALUES (5, '!check failed', null);
! INSERT INTO tmp VALUES (null, 'try again', null);
! INSERT INTO INSERT_TBL(y) select yd from tmp;
! SELECT '' AS three, * FROM INSERT_TBL order by x,y,z;
!  three | x |       y       | z  
! -------+---+---------------+----
!        | 4 | Y             | -4
!        | 5 | !check failed | -5
!        | 6 | try again     | -6
! (3 rows)
! 
! INSERT INTO INSERT_TBL SELECT * FROM tmp WHERE yd = 'try again';
! INSERT INTO INSERT_TBL(y,z) SELECT yd, -7 FROM tmp WHERE yd = 'try again';
! INSERT INTO INSERT_TBL(y,z) SELECT yd, -8 FROM tmp WHERE yd = 'try again';
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (8, try again, -8).
! SELECT '' AS four, * FROM INSERT_TBL order by x,y,z;
!  four | x |       y       | z  
! ------+---+---------------+----
!       | 4 | Y             | -4
!       | 5 | !check failed | -5
!       | 6 | try again     | -6
!       | 7 | try again     | -7
!       |   | try again     |   
! (5 rows)
! 
! DROP TABLE tmp;
! --
! -- Check constraints on UPDATE
! --
! UPDATE INSERT_TBL SET x = NULL WHERE x = 5;
! UPDATE INSERT_TBL SET x = 6 WHERE x = 6;
! UPDATE INSERT_TBL SET x = -z, z = -x;
! UPDATE INSERT_TBL SET x = z, z = x;
! ERROR:  new row for relation "insert_tbl" violates check constraint "insert_con"
! DETAIL:  Failing row contains (-4, Y, 4).
! SELECT * FROM INSERT_TBL order by x,y,z;
!  x |       y       | z  
! ---+---------------+----
!  4 | Y             | -4
!  5 | !check failed |   
!  6 | try again     | -6
!  7 | try again     | -7
!    | try again     |   
! (5 rows)
! 
! -- DROP TABLE INSERT_TBL;
! --
! -- Check constraints on COPY FROM
! --
! CREATE TABLE COPY_TBL (x INT, y TEXT, z INT,
! 	CONSTRAINT COPY_CON
! 	CHECK (x > 3 AND y <> 'check failed' AND x < 7 ));
! COPY COPY_TBL FROM '/home/wyx//opentenbase/src/test/regress/data/constro.data';
! SELECT '' AS two, * FROM COPY_TBL order by x,y,z;
!  two | x |       y       | z 
! -----+---+---------------+---
!      | 4 | !check failed | 5
!      | 6 | OK            | 4
! (2 rows)
! 
! COPY COPY_TBL FROM '/home/wyx//opentenbase/src/test/regress/data/constrf.data';
! ERROR:  new row for relation "copy_tbl" violates check constraint "copy_con"
! DETAIL:  Failing row contains (7, check failed, 6).
! SELECT * FROM COPY_TBL order by x,y,z;
!  x |       y       | z 
! ---+---------------+---
!  4 | !check failed | 5
!  6 | OK            | 4
! (2 rows)
! 
! --
! -- Primary keys
! --
! CREATE TABLE PRIMARY_TBL (i int PRIMARY KEY, t text);
! NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "primary_tbl_pkey" for table "primary_tbl"
! INSERT INTO PRIMARY_TBL VALUES (1, 'one');
! INSERT INTO PRIMARY_TBL VALUES (2, 'two');
! INSERT INTO PRIMARY_TBL VALUES (1, 'three');
! ERROR:  duplicate key value violates unique constraint "primary_tbl_pkey"
! DETAIL:  Key (i)=(1) already exists.
! INSERT INTO PRIMARY_TBL VALUES (4, 'three');
! INSERT INTO PRIMARY_TBL VALUES (5, 'one');
! INSERT INTO PRIMARY_TBL (t) VALUES ('six');
! ERROR:  null value in column "i" violates not-null constraint
! DETAIL:  Failing row contains (null, six).
! SELECT '' AS four, * FROM PRIMARY_TBL order by i,t;
!  four | i |   t   
! ------+---+-------
!       | 1 | one
!       | 2 | two
!       | 4 | three
!       | 5 | one
! (4 rows)
! 
! DROP TABLE PRIMARY_TBL;
! CREATE TABLE PRIMARY_TBL (i int, t text,
! 	PRIMARY KEY(i,t));
! NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "primary_tbl_pkey" for table "primary_tbl"
! INSERT INTO PRIMARY_TBL VALUES (1, 'one');
! INSERT INTO PRIMARY_TBL VALUES (2, 'two');
! INSERT INTO PRIMARY_TBL VALUES (1, 'three');
! INSERT INTO PRIMARY_TBL VALUES (4, 'three');
! INSERT INTO PRIMARY_TBL VALUES (5, 'one');
! INSERT INTO PRIMARY_TBL (t) VALUES ('six');
! ERROR:  null value in column "i" violates not-null constraint
! DETAIL:  Failing row contains (null, six).
! SELECT '' AS three, * FROM PRIMARY_TBL order by i,t;
!  three | i |   t   
! -------+---+-------
!        | 1 | one
!        | 1 | three
!        | 2 | two
!        | 4 | three
!        | 5 | one
! (5 rows)
! 
! DROP TABLE PRIMARY_TBL;
! --
! -- Unique keys
! --
! CREATE TABLE UNIQUE_TBL (i int UNIQUE, t text);
! NOTICE:  CREATE TABLE / UNIQUE will create implicit index "unique_tbl_i_key" for table "unique_tbl"
! INSERT INTO UNIQUE_TBL VALUES (1, 'one');
! INSERT INTO UNIQUE_TBL VALUES (2, 'two');
! INSERT INTO UNIQUE_TBL VALUES (1, 'three');
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(1) already exists.
! INSERT INTO UNIQUE_TBL VALUES (4, 'four');
! INSERT INTO UNIQUE_TBL VALUES (5, 'one');
! INSERT INTO UNIQUE_TBL (t) VALUES ('six');
! INSERT INTO UNIQUE_TBL (t) VALUES ('seven');
! SELECT '' AS five, * FROM UNIQUE_TBL order by i,t; 
!  five | i |   t   
! ------+---+-------
!       | 1 | one
!       | 2 | two
!       | 4 | four
!       | 5 | one
!       |   | seven
!       |   | six
! (6 rows)
! 
! DROP TABLE UNIQUE_TBL;
! CREATE TABLE UNIQUE_TBL (i int, t text,
! 	UNIQUE(i,t));
! NOTICE:  CREATE TABLE / UNIQUE will create implicit index "unique_tbl_i_t_key" for table "unique_tbl"
! INSERT INTO UNIQUE_TBL VALUES (1, 'one');
! INSERT INTO UNIQUE_TBL VALUES (2, 'two');
! INSERT INTO UNIQUE_TBL VALUES (1, 'three');
! INSERT INTO UNIQUE_TBL VALUES (1, 'one');
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_t_key"
! DETAIL:  Key (i, t)=(1, one) already exists.
! INSERT INTO UNIQUE_TBL VALUES (5, 'one');
! INSERT INTO UNIQUE_TBL (t) VALUES ('six');
! SELECT '' AS five, * FROM UNIQUE_TBL order by i,t;
!  five | i |   t   
! ------+---+-------
!       | 1 | one
!       | 1 | three
!       | 2 | two
!       | 5 | one
!       |   | six
! (5 rows)
! 
! DROP TABLE UNIQUE_TBL;
! --
! -- Deferrable unique constraints
! --
! -- PGXCTODO : Feature ID 3520518
! CREATE TABLE unique_tbl (i int UNIQUE DEFERRABLE, t text) DISTRIBUTE BY REPLICATION;
! NOTICE:  CREATE TABLE / UNIQUE will create implicit index "unique_tbl_i_key" for table "unique_tbl"
! INSERT INTO unique_tbl VALUES (0, 'one');
! INSERT INTO unique_tbl VALUES (1, 'two');
! INSERT INTO unique_tbl VALUES (2, 'tree');
! INSERT INTO unique_tbl VALUES (3, 'four');
! INSERT INTO unique_tbl VALUES (4, 'five');
! BEGIN;
! -- default is immediate so this should fail right away
! UPDATE unique_tbl SET i = 1 WHERE i = 0;
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(1) already exists.
! ROLLBACK;
! -- check is done at end of statement, so this should succeed
! UPDATE unique_tbl SET i = i+1;
! SELECT * FROM unique_tbl ORDER BY 1,t;
!  i |  t   
! ---+------
!  1 | one
!  2 | two
!  3 | tree
!  4 | four
!  5 | five
! (5 rows)
! 
! -- explicitly defer the constraint
! BEGIN;
! SET CONSTRAINTS unique_tbl_i_key DEFERRED;
! INSERT INTO unique_tbl VALUES (3, 'three');
! DELETE FROM unique_tbl WHERE t = 'tree'; -- makes constraint valid again
! COMMIT; -- should succeed
! SELECT * FROM unique_tbl ORDER BY 1,t;
!  i |   t   
! ---+-------
!  1 | one
!  2 | two
!  3 | three
!  4 | four
!  5 | five
! (5 rows)
! 
! -- try adding an initially deferred constraint
! ALTER TABLE unique_tbl DROP CONSTRAINT unique_tbl_i_key;
! ALTER TABLE unique_tbl ADD CONSTRAINT unique_tbl_i_key
! 	UNIQUE (i) DEFERRABLE INITIALLY DEFERRED;
! NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "unique_tbl_i_key" for table "unique_tbl"
! BEGIN;
! INSERT INTO unique_tbl VALUES (1, 'five');
! INSERT INTO unique_tbl VALUES (5, 'one');
! UPDATE unique_tbl SET i = 4 WHERE i = 2;
! UPDATE unique_tbl SET i = 2 WHERE i = 4 AND t = 'four';
! DELETE FROM unique_tbl WHERE i = 1 AND t = 'one';
! DELETE FROM unique_tbl WHERE i = 5 AND t = 'five';
! COMMIT;
! SELECT * FROM unique_tbl ORDER BY 1,t;
!  i |   t   
! ---+-------
!  1 | five
!  2 | four
!  3 | three
!  4 | two
!  5 | one
! (5 rows)
! 
! -- should fail at commit-time
! BEGIN;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for now
! COMMIT; -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! -- make constraint check immediate
! BEGIN;
! SET CONSTRAINTS ALL IMMEDIATE;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! COMMIT;
! -- forced check when SET CONSTRAINTS is called
! BEGIN;
! SET CONSTRAINTS ALL DEFERRED;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for now
! SET CONSTRAINTS ALL IMMEDIATE; -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! COMMIT;
! -- test a HOT update that invalidates the conflicting tuple.
! -- the trigger should still fire and catch the violation
! BEGIN;
! INSERT INTO unique_tbl VALUES (3, 'Three'); -- should succeed for now
! UPDATE unique_tbl SET t = 'THREE' WHERE i = 3 AND t = 'Three';
! COMMIT; -- should fail
! ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
! DETAIL:  Key (i)=(3) already exists.
! SELECT * FROM unique_tbl ORDER BY 1,t;
!  i |   t   
! ---+-------
!  1 | five
!  2 | four
!  3 | three
!  4 | two
!  5 | one
! (5 rows)
! 
! -- test a HOT update that modifies the newly inserted tuple,
! -- but should succeed because we then remove the other conflicting tuple.
! BEGIN;
! INSERT INTO unique_tbl VALUES(3, 'tree'); -- should succeed for now
! UPDATE unique_tbl SET t = 'threex' WHERE t = 'tree';
! DELETE FROM unique_tbl WHERE t = 'three';
! SELECT * FROM unique_tbl ORDER BY 1,t;
!  i |   t    
! ---+--------
!  1 | five
!  2 | four
!  3 | threex
!  4 | two
!  5 | one
! (5 rows)
! 
! COMMIT;
! SELECT * FROM unique_tbl ORDER BY 1,t;
!  i |   t    
! ---+--------
!  1 | five
!  2 | four
!  3 | threex
!  4 | two
!  5 | one
! (5 rows)
! 
! DROP TABLE unique_tbl;
! --
! -- EXCLUDE constraints
! --
! CREATE TABLE circles (
!   c1 CIRCLE,
!   c2 TEXT,
!   EXCLUDE USING gist
!     (c1 WITH &&, (c2::circle) WITH &&)
!     WHERE (circle_center(c1) <> '(0,0)')
! );
! NOTICE:  CREATE TABLE / EXCLUDE will create implicit index "circles_c1_c2_excl" for table "circles"
! -- these should succeed because they don't match the index predicate
! INSERT INTO circles VALUES('<(0,0), 5>', '<(0,0), 5>');
! INSERT INTO circles VALUES('<(0,0), 5>', '<(0,0), 4>');
! -- succeed
! INSERT INTO circles VALUES('<(10,10), 10>', '<(0,0), 5>');
! -- fail, overlaps
! INSERT INTO circles VALUES('<(20,20), 10>', '<(0,0), 4>');
! ERROR:  conflicting key value violates exclusion constraint "circles_c1_c2_excl"
! DETAIL:  Key (c1, (c2::circle))=(<(20,20),10>, <(0,0),4>) conflicts with existing key (c1, (c2::circle))=(<(10,10),10>, <(0,0),5>).
! -- succeed because c1 doesn't overlap
! INSERT INTO circles VALUES('<(20,20), 1>', '<(0,0), 5>');
! -- succeed because c2 doesn't overlap
! INSERT INTO circles VALUES('<(20,20), 10>', '<(10,10), 5>');
! -- should fail on existing data without the WHERE clause
! ALTER TABLE circles ADD EXCLUDE USING gist
!   (c1 WITH &&, (c2::circle) WITH &&);
! NOTICE:  ALTER TABLE / ADD EXCLUDE will create implicit index "circles_c1_c2_excl1" for table "circles"
! ERROR:  could not create exclusion constraint "circles_c1_c2_excl1"
! DETAIL:  Key (c1, (c2::circle))=(<(0,0),5>, <(0,0),5>) conflicts with key (c1, (c2::circle))=(<(0,0),5>, <(0,0),4>).
! -- try reindexing an existing constraint
! REINDEX INDEX circles_c1_c2_excl;
! DROP TABLE circles;
! -- Check deferred exclusion constraint
! -- PGXCTODO : Feature ID 3520518
! CREATE TABLE deferred_excl (
!   f1 int,
!   CONSTRAINT deferred_excl_con EXCLUDE (f1 WITH =) INITIALLY DEFERRED
! ) DISTRIBUTE BY REPLICATION;
! NOTICE:  CREATE TABLE / EXCLUDE will create implicit index "deferred_excl_con" for table "deferred_excl"
! INSERT INTO deferred_excl VALUES(1);
! INSERT INTO deferred_excl VALUES(2);
! INSERT INTO deferred_excl VALUES(1); -- fail
! ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
! DETAIL:  Key (f1)=(1) conflicts with existing key (f1)=(1).
! BEGIN;
! INSERT INTO deferred_excl VALUES(2); -- no fail here
! COMMIT; -- should fail here
! ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
! DETAIL:  Key (f1)=(2) conflicts with existing key (f1)=(2).
! BEGIN;
! INSERT INTO deferred_excl VALUES(3);
! INSERT INTO deferred_excl VALUES(3); -- no fail here
! COMMIT; -- should fail here
! ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
! DETAIL:  Key (f1)=(3) conflicts with existing key (f1)=(3).
! ALTER TABLE deferred_excl DROP CONSTRAINT deferred_excl_con;
! -- This should fail, but worth testing because of HOT updates
! UPDATE deferred_excl SET f1 = 3;
! ALTER TABLE deferred_excl ADD EXCLUDE (f1 WITH =);
! NOTICE:  ALTER TABLE / ADD EXCLUDE will create implicit index "deferred_excl_f1_excl" for table "deferred_excl"
! ERROR:  could not create exclusion constraint "deferred_excl_f1_excl"
! DETAIL:  Key (f1)=(3) conflicts with key (f1)=(3).
! DROP TABLE deferred_excl;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/triggers.out"	2025-07-31 16:07:15.005067818 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/triggers.out"	2025-07-31 16:39:29.059088256 +0800
***************
*** 1,2132 ****
! --
! -- TRIGGERS
! --
! create table pkeys (pkey1 int4 not null, pkey2 text not null);
! create table fkeys (fkey1 int4, fkey2 text, fkey3 int);
! create table fkeys2 (fkey21 int4, fkey22 text, pkey23 int not null);
! create index fkeys_i on fkeys (fkey1, fkey2);
! create index fkeys2_i on fkeys2 (fkey21, fkey22);
! create index fkeys2p_i on fkeys2 (pkey23);
! insert into pkeys values (10, '1');
! insert into pkeys values (20, '2');
! insert into pkeys values (30, '3');
! insert into pkeys values (40, '4');
! insert into pkeys values (50, '5');
! insert into pkeys values (60, '6');
! create unique index pkeys_i on pkeys (pkey1, pkey2);
! --
! -- For fkeys:
! -- 	(fkey1, fkey2)	--> pkeys (pkey1, pkey2)
! -- 	(fkey3)		--> fkeys2 (pkey23)
! --
! create trigger check_fkeys_pkey_exist
! 	before insert or update on fkeys
! 	for each row
! 	execute procedure
! 	check_primary_key ('fkey1', 'fkey2', 'pkeys', 'pkey1', 'pkey2');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger check_fkeys_pkey2_exist
! 	before insert or update on fkeys
! 	for each row
! 	execute procedure check_primary_key ('fkey3', 'fkeys2', 'pkey23');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! --
! -- For fkeys2:
! -- 	(fkey21, fkey22)	--> pkeys (pkey1, pkey2)
! --
! create trigger check_fkeys2_pkey_exist
! 	before insert or update on fkeys2
! 	for each row
! 	execute procedure
! 	check_primary_key ('fkey21', 'fkey22', 'pkeys', 'pkey1', 'pkey2');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- Test comments
! COMMENT ON TRIGGER check_fkeys2_pkey_bad ON fkeys2 IS 'wrong';
! ERROR:  trigger "check_fkeys2_pkey_bad" for table "fkeys2" does not exist
! COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS 'right';
! ERROR:  trigger "check_fkeys2_pkey_exist" for table "fkeys2" does not exist
! COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS NULL;
! ERROR:  trigger "check_fkeys2_pkey_exist" for table "fkeys2" does not exist
! --
! -- For pkeys:
! -- 	ON DELETE/UPDATE (pkey1, pkey2) CASCADE:
! -- 		fkeys (fkey1, fkey2) and fkeys2 (fkey21, fkey22)
! --
! create trigger check_pkeys_fkey_cascade
! 	before delete or update on pkeys
! 	for each row
! 	execute procedure
! 	check_foreign_key (2, 'cascade', 'pkey1', 'pkey2',
! 	'fkeys', 'fkey1', 'fkey2', 'fkeys2', 'fkey21', 'fkey22');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! --
! -- For fkeys2:
! -- 	ON DELETE/UPDATE (pkey23) RESTRICT:
! -- 		fkeys (fkey3)
! --
! create trigger check_fkeys2_fkey_restrict
! 	before delete or update on fkeys2
! 	for each row
! 	execute procedure check_foreign_key (1, 'restrict', 'pkey23', 'fkeys', 'fkey3');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! insert into fkeys2 values (10, '1', 1);
! insert into fkeys2 values (30, '3', 2);
! insert into fkeys2 values (40, '4', 5);
! insert into fkeys2 values (50, '5', 3);
! -- no key in pkeys
! insert into fkeys2 values (70, '5', 3);
! insert into fkeys values (10, '1', 2);
! insert into fkeys values (30, '3', 3);
! insert into fkeys values (40, '4', 2);
! insert into fkeys values (50, '5', 2);
! -- no key in pkeys
! insert into fkeys values (70, '5', 1);
! -- no key in fkeys2
! insert into fkeys values (60, '6', 4);
! delete from pkeys where pkey1 = 30 and pkey2 = '3';
! delete from pkeys where pkey1 = 40 and pkey2 = '4';
! update pkeys set pkey1 = 7, pkey2 = '70' where pkey1 = 50 and pkey2 = '5';
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! update pkeys set pkey1 = 7, pkey2 = '70' where pkey1 = 10 and pkey2 = '1';
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! DROP TABLE pkeys;
! DROP TABLE fkeys;
! DROP TABLE fkeys2;
! -- -- I've disabled the funny_dup17 test because the new semantics
! -- -- of AFTER ROW triggers, which get now fired at the end of a
! -- -- query always, cause funny_dup17 to enter an endless loop.
! -- --
! -- --      Jan
! --
! -- create table dup17 (x int4);
! --
! -- create trigger dup17_before
! -- 	before insert on dup17
! -- 	for each row
! -- 	execute procedure
! -- 	funny_dup17 ()
! -- ;
! --
! -- insert into dup17 values (17);
! -- select count(*) from dup17;
! -- insert into dup17 values (17);
! -- select count(*) from dup17;
! --
! -- drop trigger dup17_before on dup17;
! --
! -- create trigger dup17_after
! -- 	after insert on dup17
! -- 	for each row
! -- 	execute procedure
! -- 	funny_dup17 ()
! -- ;
! -- insert into dup17 values (13);
! -- select count(*) from dup17 where x = 13;
! -- insert into dup17 values (13);
! -- select count(*) from dup17 where x = 13;
! --
! -- DROP TABLE dup17;
! create sequence ttdummy_seq increment 10 start 0 minvalue 0;
! create table tttest (
! 	price_id	int4,
! 	price_val	int4,
! 	price_on	int4,
! 	price_off	int4 default 999999
! );
! create trigger ttdummy
! 	before delete or update on tttest
! 	for each row
! 	execute procedure
! 	ttdummy (price_on, price_off);
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger ttserial
! 	before insert or update on tttest
! 	for each row
! 	execute procedure
! 	autoinc (price_on, ttdummy_seq);
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! insert into tttest values (1, 1, null);
! insert into tttest values (2, 2, null);
! insert into tttest values (3, 3, 0);
! select * from tttest order by 1,2,3,4;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |          |    999999
!         2 |         2 |          |    999999
!         3 |         3 |        0 |    999999
! (3 rows)
! 
! delete from tttest where price_id = 2;
! select * from tttest order by 1,2,3,4;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |          |    999999
!         3 |         3 |        0 |    999999
! (2 rows)
! 
! -- what do we see ?
! -- get current prices
! select * from tttest where price_off = 999999 order by 1,2,3,4;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |          |    999999
!         3 |         3 |        0 |    999999
! (2 rows)
! 
! -- change price for price_id == 3
! update tttest set price_val = 30 where price_id = 3;
! select * from tttest order by 1,2,3,4;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |          |    999999
!         3 |        30 |        0 |    999999
! (2 rows)
! 
! -- now we want to change pric_id in ALL tuples
! -- this gets us not what we need
! update tttest set price_id = 5 where price_id = 3;
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! select * from tttest order by 1,2,3,4;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |          |    999999
!         3 |        30 |        0 |    999999
! (2 rows)
! 
! -- restore data as before last update:
! select set_ttdummy(0);
!  set_ttdummy 
! -------------
!            1
! (1 row)
! 
! delete from tttest where price_id = 5;
! update tttest set price_off = 999999 where price_val = 30;
! select * from tttest order by 1,2,3,4;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |          |    999999
!         3 |        30 |        0 |    999999
! (2 rows)
! 
! -- and try change price_id now!
! update tttest set price_id = 5 where price_id = 3;
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! select * from tttest order by 1,2,3,4;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |          |    999999
!         3 |        30 |        0 |    999999
! (2 rows)
! 
! -- isn't it what we need ?
! select set_ttdummy(1);
!  set_ttdummy 
! -------------
!            0
! (1 row)
! 
! -- we want to correct some "date"
! update tttest set price_on = -1 where price_id = 1;
! -- but this doesn't work
! -- try in this way
! select set_ttdummy(0);
!  set_ttdummy 
! -------------
!            1
! (1 row)
! 
! update tttest set price_on = -1 where price_id = 1;
! select * from tttest order by 1,2,3,4;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
!         1 |         1 |       -1 |    999999
!         3 |        30 |        0 |    999999
! (2 rows)
! 
! -- isn't it what we need ?
! -- get price for price_id == 5 as it was @ "date" 35
! select * from tttest where price_on <= 35 and price_off > 35 and price_id = 5 order by 1,2,3,4;
!  price_id | price_val | price_on | price_off 
! ----------+-----------+----------+-----------
! (0 rows)
! 
! drop table tttest;
! drop sequence ttdummy_seq;
! --
! -- tests for per-statement triggers
! --
! CREATE TABLE log_table (tstamp timestamp default timeofday()::timestamp);
! CREATE TABLE main_table (a int unique, b int);
! COPY main_table (a,b) FROM stdin;
! CREATE FUNCTION trigger_func() RETURNS trigger LANGUAGE plpgsql AS '
! BEGIN
! 	RAISE NOTICE ''trigger_func(%) called: action = %, when = %, level = %'', TG_ARGV[0], TG_OP, TG_WHEN, TG_LEVEL;
! 	RETURN NULL;
! END;';
! CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_ins_stmt');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_ins_stmt');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! --
! -- if neither 'FOR EACH ROW' nor 'FOR EACH STATEMENT' was specified,
! -- CREATE TRIGGER should default to 'FOR EACH STATEMENT'
! --
! CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_table
! EXECUTE PROCEDURE trigger_func('after_upd_stmt');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- Both insert and update statement level triggers (before and after) should
! -- fire.  Doesn't fire UPDATE before trigger, but only because one isn't
! -- defined.
! INSERT INTO main_table (a, b) VALUES (5, 10) ON CONFLICT (a)
!   DO UPDATE SET b = EXCLUDED.b;
! CREATE TRIGGER after_upd_row_trig AFTER UPDATE ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! INSERT INTO main_table DEFAULT VALUES;
! UPDATE main_table SET a = a + 1 WHERE b < 30;
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! -- UPDATE that effects zero rows should still call per-statement trigger
! UPDATE main_table SET a = a + 2 WHERE b > 100;
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! -- constraint now unneeded
! ALTER TABLE main_table DROP CONSTRAINT main_table_a_key;
! -- COPY should fire per-row and per-statement INSERT triggers
! COPY main_table (a, b) FROM stdin;
! SELECT * FROM main_table ORDER BY a, b;
!  a  | b  
! ----+----
!   5 | 10
!  20 | 20
!  30 | 10
!  30 | 40
!  50 | 35
!  50 | 60
!  80 | 15
!     |   
! (8 rows)
! 
! --
! -- test triggers with WHEN clause
! --
! CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table
! FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE trigger_func('modified_a');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER modified_any BEFORE UPDATE OF a ON main_table
! FOR EACH ROW WHEN (OLD.* IS DISTINCT FROM NEW.*) EXECUTE PROCEDURE trigger_func('modified_any');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER insert_a AFTER INSERT ON main_table
! FOR EACH ROW WHEN (NEW.a = 123) EXECUTE PROCEDURE trigger_func('insert_a');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER delete_a AFTER DELETE ON main_table
! FOR EACH ROW WHEN (OLD.a = 123) EXECUTE PROCEDURE trigger_func('delete_a');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER insert_when BEFORE INSERT ON main_table
! FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('insert_when');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER delete_when AFTER DELETE ON main_table
! FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('delete_when');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! INSERT INTO main_table (a) VALUES (123), (456);
! COPY main_table FROM stdin;
! DELETE FROM main_table WHERE a IN (123, 456);
! UPDATE main_table SET a = 50, b = 60;
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! SELECT * FROM main_table ORDER BY a, b;
!  a  | b  
! ----+----
!   5 | 10
!  20 | 20
!  30 | 10
!  30 | 40
!  50 | 35
!  50 | 60
!  80 | 15
!     |   
! (8 rows)
! 
! SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
!  pg_get_triggerdef 
! -------------------
! (0 rows)
! 
! SELECT pg_get_triggerdef(oid, false) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
!  pg_get_triggerdef 
! -------------------
! (0 rows)
! 
! SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_any';
!  pg_get_triggerdef 
! -------------------
! (0 rows)
! 
! DROP TRIGGER modified_a ON main_table;
! ERROR:  trigger "modified_a" for table "main_table" does not exist
! DROP TRIGGER modified_any ON main_table;
! ERROR:  trigger "modified_any" for table "main_table" does not exist
! DROP TRIGGER insert_a ON main_table;
! ERROR:  trigger "insert_a" for table "main_table" does not exist
! DROP TRIGGER delete_a ON main_table;
! ERROR:  trigger "delete_a" for table "main_table" does not exist
! DROP TRIGGER insert_when ON main_table;
! ERROR:  trigger "insert_when" for table "main_table" does not exist
! DROP TRIGGER delete_when ON main_table;
! ERROR:  trigger "delete_when" for table "main_table" does not exist
! -- Test column-level triggers
! DROP TRIGGER after_upd_row_trig ON main_table;
! ERROR:  trigger "after_upd_row_trig" for table "main_table" does not exist
! CREATE TRIGGER before_upd_a_row_trig BEFORE UPDATE OF a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_a_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER after_upd_b_row_trig AFTER UPDATE OF b ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_b_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER before_upd_a_stmt_trig BEFORE UPDATE OF a ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_upd_a_stmt');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER after_upd_b_stmt_trig AFTER UPDATE OF b ON main_table
! FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_upd_b_stmt');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! SELECT pg_get_triggerdef(oid) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'after_upd_a_b_row_trig';
!  pg_get_triggerdef 
! -------------------
! (0 rows)
! 
! UPDATE main_table SET a = 50;
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! UPDATE main_table SET b = 10;
! --
! -- Test case for bug with BEFORE trigger followed by AFTER trigger with WHEN
! --
! CREATE TABLE some_t (some_col boolean NOT NULL);
! CREATE FUNCTION dummy_update_func() RETURNS trigger AS $$
! BEGIN
!   RAISE NOTICE 'dummy_update_func(%) called: action = %, old = %, new = %',
!     TG_ARGV[0], TG_OP, OLD, NEW;
!   RETURN NEW;
! END;
! $$ LANGUAGE plpgsql;
! CREATE TRIGGER some_trig_before BEFORE UPDATE ON some_t FOR EACH ROW
!   EXECUTE PROCEDURE dummy_update_func('before');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER some_trig_aftera AFTER UPDATE ON some_t FOR EACH ROW
!   WHEN (NOT OLD.some_col AND NEW.some_col)
!   EXECUTE PROCEDURE dummy_update_func('aftera');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER some_trig_afterb AFTER UPDATE ON some_t FOR EACH ROW
!   WHEN (NOT NEW.some_col)
!   EXECUTE PROCEDURE dummy_update_func('afterb');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! INSERT INTO some_t VALUES (TRUE);
! UPDATE some_t SET some_col = TRUE;
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! UPDATE some_t SET some_col = FALSE;
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! UPDATE some_t SET some_col = TRUE;
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! DROP TABLE some_t;
! -- bogus cases
! CREATE TRIGGER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_and_col');
! ERROR:  duplicate trigger events specified at or near "ON"
! LINE 1: ...ER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_ta...
!                                                              ^
! CREATE TRIGGER error_upd_a_a BEFORE UPDATE OF a, a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_a_a');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_ins_a');
! ERROR:  syntax error at or near "OF"
! LINE 1: CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
!                                                  ^
! CREATE TRIGGER error_ins_when BEFORE INSERT OR UPDATE ON main_table
! FOR EACH ROW WHEN (OLD.a <> NEW.a)
! EXECUTE PROCEDURE trigger_func('error_ins_old');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER error_del_when BEFORE DELETE OR UPDATE ON main_table
! FOR EACH ROW WHEN (OLD.a <> NEW.a)
! EXECUTE PROCEDURE trigger_func('error_del_new');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER error_del_when BEFORE INSERT OR UPDATE ON main_table
! FOR EACH ROW WHEN (NEW.tableoid <> 0)
! EXECUTE PROCEDURE trigger_func('error_when_sys_column');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER error_stmt_when BEFORE UPDATE OF a ON main_table
! FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*)
! EXECUTE PROCEDURE trigger_func('error_stmt_when');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- check dependency restrictions
! ALTER TABLE main_table DROP COLUMN b;
! -- this should succeed, but we'll roll it back to keep the triggers around
! begin;
! DROP TRIGGER after_upd_a_b_row_trig ON main_table;
! ERROR:  trigger "after_upd_a_b_row_trig" for table "main_table" does not exist
! DROP TRIGGER after_upd_b_row_trig ON main_table;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! DROP TRIGGER after_upd_b_stmt_trig ON main_table;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ALTER TABLE main_table DROP COLUMN b;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! rollback;
! -- Test enable/disable triggers
! create table trigtest (i serial primary key);
! -- test that disabling RI triggers works
! create table trigtest2 (i int references trigtest(i) on delete cascade);
! create function trigtest() returns trigger as $$
! begin
! 	raise notice '% % % %', TG_RELNAME, TG_OP, TG_WHEN, TG_LEVEL;
! 	return new;
! end;$$ language plpgsql;
! create trigger trigtest_b_row_tg before insert or update or delete on trigtest
! for each row execute procedure trigtest();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trigtest_a_row_tg after insert or update or delete on trigtest
! for each row execute procedure trigtest();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trigtest_b_stmt_tg before insert or update or delete on trigtest
! for each statement execute procedure trigtest();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trigtest_a_stmt_tg after insert or update or delete on trigtest
! for each statement execute procedure trigtest();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! insert into trigtest default values;
! alter table trigtest disable trigger trigtest_b_row_tg;
! ERROR:  trigger "trigtest_b_row_tg" for table "trigtest" does not exist
! insert into trigtest default values;
! alter table trigtest disable trigger user;
! insert into trigtest default values;
! alter table trigtest enable trigger trigtest_a_stmt_tg;
! ERROR:  trigger "trigtest_a_stmt_tg" for table "trigtest" does not exist
! insert into trigtest default values;
! insert into trigtest2 values(1);
! insert into trigtest2 values(2);
! delete from trigtest where i=2;
! select * from trigtest2 order by 1;
!  i 
! ---
!  1
! (1 row)
! 
! alter table trigtest disable trigger all;
! delete from trigtest where i=1;
! select * from trigtest2 order by 1;
!  i 
! ---
!  1
! (1 row)
! 
! -- ensure we still insert, even when all triggers are disabled
! insert into trigtest default values;
! select *  from trigtest order by 1;
!  i 
! ---
!  3
!  4
!  5
! (3 rows)
! 
! drop table trigtest2;
! drop table trigtest;
! -- dump trigger data
! CREATE TABLE trigger_test (
!         i int,
!         v varchar
! );
! CREATE OR REPLACE FUNCTION trigger_data()  RETURNS trigger
! LANGUAGE plpgsql AS $$
! 
! declare
! 
! 	argstr text;
! 	relid text;
! 
! begin
! 
! 	relid := TG_relid::regclass;
! 
! 	-- plpgsql can't discover its trigger data in a hash like perl and python
! 	-- can, or by a sort of reflection like tcl can,
! 	-- so we have to hard code the names.
! 	raise NOTICE 'TG_NAME: %', TG_name;
! 	raise NOTICE 'TG_WHEN: %', TG_when;
! 	raise NOTICE 'TG_LEVEL: %', TG_level;
! 	raise NOTICE 'TG_OP: %', TG_op;
! 	raise NOTICE 'TG_RELID::regclass: %', relid;
! 	raise NOTICE 'TG_RELNAME: %', TG_relname;
! 	raise NOTICE 'TG_TABLE_NAME: %', TG_table_name;
! 	raise NOTICE 'TG_TABLE_SCHEMA: %', TG_table_schema;
! 	raise NOTICE 'TG_NARGS: %', TG_nargs;
! 
! 	argstr := '[';
! 	for i in 0 .. TG_nargs - 1 loop
! 		if i > 0 then
! 			argstr := argstr || ', ';
! 		end if;
! 		argstr := argstr || TG_argv[i];
! 	end loop;
! 	argstr := argstr || ']';
! 	raise NOTICE 'TG_ARGV: %', argstr;
! 
! 	if TG_OP != 'INSERT' then
! 		raise NOTICE 'OLD: %', OLD;
! 	end if;
! 
! 	if TG_OP != 'DELETE' then
! 		raise NOTICE 'NEW: %', NEW;
! 	end if;
! 
! 	if TG_OP = 'DELETE' then
! 		return OLD;
! 	else
! 		return NEW;
! 	end if;
! 
! end;
! $$;
! CREATE TRIGGER show_trigger_data_trig
! BEFORE INSERT OR UPDATE OR DELETE ON trigger_test
! FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! insert into trigger_test values(1,'insert');
! update trigger_test set v = 'update' where i = 1;
! delete from trigger_test;
! DROP TRIGGER show_trigger_data_trig on trigger_test;
! ERROR:  trigger "show_trigger_data_trig" for table "trigger_test" does not exist
! DROP FUNCTION trigger_data();
! DROP TABLE trigger_test;
! --
! -- Test use of row comparisons on OLD/NEW
! --
! CREATE TABLE trigger_test (f1 int, f2 text, f3 text);
! -- this is the obvious (and wrong...) way to compare rows
! CREATE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$
! begin
! 	if row(old.*) = row(new.*) then
! 		raise notice 'row % not changed', new.f1;
! 	else
! 		raise notice 'row % changed', new.f1;
! 	end if;
! 	return new;
! end$$;
! CREATE TRIGGER t
! BEFORE UPDATE ON trigger_test
! FOR EACH ROW EXECUTE PROCEDURE mytrigger();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! INSERT INTO trigger_test VALUES(1, 'foo', 'bar');
! INSERT INTO trigger_test VALUES(2, 'baz', 'quux');
! UPDATE trigger_test SET f3 = 'bar';
! UPDATE trigger_test SET f3 = NULL;
! -- this demonstrates that the above isn't really working as desired:
! UPDATE trigger_test SET f3 = NULL;
! -- the right way when considering nulls is
! CREATE OR REPLACE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$
! begin
! 	if row(old.*) is distinct from row(new.*) then
! 		raise notice 'row % changed', new.f1;
! 	else
! 		raise notice 'row % not changed', new.f1;
! 	end if;
! 	return new;
! end$$;
! UPDATE trigger_test SET f3 = 'bar';
! UPDATE trigger_test SET f3 = NULL;
! UPDATE trigger_test SET f3 = NULL;
! DROP TABLE trigger_test;
! DROP FUNCTION mytrigger();
! -- Test snapshot management in serializable transactions involving triggers
! -- per bug report in 6bc73d4c0910042358k3d1adff3qa36f8df75198ecea@mail.gmail.com
! CREATE FUNCTION serializable_update_trig() RETURNS trigger LANGUAGE plpgsql AS
! $$
! declare
! 	rec record;
! begin
! 	new.description = 'updated in trigger';
! 	return new;
! end;
! $$;
! CREATE TABLE serializable_update_tab (
! 	id int,
! 	filler  text,
! 	description text
! );
! CREATE TRIGGER serializable_update_trig BEFORE UPDATE ON serializable_update_tab
! 	FOR EACH ROW EXECUTE PROCEDURE serializable_update_trig();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! INSERT INTO serializable_update_tab SELECT a, repeat('xyzxz', 100), 'new'
! 	FROM generate_series(1, 50) a;
! BEGIN;
! SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! UPDATE serializable_update_tab SET description = 'no no', id = 1 WHERE id = 1;
! COMMIT;
! SELECT description FROM serializable_update_tab WHERE id = 1;
!  description 
! -------------
!  no no
! (1 row)
! 
! DROP TABLE serializable_update_tab;
! -- minimal update trigger
! CREATE TABLE min_updates_test (
! 	f1	text,
! 	f2 int,
! 	f3 int);
! CREATE TABLE min_updates_test_oids (
! 	f1	text,
! 	f2 int,
! 	f3 int) WITH OIDS;
! INSERT INTO min_updates_test VALUES ('a',1,2),('b','2',null);
! INSERT INTO min_updates_test_oids VALUES ('a',1,2),('b','2',null);
! CREATE TRIGGER z_min_update
! BEFORE UPDATE ON min_updates_test
! FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER z_min_update
! BEFORE UPDATE ON min_updates_test_oids
! FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! \set QUIET false
! UPDATE min_updates_test SET f1 = f1;
! UPDATE 2
! UPDATE min_updates_test SET f2 = f2 + 1;
! UPDATE 2
! UPDATE min_updates_test SET f3 = 2 WHERE f3 is null;
! UPDATE 1
! UPDATE min_updates_test_oids SET f1 = f1;
! UPDATE 2
! UPDATE min_updates_test_oids SET f2 = f2 + 1;
! UPDATE 2
! UPDATE min_updates_test_oids SET f3 = 2 WHERE f3 is null;
! UPDATE 1
! \set QUIET true
! SELECT * FROM min_updates_test ORDER BY 1,2,3;
!  f1 | f2 | f3 
! ----+----+----
!  a  |  2 |  2
!  b  |  3 |  2
! (2 rows)
! 
! SELECT * FROM min_updates_test_oids ORDER BY 1,2,3;
!  f1 | f2 | f3 
! ----+----+----
!  a  |  2 |  2
!  b  |  3 |  2
! (2 rows)
! 
! DROP TABLE min_updates_test;
! DROP TABLE min_updates_test_oids;
! --
! -- Test triggers on views
! --
! CREATE VIEW main_view AS SELECT a, b FROM main_table;
! ERROR:  column "b" does not exist
! LINE 1: CREATE VIEW main_view AS SELECT a, b FROM main_table;
!                                            ^
! -- VIEW trigger function
! CREATE OR REPLACE FUNCTION view_trigger() RETURNS trigger
! LANGUAGE plpgsql AS $$
! declare
!     argstr text := '';
! begin
!     for i in 0 .. TG_nargs - 1 loop
!         if i > 0 then
!             argstr := argstr || ', ';
!         end if;
!         argstr := argstr || TG_argv[i];
!     end loop;
! 
!     raise notice '% % % % (%)', TG_RELNAME, TG_WHEN, TG_OP, TG_LEVEL, argstr;
! 
!     if TG_LEVEL = 'ROW' then
!         if TG_OP = 'INSERT' then
!             raise NOTICE 'NEW: %', NEW;
!             INSERT INTO main_table VALUES (NEW.a, NEW.b);
!             RETURN NEW;
!         end if;
! 
!         if TG_OP = 'UPDATE' then
!             raise NOTICE 'OLD: %, NEW: %', OLD, NEW;
!             UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b;
!             if NOT FOUND then RETURN NULL; end if;
!             RETURN NEW;
!         end if;
! 
!         if TG_OP = 'DELETE' then
!             raise NOTICE 'OLD: %', OLD;
!             DELETE FROM main_table WHERE a = OLD.a AND b = OLD.b;
!             if NOT FOUND then RETURN NULL; end if;
!             RETURN OLD;
!         end if;
!     end if;
! 
!     RETURN NULL;
! end;
! $$;
! -- Before row triggers aren't allowed on views
! CREATE TRIGGER invalid_trig BEFORE INSERT ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER invalid_trig BEFORE UPDATE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER invalid_trig BEFORE DELETE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- After row triggers aren't allowed on views
! CREATE TRIGGER invalid_trig AFTER INSERT ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER invalid_trig AFTER UPDATE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER invalid_trig AFTER DELETE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- Truncate triggers aren't allowed on views
! CREATE TRIGGER invalid_trig BEFORE TRUNCATE ON main_view
! EXECUTE PROCEDURE trigger_func('before_tru_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER invalid_trig AFTER TRUNCATE ON main_view
! EXECUTE PROCEDURE trigger_func('before_tru_row');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- INSTEAD OF triggers aren't allowed on tables
! CREATE TRIGGER invalid_trig INSTEAD OF INSERT ON main_table
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_table
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER invalid_trig INSTEAD OF DELETE ON main_table
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- Don't support WHEN clauses with INSTEAD OF triggers
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
! FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- Don't support column-level INSTEAD OF triggers
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE OF a ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- Don't support statement-level INSTEAD OF triggers
! CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
! EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- Valid INSTEAD OF triggers
! CREATE TRIGGER instead_of_insert_trig INSTEAD OF INSERT ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER instead_of_update_trig INSTEAD OF UPDATE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER instead_of_delete_trig INSTEAD OF DELETE ON main_view
! FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- Valid BEFORE statement VIEW triggers
! CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_ins_stmt');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER before_upd_stmt_trig BEFORE UPDATE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_upd_stmt');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER before_del_stmt_trig BEFORE DELETE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_del_stmt');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- Valid AFTER statement VIEW triggers
! CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_ins_stmt');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_upd_stmt');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE TRIGGER after_del_stmt_trig AFTER DELETE ON main_view
! FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_del_stmt');
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! \set QUIET false
! -- Insert into view using trigger
! INSERT INTO main_view VALUES (20, 30);
! ERROR:  relation "main_view" does not exist
! LINE 1: INSERT INTO main_view VALUES (20, 30);
!                     ^
! INSERT INTO main_view VALUES (21, 31) RETURNING a, b;
! ERROR:  relation "main_view" does not exist
! LINE 1: INSERT INTO main_view VALUES (21, 31) RETURNING a, b;
!                     ^
! -- Table trigger will prevent updates
! UPDATE main_view SET b = 31 WHERE a = 20;
! ERROR:  relation "main_view" does not exist
! LINE 1: UPDATE main_view SET b = 31 WHERE a = 20;
!                ^
! UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
! ERROR:  relation "main_view" does not exist
! LINE 1: UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNIN...
!                ^
! -- Remove table trigger to allow updates
! DROP TRIGGER before_upd_a_row_trig ON main_table;
! ERROR:  trigger "before_upd_a_row_trig" for table "main_table" does not exist
! UPDATE main_view SET b = 31 WHERE a = 20;
! ERROR:  relation "main_view" does not exist
! LINE 1: UPDATE main_view SET b = 31 WHERE a = 20;
!                ^
! UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
! ERROR:  relation "main_view" does not exist
! LINE 1: UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNIN...
!                ^
! -- Before and after stmt triggers should fire even when no rows are affected
! UPDATE main_view SET b = 0 WHERE false;
! ERROR:  relation "main_view" does not exist
! LINE 1: UPDATE main_view SET b = 0 WHERE false;
!                ^
! -- Delete from view using trigger
! DELETE FROM main_view WHERE a IN (20,21);
! ERROR:  relation "main_view" does not exist
! LINE 1: DELETE FROM main_view WHERE a IN (20,21);
!                     ^
! DELETE FROM main_view WHERE a = 31 RETURNING a, b;
! ERROR:  relation "main_view" does not exist
! LINE 1: DELETE FROM main_view WHERE a = 31 RETURNING a, b;
!                     ^
! \set QUIET true
! -- Describe view should list triggers
! \d main_view
! -- Test dropping view triggers
! DROP TRIGGER instead_of_insert_trig ON main_view;
! ERROR:  relation "main_view" does not exist
! DROP TRIGGER instead_of_delete_trig ON main_view;
! ERROR:  relation "main_view" does not exist
! \d+ main_view
! DROP VIEW main_view;
! ERROR:  view "main_view" does not exist
! --
! -- Test triggers on a join view
! --
! CREATE TABLE country_table (
!     country_id        serial primary key,
!     country_name    text unique not null,
!     continent        text not null
! );
! INSERT INTO country_table (country_name, continent)
!     VALUES ('Japan', 'Asia'),
!            ('UK', 'Europe'),
!            ('USA', 'North America')
!     RETURNING *;
!  country_id | country_name |   continent   
! ------------+--------------+---------------
!           1 | Japan        | Asia
!           2 | UK           | Europe
!           3 | USA          | North America
! (3 rows)
! 
! CREATE TABLE city_table (
!     city_id        serial primary key,
!     city_name    text not null,
!     population    bigint,
!     country_id    int references country_table
! );
! CREATE VIEW city_view AS
!     SELECT city_id, city_name, population, country_name, continent
!     FROM city_table ci
!     LEFT JOIN country_table co ON co.country_id = ci.country_id;
! CREATE FUNCTION city_insert() RETURNS trigger LANGUAGE plpgsql AS $$
! declare
!     ctry_id int;
! begin
!     if NEW.country_name IS NOT NULL then
!         SELECT country_id, continent INTO ctry_id, NEW.continent
!             FROM country_table WHERE country_name = NEW.country_name;
!         if NOT FOUND then
!             raise exception 'No such country: "%"', NEW.country_name;
!         end if;
!     else
!         NEW.continent := NULL;
!     end if;
! 
!     if NEW.city_id IS NOT NULL then
!         INSERT INTO city_table
!             VALUES(NEW.city_id, NEW.city_name, NEW.population, ctry_id);
!     else
!         INSERT INTO city_table(city_name, population, country_id)
!             VALUES(NEW.city_name, NEW.population, ctry_id)
!             RETURNING city_id INTO NEW.city_id;
!     end if;
! 
!     RETURN NEW;
! end;
! $$;
! CREATE TRIGGER city_insert_trig INSTEAD OF INSERT ON city_view
! FOR EACH ROW EXECUTE PROCEDURE city_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE FUNCTION city_delete() RETURNS trigger LANGUAGE plpgsql AS $$
! begin
!     DELETE FROM city_table WHERE city_id = OLD.city_id;
!     if NOT FOUND then RETURN NULL; end if;
!     RETURN OLD;
! end;
! $$;
! CREATE TRIGGER city_delete_trig INSTEAD OF DELETE ON city_view
! FOR EACH ROW EXECUTE PROCEDURE city_delete();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE FUNCTION city_update() RETURNS trigger LANGUAGE plpgsql AS $$
! declare
!     ctry_id int;
! begin
!     if NEW.country_name IS DISTINCT FROM OLD.country_name then
!         SELECT country_id, continent INTO ctry_id, NEW.continent
!             FROM country_table WHERE country_name = NEW.country_name;
!         if NOT FOUND then
!             raise exception 'No such country: "%"', NEW.country_name;
!         end if;
! 
!         UPDATE city_table SET city_name = NEW.city_name,
!                               population = NEW.population,
!                               country_id = ctry_id
!             WHERE city_id = OLD.city_id;
!     else
!         UPDATE city_table SET city_name = NEW.city_name,
!                               population = NEW.population
!             WHERE city_id = OLD.city_id;
!         NEW.continent := OLD.continent;
!     end if;
! 
!     if NOT FOUND then RETURN NULL; end if;
!     RETURN NEW;
! end;
! $$;
! CREATE TRIGGER city_update_trig INSTEAD OF UPDATE ON city_view
! FOR EACH ROW EXECUTE PROCEDURE city_update();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! \set QUIET false
! -- INSERT .. RETURNING
! INSERT INTO city_view(city_name) VALUES('Tokyo') RETURNING *;
! ERROR:  cannot insert into view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! INSERT INTO city_view(city_name, population) VALUES('London', 7556900) RETURNING *;
! ERROR:  cannot insert into view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! INSERT INTO city_view(city_name, country_name) VALUES('Washington DC', 'USA') RETURNING *;
! ERROR:  cannot insert into view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! INSERT INTO city_view(city_id, city_name) VALUES(123456, 'New York') RETURNING *;
! ERROR:  cannot insert into view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! INSERT INTO city_view VALUES(234567, 'Birmingham', 1016800, 'UK', 'EU') RETURNING *;
! ERROR:  cannot insert into view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! -- UPDATE .. RETURNING
! UPDATE city_view SET country_name = 'Japon' WHERE city_name = 'Tokyo'; -- error
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Takyo'; -- no match
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Tokyo' RETURNING *; -- OK
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE city_view SET population = 13010279 WHERE city_name = 'Tokyo' RETURNING *;
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE city_view SET country_name = 'UK' WHERE city_name = 'New York' RETURNING *;
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE city_view SET country_name = 'USA', population = 8391881 WHERE city_name = 'New York' RETURNING *;
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE city_view SET continent = 'EU' WHERE continent = 'Europe' RETURNING *;
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE city_view v1 SET country_name = v2.country_name FROM city_view v2
!     WHERE v2.city_name = 'Birmingham' AND v1.city_name = 'London' RETURNING *;
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! -- DELETE .. RETURNING
! DELETE FROM city_view WHERE city_name = 'Birmingham' RETURNING *;
! ERROR:  cannot delete from view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! \set QUIET true
! -- read-only view with WHERE clause
! CREATE VIEW european_city_view AS
!     SELECT * FROM city_view WHERE continent = 'Europe';
! SELECT count(*) FROM european_city_view;
!  count 
! -------
!      0
! (1 row)
! 
! CREATE FUNCTION no_op_trig_fn() RETURNS trigger LANGUAGE plpgsql
! AS 'begin RETURN NULL; end';
! CREATE TRIGGER no_op_trig INSTEAD OF INSERT OR UPDATE OR DELETE
! ON european_city_view FOR EACH ROW EXECUTE PROCEDURE no_op_trig_fn();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! \set QUIET false
! INSERT INTO european_city_view VALUES (0, 'x', 10000, 'y', 'z');
! ERROR:  cannot insert into view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! UPDATE european_city_view SET population = 10000;
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! DELETE FROM european_city_view;
! ERROR:  cannot delete from view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! \set QUIET true
! -- rules bypassing no-op triggers
! CREATE RULE european_city_insert_rule AS ON INSERT TO european_city_view
! DO INSTEAD INSERT INTO city_view
! VALUES (NEW.city_id, NEW.city_name, NEW.population, NEW.country_name, NEW.continent)
! RETURNING *;
! CREATE RULE european_city_update_rule AS ON UPDATE TO european_city_view
! DO INSTEAD UPDATE city_view SET
!     city_name = NEW.city_name,
!     population = NEW.population,
!     country_name = NEW.country_name
! WHERE city_id = OLD.city_id
! RETURNING NEW.*;
! CREATE RULE european_city_delete_rule AS ON DELETE TO european_city_view
! DO INSTEAD DELETE FROM city_view WHERE city_id = OLD.city_id RETURNING *;
! \set QUIET false
! -- INSERT not limited by view's WHERE clause, but UPDATE AND DELETE are
! INSERT INTO european_city_view(city_name, country_name)
!     VALUES ('Cambridge', 'USA') RETURNING *;
! ERROR:  cannot insert into view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! UPDATE european_city_view SET country_name = 'UK'
!     WHERE city_name = 'Cambridge';
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! DELETE FROM european_city_view WHERE city_name = 'Cambridge';
! ERROR:  cannot delete from view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! -- UPDATE and DELETE via rule and trigger
! UPDATE city_view SET country_name = 'UK'
!     WHERE city_name = 'Cambridge' RETURNING *;
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE european_city_view SET population = 122800
!     WHERE city_name = 'Cambridge' RETURNING *;
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! DELETE FROM european_city_view WHERE city_name = 'Cambridge' RETURNING *;
! ERROR:  cannot delete from view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! -- join UPDATE test
! UPDATE city_view v SET population = 599657
!     FROM city_table ci, country_table co
!     WHERE ci.city_name = 'Washington DC' and co.country_name = 'USA'
!     AND v.city_id = ci.city_id AND v.country_name = co.country_name
!     RETURNING co.country_id, v.country_name,
!               v.city_id, v.city_name, v.population;
! ERROR:  cannot update view "city_view"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! \set QUIET true
! SELECT * FROM city_view;
!  city_id | city_name | population | country_name | continent 
! ---------+-----------+------------+--------------+-----------
! (0 rows)
! 
! DROP TABLE city_table CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view city_view
! drop cascades to view european_city_view
! DROP TABLE country_table;
! -- Test pg_trigger_depth()
! create table depth_a (id int not null primary key);
! create table depth_b (id int not null primary key);
! create table depth_c (id int not null primary key);
! create function depth_a_tf() returns trigger
!   language plpgsql as $$
! begin
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   insert into depth_b values (new.id);
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   return new;
! end;
! $$;
! create trigger depth_a_tr before insert on depth_a
!   for each row execute procedure depth_a_tf();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create function depth_b_tf() returns trigger
!   language plpgsql as $$
! begin
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   begin
!     execute 'insert into depth_c values (' || new.id::text || ')';
!   exception
!     when sqlstate 'U9999' then
!       raise notice 'SQLSTATE = U9999: depth = %', pg_trigger_depth();
!   end;
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   if new.id = 1 then
!     execute 'insert into depth_c values (' || new.id::text || ')';
!   end if;
!   return new;
! end;
! $$;
! create trigger depth_b_tr before insert on depth_b
!   for each row execute procedure depth_b_tf();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create function depth_c_tf() returns trigger
!   language plpgsql as $$
! begin
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   if new.id = 1 then
!     raise exception sqlstate 'U9999';
!   end if;
!   raise notice '%: depth = %', tg_name, pg_trigger_depth();
!   return new;
! end;
! $$;
! create trigger depth_c_tr before insert on depth_c
!   for each row execute procedure depth_c_tf();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! select pg_trigger_depth();
!  pg_trigger_depth 
! ------------------
!                 0
! (1 row)
! 
! insert into depth_a values (1);
! select pg_trigger_depth();
!  pg_trigger_depth 
! ------------------
!                 0
! (1 row)
! 
! insert into depth_a values (2);
! select pg_trigger_depth();
!  pg_trigger_depth 
! ------------------
!                 0
! (1 row)
! 
! drop table depth_a, depth_b, depth_c;
! drop function depth_a_tf();
! drop function depth_b_tf();
! drop function depth_c_tf();
! --
! -- Test updates to rows during firing of BEFORE ROW triggers.
! -- As of 9.2, such cases should be rejected (see bug #6123).
! --
! create temp table parent (
!     aid int not null primary key,
!     val1 text,
!     val2 text,
!     val3 text,
!     val4 text,
!     bcnt int not null default 0);
! create temp table child (
!     bid int not null primary key,
!     aid int not null,
!     val1 text);
! create function parent_upd_func()
!   returns trigger language plpgsql as
! $$
! begin
!   if old.val1 <> new.val1 then
!     new.val2 = new.val1;
!     delete from child where child.aid = new.aid and child.val1 = new.val1;
!   end if;
!   return new;
! end;
! $$;
! create trigger parent_upd_trig before update on parent
!   for each row execute procedure parent_upd_func();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create function parent_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   delete from child where aid = old.aid;
!   return old;
! end;
! $$;
! create trigger parent_del_trig before delete on parent
!   for each row execute procedure parent_del_func();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create function child_ins_func()
!   returns trigger language plpgsql as
! $$
! begin
!   update parent set bcnt = bcnt + 1 where aid = new.aid;
!   return new;
! end;
! $$;
! create trigger child_ins_trig after insert on child
!   for each row execute procedure child_ins_func();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create function child_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   update parent set bcnt = bcnt - 1 where aid = old.aid;
!   return old;
! end;
! $$;
! create trigger child_del_trig after delete on child
!   for each row execute procedure child_del_func();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! insert into parent values (1, 'a', 'a', 'a', 'a', 0);
! insert into child values (10, 1, 'b');
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
!    1 | a    | a    | a    | a    |    0
! (1 row)
! 
!  bid | aid | val1 
! -----+-----+------
!   10 |   1 | b
! (1 row)
! 
! update parent set val1 = 'b' where aid = 1; -- should fail
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
!    1 | b    | a    | a    | a    |    0
! (1 row)
! 
!  bid | aid | val1 
! -----+-----+------
!   10 |   1 | b
! (1 row)
! 
! delete from parent where aid = 1; -- should fail
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
! (0 rows)
! 
!  bid | aid | val1 
! -----+-----+------
!   10 |   1 | b
! (1 row)
! 
! -- replace the trigger function with one that restarts the deletion after
! -- having modified a child
! create or replace function parent_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   delete from child where aid = old.aid;
!   if found then
!     delete from parent where aid = old.aid;
!     return null; -- cancel outer deletion
!   end if;
!   return old;
! end;
! $$;
! delete from parent where aid = 1;
! select * from parent; select * from child;
!  aid | val1 | val2 | val3 | val4 | bcnt 
! -----+------+------+------+------+------
! (0 rows)
! 
!  bid | aid | val1 
! -----+-----+------
!   10 |   1 | b
! (1 row)
! 
! drop table parent, child;
! drop function parent_upd_func();
! drop function parent_del_func();
! drop function child_ins_func();
! drop function child_del_func();
! -- similar case, but with a self-referencing FK so that parent and child
! -- rows can be affected by a single operation
! create temp table self_ref_trigger (
!     id int primary key,
!     parent int references self_ref_trigger,
!     data text,
!     nchildren int not null default 0
! );
! create function self_ref_trigger_ins_func()
!   returns trigger language plpgsql as
! $$
! begin
!   if new.parent is not null then
!     update self_ref_trigger set nchildren = nchildren + 1
!       where id = new.parent;
!   end if;
!   return new;
! end;
! $$;
! create trigger self_ref_trigger_ins_trig before insert on self_ref_trigger
!   for each row execute procedure self_ref_trigger_ins_func();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create function self_ref_trigger_del_func()
!   returns trigger language plpgsql as
! $$
! begin
!   if old.parent is not null then
!     update self_ref_trigger set nchildren = nchildren - 1
!       where id = old.parent;
!   end if;
!   return old;
! end;
! $$;
! create trigger self_ref_trigger_del_trig before delete on self_ref_trigger
!   for each row execute procedure self_ref_trigger_del_func();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! insert into self_ref_trigger values (1, null, 'root');
! insert into self_ref_trigger values (2, 1, 'root child A');
! insert into self_ref_trigger values (3, 1, 'root child B');
! ERROR:  insert or update on table "self_ref_trigger" violates foreign key constraint "self_ref_trigger_parent_fkey"
! DETAIL:  Key (parent)=(1) is not present in table "self_ref_trigger".
! insert into self_ref_trigger values (4, 2, 'grandchild 1');
! ERROR:  insert or update on table "self_ref_trigger" violates foreign key constraint "self_ref_trigger_parent_fkey"
! DETAIL:  Key (parent)=(2) is not present in table "self_ref_trigger".
! insert into self_ref_trigger values (5, 3, 'grandchild 2');
! ERROR:  insert or update on table "self_ref_trigger" violates foreign key constraint "self_ref_trigger_parent_fkey"
! DETAIL:  Key (parent)=(3) is not present in table "self_ref_trigger".
! update self_ref_trigger set data = 'root!' where id = 1;
! select * from self_ref_trigger;
!  id | parent |     data     | nchildren 
! ----+--------+--------------+-----------
!   2 |      1 | root child A |         0
!   1 |        | root!        |         0
! (2 rows)
! 
! delete from self_ref_trigger;
! select * from self_ref_trigger;
!  id | parent | data | nchildren 
! ----+--------+------+-----------
! (0 rows)
! 
! drop table self_ref_trigger;
! drop function self_ref_trigger_ins_func();
! drop function self_ref_trigger_del_func();
! --
! -- Check that index creation (or DDL in general) is prohibited in a trigger
! --
! create table trigger_ddl_table (
!    col1 integer,
!    col2 integer
! );
! create function trigger_ddl_func() returns trigger as $$
! begin
!   alter table trigger_ddl_table add primary key (col1);
!   return new;
! end$$ language plpgsql;
! create trigger trigger_ddl_func before insert on trigger_ddl_table for each row
!   execute procedure trigger_ddl_func();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! insert into trigger_ddl_table values (1, 42);  -- fail
! create or replace function trigger_ddl_func() returns trigger as $$
! begin
!   create index on trigger_ddl_table (col2);
!   return new;
! end$$ language plpgsql;
! insert into trigger_ddl_table values (1, 42);  -- fail
! drop table trigger_ddl_table;
! drop function trigger_ddl_func();
! --
! -- Verify behavior of before and after triggers with INSERT...ON CONFLICT
! -- DO UPDATE
! --
! create table upsert (key int4 primary key, color text);
! create function upsert_before_func()
!   returns trigger language plpgsql as
! $$
! begin
!   if (TG_OP = 'UPDATE') then
!     raise warning 'before update (old): %', old.*::text;
!     raise warning 'before update (new): %', new.*::text;
!   elsif (TG_OP = 'INSERT') then
!     raise warning 'before insert (new): %', new.*::text;
!     if new.key % 2 = 0 then
!       new.key := new.key + 1;
!       new.color := new.color || ' trig modified';
!       raise warning 'before insert (new, modified): %', new.*::text;
!     end if;
!   end if;
!   return new;
! end;
! $$;
! create trigger upsert_before_trig before insert or update on upsert
!   for each row execute procedure upsert_before_func();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create function upsert_after_func()
!   returns trigger language plpgsql as
! $$
! begin
!   if (TG_OP = 'UPDATE') then
!     raise warning 'after update (old): %', old.*::text;
!     raise warning 'after update (new): %', new.*::text;
!   elsif (TG_OP = 'INSERT') then
!     raise warning 'after insert (new): %', new.*::text;
!   end if;
!   return null;
! end;
! $$;
! create trigger upsert_after_trig after insert or update on upsert
!   for each row execute procedure upsert_after_func();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! insert into upsert values(1, 'black') on conflict (key) do update set color = 'updated ' || upsert.color;
! insert into upsert values(2, 'red') on conflict (key) do update set color = 'updated ' || upsert.color;
! insert into upsert values(3, 'orange') on conflict (key) do update set color = 'updated ' || upsert.color;
! insert into upsert values(4, 'green') on conflict (key) do update set color = 'updated ' || upsert.color;
! insert into upsert values(5, 'purple') on conflict (key) do update set color = 'updated ' || upsert.color;
! insert into upsert values(6, 'white') on conflict (key) do update set color = 'updated ' || upsert.color;
! insert into upsert values(7, 'pink') on conflict (key) do update set color = 'updated ' || upsert.color;
! insert into upsert values(8, 'yellow') on conflict (key) do update set color = 'updated ' || upsert.color;
! select * from upsert;
!  key | color  
! -----+--------
!    1 | black
!    2 | red
!    5 | purple
!    6 | white
!    8 | yellow
!    3 | orange
!    4 | green
!    7 | pink
! (8 rows)
! 
! drop table upsert;
! drop function upsert_before_func();
! drop function upsert_after_func();
! --
! -- Verify that triggers with transition tables are not allowed on
! -- views
! --
! create table my_table (i int);
! create view my_view as select * from my_table;
! create function my_trigger_function() returns trigger as $$ begin end; $$ language plpgsql;
! create trigger my_trigger after update on my_view referencing old table as old_table
!    for each statement execute procedure my_trigger_function();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! drop function my_trigger_function();
! drop view my_view;
! drop table my_table;
! --
! -- Verify that per-statement triggers are fired for partitioned tables
! --
! create table parted_stmt_trig (a int) partition by list (a);
! create table parted_stmt_trig1 partition of parted_stmt_trig for values in (1);
! create table parted_stmt_trig2 partition of parted_stmt_trig for values in (2);
! create table parted2_stmt_trig (a int) partition by list (a);
! create table parted2_stmt_trig1 partition of parted2_stmt_trig for values in (1);
! create table parted2_stmt_trig2 partition of parted2_stmt_trig for values in (2);
! create or replace function trigger_notice() returns trigger as $$
!   begin
!     raise notice 'trigger on % % % for %', TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL;
!     if TG_LEVEL = 'ROW' then
!        return NEW;
!     end if;
!     return null;
!   end;
!   $$ language plpgsql;
! -- insert/update/delete statment-level triggers on the parent
! create trigger trig_ins_before before insert on parted_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_ins_after after insert on parted_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_upd_before before update on parted_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_upd_after after update on parted_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_del_before before delete on parted_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_del_after after delete on parted_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- insert/update/delete row-level triggers on the first partition
! create trigger trig_ins_before before insert on parted_stmt_trig1
!   for each row execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_ins_after after insert on parted_stmt_trig1
!   for each row execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_upd_before before update on parted_stmt_trig1
!   for each row execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_upd_after after update on parted_stmt_trig1
!   for each row execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- insert/update/delete statement-level triggers on the parent
! create trigger trig_ins_before before insert on parted2_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_ins_after after insert on parted2_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_upd_before before update on parted2_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_upd_after after update on parted2_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_del_before before delete on parted2_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger trig_del_after after delete on parted2_stmt_trig
!   for each statement execute procedure trigger_notice();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! with ins (a) as (
!   insert into parted2_stmt_trig values (1), (2) returning a
! ) insert into parted_stmt_trig select a from ins returning tableoid::regclass, a;
! ERROR:  INSERT/UPDATE/DELETE is not supported in subquery
! with upd as (
!   update parted2_stmt_trig set a = a
! ) update parted_stmt_trig  set a = a;
! ERROR:  INSERT/UPDATE/DELETE is not supported in subquery
! delete from parted_stmt_trig;
! -- insert via copy on the parent
! copy parted_stmt_trig(a) from stdin;
! -- insert via copy on the first partition
! copy parted_stmt_trig1(a) from stdin;
! drop table parted_stmt_trig, parted2_stmt_trig;
! --
! -- Test the interaction between transition tables and both kinds of
! -- inheritance.  We'll dump the contents of the transition tables in a
! -- format that shows the attribute order, so that we can distinguish
! -- tuple formats (though not dropped attributes).
! --
! create or replace function dump_insert() returns trigger language plpgsql as
! $$
!   begin
!     raise notice 'trigger = %, new table = %',
!                  TG_NAME,
!                  (select string_agg(new_table::text, ', ' order by a) from new_table);
!     return null;
!   end;
! $$;
! create or replace function dump_update() returns trigger language plpgsql as
! $$
!   begin
!     raise notice 'trigger = %, old table = %, new table = %',
!                  TG_NAME,
!                  (select string_agg(old_table::text, ', ' order by a) from old_table),
!                  (select string_agg(new_table::text, ', ' order by a) from new_table);
!     return null;
!   end;
! $$;
! create or replace function dump_delete() returns trigger language plpgsql as
! $$
!   begin
!     raise notice 'trigger = %, old table = %',
!                  TG_NAME,
!                  (select string_agg(old_table::text, ', ' order by a) from old_table);
!     return null;
!   end;
! $$;
! --
! -- Verify behavior of statement triggers on partition hierarchy with
! -- transition tables.  Tuples should appear to each trigger in the
! -- format of the the relation the trigger is attached to.
! --
! -- set up a partition hierarchy with some different TupleDescriptors
! create table parent (a text, b int) partition by list (a);
! -- a child matching parent
! create table child1 partition of parent for values in ('AAA');
! -- a child with a dropped column
! create table child2 (a text, b int, x int);
! alter table child2 drop column x;
! alter table parent attach partition child2 for values in ('BBB');
! -- a child with a different column order
! -- XXX XL does not support child with different column order, so change that,
! -- though it probably defeats the purpose of the test
! create table child3 (a text, b int);
! alter table parent attach partition child3 for values in ('CCC');
! create trigger parent_insert_trig
!   after insert on parent referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger parent_update_trig
!   after update on parent referencing old table as old_table new table as new_table
!   for each statement execute procedure dump_update();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger parent_delete_trig
!   after delete on parent referencing old table as old_table
!   for each statement execute procedure dump_delete();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child1_insert_trig
!   after insert on child1 referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child1_update_trig
!   after update on child1 referencing old table as old_table new table as new_table
!   for each statement execute procedure dump_update();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child1_delete_trig
!   after delete on child1 referencing old table as old_table
!   for each statement execute procedure dump_delete();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child2_insert_trig
!   after insert on child2 referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child2_update_trig
!   after update on child2 referencing old table as old_table new table as new_table
!   for each statement execute procedure dump_update();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child2_delete_trig
!   after delete on child2 referencing old table as old_table
!   for each statement execute procedure dump_delete();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child3_insert_trig
!   after insert on child3 referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child3_update_trig
!   after update on child3 referencing old table as old_table new table as new_table
!   for each statement execute procedure dump_update();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child3_delete_trig
!   after delete on child3 referencing old table as old_table
!   for each statement execute procedure dump_delete();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- insert directly into children sees respective child-format tuples
! insert into child1 values ('AAA', 42);
! insert into child2 values ('BBB', 42);
! insert into child3 (b, a) values (42, 'CCC');
! -- update via parent sees parent-format tuples
! update parent set b = b + 1;
! -- delete via parent sees parent-format tuples
! delete from parent;
! -- insert into parent sees parent-format tuples
! insert into parent values ('AAA', 42);
! insert into parent values ('BBB', 42);
! insert into parent values ('CCC', 42);
! -- delete from children sees respective child-format tuples
! delete from child1;
! delete from child2;
! delete from child3;
! -- copy into parent sees parent-format tuples
! copy parent (a, b) from stdin;
! -- DML affecting parent sees tuples collected from children even if
! -- there is no transition table trigger on the children
! drop trigger child1_insert_trig on child1;
! ERROR:  trigger "child1_insert_trig" for table "child1" does not exist
! drop trigger child1_update_trig on child1;
! ERROR:  trigger "child1_update_trig" for table "child1" does not exist
! drop trigger child1_delete_trig on child1;
! ERROR:  trigger "child1_delete_trig" for table "child1" does not exist
! drop trigger child2_insert_trig on child2;
! ERROR:  trigger "child2_insert_trig" for table "child2" does not exist
! drop trigger child2_update_trig on child2;
! ERROR:  trigger "child2_update_trig" for table "child2" does not exist
! drop trigger child2_delete_trig on child2;
! ERROR:  trigger "child2_delete_trig" for table "child2" does not exist
! drop trigger child3_insert_trig on child3;
! ERROR:  trigger "child3_insert_trig" for table "child3" does not exist
! drop trigger child3_update_trig on child3;
! ERROR:  trigger "child3_update_trig" for table "child3" does not exist
! drop trigger child3_delete_trig on child3;
! ERROR:  trigger "child3_delete_trig" for table "child3" does not exist
! delete from parent;
! -- copy into parent sees tuples collected from children even if there
! -- is no transition-table trigger on the children
! copy parent (a, b) from stdin;
! -- insert into parent with a before trigger on a child tuple before
! -- insertion, and we capture the newly modified row in parent format
! create or replace function intercept_insert() returns trigger language plpgsql as
! $$
!   begin
!     new.b = new.b + 1000;
!     return new;
!   end;
! $$;
! create trigger intercept_insert_child3
!   before insert on child3
!   for each row execute procedure intercept_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- insert, parent trigger sees post-modification parent-format tuple
! insert into parent values ('AAA', 42), ('BBB', 42), ('CCC', 66);
! -- copy, parent trigger sees post-modification parent-format tuple
! copy parent (a, b) from stdin;
! drop table child1, child2, child3, parent;
! drop function intercept_insert();
! --
! -- Verify prohibition of row triggers with transition triggers on
! -- partitions
! --
! create table parent (a text, b int) partition by list (a);
! create table child partition of parent for values in ('AAA');
! -- adding row trigger with transition table fails
! create trigger child_row_trig
!   after insert on child referencing new table as new_table
!   for each row execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- detaching it first works
! alter table parent detach partition child;
! create trigger child_row_trig
!   after insert on child referencing new table as new_table
!   for each row execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- but now we're not allowed to reattach it
! -- XXX This does not fail in XL because trigger creation itself fails
! alter table parent attach partition child for values in ('AAA');
! -- drop the trigger, and now we're allowed to attach it again
! drop trigger child_row_trig on child;
! ERROR:  trigger "child_row_trig" for table "child" does not exist
! -- XXX and this fails because the previous attach worked ok
! alter table parent attach partition child for values in ('AAA');
! ERROR:  "child" is already a partition
! drop table child, parent;
! --
! -- Verify behavior of statement triggers on (non-partition)
! -- inheritance hierarchy with transition tables; similar to the
! -- partition case, except there is no rerouting on insertion and child
! -- tables can have extra columns
! --
! -- set up inheritance hierarchy with different TupleDescriptors
! create table parent (a text, b int);
! -- a child matching parent
! create table child1 () inherits (parent);
! -- a child with a different column order
! -- XXX this fails in XL because we don't allow different column ordering
! create table child2 (b int, a text);
! alter table child2 inherit parent;
! ERROR:  table "child2" contains column "a" at position 2, but parent "parent" has it at position 1
! DETAIL:  Postgres-XL requires attribute positions to match
! HINT:  Check for column ordering and dropped columns, if any
! -- a child with an extra column
! create table child3 (c text) inherits (parent);
! create trigger parent_insert_trig
!   after insert on parent referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger parent_update_trig
!   after update on parent referencing old table as old_table new table as new_table
!   for each statement execute procedure dump_update();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger parent_delete_trig
!   after delete on parent referencing old table as old_table
!   for each statement execute procedure dump_delete();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child1_insert_trig
!   after insert on child1 referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child1_update_trig
!   after update on child1 referencing old table as old_table new table as new_table
!   for each statement execute procedure dump_update();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child1_delete_trig
!   after delete on child1 referencing old table as old_table
!   for each statement execute procedure dump_delete();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child2_insert_trig
!   after insert on child2 referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child2_update_trig
!   after update on child2 referencing old table as old_table new table as new_table
!   for each statement execute procedure dump_update();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child2_delete_trig
!   after delete on child2 referencing old table as old_table
!   for each statement execute procedure dump_delete();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child3_insert_trig
!   after insert on child3 referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child3_update_trig
!   after update on child3 referencing old table as old_table new table as new_table
!   for each statement execute procedure dump_update();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger child3_delete_trig
!   after delete on child3 referencing old table as old_table
!   for each statement execute procedure dump_delete();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- insert directly into children sees respective child-format tuples
! insert into child1 values ('AAA', 42);
! insert into child2 values (42, 'BBB');
! insert into child3 values ('CCC', 42, 'foo');
! -- update via parent sees parent-format tuples
! update parent set b = b + 1;
! -- delete via parent sees parent-format tuples
! delete from parent;
! -- reinsert values into children for next test...
! insert into child1 values ('AAA', 42);
! insert into child2 values (42, 'BBB');
! insert into child3 values ('CCC', 42, 'foo');
! -- delete from children sees respective child-format tuples
! delete from child1;
! delete from child2;
! delete from child3;
! -- copy into parent sees parent-format tuples (no rerouting, so these
! -- are really inserted into the parent)
! copy parent (a, b) from stdin;
! -- same behavior for copy if there is an index (interesting because rows are
! -- captured by a different code path in copy.c if there are indexes)
! create index on parent(b);
! copy parent (a, b) from stdin;
! -- DML affecting parent sees tuples collected from children even if
! -- there is no transition table trigger on the children
! drop trigger child1_insert_trig on child1;
! ERROR:  trigger "child1_insert_trig" for table "child1" does not exist
! drop trigger child1_update_trig on child1;
! ERROR:  trigger "child1_update_trig" for table "child1" does not exist
! drop trigger child1_delete_trig on child1;
! ERROR:  trigger "child1_delete_trig" for table "child1" does not exist
! drop trigger child2_insert_trig on child2;
! ERROR:  trigger "child2_insert_trig" for table "child2" does not exist
! drop trigger child2_update_trig on child2;
! ERROR:  trigger "child2_update_trig" for table "child2" does not exist
! drop trigger child2_delete_trig on child2;
! ERROR:  trigger "child2_delete_trig" for table "child2" does not exist
! drop trigger child3_insert_trig on child3;
! ERROR:  trigger "child3_insert_trig" for table "child3" does not exist
! drop trigger child3_update_trig on child3;
! ERROR:  trigger "child3_update_trig" for table "child3" does not exist
! drop trigger child3_delete_trig on child3;
! ERROR:  trigger "child3_delete_trig" for table "child3" does not exist
! delete from parent;
! drop table child1, child2, child3, parent;
! --
! -- Verify prohibition of row triggers with transition triggers on
! -- inheritance children
! --
! create table parent (a text, b int);
! create table child () inherits (parent);
! -- adding row trigger with transition table fails
! create trigger child_row_trig
!   after insert on child referencing new table as new_table
!   for each row execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- disinheriting it first works
! alter table child no inherit parent;
! create trigger child_row_trig
!   after insert on child referencing new table as new_table
!   for each row execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- but now we're not allowed to make it inherit anymore
! alter table child inherit parent;
! -- drop the trigger, and now we're allowed to make it inherit again
! drop trigger child_row_trig on child;
! ERROR:  trigger "child_row_trig" for table "child" does not exist
! alter table child inherit parent;
! ERROR:  relation "parent" would be inherited from more than once
! drop table child, parent;
! --
! -- Verify behavior of queries with wCTEs, where multiple transition
! -- tuplestores can be active at the same time because there are
! -- multiple DML statements that might fire triggers with transition
! -- tables
! --
! create table table1 (a int);
! create table table2 (a text);
! create trigger table1_trig
!   after insert on table1 referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger table2_trig
!   after insert on table2 referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! with wcte as (insert into table1 values (42))
!   insert into table2 values ('hello world');
! ERROR:  INSERT/UPDATE/DELETE is not supported in subquery
! drop table table1;
! drop table table2;
! --
! -- Verify behavior of INSERT ... ON CONFLICT DO UPDATE ... with
! -- transition tables.
! --
! create table my_table (a int primary key, b text);
! create trigger my_table_insert_trig
!   after insert on my_table referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! create trigger my_table_update_trig
!   after update on my_table referencing old table as old_table new table as new_table
!   for each statement execute procedure dump_update();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! -- inserts only
! insert into my_table values (1, 'AAA'), (2, 'BBB')
!   on conflict (a) do
!   update set b = my_table.b || ':' || excluded.b;
! -- mixture of inserts and updates
! insert into my_table values (1, 'AAA'), (2, 'BBB'), (3, 'CCC'), (4, 'DDD')
!   on conflict (a) do
!   update set b = my_table.b || ':' || excluded.b;
! -- updates only
! insert into my_table values (3, 'CCC'), (4, 'DDD')
!   on conflict (a) do
!   update set b = my_table.b || ':' || excluded.b;
! --
! -- Verify that you can't create a trigger with transition tables for
! -- more than one event.
! --
! create trigger my_table_multievent_trig
!   after insert or update on my_table referencing new table as new_table
!   for each statement execute procedure dump_insert();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! drop table my_table;
! -- cleanup
! drop function dump_insert();
! drop function dump_update();
! drop function dump_delete();
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/inherit_2.out"	2025-07-31 16:07:14.985068136 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/inherit.out"	2025-07-31 16:39:29.063088171 +0800
***************
*** 1,2305 ****
! --
! -- Test inheritance features
! --
! CREATE TABLE a (aa TEXT) distribute by roundrobin;
! CREATE TABLE b (bb TEXT) INHERITS (a) distribute by roundrobin;
! WARNING:  Inherited/partition tables inherit distribution from the parent
! DETAIL:  Explicitly specified distribution will be ignored
! CREATE TABLE c (cc TEXT) INHERITS (a) distribute by roundrobin;
! WARNING:  Inherited/partition tables inherit distribution from the parent
! DETAIL:  Explicitly specified distribution will be ignored
! CREATE TABLE d (dd TEXT) INHERITS (b,c,a) distribute by roundrobin;
! WARNING:  Inherited/partition tables inherit distribution from the parent
! DETAIL:  Explicitly specified distribution will be ignored
! NOTICE:  merging multiple inherited definitions of column "aa"
! NOTICE:  merging multiple inherited definitions of column "aa"
! INSERT INTO a(aa) VALUES('aaa');
! INSERT INTO a(aa) VALUES('aaaa');
! INSERT INTO a(aa) VALUES('aaaaa');
! INSERT INTO a(aa) VALUES('aaaaaa');
! INSERT INTO a(aa) VALUES('aaaaaaa');
! INSERT INTO a(aa) VALUES('aaaaaaaa');
! INSERT INTO b(aa) VALUES('bbb');
! INSERT INTO b(aa) VALUES('bbbb');
! INSERT INTO b(aa) VALUES('bbbbb');
! INSERT INTO b(aa) VALUES('bbbbbb');
! INSERT INTO b(aa) VALUES('bbbbbbb');
! INSERT INTO b(aa) VALUES('bbbbbbbb');
! INSERT INTO c(aa) VALUES('ccc');
! INSERT INTO c(aa) VALUES('cccc');
! INSERT INTO c(aa) VALUES('ccccc');
! INSERT INTO c(aa) VALUES('cccccc');
! INSERT INTO c(aa) VALUES('ccccccc');
! INSERT INTO c(aa) VALUES('cccccccc');
! INSERT INTO d(aa) VALUES('ddd');
! INSERT INTO d(aa) VALUES('dddd');
! INSERT INTO d(aa) VALUES('ddddd');
! INSERT INTO d(aa) VALUES('dddddd');
! INSERT INTO d(aa) VALUES('ddddddd');
! INSERT INTO d(aa) VALUES('dddddddd');
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid ORDER BY relname, a.aa;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid ORDER BY relname, b.aa;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid ORDER BY relname, c.aa;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid ORDER BY relname, d.aa;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid ORDER BY relname, a.aa;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid ORDER BY relname, b.aa;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid ORDER BY relname, c.aa;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid ORDER BY relname, d.aa;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! -- In Postgres-XL OIDs are not consistent across the cluster. Hence above
! -- queries do not show any result. Hence in order to ensure data consistency, we
! -- add following SQLs. In case above set of queries start producing valid
! -- results in XC, we should remove the following set
! SELECT * FROM a ORDER BY a.aa;
!     aa    
! ----------
!  aaa
!  aaaa
!  aaaaa
!  aaaaaa
!  aaaaaaa
!  aaaaaaaa
!  bbb
!  bbbb
!  bbbbb
!  bbbbbb
!  bbbbbbb
!  bbbbbbbb
!  ccc
!  cccc
!  ccccc
!  cccccc
!  ccccccc
!  cccccccc
!  ddd
!  dddd
!  ddddd
!  dddddd
!  ddddddd
!  dddddddd
! (24 rows)
! 
! SELECT * from b ORDER BY b.aa;
!     aa    | bb 
! ----------+----
!  bbb      | 
!  bbbb     | 
!  bbbbb    | 
!  bbbbbb   | 
!  bbbbbbb  | 
!  bbbbbbbb | 
!  ddd      | 
!  dddd     | 
!  ddddd    | 
!  dddddd   | 
!  ddddddd  | 
!  dddddddd | 
! (12 rows)
! 
! SELECT * FROM c ORDER BY c.aa;
!     aa    | cc 
! ----------+----
!  ccc      | 
!  cccc     | 
!  ccccc    | 
!  cccccc   | 
!  ccccccc  | 
!  cccccccc | 
!  ddd      | 
!  dddd     | 
!  ddddd    | 
!  dddddd   | 
!  ddddddd  | 
!  dddddddd | 
! (12 rows)
! 
! SELECT * from d ORDER BY d.aa;
!     aa    | bb | cc | dd 
! ----------+----+----+----
!  ddd      |    |    | 
!  dddd     |    |    | 
!  ddddd    |    |    | 
!  dddddd   |    |    | 
!  ddddddd  |    |    | 
!  dddddddd |    |    | 
! (6 rows)
! 
! SELECT * FROM ONLY a ORDER BY a.aa;
!     aa    
! ----------
!  aaa
!  aaaa
!  aaaaa
!  aaaaaa
!  aaaaaaa
!  aaaaaaaa
! (6 rows)
! 
! SELECT * from ONLY b ORDER BY b.aa;
!     aa    | bb 
! ----------+----
!  bbb      | 
!  bbbb     | 
!  bbbbb    | 
!  bbbbbb   | 
!  bbbbbbb  | 
!  bbbbbbbb | 
! (6 rows)
! 
! SELECT * FROM ONLY c ORDER BY c.aa;
!     aa    | cc 
! ----------+----
!  ccc      | 
!  cccc     | 
!  ccccc    | 
!  cccccc   | 
!  ccccccc  | 
!  cccccccc | 
! (6 rows)
! 
! SELECT * from ONLY d ORDER BY d.aa;
!     aa    | bb | cc | dd 
! ----------+----+----+----
!  ddd      |    |    | 
!  dddd     |    |    | 
!  ddddd    |    |    | 
!  dddddd   |    |    | 
!  ddddddd  |    |    | 
!  dddddddd |    |    | 
! (6 rows)
! 
! UPDATE a SET aa='zzzz' WHERE aa='aaaa';
! UPDATE ONLY a SET aa='zzzzz' WHERE aa='aaaaa';
! UPDATE b SET aa='zzz' WHERE aa='aaa';
! UPDATE ONLY b SET aa='zzz' WHERE aa='aaa';
! UPDATE a SET aa='zzzzzz' WHERE aa LIKE 'aaa%';
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid ORDER BY relname, a.aa;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid ORDER BY relname, b.aa;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid ORDER BY relname, c.aa;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid ORDER BY relname, d.aa;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid ORDER BY relname, a.aa;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid ORDER BY relname, b.aa;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid ORDER BY relname, c.aa;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid ORDER BY relname, d.aa;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! -- In Postgres-XL OIDs are not consistent across the cluster. Hence above
! -- queries do not show any result. Hence in order to ensure data consistency, we
! -- add following SQLs. In case above set of queries start producing valid
! -- results in XC, we should remove the following set
! SELECT * FROM a ORDER BY a.aa;
!     aa    
! ----------
!  bbb
!  bbbb
!  bbbbb
!  bbbbbb
!  bbbbbbb
!  bbbbbbbb
!  ccc
!  cccc
!  ccccc
!  cccccc
!  ccccccc
!  cccccccc
!  ddd
!  dddd
!  ddddd
!  dddddd
!  ddddddd
!  dddddddd
!  zzzz
!  zzzzz
!  zzzzzz
!  zzzzzz
!  zzzzzz
!  zzzzzz
! (24 rows)
! 
! SELECT * from b ORDER BY b.aa;
!     aa    | bb 
! ----------+----
!  bbb      | 
!  bbbb     | 
!  bbbbb    | 
!  bbbbbb   | 
!  bbbbbbb  | 
!  bbbbbbbb | 
!  ddd      | 
!  dddd     | 
!  ddddd    | 
!  dddddd   | 
!  ddddddd  | 
!  dddddddd | 
! (12 rows)
! 
! SELECT * FROM c ORDER BY c.aa;
!     aa    | cc 
! ----------+----
!  ccc      | 
!  cccc     | 
!  ccccc    | 
!  cccccc   | 
!  ccccccc  | 
!  cccccccc | 
!  ddd      | 
!  dddd     | 
!  ddddd    | 
!  dddddd   | 
!  ddddddd  | 
!  dddddddd | 
! (12 rows)
! 
! SELECT * from d ORDER BY d.aa;
!     aa    | bb | cc | dd 
! ----------+----+----+----
!  ddd      |    |    | 
!  dddd     |    |    | 
!  ddddd    |    |    | 
!  dddddd   |    |    | 
!  ddddddd  |    |    | 
!  dddddddd |    |    | 
! (6 rows)
! 
! SELECT * FROM ONLY a ORDER BY a.aa;
!    aa   
! --------
!  zzzz
!  zzzzz
!  zzzzzz
!  zzzzzz
!  zzzzzz
!  zzzzzz
! (6 rows)
! 
! SELECT * from ONLY b ORDER BY b.aa;
!     aa    | bb 
! ----------+----
!  bbb      | 
!  bbbb     | 
!  bbbbb    | 
!  bbbbbb   | 
!  bbbbbbb  | 
!  bbbbbbbb | 
! (6 rows)
! 
! SELECT * FROM ONLY c ORDER BY c.aa;
!     aa    | cc 
! ----------+----
!  ccc      | 
!  cccc     | 
!  ccccc    | 
!  cccccc   | 
!  ccccccc  | 
!  cccccccc | 
! (6 rows)
! 
! SELECT * from ONLY d ORDER BY d.aa;
!     aa    | bb | cc | dd 
! ----------+----+----+----
!  ddd      |    |    | 
!  dddd     |    |    | 
!  ddddd    |    |    | 
!  dddddd   |    |    | 
!  ddddddd  |    |    | 
!  dddddddd |    |    | 
! (6 rows)
! 
! UPDATE b SET aa='new';
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid ORDER BY relname, a.aa;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid ORDER BY relname, b.aa;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid ORDER BY relname, c.aa;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid ORDER BY relname, d.aa;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid ORDER BY relname, a.aa;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid ORDER BY relname, b.aa;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid ORDER BY relname, c.aa;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid ORDER BY relname, d.aa;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! -- In Postgres-XL OIDs are not consistent across the cluster. Hence above
! -- queries do not show any result. Hence in order to ensure data consistency, we
! -- add following SQLs. In case above set of queries start producing valid
! -- results in XC, we should remove the following set
! SELECT * FROM a ORDER BY a.aa;
!     aa    
! ----------
!  ccc
!  cccc
!  ccccc
!  cccccc
!  ccccccc
!  cccccccc
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  zzzz
!  zzzzz
!  zzzzzz
!  zzzzzz
!  zzzzzz
!  zzzzzz
! (24 rows)
! 
! SELECT * from b ORDER BY b.aa;
!  aa  | bb 
! -----+----
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
! (12 rows)
! 
! SELECT * FROM c ORDER BY c.aa;
!     aa    | cc 
! ----------+----
!  ccc      | 
!  cccc     | 
!  ccccc    | 
!  cccccc   | 
!  ccccccc  | 
!  cccccccc | 
!  new      | 
!  new      | 
!  new      | 
!  new      | 
!  new      | 
!  new      | 
! (12 rows)
! 
! SELECT * from d ORDER BY d.aa;
!  aa  | bb | cc | dd 
! -----+----+----+----
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
! (6 rows)
! 
! SELECT * FROM ONLY a ORDER BY a.aa;
!    aa   
! --------
!  zzzz
!  zzzzz
!  zzzzzz
!  zzzzzz
!  zzzzzz
!  zzzzzz
! (6 rows)
! 
! SELECT * from ONLY b ORDER BY b.aa;
!  aa  | bb 
! -----+----
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
! (6 rows)
! 
! SELECT * FROM ONLY c ORDER BY c.aa;
!     aa    | cc 
! ----------+----
!  ccc      | 
!  cccc     | 
!  ccccc    | 
!  cccccc   | 
!  ccccccc  | 
!  cccccccc | 
! (6 rows)
! 
! SELECT * from ONLY d ORDER BY d.aa;
!  aa  | bb | cc | dd 
! -----+----+----+----
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
! (6 rows)
! 
! UPDATE a SET aa='new';
! DELETE FROM ONLY c WHERE aa='new';
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid ORDER BY relname, a.aa;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid ORDER BY relname, b.aa;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid ORDER BY relname, c.aa;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid ORDER BY relname, d.aa;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid ORDER BY relname, a.aa;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid ORDER BY relname, b.aa;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid ORDER BY relname, c.aa;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid ORDER BY relname, d.aa;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! -- In Postgres-XL OIDs are not consistent across the cluster. Hence above
! -- queries do not show any result. Hence in order to ensure data consistency, we
! -- add following SQLs. In case above set of queries start producing valid
! -- results in XC, we should remove the following set
! SELECT * FROM a ORDER BY a.aa;
!  aa  
! -----
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
!  new
! (18 rows)
! 
! SELECT * from b ORDER BY b.aa;
!  aa  | bb 
! -----+----
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
! (12 rows)
! 
! SELECT * FROM c ORDER BY c.aa;
!  aa  | cc 
! -----+----
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
! (6 rows)
! 
! SELECT * from d ORDER BY d.aa;
!  aa  | bb | cc | dd 
! -----+----+----+----
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
! (6 rows)
! 
! SELECT * FROM ONLY a ORDER BY a.aa;
!  aa  
! -----
!  new
!  new
!  new
!  new
!  new
!  new
! (6 rows)
! 
! SELECT * from ONLY b ORDER BY b.aa;
!  aa  | bb 
! -----+----
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
!  new | 
! (6 rows)
! 
! SELECT * FROM ONLY c ORDER BY c.aa;
!  aa | cc 
! ----+----
! (0 rows)
! 
! SELECT * from ONLY d ORDER BY d.aa;
!  aa  | bb | cc | dd 
! -----+----+----+----
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
!  new |    |    | 
! (6 rows)
! 
! DELETE FROM a;
! SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid ORDER BY relname, a.aa;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid ORDER BY relname, b.aa;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid ORDER BY relname, c.aa;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid ORDER BY relname, d.aa;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid ORDER BY relname, a.aa;
!  relname | aa 
! ---------+----
! (0 rows)
! 
! SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid ORDER BY relname, b.aa;
!  relname | aa | bb 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid ORDER BY relname, c.aa;
!  relname | aa | cc 
! ---------+----+----
! (0 rows)
! 
! SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid ORDER BY relname, d.aa;
!  relname | aa | bb | cc | dd 
! ---------+----+----+----+----
! (0 rows)
! 
! -- In Postgres-XL OIDs are not consistent across the cluster. Hence above
! -- queries do not show any result. Hence in order to ensure data consistency, we
! -- add following SQLs. In case above set of queries start producing valid
! -- results in XC, we should remove the following set
! SELECT * FROM a ORDER BY a.aa;
!  aa 
! ----
! (0 rows)
! 
! SELECT * from b ORDER BY b.aa;
!  aa | bb 
! ----+----
! (0 rows)
! 
! SELECT * FROM c ORDER BY c.aa;
!  aa | cc 
! ----+----
! (0 rows)
! 
! SELECT * from d ORDER BY d.aa;
!  aa | bb | cc | dd 
! ----+----+----+----
! (0 rows)
! 
! SELECT * FROM ONLY a ORDER BY a.aa;
!  aa 
! ----
! (0 rows)
! 
! SELECT * from ONLY b ORDER BY b.aa;
!  aa | bb 
! ----+----
! (0 rows)
! 
! SELECT * FROM ONLY c ORDER BY c.aa;
!  aa | cc 
! ----+----
! (0 rows)
! 
! SELECT * from ONLY d ORDER BY d.aa;
!  aa | bb | cc | dd 
! ----+----+----+----
! (0 rows)
! 
! -- Confirm PRIMARY KEY adds NOT NULL constraint to child table
! CREATE TEMP TABLE z (b TEXT, PRIMARY KEY(aa, b)) inherits (a);
! ERROR:  Cannot locally enforce a unique index on round robin distributed table.
! INSERT INTO z VALUES (NULL, 'text'); -- should fail
! ERROR:  relation "z" does not exist
! LINE 1: INSERT INTO z VALUES (NULL, 'text');
!                     ^
! -- Check UPDATE with inherited target and an inherited source table
! create temp table foo(f1 int, f2 int);
! create temp table foo2(f3 int) inherits (foo);
! create temp table bar(f1 int, f2 int);
! create temp table bar2(f3 int) inherits (bar);
! insert into foo values(1,1);
! insert into foo values(3,3);
! insert into foo2 values(2,2,2);
! insert into foo2 values(3,3,3);
! insert into bar values(1,1);
! insert into bar values(2,2);
! insert into bar values(3,3);
! insert into bar values(4,4);
! insert into bar2 values(1,1,1);
! insert into bar2 values(2,2,2);
! insert into bar2 values(3,3,3);
! insert into bar2 values(4,4,4);
! update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
! --select tableoid::regclass::text as relname, bar.* from bar order by 1,2;
! -- In Postgres-XL OIDs are not consistent across the cluster. Hence above
! -- queries do not show any result. Hence in order to ensure data consistency, we
! -- add following SQLs. In case above set of queries start producing valid
! -- results in XC, we should remove the following set
! SELECT * FROM bar ORDER BY f1, f2;
!  f1 | f2  
! ----+-----
!   1 | 101
!   1 | 101
!   2 | 102
!   2 | 102
!   3 | 103
!   3 | 103
!   4 |   4
!   4 |   4
! (8 rows)
! 
! SELECT * FROM ONLY bar ORDER BY f1, f2;
!  f1 | f2  
! ----+-----
!   1 | 101
!   2 | 102
!   3 | 103
!   4 |   4
! (4 rows)
! 
! SELECT * FROM bar2 ORDER BY f1, f2;
!  f1 | f2  | f3 
! ----+-----+----
!   1 | 101 |  1
!   2 | 102 |  2
!   3 | 103 |  3
!   4 |   4 |  4
! (4 rows)
! 
! -- Check UPDATE with inherited target and an appendrel subquery
! update bar set f2 = f2 + 100
! from
!   ( select f1 from foo union all select f1+3 from foo ) ss
! where bar.f1 = ss.f1;
! --select tableoid::regclass::text as relname, bar.* from bar order by 1,2;
! -- Check UPDATE with *partitioned* inherited target and an appendrel subquery
! create table some_tab (a int);
! insert into some_tab values (0);
! create table some_tab_child () inherits (some_tab);
! insert into some_tab_child values (1);
! create table parted_tab (a int, b char) partition by list (a);
! create table parted_tab_part1 partition of parted_tab for values in (1);
! create table parted_tab_part2 partition of parted_tab for values in (2);
! create table parted_tab_part3 partition of parted_tab for values in (3);
! insert into parted_tab values (1, 'a'), (2, 'a'), (3, 'a');
! update parted_tab set b = 'b'
! from
!   (select a from some_tab union all select a+1 from some_tab) ss (a)
! where parted_tab.a = ss.a;
! select tableoid::regclass::text as relname, parted_tab.* from parted_tab order by 1,2;
!      relname      | a | b 
! ------------------+---+---
!  parted_tab_part1 | 1 | b
!  parted_tab_part2 | 2 | b
!  parted_tab_part3 | 3 | a
! (3 rows)
! 
! truncate parted_tab;
! insert into parted_tab values (1, 'a'), (2, 'a'), (3, 'a');
! update parted_tab set b = 'b'
! from
!   (select 0 from parted_tab union all select 1 from parted_tab) ss (a)
! where parted_tab.a = ss.a;
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! select tableoid::regclass::text as relname, parted_tab.* from parted_tab order by 1,2;
!      relname      | a | b 
! ------------------+---+---
!  parted_tab_part1 | 1 | a
!  parted_tab_part2 | 2 | a
!  parted_tab_part3 | 3 | a
! (3 rows)
! 
! drop table parted_tab;
! -- Check UPDATE with multi-level partitioned inherited target
! create table mlparted_tab (a int, b char, c text) partition by list (a);
! create table mlparted_tab_part1 partition of mlparted_tab for values in (1);
! create table mlparted_tab_part2 partition of mlparted_tab for values in (2) partition by list (b);
! create table mlparted_tab_part3 partition of mlparted_tab for values in (3);
! create table mlparted_tab_part2a partition of mlparted_tab_part2 for values in ('a');
! create table mlparted_tab_part2b partition of mlparted_tab_part2 for values in ('b');
! insert into mlparted_tab values (1, 'a'), (2, 'a'), (2, 'b'), (3, 'a');
! update mlparted_tab mlp set c = 'xxx'
! from
!   (select a from some_tab union all select a+1 from some_tab) ss (a)
! where (mlp.a = ss.a and mlp.b = 'b') or mlp.a = 3;
! select tableoid::regclass::text as relname, mlparted_tab.* from mlparted_tab order by 1,2;
!        relname       | a | b |  c  
! ---------------------+---+---+-----
!  mlparted_tab_part1  | 1 | a | 
!  mlparted_tab_part2a | 2 | a | 
!  mlparted_tab_part2b | 2 | b | xxx
!  mlparted_tab_part3  | 3 | a | xxx
! (4 rows)
! 
! drop table mlparted_tab;
! drop table some_tab cascade;
! NOTICE:  drop cascades to table some_tab_child
! /* Test multiple inheritance of column defaults */
! CREATE TABLE firstparent (tomorrow date default now()::date + 1);
! CREATE TABLE secondparent (tomorrow date default  now() :: date  +  1);
! CREATE TABLE jointchild () INHERITS (firstparent, secondparent);  -- ok
! NOTICE:  merging multiple inherited definitions of column "tomorrow"
! CREATE TABLE thirdparent (tomorrow date default now()::date - 1);
! CREATE TABLE otherchild () INHERITS (firstparent, thirdparent);  -- not ok
! NOTICE:  merging multiple inherited definitions of column "tomorrow"
! ERROR:  column "tomorrow" inherits conflicting default values
! HINT:  To resolve the conflict, specify a default explicitly.
! CREATE TABLE otherchild (tomorrow date default now())
!   INHERITS (firstparent, thirdparent);  -- ok, child resolves ambiguous default
! NOTICE:  merging multiple inherited definitions of column "tomorrow"
! NOTICE:  merging column "tomorrow" with inherited definition
! DROP TABLE firstparent, secondparent, jointchild, thirdparent, otherchild;
! -- Test changing the type of inherited columns
! insert into d values('test','one','two','three');
! alter table a alter column aa type integer using bit_length(aa);
! select * from d;
!  aa | bb  | cc  |  dd   
! ----+-----+-----+-------
!  32 | one | two | three
! (1 row)
! 
! -- check that oid column is handled properly during alter table inherit
! create table oid_parent (a int) with oids;
! create table oid_child () inherits (oid_parent);
! select attinhcount, attislocal from pg_attribute
!   where attrelid = 'oid_child'::regclass and attname = 'oid';
!  attinhcount | attislocal 
! -------------+------------
!            1 | f
! (1 row)
! 
! drop table oid_child;
! create table oid_child (a int) without oids;
! alter table oid_child inherit oid_parent;  -- fail
! ERROR:  table "oid_child" without OIDs cannot inherit from table "oid_parent" with OIDs
! alter table oid_child set with oids;
! select attinhcount, attislocal from pg_attribute
!   where attrelid = 'oid_child'::regclass and attname = 'oid';
!  attinhcount | attislocal 
! -------------+------------
!            0 | t
! (1 row)
! 
! alter table oid_child inherit oid_parent;
! select attinhcount, attislocal from pg_attribute
!   where attrelid = 'oid_child'::regclass and attname = 'oid';
!  attinhcount | attislocal 
! -------------+------------
!            1 | t
! (1 row)
! 
! alter table oid_child set without oids;  -- fail
! ERROR:  cannot drop inherited column "oid"
! alter table oid_parent set without oids;
! select attinhcount, attislocal from pg_attribute
!   where attrelid = 'oid_child'::regclass and attname = 'oid';
!  attinhcount | attislocal 
! -------------+------------
!            0 | t
! (1 row)
! 
! alter table oid_child set without oids;
! select attinhcount, attislocal from pg_attribute
!   where attrelid = 'oid_child'::regclass and attname = 'oid';
!  attinhcount | attislocal 
! -------------+------------
! (0 rows)
! 
! drop table oid_parent cascade;
! NOTICE:  drop cascades to table oid_child
! -- Test non-inheritable parent constraints
! create table p1(ff1 int);
! alter table p1 add constraint p1chk check (ff1 > 0) no inherit;
! alter table p1 add constraint p2chk check (ff1 > 10);
! -- connoinherit should be true for NO INHERIT constraint
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.connoinherit from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname = 'p1' order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | connoinherit 
! ---------+---------+---------+------------+-------------+--------------
!  p1      | p1chk   | c       | t          |           0 | t
!  p1      | p2chk   | c       | t          |           0 | f
! (2 rows)
! 
! -- Test that child does not inherit NO INHERIT constraints
! create table c1 () inherits (p1);
! \d p1
!                  Table "public.p1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  ff1    | integer |           |          | 
! Check constraints:
!     "p1chk" CHECK (ff1 > 0) NO INHERIT
!     "p2chk" CHECK (ff1 > 10)
! Number of child tables: 1 (Use \d+ to list them.)
! 
! \d c1
!                  Table "public.c1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  ff1    | integer |           |          | 
! Check constraints:
!     "p2chk" CHECK (ff1 > 10)
! Inherits: p1
! 
! -- Test that child does not override inheritable constraints of the parent
! create table c2 (constraint p2chk check (ff1 > 10) no inherit) inherits (p1);	--fails
! ERROR:  constraint "p2chk" conflicts with inherited constraint on relation "c2"
! drop table p1 cascade;
! NOTICE:  drop cascades to table c1
! -- Tests for casting between the rowtypes of parent and child
! -- tables. See the pgsql-hackers thread beginning Dec. 4/04
! create table base (i integer);
! create table derived () inherits (base);
! create table more_derived (like derived, b int) inherits (derived);
! NOTICE:  merging column "i" with inherited definition
! insert into derived (i) values (0);
! select derived::base from derived;
!  derived 
! ---------
!  (0)
! (1 row)
! 
! select NULL::derived::base;
!  base 
! ------
!  
! (1 row)
! 
! -- remove redundant conversions.
! explain (verbose on, costs off) select row(i, b)::more_derived::derived::base from more_derived;
!                 QUERY PLAN                 
! -------------------------------------------
!  Seq Scan on public.more_derived
!    Output: (ROW(i, b)::more_derived)::base
! (2 rows)
! 
! explain (verbose on, costs off) select (1, 2)::more_derived::derived::base;
!       QUERY PLAN       
! -----------------------
!  Result
!    Output: '(1)'::base
! (2 rows)
! 
! drop table more_derived;
! drop table derived;
! drop table base;
! create table p1(ff1 int) distribute by roundrobin;
! create table p2(f1 text) distribute by roundrobin;
! create function p2text(p2) returns text as 'select $1.f1' language sql;
! create table c1(f3 int) inherits(p1,p2);
! insert into c1 values(123456789, 'hi', 42);
! select p2text(c1.*) from c1;
!  p2text 
! --------
!  hi
! (1 row)
! 
! drop function p2text(p2);
! drop table c1;
! drop table p2;
! drop table p1;
! CREATE TABLE ac (aa TEXT);
! alter table ac add constraint ac_check check (aa is not null);
! CREATE TABLE bc (bb TEXT) INHERITS (ac);
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname  | contype | conislocal | coninhcount |      consrc      
! ---------+----------+---------+------------+-------------+------------------
!  ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
!  bc      | ac_check | c       | f          |           1 | (aa IS NOT NULL)
! (2 rows)
! 
! insert into ac (aa) values (NULL);
! ERROR:  new row for relation "ac" violates check constraint "ac_check"
! DETAIL:  Failing row contains (null).
! insert into bc (aa) values (NULL);
! ERROR:  new row for relation "bc" violates check constraint "ac_check"
! DETAIL:  Failing row contains (null, null).
! alter table bc drop constraint ac_check;  -- fail, disallowed
! ERROR:  cannot drop inherited constraint "ac_check" of relation "bc"
! alter table ac drop constraint ac_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | consrc 
! ---------+---------+---------+------------+-------------+--------
! (0 rows)
! 
! -- try the unnamed-constraint case
! alter table ac add check (aa is not null);
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname |   conname   | contype | conislocal | coninhcount |      consrc      
! ---------+-------------+---------+------------+-------------+------------------
!  ac      | ac_aa_check | c       | t          |           0 | (aa IS NOT NULL)
!  bc      | ac_aa_check | c       | f          |           1 | (aa IS NOT NULL)
! (2 rows)
! 
! insert into ac (aa) values (NULL);
! ERROR:  new row for relation "ac" violates check constraint "ac_aa_check"
! DETAIL:  Failing row contains (null).
! insert into bc (aa) values (NULL);
! ERROR:  new row for relation "bc" violates check constraint "ac_aa_check"
! DETAIL:  Failing row contains (null, null).
! alter table bc drop constraint ac_aa_check;  -- fail, disallowed
! ERROR:  cannot drop inherited constraint "ac_aa_check" of relation "bc"
! alter table ac drop constraint ac_aa_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | consrc 
! ---------+---------+---------+------------+-------------+--------
! (0 rows)
! 
! alter table ac add constraint ac_check check (aa is not null);
! alter table bc no inherit ac;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname  | contype | conislocal | coninhcount |      consrc      
! ---------+----------+---------+------------+-------------+------------------
!  ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
!  bc      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
! (2 rows)
! 
! alter table bc drop constraint ac_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname  | contype | conislocal | coninhcount |      consrc      
! ---------+----------+---------+------------+-------------+------------------
!  ac      | ac_check | c       | t          |           0 | (aa IS NOT NULL)
! (1 row)
! 
! alter table ac drop constraint ac_check;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount | consrc 
! ---------+---------+---------+------------+-------------+--------
! (0 rows)
! 
! drop table bc;
! drop table ac;
! create table ac (a int constraint check_a check (a <> 0));
! create table bc (a int constraint check_a check (a <> 0), b int constraint check_b check (b <> 0)) inherits (ac);
! NOTICE:  merging column "a" with inherited definition
! NOTICE:  merging constraint "check_a" with inherited definition
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount |  consrc  
! ---------+---------+---------+------------+-------------+----------
!  ac      | check_a | c       | t          |           0 | (a <> 0)
!  bc      | check_a | c       | t          |           1 | (a <> 0)
!  bc      | check_b | c       | t          |           0 | (b <> 0)
! (3 rows)
! 
! drop table bc;
! drop table ac;
! create table ac (a int constraint check_a check (a <> 0)) distribute by roundrobin;
! create table bc (b int constraint check_b check (b <> 0)) distribute by roundrobin;
! create table cc (c int constraint check_c check (c <> 0)) inherits (ac, bc);
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount |  consrc  
! ---------+---------+---------+------------+-------------+----------
!  ac      | check_a | c       | t          |           0 | (a <> 0)
!  bc      | check_b | c       | t          |           0 | (b <> 0)
!  cc      | check_a | c       | f          |           1 | (a <> 0)
!  cc      | check_b | c       | f          |           1 | (b <> 0)
!  cc      | check_c | c       | t          |           0 | (c <> 0)
! (5 rows)
! 
! alter table cc no inherit bc;
! select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
!  relname | conname | contype | conislocal | coninhcount |  consrc  
! ---------+---------+---------+------------+-------------+----------
!  ac      | check_a | c       | t          |           0 | (a <> 0)
!  bc      | check_b | c       | t          |           0 | (b <> 0)
!  cc      | check_a | c       | f          |           1 | (a <> 0)
!  cc      | check_b | c       | t          |           0 | (b <> 0)
!  cc      | check_c | c       | t          |           0 | (c <> 0)
! (5 rows)
! 
! drop table cc;
! drop table bc;
! drop table ac;
! create table p1(f1 int) distribute by roundrobin;
! create table p2(f2 int) distribute by roundrobin;
! create table c1(f3 int) inherits(p1,p2);
! insert into c1 values(1,-1,2);
! alter table p2 add constraint cc check (f2>0);  -- fail
! ERROR:  check constraint "cc" is violated by some row
! alter table p2 add check (f2>0);  -- check it without a name, too
! ERROR:  check constraint "p2_f2_check" is violated by some row
! delete from c1;
! insert into c1 values(1,1,2);
! alter table p2 add check (f2>0);
! insert into c1 values(1,-1,2);  -- fail
! ERROR:  new row for relation "c1" violates check constraint "p2_f2_check"
! DETAIL:  Failing row contains (1, -1, 2).
! create table c2(f3 int) inherits(p1,p2);
! \d c2
!                  Table "public.c2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  f1     | integer |           |          | 
!  f2     | integer |           |          | 
!  f3     | integer |           |          | 
! Check constraints:
!     "p2_f2_check" CHECK (f2 > 0)
! Inherits: p1,
!           p2
! 
! create table c3 (f4 int) inherits(c1,c2);
! NOTICE:  merging multiple inherited definitions of column "f1"
! NOTICE:  merging multiple inherited definitions of column "f2"
! NOTICE:  merging multiple inherited definitions of column "f3"
! \d c3
!                  Table "public.c3"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  f1     | integer |           |          | 
!  f2     | integer |           |          | 
!  f3     | integer |           |          | 
!  f4     | integer |           |          | 
! Check constraints:
!     "p2_f2_check" CHECK (f2 > 0)
! Inherits: c1,
!           c2
! 
! drop table p1 cascade;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table c1
! drop cascades to table c2
! drop cascades to table c3
! drop table p2 cascade;
! create table pp1 (f1 int);
! create table cc1 (f2 text, f3 int) inherits (pp1);
! alter table pp1 add column a1 int check (a1 > 0);
! \d cc1
!                 Table "public.cc1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  f1     | integer |           |          | 
!  f2     | text    |           |          | 
!  f3     | integer |           |          | 
!  a1     | integer |           |          | 
! Check constraints:
!     "pp1_a1_check" CHECK (a1 > 0)
! Inherits: pp1
! 
! create table cc2(f4 float) inherits(pp1,cc1);
! NOTICE:  merging multiple inherited definitions of column "f1"
! NOTICE:  merging multiple inherited definitions of column "a1"
! \d cc2
!                      Table "public.cc2"
!  Column |       Type       | Collation | Nullable | Default 
! --------+------------------+-----------+----------+---------
!  f1     | integer          |           |          | 
!  a1     | integer          |           |          | 
!  f2     | text             |           |          | 
!  f3     | integer          |           |          | 
!  f4     | double precision |           |          | 
! Check constraints:
!     "pp1_a1_check" CHECK (a1 > 0)
! Inherits: pp1,
!           cc1
! 
! alter table pp1 add column a2 int check (a2 > 0);
! NOTICE:  merging definition of column "a2" for child "cc2"
! NOTICE:  merging constraint "pp1_a2_check" with inherited definition
! \d cc2
!                      Table "public.cc2"
!  Column |       Type       | Collation | Nullable | Default 
! --------+------------------+-----------+----------+---------
!  f1     | integer          |           |          | 
!  a1     | integer          |           |          | 
!  f2     | text             |           |          | 
!  f3     | integer          |           |          | 
!  f4     | double precision |           |          | 
!  a2     | integer          |           |          | 
! Check constraints:
!     "pp1_a1_check" CHECK (a1 > 0)
!     "pp1_a2_check" CHECK (a2 > 0)
! Inherits: pp1,
!           cc1
! 
! drop table pp1 cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table cc1
! drop cascades to table cc2
! -- Test for renaming in simple multiple inheritance
! CREATE TABLE inht1 (a int, b int) distribute by roundrobin;
! CREATE TABLE inhs1 (b int, c int) distribute by roundrobin;
! CREATE TABLE inhts (d int) INHERITS (inht1, inhs1);
! NOTICE:  merging multiple inherited definitions of column "b"
! ALTER TABLE inht1 RENAME a TO aa;
! ALTER TABLE inht1 RENAME b TO bb;                -- to be failed
! ERROR:  cannot rename inherited column "b"
! ALTER TABLE inhts RENAME aa TO aaa;      -- to be failed
! ERROR:  cannot rename inherited column "aa"
! ALTER TABLE inhts RENAME d TO dd;
! \d+ inhts
!                                    Table "public.inhts"
!  Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
! --------+---------+-----------+----------+---------+---------+--------------+-------------
!  aa     | integer |           |          |         | plain   |              | 
!  b      | integer |           |          |         | plain   |              | 
!  c      | integer |           |          |         | plain   |              | 
!  dd     | integer |           |          |         | plain   |              | 
! Inherits: inht1,
!           inhs1
! Distribute By: ROUND ROBIN
! Location Nodes: ALL DATANODES
! 
! DROP TABLE inhts;
! -- Test for renaming in diamond inheritance
! CREATE TABLE inht2 (x int) INHERITS (inht1);
! CREATE TABLE inht3 (y int) INHERITS (inht1);
! CREATE TABLE inht4 (z int) INHERITS (inht2, inht3);
! NOTICE:  merging multiple inherited definitions of column "aa"
! NOTICE:  merging multiple inherited definitions of column "b"
! ALTER TABLE inht1 RENAME aa TO aaa;
! \d+ inht4
!                                    Table "public.inht4"
!  Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
! --------+---------+-----------+----------+---------+---------+--------------+-------------
!  aaa    | integer |           |          |         | plain   |              | 
!  b      | integer |           |          |         | plain   |              | 
!  x      | integer |           |          |         | plain   |              | 
!  y      | integer |           |          |         | plain   |              | 
!  z      | integer |           |          |         | plain   |              | 
! Inherits: inht2,
!           inht3
! Distribute By: ROUND ROBIN
! Location Nodes: ALL DATANODES
! 
! CREATE TABLE inhts (d int) INHERITS (inht2, inhs1);
! NOTICE:  merging multiple inherited definitions of column "b"
! ALTER TABLE inht1 RENAME aaa TO aaaa;
! ALTER TABLE inht1 RENAME b TO bb;                -- to be failed
! ERROR:  cannot rename inherited column "b"
! \d+ inhts
!                                    Table "public.inhts"
!  Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
! --------+---------+-----------+----------+---------+---------+--------------+-------------
!  aaaa   | integer |           |          |         | plain   |              | 
!  b      | integer |           |          |         | plain   |              | 
!  x      | integer |           |          |         | plain   |              | 
!  c      | integer |           |          |         | plain   |              | 
!  d      | integer |           |          |         | plain   |              | 
! Inherits: inht2,
!           inhs1
! Distribute By: ROUND ROBIN
! Location Nodes: ALL DATANODES
! 
! WITH RECURSIVE r AS (
!   SELECT 'inht1'::regclass AS inhrelid
! UNION ALL
!   SELECT c.inhrelid FROM pg_inherits c, r WHERE r.inhrelid = c.inhparent
! )
! SELECT a.attrelid::regclass, a.attname, a.attinhcount, e.expected
!   FROM (SELECT inhrelid, count(*) AS expected FROM pg_inherits
!         WHERE inhparent IN (SELECT inhrelid FROM r) GROUP BY inhrelid) e
!   JOIN pg_attribute a ON e.inhrelid = a.attrelid WHERE NOT attislocal
!   ORDER BY a.attrelid::regclass::name, a.attnum;
!  attrelid | attname | attinhcount | expected 
! ----------+---------+-------------+----------
!  inht2    | aaaa    |           1 |        1
!  inht2    | b       |           1 |        1
!  inht3    | aaaa    |           1 |        1
!  inht3    | b       |           1 |        1
!  inht4    | aaaa    |           2 |        2
!  inht4    | b       |           2 |        2
!  inht4    | x       |           1 |        2
!  inht4    | y       |           1 |        2
!  inhts    | aaaa    |           1 |        1
!  inhts    | b       |           2 |        1
!  inhts    | x       |           1 |        1
!  inhts    | c       |           1 |        1
! (12 rows)
! 
! DROP TABLE inht1, inhs1 CASCADE;
! NOTICE:  drop cascades to 4 other objects
! DETAIL:  drop cascades to table inht2
! drop cascades to table inhts
! drop cascades to table inht3
! drop cascades to table inht4
! -- Test non-inheritable indices [UNIQUE, EXCLUDE] constraints
! CREATE TABLE test_constraints (id int, val1 varchar, val2 int, UNIQUE(val1, val2));
! CREATE TABLE test_constraints_inh () INHERITS (test_constraints);
! \d+ test_constraints
!                                    Table "public.test_constraints"
!  Column |       Type        | Collation | Nullable | Default | Storage  | Stats target | Description 
! --------+-------------------+-----------+----------+---------+----------+--------------+-------------
!  id     | integer           |           |          |         | plain    |              | 
!  val1   | character varying |           |          |         | extended |              | 
!  val2   | integer           |           |          |         | plain    |              | 
! Indexes:
!     "test_constraints_val1_val2_key" UNIQUE CONSTRAINT, btree (val1, val2)
! Child tables: test_constraints_inh
! Distribute By: HASH(val1)
! Location Nodes: ALL DATANODES
! 
! ALTER TABLE ONLY test_constraints DROP CONSTRAINT test_constraints_val1_val2_key;
! \d+ test_constraints
!                                    Table "public.test_constraints"
!  Column |       Type        | Collation | Nullable | Default | Storage  | Stats target | Description 
! --------+-------------------+-----------+----------+---------+----------+--------------+-------------
!  id     | integer           |           |          |         | plain    |              | 
!  val1   | character varying |           |          |         | extended |              | 
!  val2   | integer           |           |          |         | plain    |              | 
! Child tables: test_constraints_inh
! Distribute By: HASH(val1)
! Location Nodes: ALL DATANODES
! 
! \d+ test_constraints_inh
!                                  Table "public.test_constraints_inh"
!  Column |       Type        | Collation | Nullable | Default | Storage  | Stats target | Description 
! --------+-------------------+-----------+----------+---------+----------+--------------+-------------
!  id     | integer           |           |          |         | plain    |              | 
!  val1   | character varying |           |          |         | extended |              | 
!  val2   | integer           |           |          |         | plain    |              | 
! Inherits: test_constraints
! Distribute By: HASH(val1)
! Location Nodes: ALL DATANODES
! 
! DROP TABLE test_constraints_inh;
! DROP TABLE test_constraints;
! CREATE TABLE test_ex_constraints (
!     c circle,
!     EXCLUDE USING gist (c WITH &&)
! );
! CREATE TABLE test_ex_constraints_inh () INHERITS (test_ex_constraints);
! \d+ test_ex_constraints
!                            Table "public.test_ex_constraints"
!  Column |  Type  | Collation | Nullable | Default | Storage | Stats target | Description 
! --------+--------+-----------+----------+---------+---------+--------------+-------------
!  c      | circle |           |          |         | plain   |              | 
! Indexes:
!     "test_ex_constraints_c_excl" EXCLUDE USING gist (c WITH &&)
! Child tables: test_ex_constraints_inh
! Distribute By: ROUND ROBIN
! Location Nodes: ALL DATANODES
! 
! ALTER TABLE test_ex_constraints DROP CONSTRAINT test_ex_constraints_c_excl;
! \d+ test_ex_constraints
!                            Table "public.test_ex_constraints"
!  Column |  Type  | Collation | Nullable | Default | Storage | Stats target | Description 
! --------+--------+-----------+----------+---------+---------+--------------+-------------
!  c      | circle |           |          |         | plain   |              | 
! Child tables: test_ex_constraints_inh
! Distribute By: ROUND ROBIN
! Location Nodes: ALL DATANODES
! 
! \d+ test_ex_constraints_inh
!                          Table "public.test_ex_constraints_inh"
!  Column |  Type  | Collation | Nullable | Default | Storage | Stats target | Description 
! --------+--------+-----------+----------+---------+---------+--------------+-------------
!  c      | circle |           |          |         | plain   |              | 
! Inherits: test_ex_constraints
! Distribute By: ROUND ROBIN
! Location Nodes: ALL DATANODES
! 
! DROP TABLE test_ex_constraints_inh;
! DROP TABLE test_ex_constraints;
! -- Test non-inheritable foreign key constraints
! CREATE TABLE test_primary_constraints(id int PRIMARY KEY);
! CREATE TABLE test_foreign_constraints(id1 int REFERENCES test_primary_constraints(id));
! CREATE TABLE test_foreign_constraints_inh () INHERITS (test_foreign_constraints);
! \d+ test_primary_constraints
!                          Table "public.test_primary_constraints"
!  Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
! --------+---------+-----------+----------+---------+---------+--------------+-------------
!  id     | integer |           | not null |         | plain   |              | 
! Indexes:
!     "test_primary_constraints_pkey" PRIMARY KEY, btree (id)
! Referenced by:
!     TABLE "test_foreign_constraints" CONSTRAINT "test_foreign_constraints_id1_fkey" FOREIGN KEY (id1) REFERENCES test_primary_constraints(id)
! Distribute By: HASH(id)
! Location Nodes: ALL DATANODES
! 
! \d+ test_foreign_constraints
!                          Table "public.test_foreign_constraints"
!  Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
! --------+---------+-----------+----------+---------+---------+--------------+-------------
!  id1    | integer |           |          |         | plain   |              | 
! Foreign-key constraints:
!     "test_foreign_constraints_id1_fkey" FOREIGN KEY (id1) REFERENCES test_primary_constraints(id)
! Child tables: test_foreign_constraints_inh
! Distribute By: HASH(id1)
! Location Nodes: ALL DATANODES
! 
! ALTER TABLE test_foreign_constraints DROP CONSTRAINT test_foreign_constraints_id1_fkey;
! \d+ test_foreign_constraints
!                          Table "public.test_foreign_constraints"
!  Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
! --------+---------+-----------+----------+---------+---------+--------------+-------------
!  id1    | integer |           |          |         | plain   |              | 
! Child tables: test_foreign_constraints_inh
! Distribute By: HASH(id1)
! Location Nodes: ALL DATANODES
! 
! \d+ test_foreign_constraints_inh
!                        Table "public.test_foreign_constraints_inh"
!  Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
! --------+---------+-----------+----------+---------+---------+--------------+-------------
!  id1    | integer |           |          |         | plain   |              | 
! Inherits: test_foreign_constraints
! Distribute By: HASH(id1)
! Location Nodes: ALL DATANODES
! 
! DROP TABLE test_foreign_constraints_inh;
! DROP TABLE test_foreign_constraints;
! DROP TABLE test_primary_constraints;
! -- Test that parent and child CHECK constraints can be created in either order
! create table p1(f1 int);
! create table p1_c1() inherits(p1);
! alter table p1 add constraint inh_check_constraint1 check (f1 > 0);
! alter table p1_c1 add constraint inh_check_constraint1 check (f1 > 0);
! NOTICE:  merging constraint "inh_check_constraint1" with inherited definition
! alter table p1_c1 add constraint inh_check_constraint2 check (f1 < 10);
! alter table p1 add constraint inh_check_constraint2 check (f1 < 10);
! NOTICE:  merging constraint "inh_check_constraint2" with inherited definition
! select conrelid::regclass::text as relname, conname, conislocal, coninhcount
! from pg_constraint where conname like 'inh\_check\_constraint%'
! order by 1, 2;
!  relname |        conname        | conislocal | coninhcount 
! ---------+-----------------------+------------+-------------
!  p1      | inh_check_constraint1 | t          |           0
!  p1      | inh_check_constraint2 | t          |           0
!  p1_c1   | inh_check_constraint1 | t          |           1
!  p1_c1   | inh_check_constraint2 | t          |           1
! (4 rows)
! 
! drop table p1 cascade;
! NOTICE:  drop cascades to table p1_c1
! -- Test that a valid child can have not-valid parent, but not vice versa
! create table invalid_check_con(f1 int);
! create table invalid_check_con_child() inherits(invalid_check_con);
! alter table invalid_check_con_child add constraint inh_check_constraint check(f1 > 0) not valid;
! alter table invalid_check_con add constraint inh_check_constraint check(f1 > 0); -- fail
! ERROR:  constraint "inh_check_constraint" conflicts with NOT VALID constraint on relation "invalid_check_con_child"
! alter table invalid_check_con_child drop constraint inh_check_constraint;
! insert into invalid_check_con values(0);
! alter table invalid_check_con_child add constraint inh_check_constraint check(f1 > 0);
! alter table invalid_check_con add constraint inh_check_constraint check(f1 > 0) not valid;
! NOTICE:  merging constraint "inh_check_constraint" with inherited definition
! insert into invalid_check_con values(0); -- fail
! ERROR:  new row for relation "invalid_check_con" violates check constraint "inh_check_constraint"
! DETAIL:  Failing row contains (0).
! insert into invalid_check_con_child values(0); -- fail
! ERROR:  new row for relation "invalid_check_con_child" violates check constraint "inh_check_constraint"
! DETAIL:  Failing row contains (0).
! select conrelid::regclass::text as relname, conname,
!        convalidated, conislocal, coninhcount, connoinherit
! from pg_constraint where conname like 'inh\_check\_constraint%'
! order by 1, 2;
!          relname         |       conname        | convalidated | conislocal | coninhcount | connoinherit 
! -------------------------+----------------------+--------------+------------+-------------+--------------
!  invalid_check_con       | inh_check_constraint | f            | t          |           0 | f
!  invalid_check_con_child | inh_check_constraint | t            | t          |           1 | f
! (2 rows)
! 
! -- We don't drop the invalid_check_con* tables, to test dump/reload with
! --
! -- Test parameterized append plans for inheritance trees
! --
! create temp table patest0 (id, x) as
!   select x, x from generate_series(0,1000) x;
! create temp table patest1() inherits (patest0);
! insert into patest1
!   select x, x from generate_series(0,1000) x;
! create temp table patest2() inherits (patest0);
! insert into patest2
!   select x, x from generate_series(0,1000) x;
! create index patest0i on patest0(id);
! create index patest1i on patest1(id);
! create index patest2i on patest2(id);
! vacuum analyze patest0;
! vacuum analyze patest1;
! vacuum analyze patest2;
! analyze int4_tbl;
! explain (costs off, num_nodes off, nodes off)
! select * from patest0 join (select f1 from int4_tbl where f1 = 0 limit 1) ss on id = f1;
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Nested Loop
!    ->  Limit
!          ->  Remote Subquery Scan on all
!                ->  Limit
!                      ->  Seq Scan on int4_tbl
!                            Filter: (f1 = 0)
!    ->  Materialize
!          ->  Remote Subquery Scan on all
!                ->  Append
!                      ->  Seq Scan on patest0
!                            Filter: (int4_tbl.f1 = id)
!                      ->  Bitmap Heap Scan on patest1
!                            Recheck Cond: (id = int4_tbl.f1)
!                            ->  Bitmap Index Scan on patest1i
!                                  Index Cond: (id = int4_tbl.f1)
!                      ->  Bitmap Heap Scan on patest2
!                            Recheck Cond: (id = int4_tbl.f1)
!                            ->  Bitmap Index Scan on patest2i
!                                  Index Cond: (id = int4_tbl.f1)
! (19 rows)
! 
! select * from patest0 join (select f1 from int4_tbl where f1 = 0 limit 1) ss on id = f1;
!  id | x | f1 
! ----+---+----
!   0 | 0 |  0
!   0 | 0 |  0
!   0 | 0 |  0
! (3 rows)
! 
! drop index patest2i;
! explain (costs off, num_nodes off, nodes off)
! select * from patest0 join (select f1 from int4_tbl where f1 = 0 limit 1) ss on id = f1;
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Nested Loop
!    ->  Limit
!          ->  Remote Subquery Scan on all
!                ->  Limit
!                      ->  Seq Scan on int4_tbl
!                            Filter: (f1 = 0)
!    ->  Materialize
!          ->  Remote Subquery Scan on all
!                ->  Append
!                      ->  Seq Scan on patest0
!                            Filter: (int4_tbl.f1 = id)
!                      ->  Bitmap Heap Scan on patest1
!                            Recheck Cond: (id = int4_tbl.f1)
!                            ->  Bitmap Index Scan on patest1i
!                                  Index Cond: (id = int4_tbl.f1)
!                      ->  Seq Scan on patest2
!                            Filter: (int4_tbl.f1 = id)
! (17 rows)
! 
! select * from patest0 join (select f1 from int4_tbl where f1 = 0 limit 1) ss on id = f1;
!  id | x | f1 
! ----+---+----
!   0 | 0 |  0
!   0 | 0 |  0
!   0 | 0 |  0
! (3 rows)
! 
! drop table patest0 cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table patest1
! drop cascades to table patest2
! --
! -- Test merge-append plans for inheritance trees
! --
! create table matest0 (id serial primary key, name text);
! create table matest1 (id integer primary key) inherits (matest0);
! NOTICE:  merging column "id" with inherited definition
! create table matest2 (id integer primary key) inherits (matest0);
! NOTICE:  merging column "id" with inherited definition
! create table matest3 (id integer primary key) inherits (matest0);
! NOTICE:  merging column "id" with inherited definition
! create index matest0i on matest0 ((1-id));
! create index matest1i on matest1 ((1-id));
! -- create index matest2i on matest2 ((1-id));  -- intentionally missing
! create index matest3i on matest3 ((1-id));
! insert into matest1 (name) values ('Test 1');
! insert into matest1 (name) values ('Test 2');
! insert into matest2 (name) values ('Test 3');
! insert into matest2 (name) values ('Test 4');
! insert into matest3 (name) values ('Test 5');
! insert into matest3 (name) values ('Test 6');
! set enable_indexscan = off;  -- force use of seqscan/sort, so no merge
! explain (verbose, costs off, nodes off) select * from matest0 order by 1-id;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: id, name, (1 - id)
!    Sort Key: (1 - id)
!    ->  Sort
!          Output: matest0.id, matest0.name, ((1 - matest0.id))
!          Sort Key: ((1 - matest0.id))
!          ->  Result
!                Output: matest0.id, matest0.name, (1 - matest0.id)
!                ->  Append
!                      ->  Seq Scan on public.matest0
!                            Output: matest0.id, matest0.name
!                      ->  Seq Scan on public.matest1
!                            Output: matest1.id, matest1.name
!                      ->  Seq Scan on public.matest2
!                            Output: matest2.id, matest2.name
!                      ->  Seq Scan on public.matest3
!                            Output: matest3.id, matest3.name
! (17 rows)
! 
! select * from matest0 order by 1-id;
!  id |  name  
! ----+--------
!   6 | Test 6
!   5 | Test 5
!   4 | Test 4
!   3 | Test 3
!   2 | Test 2
!   1 | Test 1
! (6 rows)
! 
! explain (verbose, costs off) select min(1-id) from matest0;
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Finalize Aggregate
!    Output: min((1 - id))
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          Output: PARTIAL min((1 - id))
!          ->  Partial Aggregate
!                Output: PARTIAL min((1 - matest0.id))
!                ->  Append
!                      ->  Seq Scan on public.matest0
!                            Output: matest0.id
!                      ->  Seq Scan on public.matest1
!                            Output: matest1.id
!                      ->  Seq Scan on public.matest2
!                            Output: matest2.id
!                      ->  Seq Scan on public.matest3
!                            Output: matest3.id
! (15 rows)
! 
! select min(1-id) from matest0;
!  min 
! -----
!   -5
! (1 row)
! 
! reset enable_indexscan;
! set enable_seqscan = off;  -- plan with fewest seqscans should be merge
! explain (verbose, costs off, nodes off) select * from matest0 order by 1-id;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: id, name, (1 - id)
!    Sort Key: (1 - id)
!    ->  Sort
!          Output: matest0.id, matest0.name, ((1 - matest0.id))
!          Sort Key: ((1 - matest0.id))
!          ->  Result
!                Output: matest0.id, matest0.name, (1 - matest0.id)
!                ->  Append
!                      ->  Index Scan using matest0i on public.matest0
!                            Output: matest0.id, matest0.name
!                      ->  Index Scan using matest1i on public.matest1
!                            Output: matest1.id, matest1.name
!                      ->  Seq Scan on public.matest2
!                            Output: matest2.id, matest2.name
!                      ->  Index Scan using matest3i on public.matest3
!                            Output: matest3.id, matest3.name
! (17 rows)
! 
! select * from matest0 order by 1-id;
!  id |  name  
! ----+--------
!   6 | Test 6
!   5 | Test 5
!   4 | Test 4
!   3 | Test 3
!   2 | Test 2
!   1 | Test 1
! (6 rows)
! 
! explain (verbose, costs off) select min(1-id) from matest0;
!                                   QUERY PLAN                                  
! ------------------------------------------------------------------------------
!  Finalize Aggregate
!    Output: min((1 - id))
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          Output: PARTIAL min((1 - id))
!          ->  Partial Aggregate
!                Output: PARTIAL min((1 - matest0.id))
!                ->  Append
!                      ->  Index Only Scan using matest0_pkey on public.matest0
!                            Output: matest0.id
!                      ->  Bitmap Heap Scan on public.matest1
!                            Output: matest1.id
!                            ->  Bitmap Index Scan on matest1_pkey
!                      ->  Bitmap Heap Scan on public.matest2
!                            Output: matest2.id
!                            ->  Bitmap Index Scan on matest2_pkey
!                      ->  Bitmap Heap Scan on public.matest3
!                            Output: matest3.id
!                            ->  Bitmap Index Scan on matest3_pkey
! (18 rows)
! 
! select min(1-id) from matest0;
!  min 
! -----
!   -5
! (1 row)
! 
! reset enable_seqscan;
! drop table matest0 cascade;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table matest1
! drop cascades to table matest2
! drop cascades to table matest3
! --
! -- Check that use of an index with an extraneous column doesn't produce
! -- a plan with extraneous sorting
! --
! create table matest0 (a int, b int, c int, d int);
! create table matest1 () inherits(matest0);
! create index matest0i on matest0 (b, c);
! create index matest1i on matest1 (b, c);
! set enable_nestloop = off;  -- we want a plan with two MergeAppends
! explain (costs off)
! select t1.* from matest0 t1, matest0 t2
! where t1.b = t2.b and t2.c = t2.d
! order by t1.b limit 10;
!                                        QUERY PLAN                                        
! -----------------------------------------------------------------------------------------
!  Limit
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          ->  Limit
!                ->  Sort
!                      Sort Key: t1.b
!                      ->  Hash Join
!                            Hash Cond: (t1.b = b)
!                            ->  Append
!                                  ->  Seq Scan on matest0 t1
!                                  ->  Seq Scan on matest1 t1_1
!                            ->  Hash
!                                  ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                        ->  Append
!                                              ->  Seq Scan on matest0 t2
!                                                    Filter: (c = d)
!                                              ->  Seq Scan on matest1 t2_1
!                                                    Filter: (c = d)
! (17 rows)
! 
! reset enable_nestloop;
! drop table matest0 cascade;
! NOTICE:  drop cascades to table matest1
! --
! -- Test merge-append for UNION ALL append relations
! --
! set enable_seqscan = off;
! set enable_indexscan = on;
! set enable_bitmapscan = off;
! -- Check handling of duplicated, constant, or volatile targetlist items
! explain (costs off, num_nodes off, nodes off)
! SELECT thousand, tenthous FROM tenk1
! UNION ALL
! SELECT thousand, thousand FROM tenk1
! ORDER BY thousand, tenthous;
!                                   QUERY PLAN                                   
! -------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Sort
!          Sort Key: tenk1.thousand, tenk1.tenthous
!          ->  Append
!                ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!                ->  Index Only Scan using tenk1_thous_tenthous on tenk1 tenk1_1
! (6 rows)
! 
! explain (costs off, num_nodes off, nodes off)
! SELECT thousand, tenthous, thousand+tenthous AS x FROM tenk1
! UNION ALL
! SELECT 42, 42, hundred FROM tenk1
! ORDER BY thousand, tenthous;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Sort
!          Sort Key: tenk1.thousand, tenk1.tenthous
!          ->  Append
!                ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!                ->  Index Only Scan using tenk1_hundred on tenk1 tenk1_1
! (6 rows)
! 
! explain (costs off, num_nodes off, nodes off)
! SELECT thousand, tenthous FROM tenk1
! UNION ALL
! SELECT thousand, random()::integer FROM tenk1
! ORDER BY thousand, tenthous;
!                                   QUERY PLAN                                   
! -------------------------------------------------------------------------------
!  Merge Append
!    Sort Key: tenk1.thousand, tenk1.tenthous
!    ->  Remote Subquery Scan on all
!          ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!    ->  Remote Subquery Scan on all
!          ->  Sort
!                Sort Key: tenk1_1.thousand, ((random())::integer)
!                ->  Index Only Scan using tenk1_thous_tenthous on tenk1 tenk1_1
! (8 rows)
! 
! -- Check min/max aggregate optimization
! explain (costs off, num_nodes off, nodes off)
! SELECT min(x) FROM
!   (SELECT unique1 AS x FROM tenk1 a
!    UNION ALL
!    SELECT unique2 AS x FROM tenk1 b) s;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Append
!                      ->  Index Only Scan using tenk1_unique1 on tenk1 a
!                      ->  Index Only Scan using tenk1_unique2 on tenk1 b
! (6 rows)
! 
! explain (costs off, num_nodes off, nodes off)
! SELECT min(y) FROM
!   (SELECT unique1 AS x, unique1 AS y FROM tenk1 a
!    UNION ALL
!    SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Append
!                      ->  Index Only Scan using tenk1_unique1 on tenk1 a
!                      ->  Index Only Scan using tenk1_unique2 on tenk1 b
! (6 rows)
! 
! -- XXX planner doesn't recognize that index on unique2 is sufficiently sorted
! explain (costs off, num_nodes off, nodes off)
! SELECT x, y FROM
!   (SELECT thousand AS x, tenthous AS y FROM tenk1 a
!    UNION ALL
!    SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s
! ORDER BY x, y;
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Sort
!          Sort Key: a.thousand, a.tenthous
!          ->  Append
!                ->  Index Only Scan using tenk1_thous_tenthous on tenk1 a
!                ->  Index Only Scan using tenk1_unique2 on tenk1 b
! (6 rows)
! 
! -- exercise rescan code path via a repeatedly-evaluated subquery
! explain (costs off)
! SELECT
!     ARRAY(SELECT f.i FROM (
!         (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)
!         UNION ALL
!         (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)
!     ) f(i)
!     ORDER BY f.i LIMIT 10)
! FROM generate_series(1, 3) g(i);
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Function Scan on generate_series g
!    SubPlan 1
!      ->  Limit
!            ->  Merge Append
!                  Sort Key: ((d.d + g.i))
!                  ->  Sort
!                        Sort Key: ((d.d + g.i))
!                        ->  Function Scan on generate_series d
!                  ->  Sort
!                        Sort Key: ((d_1.d + g.i))
!                        ->  Function Scan on generate_series d_1
! (11 rows)
! 
! SELECT
!     ARRAY(SELECT f.i FROM (
!         (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)
!         UNION ALL
!         (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)
!     ) f(i)
!     ORDER BY f.i LIMIT 10)
! FROM generate_series(1, 3) g(i);
!             array             
! ------------------------------
!  {1,5,6,8,11,11,14,16,17,20}
!  {2,6,7,9,12,12,15,17,18,21}
!  {3,7,8,10,13,13,16,18,19,22}
! (3 rows)
! 
! reset enable_seqscan;
! reset enable_indexscan;
! reset enable_bitmapscan;
! --
! -- Check that constraint exclusion works correctly with partitions using
! -- implicit constraints generated from the partition bound information.
! --
! create table list_parted (
! 	a	varchar
! ) partition by list (a);
! create table part_ab_cd partition of list_parted for values in ('ab', 'cd');
! create table part_ef_gh partition of list_parted for values in ('ef', 'gh');
! create table part_null_xy partition of list_parted for values in (null, 'xy');
! explain (costs off) select * from list_parted;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_ab_cd
!          ->  Seq Scan on part_ef_gh
!          ->  Seq Scan on part_null_xy
! (5 rows)
! 
! explain (costs off) select * from list_parted where a is null;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_null_xy
!                Filter: (a IS NULL)
! (4 rows)
! 
! explain (costs off) select * from list_parted where a is not null;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_ab_cd
!                Filter: (a IS NOT NULL)
!          ->  Seq Scan on part_ef_gh
!                Filter: (a IS NOT NULL)
!          ->  Seq Scan on part_null_xy
!                Filter: (a IS NOT NULL)
! (8 rows)
! 
! explain (costs off) select * from list_parted where a in ('ab', 'cd', 'ef');
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_ab_cd
!                Filter: ((a)::text = ANY ('{ab,cd,ef}'::text[]))
!          ->  Seq Scan on part_ef_gh
!                Filter: ((a)::text = ANY ('{ab,cd,ef}'::text[]))
! (6 rows)
! 
! explain (costs off) select * from list_parted where a = 'ab' or a in (null, 'cd');
!                                          QUERY PLAN                                          
! ---------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_ab_cd
!                Filter: (((a)::text = 'ab'::text) OR ((a)::text = ANY ('{NULL,cd}'::text[])))
!          ->  Seq Scan on part_ef_gh
!                Filter: (((a)::text = 'ab'::text) OR ((a)::text = ANY ('{NULL,cd}'::text[])))
!          ->  Seq Scan on part_null_xy
!                Filter: (((a)::text = 'ab'::text) OR ((a)::text = ANY ('{NULL,cd}'::text[])))
! (8 rows)
! 
! explain (costs off) select * from list_parted where a = 'ab';
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_ab_cd
!                Filter: ((a)::text = 'ab'::text)
! (4 rows)
! 
! create table range_list_parted (
! 	a	int,
! 	b	char(2)
! ) partition by range (a);
! create table part_1_10 partition of range_list_parted for values from (1) to (10) partition by list (b);
! create table part_1_10_ab partition of part_1_10 for values in ('ab');
! create table part_1_10_cd partition of part_1_10 for values in ('cd');
! create table part_10_20 partition of range_list_parted for values from (10) to (20) partition by list (b);
! create table part_10_20_ab partition of part_10_20 for values in ('ab');
! create table part_10_20_cd partition of part_10_20 for values in ('cd');
! create table part_21_30 partition of range_list_parted for values from (21) to (30) partition by list (b);
! create table part_21_30_ab partition of part_21_30 for values in ('ab');
! create table part_21_30_cd partition of part_21_30 for values in ('cd');
! create table part_40_inf partition of range_list_parted for values from (40) to (maxvalue) partition by list (b);
! create table part_40_inf_ab partition of part_40_inf for values in ('ab');
! create table part_40_inf_cd partition of part_40_inf for values in ('cd');
! create table part_40_inf_null partition of part_40_inf for values in (null);
! explain (costs off) select * from range_list_parted;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_1_10_ab
!          ->  Seq Scan on part_1_10_cd
!          ->  Seq Scan on part_10_20_ab
!          ->  Seq Scan on part_10_20_cd
!          ->  Seq Scan on part_21_30_ab
!          ->  Seq Scan on part_21_30_cd
!          ->  Seq Scan on part_40_inf_ab
!          ->  Seq Scan on part_40_inf_cd
!          ->  Seq Scan on part_40_inf_null
! (11 rows)
! 
! explain (costs off) select * from range_list_parted where a = 5;
!                 QUERY PLAN                
! ------------------------------------------
!  Remote Subquery Scan on all (datanode_1)
!    ->  Append
!          ->  Seq Scan on part_1_10_ab
!                Filter: (a = 5)
!          ->  Seq Scan on part_1_10_cd
!                Filter: (a = 5)
! (6 rows)
! 
! explain (costs off) select * from range_list_parted where b = 'ab';
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_1_10_ab
!                Filter: (b = 'ab'::bpchar)
!          ->  Seq Scan on part_10_20_ab
!                Filter: (b = 'ab'::bpchar)
!          ->  Seq Scan on part_21_30_ab
!                Filter: (b = 'ab'::bpchar)
!          ->  Seq Scan on part_40_inf_ab
!                Filter: (b = 'ab'::bpchar)
! (10 rows)
! 
! explain (costs off) select * from range_list_parted where a between 3 and 23 and b in ('ab');
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_1_10_ab
!                Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))
!          ->  Seq Scan on part_10_20_ab
!                Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))
!          ->  Seq Scan on part_21_30_ab
!                Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))
! (8 rows)
! 
! /* Should select no rows because range partition key cannot be null */
! explain (costs off) select * from range_list_parted where a is null;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! /* Should only select rows from the null-accepting partition */
! explain (costs off) select * from range_list_parted where b is null;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_40_inf_null
!                Filter: (b IS NULL)
! (4 rows)
! 
! explain (costs off) select * from range_list_parted where a is not null and a < 67;
!                       QUERY PLAN                      
! ------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_1_10_ab
!                Filter: ((a IS NOT NULL) AND (a < 67))
!          ->  Seq Scan on part_1_10_cd
!                Filter: ((a IS NOT NULL) AND (a < 67))
!          ->  Seq Scan on part_10_20_ab
!                Filter: ((a IS NOT NULL) AND (a < 67))
!          ->  Seq Scan on part_10_20_cd
!                Filter: ((a IS NOT NULL) AND (a < 67))
!          ->  Seq Scan on part_21_30_ab
!                Filter: ((a IS NOT NULL) AND (a < 67))
!          ->  Seq Scan on part_21_30_cd
!                Filter: ((a IS NOT NULL) AND (a < 67))
!          ->  Seq Scan on part_40_inf_ab
!                Filter: ((a IS NOT NULL) AND (a < 67))
!          ->  Seq Scan on part_40_inf_cd
!                Filter: ((a IS NOT NULL) AND (a < 67))
!          ->  Seq Scan on part_40_inf_null
!                Filter: ((a IS NOT NULL) AND (a < 67))
! (20 rows)
! 
! explain (costs off) select * from range_list_parted where a >= 30;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on part_40_inf_ab
!                Filter: (a >= 30)
!          ->  Seq Scan on part_40_inf_cd
!                Filter: (a >= 30)
!          ->  Seq Scan on part_40_inf_null
!                Filter: (a >= 30)
! (8 rows)
! 
! drop table list_parted;
! drop table range_list_parted;
! -- check that constraint exclusion is able to cope with the partition
! -- constraint emitted for multi-column range partitioned tables
! create table mcrparted (a int, b int, c int) partition by range (a, abs(b), c);
! create table mcrparted_def partition of mcrparted default;
! create table mcrparted0 partition of mcrparted for values from (minvalue, minvalue, minvalue) to (1, 1, 1);
! create table mcrparted1 partition of mcrparted for values from (1, 1, 1) to (10, 5, 10);
! create table mcrparted2 partition of mcrparted for values from (10, 5, 10) to (10, 10, 10);
! create table mcrparted3 partition of mcrparted for values from (11, 1, 1) to (20, 10, 10);
! create table mcrparted4 partition of mcrparted for values from (20, 10, 10) to (20, 20, 20);
! create table mcrparted5 partition of mcrparted for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue);
! explain (costs off) select * from mcrparted where a = 0;	-- scans mcrparted0, mcrparted_def
!                 QUERY PLAN                
! ------------------------------------------
!  Remote Subquery Scan on all (datanode_2)
!    ->  Append
!          ->  Seq Scan on mcrparted0
!                Filter: (a = 0)
! (4 rows)
! 
! explain (costs off) select * from mcrparted where a = 10 and abs(b) < 5;	-- scans mcrparted1, mcrparted_def
!                     QUERY PLAN                     
! ---------------------------------------------------
!  Remote Subquery Scan on all (datanode_2)
!    ->  Append
!          ->  Seq Scan on mcrparted1
!                Filter: ((a = 10) AND (abs(b) < 5))
! (4 rows)
! 
! explain (costs off) select * from mcrparted where a = 10 and abs(b) = 5;	-- scans mcrparted1, mcrparted2, mcrparted_def, mcrparted_def
!                     QUERY PLAN                     
! ---------------------------------------------------
!  Remote Subquery Scan on all (datanode_2)
!    ->  Append
!          ->  Seq Scan on mcrparted1
!                Filter: ((a = 10) AND (abs(b) = 5))
!          ->  Seq Scan on mcrparted2
!                Filter: ((a = 10) AND (abs(b) = 5))
! (6 rows)
! 
! explain (costs off) select * from mcrparted where abs(b) = 5;	-- scans all partitions
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on mcrparted0
!                Filter: (abs(b) = 5)
!          ->  Seq Scan on mcrparted1
!                Filter: (abs(b) = 5)
!          ->  Seq Scan on mcrparted2
!                Filter: (abs(b) = 5)
!          ->  Seq Scan on mcrparted3
!                Filter: (abs(b) = 5)
!          ->  Seq Scan on mcrparted4
!                Filter: (abs(b) = 5)
!          ->  Seq Scan on mcrparted5
!                Filter: (abs(b) = 5)
! (14 rows)
! 
! explain (costs off) select * from mcrparted where a > -1;	-- scans all partitions
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Append
!          ->  Seq Scan on mcrparted0
!                Filter: (a > '-1'::integer)
!          ->  Seq Scan on mcrparted1
!                Filter: (a > '-1'::integer)
!          ->  Seq Scan on mcrparted2
!                Filter: (a > '-1'::integer)
!          ->  Seq Scan on mcrparted3
!                Filter: (a > '-1'::integer)
!          ->  Seq Scan on mcrparted4
!                Filter: (a > '-1'::integer)
!          ->  Seq Scan on mcrparted5
!                Filter: (a > '-1'::integer)
! (14 rows)
! 
! explain (costs off) select * from mcrparted where a = 20 and abs(b) = 10 and c > 10;	-- scans mcrparted4
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_2)
!    ->  Append
!          ->  Seq Scan on mcrparted4
!                Filter: ((c > 10) AND (a = 20) AND (abs(b) = 10))
! (4 rows)
! 
! explain (costs off) select * from mcrparted where a = 20 and c > 20; -- scans mcrparted3, mcrparte4, mcrparte5
!                   QUERY PLAN                   
! -----------------------------------------------
!  Remote Subquery Scan on all (datanode_2)
!    ->  Append
!          ->  Seq Scan on mcrparted3
!                Filter: ((c > 20) AND (a = 20))
!          ->  Seq Scan on mcrparted4
!                Filter: ((c > 20) AND (a = 20))
!          ->  Seq Scan on mcrparted5
!                Filter: ((c > 20) AND (a = 20))
! (8 rows)
! 
! drop table mcrparted;
! -- check that partitioned table Appends cope with being referenced in
! -- subplans
! create table parted_minmax (a int, b varchar(16)) partition by range (a);
! create table parted_minmax1 partition of parted_minmax for values from (1) to (10);
! create index parted_minmax1i on parted_minmax1 (a, b);
! insert into parted_minmax values (1,'12345');
! explain (costs off) select min(a), max(a) from parted_minmax where b = '12345';
!                                                     QUERY PLAN                                                     
! -------------------------------------------------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                  ->  Limit
!                        ->  Merge Append
!                              Sort Key: parted_minmax1.a
!                              ->  Index Only Scan using parted_minmax1i on parted_minmax1
!                                    Index Cond: ((a IS NOT NULL) AND (b = '12345'::text))
!    InitPlan 2 (returns $1)
!      ->  Limit
!            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                  ->  Limit
!                        ->  Merge Append
!                              Sort Key: parted_minmax1_1.a DESC
!                              ->  Index Only Scan Backward using parted_minmax1i on parted_minmax1 parted_minmax1_1
!                                    Index Cond: ((a IS NOT NULL) AND (b = '12345'::text))
! (17 rows)
! 
! select min(a), max(a) from parted_minmax where b = '12345';
!  min | max 
! -----+-----
!    1 |   1
! (1 row)
! 
! drop table parted_minmax;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/create_table_like.out"	2025-07-31 16:07:14.981068200 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/create_table_like.out"	2025-07-31 16:39:29.050088448 +0800
***************
*** 1,329 ****
! /* Test inheritance of structure (LIKE) */
! CREATE TABLE inhx (xx text DEFAULT 'text');
! /*
!  * Test double inheritance
!  *
!  * Ensure that defaults are NOT included unless
!  * INCLUDING DEFAULTS is specified
!  */
! CREATE TABLE ctla (aa TEXT);
! CREATE TABLE ctlb (bb TEXT) INHERITS (ctla);
! CREATE TABLE foo (LIKE nonexistent);
! ERROR:  relation "nonexistent" does not exist
! LINE 1: CREATE TABLE foo (LIKE nonexistent);
!                                ^
! CREATE TABLE inhe (ee text, LIKE inhx) inherits (ctlb);
! INSERT INTO inhe VALUES ('ee-col1', 'ee-col2', DEFAULT, 'ee-col4');
! SELECT * FROM inhe; /* Columns aa, bb, xx value NULL, ee */
!    aa    |   bb    | ee |   xx    
! ---------+---------+----+---------
!  ee-col1 | ee-col2 |    | ee-col4
! (1 row)
! 
! SELECT * FROM inhx; /* Empty set since LIKE inherits structure only */
!  xx 
! ----
! (0 rows)
! 
! SELECT * FROM ctlb; /* Has ee entry */
!    aa    |   bb    
! ---------+---------
!  ee-col1 | ee-col2
! (1 row)
! 
! SELECT * FROM ctla; /* Has ee entry */
!    aa    
! ---------
!  ee-col1
! (1 row)
! 
! CREATE TABLE inhf (LIKE inhx, LIKE inhx); /* Throw error */
! ERROR:  column "xx" specified more than once
! CREATE TABLE inhf (LIKE inhx INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
! INSERT INTO inhf DEFAULT VALUES;
! SELECT * FROM inhf; /* Single entry with value 'text' */
!   xx  
! ------
!  text
! (1 row)
! 
! ALTER TABLE inhx add constraint foo CHECK (xx = 'text');
! ALTER TABLE inhx ADD PRIMARY KEY (xx);
! CREATE TABLE inhg (LIKE inhx); /* Doesn't copy constraint */
! INSERT INTO inhg VALUES ('foo');
! DROP TABLE inhg;
! CREATE TABLE inhg (x text, LIKE inhx INCLUDING CONSTRAINTS, y text); /* Copies constraints */
! INSERT INTO inhg VALUES ('x', 'text', 'y'); /* Succeeds */
! INSERT INTO inhg VALUES ('x', 'text', 'y'); /* Succeeds -- Unique constraints not copied */
! INSERT INTO inhg VALUES ('x', 'foo',  'y');  /* fails due to constraint */
! ERROR:  new row for relation "inhg" violates check constraint "foo"
! DETAIL:  Failing row contains (x, foo, y).
! SELECT * FROM inhg; /* Two records with three columns in order x=x, xx=text, y=y */
!  x |  xx  | y 
! ---+------+---
!  x | text | y
!  x | text | y
! (2 rows)
! 
! DROP TABLE inhg;
! CREATE TABLE test_like_id_1 (a int GENERATED ALWAYS AS IDENTITY, b text);
! \d test_like_id_1
!                      Table "public.test_like_id_1"
!  Column |  Type   | Collation | Nullable |           Default            
! --------+---------+-----------+----------+------------------------------
!  a      | integer |           | not null | generated always as identity
!  b      | text    |           |          | 
! 
! INSERT INTO test_like_id_1 (b) VALUES ('b1');
! SELECT * FROM test_like_id_1;
!  a | b  
! ---+----
!  1 | b1
! (1 row)
! 
! CREATE TABLE test_like_id_2 (LIKE test_like_id_1);
! \d test_like_id_2
!            Table "public.test_like_id_2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
!  b      | text    |           |          | 
! 
! INSERT INTO test_like_id_2 (b) VALUES ('b2');
! ERROR:  null value in column "a" violates not-null constraint
! DETAIL:  Failing row contains (null, b2).
! SELECT * FROM test_like_id_2;  -- identity was not copied
!  a | b 
! ---+---
! (0 rows)
! 
! CREATE TABLE test_like_id_3 (LIKE test_like_id_1 INCLUDING IDENTITY);
! \d test_like_id_3
!                      Table "public.test_like_id_3"
!  Column |  Type   | Collation | Nullable |           Default            
! --------+---------+-----------+----------+------------------------------
!  a      | integer |           | not null | generated always as identity
!  b      | text    |           |          | 
! 
! INSERT INTO test_like_id_3 (b) VALUES ('b3');
! SELECT * FROM test_like_id_3;  -- identity was copied and applied
!  a | b  
! ---+----
!  1 | b3
! (1 row)
! 
! DROP TABLE test_like_id_1, test_like_id_2, test_like_id_3;
! CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, y text) DISTRIBUTE BY REPLICATION; /* copies indexes */
! INSERT INTO inhg VALUES (5, 10);
! INSERT INTO inhg VALUES (20, 10); -- should fail
! ERROR:  duplicate key value violates unique constraint "inhg_pkey"
! DETAIL:  Key (xx)=(10) already exists.
! DROP TABLE inhg;
! /* Multiple primary keys creation should fail */
! CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, PRIMARY KEY(x)); /* fails */
! ERROR:  multiple primary keys for table "inhg" are not allowed
! CREATE TABLE inhz (xx text DEFAULT 'text', yy int UNIQUE) DISTRIBUTE BY REPLICATION;
! CREATE UNIQUE INDEX inhz_xx_idx on inhz (xx) WHERE xx <> 'test';
! /* Ok to create multiple unique indexes */
! CREATE TABLE inhg (x text UNIQUE, LIKE inhz INCLUDING INDEXES) DISTRIBUTE BY REPLICATION;
! INSERT INTO inhg (xx, yy, x) VALUES ('test', 5, 10);
! INSERT INTO inhg (xx, yy, x) VALUES ('test', 10, 15);
! INSERT INTO inhg (xx, yy, x) VALUES ('foo', 10, 15); -- should fail
! ERROR:  duplicate key value violates unique constraint "inhg_x_key"
! DETAIL:  Key (x)=(15) already exists.
! DROP TABLE inhg;
! DROP TABLE inhz;
! -- including storage and comments
! CREATE TABLE ctlt1 (a text CHECK (length(a) > 2) PRIMARY KEY, b text);
! CREATE INDEX ctlt1_b_key ON ctlt1 (b);
! CREATE INDEX ctlt1_fnidx ON ctlt1 ((a || b));
! COMMENT ON COLUMN ctlt1.a IS 'A';
! COMMENT ON COLUMN ctlt1.b IS 'B';
! COMMENT ON CONSTRAINT ctlt1_a_check ON ctlt1 IS 't1_a_check';
! COMMENT ON INDEX ctlt1_pkey IS 'index pkey';
! COMMENT ON INDEX ctlt1_b_key IS 'index b_key';
! ALTER TABLE ctlt1 ALTER COLUMN a SET STORAGE MAIN;
! CREATE TABLE ctlt2 (c text);
! ALTER TABLE ctlt2 ALTER COLUMN c SET STORAGE EXTERNAL;
! COMMENT ON COLUMN ctlt2.c IS 'C';
! CREATE TABLE ctlt3 (a text CHECK (length(a) < 5), c text);
! ALTER TABLE ctlt3 ALTER COLUMN c SET STORAGE EXTERNAL;
! ALTER TABLE ctlt3 ALTER COLUMN a SET STORAGE MAIN;
! COMMENT ON COLUMN ctlt3.a IS 'A3';
! COMMENT ON COLUMN ctlt3.c IS 'C';
! COMMENT ON CONSTRAINT ctlt3_a_check ON ctlt3 IS 't3_a_check';
! CREATE TABLE ctlt4 (a text, c text);
! ALTER TABLE ctlt4 ALTER COLUMN c SET STORAGE EXTERNAL;
! CREATE TABLE ctlt12_storage (LIKE ctlt1 INCLUDING STORAGE, LIKE ctlt2 INCLUDING STORAGE);
! \d+ ctlt12_storage
!                              Table "public.ctlt12_storage"
!  Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
! --------+------+-----------+----------+---------+----------+--------------+-------------
!  a      | text |           | not null |         | main     |              | 
!  b      | text |           |          |         | extended |              | 
!  c      | text |           |          |         | external |              | 
! Distribute By: HASH(a)
! Location Nodes: ALL DATANODES
! 
! CREATE TABLE ctlt12_comments (LIKE ctlt1 INCLUDING COMMENTS, LIKE ctlt2 INCLUDING COMMENTS);
! \d+ ctlt12_comments
!                              Table "public.ctlt12_comments"
!  Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
! --------+------+-----------+----------+---------+----------+--------------+-------------
!  a      | text |           | not null |         | extended |              | A
!  b      | text |           |          |         | extended |              | B
!  c      | text |           |          |         | extended |              | C
! Distribute By: HASH(a)
! Location Nodes: ALL DATANODES
! 
! CREATE TABLE ctlt1_inh (LIKE ctlt1 INCLUDING CONSTRAINTS INCLUDING COMMENTS) INHERITS (ctlt1);
! NOTICE:  merging column "a" with inherited definition
! NOTICE:  merging column "b" with inherited definition
! NOTICE:  merging constraint "ctlt1_a_check" with inherited definition
! \d+ ctlt1_inh
!                                 Table "public.ctlt1_inh"
!  Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
! --------+------+-----------+----------+---------+----------+--------------+-------------
!  a      | text |           | not null |         | main     |              | A
!  b      | text |           |          |         | extended |              | B
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
! Inherits: ctlt1
! Distribute By: HASH(a)
! Location Nodes: ALL DATANODES
! 
! SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt1_inh'::regclass;
!  description 
! -------------
!  t1_a_check
! (1 row)
! 
! CREATE TABLE ctlt13_inh () INHERITS (ctlt1, ctlt3);
! NOTICE:  merging multiple inherited definitions of column "a"
! \d+ ctlt13_inh
!                                Table "public.ctlt13_inh"
!  Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
! --------+------+-----------+----------+---------+----------+--------------+-------------
!  a      | text |           | not null |         | main     |              | 
!  b      | text |           |          |         | extended |              | 
!  c      | text |           |          |         | external |              | 
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
!     "ctlt3_a_check" CHECK (length(a) < 5)
! Inherits: ctlt1,
!           ctlt3
! Distribute By: HASH(a)
! Location Nodes: ALL DATANODES
! 
! CREATE TABLE ctlt13_like (LIKE ctlt3 INCLUDING CONSTRAINTS INCLUDING COMMENTS INCLUDING STORAGE) INHERITS (ctlt1);
! NOTICE:  merging column "a" with inherited definition
! \d+ ctlt13_like
!                                Table "public.ctlt13_like"
!  Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
! --------+------+-----------+----------+---------+----------+--------------+-------------
!  a      | text |           | not null |         | main     |              | A3
!  b      | text |           |          |         | extended |              | 
!  c      | text |           |          |         | external |              | C
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
!     "ctlt3_a_check" CHECK (length(a) < 5)
! Inherits: ctlt1
! Distribute By: HASH(a)
! Location Nodes: ALL DATANODES
! 
! SELECT description FROM pg_description, pg_constraint c WHERE classoid = 'pg_constraint'::regclass AND objoid = c.oid AND c.conrelid = 'ctlt13_like'::regclass;
!  description 
! -------------
!  t3_a_check
! (1 row)
! 
! CREATE TABLE ctlt_all (LIKE ctlt1 INCLUDING ALL);
! \d+ ctlt_all
!                                 Table "public.ctlt_all"
!  Column | Type | Collation | Nullable | Default | Storage  | Stats target | Description 
! --------+------+-----------+----------+---------+----------+--------------+-------------
!  a      | text |           | not null |         | main     |              | A
!  b      | text |           |          |         | extended |              | B
! Indexes:
!     "ctlt_all_pkey" PRIMARY KEY, btree (a)
!     "ctlt_all_b_idx" btree (b)
!     "ctlt_all_expr_idx" btree ((a || b))
! Check constraints:
!     "ctlt1_a_check" CHECK (length(a) > 2)
! Distribute By: HASH(a)
! Location Nodes: ALL DATANODES
! 
! SELECT c.relname, objsubid, description FROM pg_description, pg_index i, pg_class c WHERE classoid = 'pg_class'::regclass AND objoid = i.indexrelid AND c.oid = i.indexrelid AND i.indrelid = 'ctlt_all'::regclass ORDER BY c.relname, objsubid;
!     relname     | objsubid | description 
! ----------------+----------+-------------
!  ctlt_all_b_idx |        0 | index b_key
!  ctlt_all_pkey  |        0 | index pkey
! (2 rows)
! 
! CREATE TABLE inh_error1 () INHERITS (ctlt1, ctlt4);
! NOTICE:  merging multiple inherited definitions of column "a"
! ERROR:  inherited column "a" has a storage parameter conflict
! DETAIL:  MAIN versus EXTENDED
! CREATE TABLE inh_error2 (LIKE ctlt4 INCLUDING STORAGE) INHERITS (ctlt1);
! NOTICE:  merging column "a" with inherited definition
! ERROR:  column "a" has a storage parameter conflict
! DETAIL:  MAIN versus EXTENDED
! DROP TABLE ctlt1, ctlt2, ctlt3, ctlt4, ctlt12_storage, ctlt12_comments, ctlt1_inh, ctlt13_inh, ctlt13_like, ctlt_all, ctla, ctlb CASCADE;
! NOTICE:  drop cascades to table inhe
! /* LIKE with other relation kinds */
! CREATE TABLE ctlt4 (a int, b text);
! CREATE SEQUENCE ctlseq1;
! CREATE TABLE ctlt10 (LIKE ctlseq1);  -- fail
! ERROR:  "ctlseq1" is not a table, view, materialized view, composite type, or foreign table
! LINE 1: CREATE TABLE ctlt10 (LIKE ctlseq1);
!                                   ^
! CREATE VIEW ctlv1 AS SELECT * FROM ctlt4;
! CREATE TABLE ctlt11 (LIKE ctlv1);
! ERROR:  Postgres-XL does not support VIEW in LIKE clauses
! DETAIL:  The feature is not currently supported
! CREATE TABLE ctlt11a (LIKE ctlv1 INCLUDING ALL);
! ERROR:  Postgres-XL does not support VIEW in LIKE clauses
! DETAIL:  The feature is not currently supported
! CREATE TYPE ctlty1 AS (a int, b text);
! CREATE TABLE ctlt12 (LIKE ctlty1);
! DROP SEQUENCE ctlseq1;
! DROP TYPE ctlty1;
! DROP VIEW ctlv1;
! DROP TABLE IF EXISTS ctlt4, ctlt10, ctlt11, ctlt11a, ctlt12;
! NOTICE:  table "ctlt10" does not exist, skipping
! NOTICE:  table "ctlt11" does not exist, skipping
! NOTICE:  table "ctlt11a" does not exist, skipping
! /* LIKE WITH OIDS */
! CREATE TABLE has_oid (x INTEGER) WITH OIDS;
! CREATE TABLE no_oid (y INTEGER);
! CREATE TABLE like_test (z INTEGER, LIKE has_oid);
! SELECT oid FROM like_test;
!  oid 
! -----
! (0 rows)
! 
! CREATE TABLE like_test2 (z INTEGER, LIKE no_oid);
! SELECT oid FROM like_test2; -- fail
! ERROR:  column "oid" does not exist
! LINE 1: SELECT oid FROM like_test2;
!                ^
! CREATE TABLE like_test3 (z INTEGER, LIKE has_oid, LIKE no_oid);
! SELECT oid FROM like_test3;
!  oid 
! -----
! (0 rows)
! 
! CREATE TABLE like_test4 (z INTEGER, PRIMARY KEY(oid), LIKE has_oid);
! SELECT oid FROM like_test4;
!  oid 
! -----
! (0 rows)
! 
! CREATE TABLE like_test5 (z INTEGER, LIKE no_oid) WITH OIDS;
! SELECT oid FROM like_test5;
!  oid 
! -----
! (0 rows)
! 
! DROP TABLE has_oid, no_oid, like_test, like_test2, like_test3,
!   like_test4, like_test5;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/typed_table.out"	2025-07-31 16:07:15.006067803 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/typed_table.out"	2025-07-31 16:39:29.062088192 +0800
***************
*** 1,133 ****
! CREATE TABLE ttable1 OF nothing;
! ERROR:  type "nothing" does not exist
! CREATE TYPE person_type AS (id int, name text);
! CREATE TABLE persons OF person_type;
! CREATE TABLE IF NOT EXISTS persons OF person_type;
! NOTICE:  relation "persons" already exists, skipping
! SELECT * FROM persons;
!  id | name 
! ----+------
! (0 rows)
! 
! \d persons
!               Table "public.persons"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  id     | integer |           |          | 
!  name   | text    |           |          | 
! Typed table of type: person_type
! 
! CREATE FUNCTION get_all_persons() RETURNS SETOF person_type
! LANGUAGE SQL
! AS $$
!     SELECT * FROM persons;
! $$;
! SELECT * FROM get_all_persons();
!  id | name 
! ----+------
! (0 rows)
! 
! -- certain ALTER TABLE operations on typed tables are not allowed
! ALTER TABLE persons ADD COLUMN comment text;
! ERROR:  cannot add column to typed table
! ALTER TABLE persons DROP COLUMN name;
! ERROR:  cannot drop column from typed table
! ALTER TABLE persons RENAME COLUMN id TO num;
! ERROR:  cannot rename column of typed table
! ALTER TABLE persons ALTER COLUMN name TYPE varchar;
! ERROR:  cannot alter column type of typed table
! CREATE TABLE stuff (id int);
! ALTER TABLE persons INHERIT stuff;
! ERROR:  cannot change inheritance of typed table
! CREATE TABLE personsx OF person_type (myname WITH OPTIONS NOT NULL); -- error
! ERROR:  column "myname" does not exist
! CREATE TABLE persons2 OF person_type (
!     id WITH OPTIONS PRIMARY KEY,
!     UNIQUE (name)
! );
! \d persons2
!               Table "public.persons2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  id     | integer |           | not null | 
!  name   | text    |           |          | 
! Indexes:
!     "persons2_pkey" PRIMARY KEY, btree (id)
!     "persons2_name_key" UNIQUE CONSTRAINT, btree (name)
! Typed table of type: person_type
! 
! CREATE TABLE persons3 OF person_type (
!     PRIMARY KEY (id),
!     name WITH OPTIONS DEFAULT ''
! );
! \d persons3
!               Table "public.persons3"
!  Column |  Type   | Collation | Nullable | Default  
! --------+---------+-----------+----------+----------
!  id     | integer |           | not null | 
!  name   | text    |           |          | ''::text
! Indexes:
!     "persons3_pkey" PRIMARY KEY, btree (id)
! Typed table of type: person_type
! 
! CREATE TABLE persons4 OF person_type (
!     name WITH OPTIONS NOT NULL,
!     name WITH OPTIONS DEFAULT ''  -- error, specified more than once
! );
! ERROR:  column "name" specified more than once
! DROP TYPE person_type RESTRICT;
! ERROR:  cannot drop type person_type because other objects depend on it
! DETAIL:  table persons depends on type person_type
! function get_all_persons() depends on type person_type
! table persons2 depends on type person_type
! table persons3 depends on type person_type
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! DROP TYPE person_type CASCADE;
! NOTICE:  drop cascades to 4 other objects
! DETAIL:  drop cascades to table persons
! drop cascades to function get_all_persons()
! drop cascades to table persons2
! drop cascades to table persons3
! CREATE TABLE persons5 OF stuff; -- only CREATE TYPE AS types may be used
! ERROR:  type stuff is not a composite type
! DROP TABLE stuff;
! -- implicit casting
! CREATE TYPE person_type AS (id int, name text);
! CREATE TABLE persons OF person_type;
! INSERT INTO persons VALUES (1, 'test');
! CREATE FUNCTION namelen(person_type) RETURNS int LANGUAGE SQL AS $$ SELECT length($1.name) $$;
! SELECT id, namelen(persons) FROM persons;
!  id | namelen 
! ----+---------
!   1 |       4
! (1 row)
! 
! CREATE TABLE persons2 OF person_type (
!     id WITH OPTIONS PRIMARY KEY,
!     UNIQUE (name)
! );
! \d persons2
!               Table "public.persons2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  id     | integer |           | not null | 
!  name   | text    |           |          | 
! Indexes:
!     "persons2_pkey" PRIMARY KEY, btree (id)
!     "persons2_name_key" UNIQUE CONSTRAINT, btree (name)
! Typed table of type: person_type
! 
! CREATE TABLE persons3 OF person_type (
!     PRIMARY KEY (id),
!     name NOT NULL DEFAULT ''
! );
! \d persons3
!               Table "public.persons3"
!  Column |  Type   | Collation | Nullable | Default  
! --------+---------+-----------+----------+----------
!  id     | integer |           | not null | 
!  name   | text    |           | not null | ''::text
! Indexes:
!     "persons3_pkey" PRIMARY KEY, btree (id)
! Typed table of type: person_type
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/vacuum.out"	2025-07-31 16:07:15.006067803 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/vacuum.out"	2025-07-31 16:39:29.067088086 +0800
***************
*** 1,89 ****
! --
! -- VACUUM
! --
! CREATE TABLE vactst (i INT) DISTRIBUTE BY REPLICATION;
! INSERT INTO vactst VALUES (1);
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst VALUES (0);
! SELECT count(*) FROM vactst;
!  count 
! -------
!   2049
! (1 row)
! 
! DELETE FROM vactst WHERE i != 0;
! SELECT * FROM vactst;
!  i 
! ---
!  0
! (1 row)
! 
! VACUUM FULL vactst;
! UPDATE vactst SET i = i + 1;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst SELECT * FROM vactst;
! INSERT INTO vactst VALUES (0);
! SELECT count(*) FROM vactst;
!  count 
! -------
!   2049
! (1 row)
! 
! DELETE FROM vactst WHERE i != 0;
! VACUUM (FULL) vactst;
! DELETE FROM vactst;
! SELECT * FROM vactst;
!  i 
! ---
! (0 rows)
! 
! VACUUM (FULL, FREEZE) vactst;
! VACUUM (ANALYZE, FULL) vactst;
! CREATE TABLE vaccluster (i INT PRIMARY KEY);
! ALTER TABLE vaccluster CLUSTER ON vaccluster_pkey;
! CLUSTER vaccluster;
! CREATE FUNCTION do_analyze() RETURNS VOID VOLATILE LANGUAGE SQL
! 	AS 'ANALYZE pg_am';
! CREATE FUNCTION wrap_do_analyze(c INT) RETURNS INT IMMUTABLE LANGUAGE SQL
! 	AS 'SELECT $1 FROM do_analyze()';
! CREATE INDEX ON vaccluster(wrap_do_analyze(i));
! INSERT INTO vaccluster VALUES (1), (2);
! ANALYZE vaccluster;
! ERROR:  ANALYZE cannot be executed from VACUUM or ANALYZE
! VACUUM FULL pg_am;
! VACUUM FULL pg_class;
! VACUUM FULL pg_catalog.pg_database;
! VACUUM FULL vaccluster;
! ERROR:  ANALYZE cannot be executed from VACUUM or ANALYZE
! VACUUM FULL vactst;
! VACUUM (DISABLE_PAGE_SKIPPING) vaccluster;
! DROP TABLE vaccluster;
! DROP TABLE vactst;
! -- partitioned table
! CREATE TABLE vacparted (a int, b char) PARTITION BY LIST (a);
! CREATE TABLE vacparted1 PARTITION OF vacparted FOR VALUES IN (1);
! INSERT INTO vacparted VALUES (1, 'a');
! UPDATE vacparted SET b = 'b';
! VACUUM (ANALYZE) vacparted;
! VACUUM (FULL) vacparted;
! VACUUM (FREEZE) vacparted;
! DROP TABLE vacparted;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/drop_if_exists.out"	2025-07-31 16:07:14.982068184 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/drop_if_exists.out"	2025-07-31 16:39:29.053088384 +0800
***************
*** 1,306 ****
! --
! -- IF EXISTS tests
! --
! -- table (will be really dropped at the end)
! DROP TABLE test_exists;
! ERROR:  table "test_exists" does not exist
! DROP TABLE IF EXISTS test_exists;
! NOTICE:  table "test_exists" does not exist, skipping
! CREATE TABLE test_exists (a int, b text);
! -- view
! DROP VIEW test_view_exists;
! ERROR:  view "test_view_exists" does not exist
! DROP VIEW IF EXISTS test_view_exists;
! NOTICE:  view "test_view_exists" does not exist, skipping
! CREATE VIEW test_view_exists AS select * from test_exists;
! DROP VIEW IF EXISTS test_view_exists;
! DROP VIEW test_view_exists;
! ERROR:  view "test_view_exists" does not exist
! -- index
! DROP INDEX test_index_exists;
! ERROR:  index "test_index_exists" does not exist
! DROP INDEX IF EXISTS test_index_exists;
! NOTICE:  index "test_index_exists" does not exist, skipping
! CREATE INDEX test_index_exists on test_exists(a);
! DROP INDEX IF EXISTS test_index_exists;
! DROP INDEX test_index_exists;
! ERROR:  index "test_index_exists" does not exist
! -- sequence
! DROP SEQUENCE test_sequence_exists;
! ERROR:  sequence "test_sequence_exists" does not exist
! DROP SEQUENCE IF EXISTS test_sequence_exists;
! NOTICE:  sequence "test_sequence_exists" does not exist, skipping
! CREATE SEQUENCE test_sequence_exists;
! DROP SEQUENCE IF EXISTS test_sequence_exists;
! DROP SEQUENCE test_sequence_exists;
! ERROR:  sequence "test_sequence_exists" does not exist
! -- schema
! DROP SCHEMA test_schema_exists;
! ERROR:  schema "test_schema_exists" does not exist
! DROP SCHEMA IF EXISTS test_schema_exists;
! NOTICE:  schema "test_schema_exists" does not exist, skipping
! CREATE SCHEMA test_schema_exists;
! DROP SCHEMA IF EXISTS test_schema_exists;
! DROP SCHEMA test_schema_exists;
! ERROR:  schema "test_schema_exists" does not exist
! -- type
! DROP TYPE test_type_exists;
! ERROR:  type "test_type_exists" does not exist
! DROP TYPE IF EXISTS test_type_exists;
! NOTICE:  type "test_type_exists" does not exist, skipping
! CREATE type test_type_exists as (a int, b text);
! DROP TYPE IF EXISTS test_type_exists;
! DROP TYPE test_type_exists;
! ERROR:  type "test_type_exists" does not exist
! -- domain
! DROP DOMAIN test_domain_exists;
! ERROR:  type "test_domain_exists" does not exist
! DROP DOMAIN IF EXISTS test_domain_exists;
! NOTICE:  type "test_domain_exists" does not exist, skipping
! CREATE domain test_domain_exists as int not null check (value > 0);
! DROP DOMAIN IF EXISTS test_domain_exists;
! DROP DOMAIN test_domain_exists;
! ERROR:  type "test_domain_exists" does not exist
! ---
! --- role/user/group
! ---
! CREATE USER regress_test_u1;
! CREATE ROLE regress_test_r1;
! CREATE GROUP regress_test_g1;
! DROP USER regress_test_u2;
! ERROR:  role "regress_test_u2" does not exist
! DROP USER IF EXISTS regress_test_u1, regress_test_u2;
! NOTICE:  role "regress_test_u2" does not exist, skipping
! DROP USER regress_test_u1;
! ERROR:  role "regress_test_u1" does not exist
! DROP ROLE regress_test_r2;
! ERROR:  role "regress_test_r2" does not exist
! DROP ROLE IF EXISTS regress_test_r1, regress_test_r2;
! NOTICE:  role "regress_test_r2" does not exist, skipping
! DROP ROLE regress_test_r1;
! ERROR:  role "regress_test_r1" does not exist
! DROP GROUP regress_test_g2;
! ERROR:  role "regress_test_g2" does not exist
! DROP GROUP IF EXISTS regress_test_g1, regress_test_g2;
! NOTICE:  role "regress_test_g2" does not exist, skipping
! DROP GROUP regress_test_g1;
! ERROR:  role "regress_test_g1" does not exist
! -- collation
! DROP COLLATION IF EXISTS test_collation_exists;
! NOTICE:  collation "test_collation_exists" does not exist, skipping
! -- conversion
! DROP CONVERSION test_conversion_exists;
! ERROR:  conversion "test_conversion_exists" does not exist
! DROP CONVERSION IF EXISTS test_conversion_exists;
! NOTICE:  conversion "test_conversion_exists" does not exist, skipping
! CREATE CONVERSION test_conversion_exists
!     FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! DROP CONVERSION test_conversion_exists;
! -- text search parser
! DROP TEXT SEARCH PARSER test_tsparser_exists;
! ERROR:  text search parser "test_tsparser_exists" does not exist
! DROP TEXT SEARCH PARSER IF EXISTS test_tsparser_exists;
! NOTICE:  text search parser "test_tsparser_exists" does not exist, skipping
! -- text search dictionary
! DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
! ERROR:  text search dictionary "test_tsdict_exists" does not exist
! DROP TEXT SEARCH DICTIONARY IF EXISTS test_tsdict_exists;
! NOTICE:  text search dictionary "test_tsdict_exists" does not exist, skipping
! CREATE TEXT SEARCH DICTIONARY test_tsdict_exists (
!         Template=ispell,
!         DictFile=ispell_sample,
!         AffFile=ispell_sample
! );
! DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
! -- test search template
! DROP TEXT SEARCH TEMPLATE test_tstemplate_exists;
! ERROR:  text search template "test_tstemplate_exists" does not exist
! DROP TEXT SEARCH TEMPLATE IF EXISTS test_tstemplate_exists;
! NOTICE:  text search template "test_tstemplate_exists" does not exist, skipping
! -- text search configuration
! DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
! ERROR:  text search configuration "test_tsconfig_exists" does not exist
! DROP TEXT SEARCH CONFIGURATION IF EXISTS test_tsconfig_exists;
! NOTICE:  text search configuration "test_tsconfig_exists" does not exist, skipping
! CREATE TEXT SEARCH CONFIGURATION test_tsconfig_exists (COPY=english);
! DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
! -- extension
! DROP EXTENSION test_extension_exists;
! ERROR:  extension "test_extension_exists" does not exist
! DROP EXTENSION IF EXISTS test_extension_exists;
! NOTICE:  extension "test_extension_exists" does not exist, skipping
! -- functions
! DROP FUNCTION test_function_exists();
! ERROR:  function test_function_exists() does not exist
! DROP FUNCTION IF EXISTS test_function_exists();
! NOTICE:  function test_function_exists() does not exist, skipping
! DROP FUNCTION test_function_exists(int, text, int[]);
! ERROR:  function test_function_exists(integer, text, integer[]) does not exist
! DROP FUNCTION IF EXISTS test_function_exists(int, text, int[]);
! NOTICE:  function test_function_exists(pg_catalog.int4,text,pg_catalog.int4[]) does not exist, skipping
! -- aggregate
! DROP AGGREGATE test_aggregate_exists(*);
! ERROR:  aggregate test_aggregate_exists(*) does not exist
! DROP AGGREGATE IF EXISTS test_aggregate_exists(*);
! NOTICE:  aggregate test_aggregate_exists() does not exist, skipping
! DROP AGGREGATE test_aggregate_exists(int);
! ERROR:  aggregate test_aggregate_exists(integer) does not exist
! DROP AGGREGATE IF EXISTS test_aggregate_exists(int);
! NOTICE:  aggregate test_aggregate_exists(pg_catalog.int4) does not exist, skipping
! -- operator
! DROP OPERATOR @#@ (int, int);
! ERROR:  operator does not exist: integer @#@ integer
! DROP OPERATOR IF EXISTS @#@ (int, int);
! NOTICE:  operator @#@ does not exist, skipping
! CREATE OPERATOR @#@
!         (leftarg = int8, rightarg = int8, procedure = int8xor);
! DROP OPERATOR @#@ (int8, int8);
! -- language
! DROP LANGUAGE test_language_exists;
! ERROR:  language "test_language_exists" does not exist
! DROP LANGUAGE IF EXISTS test_language_exists;
! NOTICE:  language "test_language_exists" does not exist, skipping
! -- cast
! DROP CAST (text AS text);
! ERROR:  cast from type text to type text does not exist
! DROP CAST IF EXISTS (text AS text);
! NOTICE:  cast from type text to type text does not exist, skipping
! -- trigger
! DROP TRIGGER test_trigger_exists ON test_exists;
! ERROR:  trigger "test_trigger_exists" for table "test_exists" does not exist
! DROP TRIGGER IF EXISTS test_trigger_exists ON test_exists;
! NOTICE:  trigger "test_trigger_exists" for relation "test_exists" does not exist, skipping
! DROP TRIGGER test_trigger_exists ON no_such_table;
! ERROR:  relation "no_such_table" does not exist
! DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_table;
! NOTICE:  relation "no_such_table" does not exist, skipping
! DROP TRIGGER test_trigger_exists ON no_such_schema.no_such_table;
! ERROR:  schema "no_such_schema" does not exist
! DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_schema.no_such_table;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! CREATE TRIGGER test_trigger_exists
!     BEFORE UPDATE ON test_exists
!     FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! DROP TRIGGER test_trigger_exists ON test_exists;
! ERROR:  trigger "test_trigger_exists" for table "test_exists" does not exist
! -- rule
! DROP RULE test_rule_exists ON test_exists;
! ERROR:  rule "test_rule_exists" for relation "test_exists" does not exist
! DROP RULE IF EXISTS test_rule_exists ON test_exists;
! NOTICE:  rule "test_rule_exists" for relation "test_exists" does not exist, skipping
! DROP RULE test_rule_exists ON no_such_table;
! ERROR:  relation "no_such_table" does not exist
! DROP RULE IF EXISTS test_rule_exists ON no_such_table;
! NOTICE:  relation "no_such_table" does not exist, skipping
! DROP RULE test_rule_exists ON no_such_schema.no_such_table;
! ERROR:  schema "no_such_schema" does not exist
! DROP RULE IF EXISTS test_rule_exists ON no_such_schema.no_such_table;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! CREATE RULE test_rule_exists AS ON INSERT TO test_exists
!     DO INSTEAD
!     INSERT INTO test_exists VALUES (NEW.a, NEW.b || NEW.a::text);
! DROP RULE test_rule_exists ON test_exists;
! -- foreign data wrapper
! DROP FOREIGN DATA WRAPPER test_fdw_exists;
! ERROR:  foreign-data wrapper "test_fdw_exists" does not exist
! DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists;
! NOTICE:  foreign-data wrapper "test_fdw_exists" does not exist, skipping
! -- foreign server
! DROP SERVER test_server_exists;
! ERROR:  server "test_server_exists" does not exist
! DROP SERVER IF EXISTS test_server_exists;
! NOTICE:  server "test_server_exists" does not exist, skipping
! -- operator class
! DROP OPERATOR CLASS test_operator_class USING btree;
! ERROR:  operator class "test_operator_class" does not exist for access method "btree"
! DROP OPERATOR CLASS IF EXISTS test_operator_class USING btree;
! NOTICE:  operator class "test_operator_class" does not exist for access method "btree", skipping
! DROP OPERATOR CLASS test_operator_class USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! DROP OPERATOR CLASS IF EXISTS test_operator_class USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! -- operator family
! DROP OPERATOR FAMILY test_operator_family USING btree;
! ERROR:  operator family "test_operator_family" does not exist for access method "btree"
! DROP OPERATOR FAMILY IF EXISTS test_operator_family USING btree;
! NOTICE:  operator family "test_operator_family" does not exist for access method "btree", skipping
! DROP OPERATOR FAMILY test_operator_family USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! DROP OPERATOR FAMILY IF EXISTS test_operator_family USING no_such_am;
! ERROR:  access method "no_such_am" does not exist
! -- access method
! DROP ACCESS METHOD no_such_am;
! ERROR:  access method "no_such_am" does not exist
! DROP ACCESS METHOD IF EXISTS no_such_am;
! NOTICE:  access method "no_such_am" does not exist, skipping
! -- drop the table
! DROP TABLE IF EXISTS test_exists;
! DROP TABLE test_exists;
! ERROR:  table "test_exists" does not exist
! -- be tolerant with missing schemas, types, etc
! DROP AGGREGATE IF EXISTS no_such_schema.foo(int);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP AGGREGATE IF EXISTS foo(no_such_type);
! NOTICE:  type "no_such_type" does not exist, skipping
! DROP AGGREGATE IF EXISTS foo(no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP CAST IF EXISTS (INTEGER AS no_such_type2);
! NOTICE:  type "no_such_type2" does not exist, skipping
! DROP CAST IF EXISTS (no_such_type1 AS INTEGER);
! NOTICE:  type "no_such_type1" does not exist, skipping
! DROP CAST IF EXISTS (INTEGER AS no_such_schema.bar);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP CAST IF EXISTS (no_such_schema.foo AS INTEGER);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP COLLATION IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP CONVERSION IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP DOMAIN IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP FOREIGN TABLE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP FUNCTION IF EXISTS no_such_schema.foo();
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP FUNCTION IF EXISTS foo(no_such_type);
! NOTICE:  type "no_such_type" does not exist, skipping
! DROP FUNCTION IF EXISTS foo(no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP INDEX IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP MATERIALIZED VIEW IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR IF EXISTS no_such_schema.+ (int, int);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR IF EXISTS + (no_such_type, no_such_type);
! NOTICE:  type "no_such_type" does not exist, skipping
! DROP OPERATOR IF EXISTS + (no_such_schema.no_such_type, no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR IF EXISTS # (NONE, no_such_schema.no_such_type);
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR CLASS IF EXISTS no_such_schema.widget_ops USING btree;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP OPERATOR FAMILY IF EXISTS no_such_schema.float_ops USING btree;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP RULE IF EXISTS foo ON no_such_schema.bar;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP SEQUENCE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TABLE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH CONFIGURATION IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH DICTIONARY IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH PARSER IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TEXT SEARCH TEMPLATE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TRIGGER IF EXISTS foo ON no_such_schema.bar;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP TYPE IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
! DROP VIEW IF EXISTS no_such_schema.foo;
! NOTICE:  schema "no_such_schema" does not exist, skipping
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/updatable_views.out"	2025-07-31 16:07:15.006067803 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/updatable_views.out"	2025-07-31 16:39:29.062088192 +0800
***************
*** 1,2410 ****
! --
! -- UPDATABLE VIEWS
! --
! -- check that non-updatable views and columns are rejected with useful error
! -- messages
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified') DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW ro_view1 AS SELECT DISTINCT a, b FROM base_tbl; -- DISTINCT not supported
! CREATE VIEW ro_view2 AS SELECT a, b FROM base_tbl GROUP BY a, b; -- GROUP BY not supported
! CREATE VIEW ro_view3 AS SELECT 1 FROM base_tbl HAVING max(a) > 0; -- HAVING not supported
! CREATE VIEW ro_view4 AS SELECT count(*) FROM base_tbl; -- Aggregate functions not supported
! CREATE VIEW ro_view5 AS SELECT a, rank() OVER() FROM base_tbl; -- Window functions not supported
! CREATE VIEW ro_view6 AS SELECT a, b FROM base_tbl UNION SELECT -a, b FROM base_tbl; -- Set ops not supported
! CREATE VIEW ro_view7 AS WITH t AS (SELECT a, b FROM base_tbl) SELECT * FROM t; -- WITH not supported
! CREATE VIEW ro_view8 AS SELECT a, b FROM base_tbl ORDER BY a OFFSET 1; -- OFFSET not supported
! CREATE VIEW ro_view9 AS SELECT a, b FROM base_tbl ORDER BY a LIMIT 1; -- LIMIT not supported
! CREATE VIEW ro_view10 AS SELECT 1 AS a; -- No base relations
! CREATE VIEW ro_view11 AS SELECT b1.a, b2.b FROM base_tbl b1, base_tbl b2; -- Multiple base relations
! CREATE VIEW ro_view12 AS SELECT * FROM generate_series(1, 10) AS g(a); -- SRF in rangetable
! CREATE VIEW ro_view13 AS SELECT a, b FROM (SELECT * FROM base_tbl) AS t; -- Subselect in rangetable
! CREATE VIEW rw_view14 AS SELECT ctid, a, b FROM base_tbl; -- System columns may be part of an updatable view
! CREATE VIEW rw_view15 AS SELECT a, upper(b) FROM base_tbl; -- Expression/function may be part of an updatable view
! CREATE VIEW rw_view16 AS SELECT a, b, a AS aa FROM base_tbl; -- Repeated column may be part of an updatable view
! CREATE VIEW ro_view17 AS SELECT * FROM ro_view1; -- Base relation not updatable
! CREATE VIEW ro_view18 AS SELECT * FROM (VALUES(1)) AS tmp(a); -- VALUES in rangetable
! CREATE SEQUENCE seq;
! CREATE VIEW ro_view19 AS SELECT * FROM seq; -- View based on a sequence
! CREATE VIEW ro_view20 AS SELECT a, b, generate_series(1, a) g FROM base_tbl; -- SRF in targetlist not supported
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  ro_view1   | NO
!  ro_view10  | NO
!  ro_view11  | NO
!  ro_view12  | NO
!  ro_view13  | NO
!  ro_view17  | NO
!  ro_view18  | NO
!  ro_view19  | NO
!  ro_view2   | NO
!  ro_view20  | NO
!  ro_view3   | NO
!  ro_view4   | NO
!  ro_view5   | NO
!  ro_view6   | NO
!  ro_view7   | NO
!  ro_view8   | NO
!  ro_view9   | NO
!  rw_view14  | YES
!  rw_view15  | YES
!  rw_view16  | YES
! (20 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  ro_view1   | NO           | NO
!  ro_view10  | NO           | NO
!  ro_view11  | NO           | NO
!  ro_view12  | NO           | NO
!  ro_view13  | NO           | NO
!  ro_view17  | NO           | NO
!  ro_view18  | NO           | NO
!  ro_view19  | NO           | NO
!  ro_view2   | NO           | NO
!  ro_view20  | NO           | NO
!  ro_view3   | NO           | NO
!  ro_view4   | NO           | NO
!  ro_view5   | NO           | NO
!  ro_view6   | NO           | NO
!  ro_view7   | NO           | NO
!  ro_view8   | NO           | NO
!  ro_view9   | NO           | NO
!  rw_view14  | YES          | YES
!  rw_view15  | YES          | YES
!  rw_view16  | YES          | YES
! (20 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  ro_view1   | a           | NO
!  ro_view1   | b           | NO
!  ro_view10  | a           | NO
!  ro_view11  | a           | NO
!  ro_view11  | b           | NO
!  ro_view12  | a           | NO
!  ro_view13  | a           | NO
!  ro_view13  | b           | NO
!  ro_view17  | a           | NO
!  ro_view17  | b           | NO
!  ro_view18  | a           | NO
!  ro_view19  | last_value  | NO
!  ro_view19  | log_cnt     | NO
!  ro_view19  | is_called   | NO
!  ro_view2   | a           | NO
!  ro_view2   | b           | NO
!  ro_view20  | a           | NO
!  ro_view20  | b           | NO
!  ro_view20  | g           | NO
!  ro_view3   | ?column?    | NO
!  ro_view4   | count       | NO
!  ro_view5   | a           | NO
!  ro_view5   | rank        | NO
!  ro_view6   | a           | NO
!  ro_view6   | b           | NO
!  ro_view7   | a           | NO
!  ro_view7   | b           | NO
!  ro_view8   | a           | NO
!  ro_view8   | b           | NO
!  ro_view9   | a           | NO
!  ro_view9   | b           | NO
!  rw_view14  | ctid        | NO
!  rw_view14  | a           | YES
!  rw_view14  | b           | YES
!  rw_view15  | a           | YES
!  rw_view15  | upper       | NO
!  rw_view16  | a           | YES
!  rw_view16  | b           | YES
!  rw_view16  | aa          | YES
! (39 rows)
! 
! -- Read-only views
! DELETE FROM ro_view1;
! ERROR:  cannot delete from view "ro_view1"
! DETAIL:  Views containing DISTINCT are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view2;
! ERROR:  cannot delete from view "ro_view2"
! DETAIL:  Views containing GROUP BY are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view3;
! ERROR:  cannot delete from view "ro_view3"
! DETAIL:  Views containing HAVING are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view4;
! ERROR:  cannot delete from view "ro_view4"
! DETAIL:  Views that return aggregate functions are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view5;
! ERROR:  cannot delete from view "ro_view5"
! DETAIL:  Views that return window functions are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DELETE FROM ro_view6;
! ERROR:  cannot delete from view "ro_view6"
! DETAIL:  Views containing UNION, INTERSECT, or EXCEPT are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! UPDATE ro_view7 SET a=a+1;
! ERROR:  cannot update view "ro_view7"
! DETAIL:  Views containing WITH are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view8 SET a=a+1;
! ERROR:  cannot update view "ro_view8"
! DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view9 SET a=a+1;
! ERROR:  cannot update view "ro_view9"
! DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view10 SET a=a+1;
! ERROR:  cannot update view "ro_view10"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view11 SET a=a+1;
! ERROR:  cannot update view "ro_view11"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view12 SET a=a+1;
! ERROR:  cannot update view "ro_view12"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! INSERT INTO ro_view13 VALUES (3, 'Row 3');
! ERROR:  cannot insert into view "ro_view13"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! -- Partially updatable view
! INSERT INTO rw_view14 VALUES (null, 3, 'Row 3'); -- should fail
! ERROR:  cannot insert into column "ctid" of view "rw_view14"
! DETAIL:  View columns that refer to system columns are not updatable.
! INSERT INTO rw_view14 (a, b) VALUES (3, 'Row 3'); -- should be OK
! UPDATE rw_view14 SET ctid=null WHERE a=3; -- should fail
! ERROR:  cannot update column "ctid" of view "rw_view14"
! DETAIL:  View columns that refer to system columns are not updatable.
! UPDATE rw_view14 SET b='ROW 3' WHERE a=3; -- should be OK
! SELECT * FROM base_tbl;
!  a  |   b    
! ----+--------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Row 2
!   3 | ROW 3
! (6 rows)
! 
! DELETE FROM rw_view14 WHERE a=3; -- should be OK
! -- Partially updatable view
! INSERT INTO rw_view15 VALUES (3, 'ROW 3'); -- should fail
! ERROR:  cannot insert into column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view15 (a) VALUES (3); -- should be OK
! INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT DO NOTHING; -- succeeds
! SELECT * FROM rw_view15;
!  a  |    upper    
! ----+-------------
!  -2 | ROW -2
!  -1 | ROW -1
!   0 | ROW 0
!   1 | ROW 1
!   2 | ROW 2
!   3 | UNSPECIFIED
! (6 rows)
! 
! INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO NOTHING; -- succeeds
! SELECT * FROM rw_view15;
!  a  |    upper    
! ----+-------------
!  -2 | ROW -2
!  -1 | ROW -1
!   0 | ROW 0
!   1 | ROW 1
!   2 | ROW 2
!   3 | UNSPECIFIED
! (6 rows)
! 
! INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO UPDATE set a = excluded.a; -- succeeds
! SELECT * FROM rw_view15;
!  a  |    upper    
! ----+-------------
!  -2 | ROW -2
!  -1 | ROW -1
!   0 | ROW 0
!   1 | ROW 1
!   2 | ROW 2
!   3 | UNSPECIFIED
! (6 rows)
! 
! INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO UPDATE set upper = 'blarg'; -- fails
! ERROR:  cannot insert into column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! SELECT * FROM rw_view15;
!  a  |    upper    
! ----+-------------
!  -2 | ROW -2
!  -1 | ROW -1
!   0 | ROW 0
!   1 | ROW 1
!   2 | ROW 2
!   3 | UNSPECIFIED
! (6 rows)
! 
! SELECT * FROM rw_view15;
!  a  |    upper    
! ----+-------------
!  -2 | ROW -2
!  -1 | ROW -1
!   0 | ROW 0
!   1 | ROW 1
!   2 | ROW 2
!   3 | UNSPECIFIED
! (6 rows)
! 
! ALTER VIEW rw_view15 ALTER COLUMN upper SET DEFAULT 'NOT SET';
! INSERT INTO rw_view15 (a) VALUES (4); -- should fail
! ERROR:  cannot insert into column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view15 SET upper='ROW 3' WHERE a=3; -- should fail
! ERROR:  cannot update column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view15 SET upper=DEFAULT WHERE a=3; -- should fail
! ERROR:  cannot update column "upper" of view "rw_view15"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view15 SET a=4 WHERE a=3; -- should be OK
! SELECT * FROM base_tbl;
!  a  |      b      
! ----+-------------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Row 2
!   4 | Unspecified
! (6 rows)
! 
! DELETE FROM rw_view15 WHERE a=4; -- should be OK
! -- Partially updatable view
! INSERT INTO rw_view16 VALUES (3, 'Row 3', 3); -- should fail
! ERROR:  multiple assignments to same column "a"
! INSERT INTO rw_view16 (a, b) VALUES (3, 'Row 3'); -- should be OK
! UPDATE rw_view16 SET a=3, aa=-3 WHERE a=3; -- should fail
! ERROR:  multiple assignments to same column "a"
! UPDATE rw_view16 SET aa=-3 WHERE a=3; -- should be OK
! SELECT * FROM base_tbl;
!  a  |   b    
! ----+--------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Row 2
!  -3 | Row 3
! (6 rows)
! 
! DELETE FROM rw_view16 WHERE a=-3; -- should be OK
! -- Read-only views
! INSERT INTO ro_view17 VALUES (3, 'ROW 3');
! ERROR:  cannot insert into view "ro_view1"
! DETAIL:  Views containing DISTINCT are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! DELETE FROM ro_view18;
! ERROR:  cannot delete from view "ro_view18"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! UPDATE ro_view19 SET last_value=1000;
! ERROR:  cannot update view "ro_view19"
! DETAIL:  Views that do not select from a single table or view are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! UPDATE ro_view20 SET b=upper(b);
! ERROR:  cannot update view "ro_view20"
! DETAIL:  Views that return set-returning functions are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 16 other objects
! DETAIL:  drop cascades to view ro_view1
! drop cascades to view ro_view17
! drop cascades to view ro_view2
! drop cascades to view ro_view3
! drop cascades to view ro_view5
! drop cascades to view ro_view6
! drop cascades to view ro_view7
! drop cascades to view ro_view8
! drop cascades to view ro_view9
! drop cascades to view ro_view11
! drop cascades to view ro_view13
! drop cascades to view rw_view15
! drop cascades to view rw_view16
! drop cascades to view ro_view20
! drop cascades to view ro_view4
! drop cascades to view rw_view14
! DROP VIEW ro_view10, ro_view12, ro_view18;
! DROP SEQUENCE seq CASCADE;
! NOTICE:  drop cascades to view ro_view19
! -- simple updatable view
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified') DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view1';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view1';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view1'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | YES
!  rw_view1   | b           | YES
! (2 rows)
! 
! INSERT INTO rw_view1 VALUES (3, 'Row 3');
! INSERT INTO rw_view1 (a) VALUES (4);
! UPDATE rw_view1 SET a=5 WHERE a=4;
! DELETE FROM rw_view1 WHERE b='Row 2';
! SELECT * FROM base_tbl;
!  a  |      b      
! ----+-------------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   3 | Row 3
!   5 | Unspecified
! (6 rows)
! 
! EXPLAIN (costs off, nodes off) UPDATE rw_view1 SET a=6 WHERE a=5;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Update on base_tbl
!          ->  Index Scan using base_tbl_pkey on base_tbl
!                Index Cond: ((a > 0) AND (a = 5))
! (4 rows)
! 
! EXPLAIN (costs off, nodes off) DELETE FROM rw_view1 WHERE a=5;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Delete on base_tbl
!          ->  Index Scan using base_tbl_pkey on base_tbl
!                Index Cond: ((a > 0) AND (a = 5))
! (4 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- view on top of view
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified') DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl WHERE a>0;
! CREATE VIEW rw_view2 AS SELECT aa AS aaa, bb AS bbb FROM rw_view1 WHERE aa<10;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view2';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view2   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view2';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view2   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view2'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view2   | aaa         | YES
!  rw_view2   | bbb         | YES
! (2 rows)
! 
! INSERT INTO rw_view2 VALUES (3, 'Row 3');
! INSERT INTO rw_view2 (aaa) VALUES (4);
! SELECT * FROM rw_view2;
!  aaa |     bbb     
! -----+-------------
!    1 | Row 1
!    2 | Row 2
!    3 | Row 3
!    4 | Unspecified
! (4 rows)
! 
! UPDATE rw_view2 SET bbb='Row 4' WHERE aaa=4;
! DELETE FROM rw_view2 WHERE aaa=2;
! SELECT * FROM rw_view2;
!  aaa |  bbb  
! -----+-------
!    1 | Row 1
!    3 | Row 3
!    4 | Row 4
! (3 rows)
! 
! EXPLAIN (costs off, nodes off) UPDATE rw_view2 SET aaa=5 WHERE aaa=4;
!                           QUERY PLAN                          
! --------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Update on base_tbl
!          ->  Index Scan using base_tbl_pkey on base_tbl
!                Index Cond: ((a < 10) AND (a > 0) AND (a = 4))
! (4 rows)
! 
! EXPLAIN (costs off, nodes off) DELETE FROM rw_view2 WHERE aaa=4;
!                           QUERY PLAN                          
! --------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Delete on base_tbl
!          ->  Index Scan using base_tbl_pkey on base_tbl
!                Index Cond: ((a < 10) AND (a > 0) AND (a = 4))
! (4 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- view on top of view with rules
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified') DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0; -- not updatable without rules/triggers
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | NO           | NO
!  rw_view2   | NO           | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
!   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, NEW.b) RETURNING *;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | NO           | YES
!  rw_view2   | NO           | YES
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1
!   DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a RETURNING NEW.*;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | NO           | YES
!  rw_view2   | NO           | YES
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE RULE rw_view1_del_rule AS ON DELETE TO rw_view1
!   DO INSTEAD DELETE FROM base_tbl WHERE a=OLD.a RETURNING OLD.*;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
!  rw_view2   | YES          | YES
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | YES
!  rw_view1   | b           | YES
!  rw_view2   | a           | YES
!  rw_view2   | b           | YES
! (4 rows)
! 
! INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
!  a |   b   
! ---+-------
!  3 | Row 3
! (1 row)
! 
! UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
!  a |     b     
! ---+-----------
!  3 | Row three
! (1 row)
! 
! SELECT * FROM rw_view2;
!  a |     b     
! ---+-----------
!  1 | Row 1
!  2 | Row 2
!  3 | Row three
! (3 rows)
! 
! DELETE FROM rw_view2 WHERE a=3 RETURNING *;
!  a |     b     
! ---+-----------
!  3 | Row three
! (1 row)
! 
! SELECT * FROM rw_view2;
!  a |   b   
! ---+-------
!  1 | Row 1
!  2 | Row 2
! (2 rows)
! 
! EXPLAIN (costs off, nodes off) UPDATE rw_view2 SET a=3 WHERE a=2;
!                               QUERY PLAN                              
! ----------------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Update on base_tbl
!          ->  Nested Loop
!                ->  Index Scan using base_tbl_pkey on base_tbl
!                      Index Cond: (a = 2)
!                ->  Subquery Scan on rw_view1
!                      Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))
!                      ->  Bitmap Heap Scan on base_tbl base_tbl_1
!                            Recheck Cond: (a > 0)
!                            ->  Bitmap Index Scan on base_tbl_pkey
!                                  Index Cond: (a > 0)
! (11 rows)
! 
! EXPLAIN (costs off, nodes off) DELETE FROM rw_view2 WHERE a=2;
!                               QUERY PLAN                              
! ----------------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Delete on base_tbl
!          ->  Nested Loop
!                ->  Index Scan using base_tbl_pkey on base_tbl
!                      Index Cond: (a = 2)
!                ->  Subquery Scan on rw_view1
!                      Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))
!                      ->  Bitmap Heap Scan on base_tbl base_tbl_1
!                            Recheck Cond: (a > 0)
!                            ->  Bitmap Index Scan on base_tbl_pkey
!                                  Index Cond: (a > 0)
! (11 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- view on top of view with triggers
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified') DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0; -- not updatable without rules/triggers
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | NO                   | NO                   | NO
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE FUNCTION rw_view1_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   IF TG_OP = 'INSERT' THEN
!     INSERT INTO base_tbl VALUES (NEW.a, NEW.b);
!     RETURN NEW;
!   ELSIF TG_OP = 'UPDATE' THEN
!     UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a;
!     RETURN NEW;
!   ELSIF TG_OP = 'DELETE' THEN
!     DELETE FROM base_tbl WHERE a=OLD.a;
!     RETURN OLD;
!   END IF;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER rw_view1_ins_trig INSTEAD OF INSERT ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | NO                   | NO                   | NO
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE TRIGGER rw_view1_upd_trig INSTEAD OF UPDATE ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | NO                   | NO                   | NO
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! CREATE TRIGGER rw_view1_del_trig INSTEAD OF DELETE ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | NO
!  rw_view2   | NO
! (2 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into,
!        is_trigger_updatable, is_trigger_deletable,
!        is_trigger_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  rw_view1   | NO           | NO                 | NO                   | NO                   | NO
!  rw_view2   | NO           | NO                 | NO                   | NO                   | NO
! (2 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE 'rw_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | a           | NO
!  rw_view1   | b           | NO
!  rw_view2   | a           | NO
!  rw_view2   | b           | NO
! (4 rows)
! 
! INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
! ERROR:  cannot insert into view "rw_view1"
! DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
! HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
! UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
! ERROR:  cannot update view "rw_view1"
! DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! SELECT * FROM rw_view2;
!  a |   b   
! ---+-------
!  1 | Row 1
!  2 | Row 2
! (2 rows)
! 
! DELETE FROM rw_view2 WHERE a=3 RETURNING *;
! ERROR:  cannot delete from view "rw_view1"
! DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! SELECT * FROM rw_view2;
!  a |   b   
! ---+-------
!  1 | Row 1
!  2 | Row 2
! (2 rows)
! 
! EXPLAIN (costs off, nodes off) UPDATE rw_view2 SET a=3 WHERE a=2;
! ERROR:  cannot update view "rw_view1"
! DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
! HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
! EXPLAIN (costs off, nodes off) DELETE FROM rw_view2 WHERE a=2;
! ERROR:  cannot delete from view "rw_view1"
! DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
! HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! DROP FUNCTION rw_view1_trig_fn();
! -- update using whole row from view
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified') DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
! CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl;
! CREATE FUNCTION rw_view1_aa(x rw_view1)
!   RETURNS int AS $$ SELECT x.aa $$ LANGUAGE sql;
! UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2
!   RETURNING rw_view1_aa(v), v.bb;
!  rw_view1_aa |      bb       
! -------------+---------------
!            2 | Updated row 2
! (1 row)
! 
! SELECT * FROM base_tbl;
!  a  |       b       
! ----+---------------
!  -2 | Row -2
!  -1 | Row -1
!   0 | Row 0
!   1 | Row 1
!   2 | Updated row 2
! (5 rows)
! 
! EXPLAIN (costs off, nodes off)
! UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2
!   RETURNING rw_view1_aa(v), v.bb;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Update on base_tbl
!          ->  Index Scan using base_tbl_pkey on base_tbl
!                Index Cond: (a = 2)
! (4 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to function rw_view1_aa(rw_view1)
! -- permissions checks
! CREATE USER regress_view_user1;
! CREATE USER regress_view_user2;
! SET SESSION AUTHORIZATION regress_view_user1;
! CREATE TABLE base_tbl(a int, b text, c float) DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
! CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
! INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
! GRANT SELECT ON base_tbl TO regress_view_user2;
! GRANT SELECT ON rw_view1 TO regress_view_user2;
! GRANT UPDATE (a,c) ON base_tbl TO regress_view_user2;
! GRANT UPDATE (bb,cc) ON rw_view1 TO regress_view_user2;
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION regress_view_user2;
! CREATE VIEW rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
! SELECT * FROM base_tbl; -- ok
!  a |   b   | c 
! ---+-------+---
!  1 | Row 1 | 1
!  2 | Row 2 | 2
! (2 rows)
! 
! SELECT * FROM rw_view1; -- ok
!   bb   | cc | aa 
! -------+----+----
!  Row 1 |  1 |  1
!  Row 2 |  2 |  2
! (2 rows)
! 
! SELECT * FROM rw_view2; -- ok
!   bb   | cc | aa 
! -------+----+----
!  Row 1 |  1 |  1
!  Row 2 |  2 |  2
! (2 rows)
! 
! INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- not allowed
! ERROR:  permission denied for relation base_tbl
! INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3); -- not allowed
! ERROR:  permission denied for relation rw_view1
! INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3); -- not allowed
! ERROR:  permission denied for relation base_tbl
! UPDATE base_tbl SET a=a, c=c; -- ok
! UPDATE base_tbl SET b=b; -- not allowed
! ERROR:  permission denied for relation base_tbl
! UPDATE rw_view1 SET bb=bb, cc=cc; -- ok
! UPDATE rw_view1 SET aa=aa; -- not allowed
! ERROR:  permission denied for relation rw_view1
! UPDATE rw_view2 SET aa=aa, cc=cc; -- ok
! UPDATE rw_view2 SET bb=bb; -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM base_tbl; -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM rw_view1; -- not allowed
! ERROR:  permission denied for relation rw_view1
! DELETE FROM rw_view2; -- not allowed
! ERROR:  permission denied for relation base_tbl
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION regress_view_user1;
! GRANT INSERT, DELETE ON base_tbl TO regress_view_user2;
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION regress_view_user2;
! INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- ok
! INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4); -- not allowed
! ERROR:  permission denied for relation rw_view1
! INSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4); -- ok
! DELETE FROM base_tbl WHERE a=1; -- ok
! DELETE FROM rw_view1 WHERE aa=2; -- not allowed
! ERROR:  permission denied for relation rw_view1
! DELETE FROM rw_view2 WHERE aa=2; -- ok
! SELECT * FROM base_tbl;
!  a |   b   | c 
! ---+-------+---
!  3 | Row 3 | 3
!  4 | Row 4 | 4
! (2 rows)
! 
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION regress_view_user1;
! REVOKE INSERT, DELETE ON base_tbl FROM regress_view_user2;
! GRANT INSERT, DELETE ON rw_view1 TO regress_view_user2;
! RESET SESSION AUTHORIZATION;
! SET SESSION AUTHORIZATION regress_view_user2;
! INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0); -- not allowed
! ERROR:  permission denied for relation base_tbl
! INSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5); -- ok
! INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6); -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM base_tbl WHERE a=3; -- not allowed
! ERROR:  permission denied for relation base_tbl
! DELETE FROM rw_view1 WHERE aa=3; -- ok
! DELETE FROM rw_view2 WHERE aa=4; -- not allowed
! ERROR:  permission denied for relation base_tbl
! SELECT * FROM base_tbl;
!  a |   b   | c 
! ---+-------+---
!  4 | Row 4 | 4
!  5 | Row 5 | 5
! (2 rows)
! 
! RESET SESSION AUTHORIZATION;
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! DROP USER regress_view_user1;
! DROP USER regress_view_user2;
! -- column defaults
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified', c serial) DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl VALUES (1, 'Row 1');
! INSERT INTO base_tbl VALUES (2, 'Row 2');
! INSERT INTO base_tbl VALUES (3);
! CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
! ALTER VIEW rw_view1 ALTER COLUMN bb SET DEFAULT 'View default';
! INSERT INTO rw_view1 VALUES (4, 'Row 4');
! INSERT INTO rw_view1 (aa) VALUES (5);
! SELECT * FROM base_tbl;
!  a |      b       | c 
! ---+--------------+---
!  1 | Row 1        | 1
!  2 | Row 2        | 2
!  3 | Unspecified  | 3
!  4 | Row 4        | 4
!  5 | View default | 5
! (5 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- Table having triggers
! CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified') DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl VALUES (1, 'Row 1');
! INSERT INTO base_tbl VALUES (2, 'Row 2');
! CREATE FUNCTION rw_view1_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   IF TG_OP = 'INSERT' THEN
!     UPDATE base_tbl SET b=NEW.b WHERE a=1;
!     RETURN NULL;
!   END IF;
!   RETURN NULL;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER rw_view1_ins_trig AFTER INSERT ON base_tbl
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
! INSERT INTO rw_view1 VALUES (3, 'Row 3');
! select * from base_tbl;
!  a |   b   
! ---+-------
!  1 | Row 1
!  2 | Row 2
!  3 | Row 3
! (3 rows)
! 
! DROP VIEW rw_view1;
! DROP TRIGGER rw_view1_ins_trig on base_tbl;
! ERROR:  trigger "rw_view1_ins_trig" for table "base_tbl" does not exist
! DROP FUNCTION rw_view1_trig_fn();
! DROP TABLE base_tbl;
! -- view with ORDER BY
! CREATE TABLE base_tbl (a int, b int) DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl VALUES (1,2), (4,5), (3,-3);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl ORDER BY a+b;
! SELECT * FROM rw_view1;
!  a | b  
! ---+----
!  3 | -3
!  1 |  2
!  4 |  5
! (3 rows)
! 
! INSERT INTO rw_view1 VALUES (7,-8);
! SELECT * FROM rw_view1;
!  a | b  
! ---+----
!  7 | -8
!  3 | -3
!  1 |  2
!  4 |  5
! (4 rows)
! 
! EXPLAIN (verbose, costs off, nodes off) UPDATE rw_view1 SET b = b + 1 RETURNING *;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Remote Subquery Scan on any
!    Output: base_tbl.a, base_tbl.b
!    ->  Update on public.base_tbl
!          Output: base_tbl.a, base_tbl.b
!          ->  Seq Scan on public.base_tbl
!                Output: base_tbl.a, (base_tbl.b + 1), base_tbl.ctid
! (6 rows)
! 
! UPDATE rw_view1 SET b = b + 1 RETURNING *;
!  a | b  
! ---+----
!  1 |  3
!  4 |  6
!  3 | -2
!  7 | -7
! (4 rows)
! 
! SELECT * FROM rw_view1;
!  a | b  
! ---+----
!  7 | -7
!  3 | -2
!  1 |  3
!  4 |  6
! (4 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- multiple array-column updates
! CREATE TABLE base_tbl (a int, arr int[]) DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl VALUES (1,ARRAY[2]), (3,ARRAY[4]);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
! UPDATE rw_view1 SET arr[1] = 42, arr[2] = 77 WHERE a = 3;
! SELECT * FROM rw_view1;
!  a |   arr   
! ---+---------
!  1 | {2}
!  3 | {42,77}
! (2 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- views with updatable and non-updatable columns
! CREATE TABLE base_tbl(a float) DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl SELECT i/10.0 FROM generate_series(1,10) g(i);
! CREATE VIEW rw_view1 AS
!   SELECT ctid, sin(a) s, a, cos(a) c
!   FROM base_tbl
!   WHERE a != 0
!   ORDER BY abs(a);
! INSERT INTO rw_view1 VALUES (null, null, 1.1, null); -- should fail
! ERROR:  cannot insert into column "ctid" of view "rw_view1"
! DETAIL:  View columns that refer to system columns are not updatable.
! INSERT INTO rw_view1 (s, c, a) VALUES (null, null, 1.1); -- should fail
! ERROR:  cannot insert into column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view1 (a) VALUES (1.1) RETURNING a, s, c; -- OK
!   a  |         s         |         c         
! -----+-------------------+-------------------
!  1.1 | 0.891207360061435 | 0.453596121425577
! (1 row)
! 
! UPDATE rw_view1 SET s = s WHERE a = 1.1; -- should fail
! ERROR:  cannot update column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view1 SET a = 1.05 WHERE a = 1.1 RETURNING s; -- OK
!          s         
! -------------------
!  0.867423225594017
! (1 row)
! 
! DELETE FROM rw_view1 WHERE a = 1.05; -- OK
! CREATE VIEW rw_view2 AS
!   SELECT s, c, s/c t, a base_a, ctid
!   FROM rw_view1;
! INSERT INTO rw_view2 VALUES (null, null, null, 1.1, null); -- should fail
! ERROR:  cannot insert into column "t" of view "rw_view2"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view2(s, c, base_a) VALUES (null, null, 1.1); -- should fail
! ERROR:  cannot insert into column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view2(base_a) VALUES (1.1) RETURNING t; -- OK
!         t         
! ------------------
!  1.96475965724865
! (1 row)
! 
! UPDATE rw_view2 SET s = s WHERE base_a = 1.1; -- should fail
! ERROR:  cannot update column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view2 SET t = t WHERE base_a = 1.1; -- should fail
! ERROR:  cannot update column "t" of view "rw_view2"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view2 SET base_a = 1.05 WHERE base_a = 1.1; -- OK
! DELETE FROM rw_view2 WHERE base_a = 1.05 RETURNING base_a, s, c, t; -- OK
!  base_a |         s         |         c         |        t         
! --------+-------------------+-------------------+------------------
!    1.05 | 0.867423225594017 | 0.497571047891727 | 1.74331530998317
! (1 row)
! 
! CREATE VIEW rw_view3 AS
!   SELECT s, c, s/c t, ctid
!   FROM rw_view1;
! INSERT INTO rw_view3 VALUES (null, null, null, null); -- should fail
! ERROR:  cannot insert into column "t" of view "rw_view3"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! INSERT INTO rw_view3(s) VALUES (null); -- should fail
! ERROR:  cannot insert into column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! UPDATE rw_view3 SET s = s; -- should fail
! ERROR:  cannot update column "s" of view "rw_view1"
! DETAIL:  View columns that are not columns of their base relation are not updatable.
! DELETE FROM rw_view3 WHERE s = sin(0.1); -- should be OK
! SELECT * FROM base_tbl ORDER BY a;
!   a  
! -----
!  0.1
!  0.2
!  0.3
!  0.4
!  0.5
!  0.6
!  0.7
!  0.8
!  0.9
!    1
! (10 rows)
! 
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
!  rw_view2   | YES
!  rw_view3   | NO
! (3 rows)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name;
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
!  rw_view2   | YES          | YES
!  rw_view3   | NO           | NO
! (3 rows)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name LIKE E'r_\\_view%'
!  ORDER BY table_name, ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | ctid        | NO
!  rw_view1   | s           | NO
!  rw_view1   | a           | YES
!  rw_view1   | c           | NO
!  rw_view2   | s           | NO
!  rw_view2   | c           | NO
!  rw_view2   | t           | NO
!  rw_view2   | base_a      | YES
!  rw_view2   | ctid        | NO
!  rw_view3   | s           | NO
!  rw_view3   | c           | NO
!  rw_view3   | t           | NO
!  rw_view3   | ctid        | NO
! (13 rows)
! 
! SELECT events & 4 != 0 AS upd,
!        events & 8 != 0 AS ins,
!        events & 16 != 0 AS del
!   FROM pg_catalog.pg_relation_is_updatable('rw_view3'::regclass, false) t(events);
!  upd | ins | del 
! -----+-----+-----
!  f   | f   | t
! (1 row)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! drop cascades to view rw_view3
! -- inheritance tests
! CREATE TABLE base_tbl_parent (a int) DISTRIBUTE BY REPLICATION;
! CREATE TABLE base_tbl_child (CHECK (a > 0)) INHERITS (base_tbl_parent) DISTRIBUTE BY REPLICATION;
! WARNING:  Inherited/partition tables inherit distribution from the parent
! DETAIL:  Explicitly specified distribution will be ignored
! INSERT INTO base_tbl_parent SELECT * FROM generate_series(-8, -1);
! INSERT INTO base_tbl_child SELECT * FROM generate_series(1, 8);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl_parent;
! CREATE VIEW rw_view2 AS SELECT * FROM ONLY base_tbl_parent;
! SELECT * FROM rw_view1 ORDER BY a;
!  a  
! ----
!  -8
!  -7
!  -6
!  -5
!  -4
!  -3
!  -2
!  -1
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
! (16 rows)
! 
! SELECT * FROM ONLY rw_view1 ORDER BY a;
!  a  
! ----
!  -8
!  -7
!  -6
!  -5
!  -4
!  -3
!  -2
!  -1
!   1
!   2
!   3
!   4
!   5
!   6
!   7
!   8
! (16 rows)
! 
! SELECT * FROM rw_view2 ORDER BY a;
!  a  
! ----
!  -8
!  -7
!  -6
!  -5
!  -4
!  -3
!  -2
!  -1
! (8 rows)
! 
! INSERT INTO rw_view1 VALUES (-100), (100);
! INSERT INTO rw_view2 VALUES (-200), (200);
! UPDATE rw_view1 SET a = a*10 WHERE a IN (-1, 1); -- Should produce -10 and 10
! UPDATE ONLY rw_view1 SET a = a*10 WHERE a IN (-2, 2); -- Should produce -20 and 20
! UPDATE rw_view2 SET a = a*10 WHERE a IN (-3, 3); -- Should produce -30 only
! UPDATE ONLY rw_view2 SET a = a*10 WHERE a IN (-4, 4); -- Should produce -40 only
! DELETE FROM rw_view1 WHERE a IN (-5, 5); -- Should delete -5 and 5
! DELETE FROM ONLY rw_view1 WHERE a IN (-6, 6); -- Should delete -6 and 6
! DELETE FROM rw_view2 WHERE a IN (-7, 7); -- Should delete -7 only
! DELETE FROM ONLY rw_view2 WHERE a IN (-8, 8); -- Should delete -8 only
! SELECT * FROM ONLY base_tbl_parent ORDER BY a;
!   a   
! ------
!  -200
!  -100
!   -40
!   -30
!   -20
!   -10
!   100
!   200
! (8 rows)
! 
! SELECT * FROM base_tbl_child ORDER BY a;
!  a  
! ----
!   3
!   4
!   7
!   8
!  10
!  20
! (6 rows)
! 
! DROP TABLE base_tbl_parent, base_tbl_child CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- simple WITH CHECK OPTION
! CREATE TABLE base_tbl (a int, b int DEFAULT 10) DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl VALUES (1,2), (2,3), (1,-1);
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b
!   WITH LOCAL CHECK OPTION;
! \d+ rw_view1
!                           View "public.rw_view1"
!  Column |  Type   | Collation | Nullable | Default | Storage | Description 
! --------+---------+-----------+----------+---------+---------+-------------
!  a      | integer |           |          |         | plain   | 
!  b      | integer |           |          |         | plain   | 
! View definition:
!  SELECT base_tbl.a,
!     base_tbl.b
!    FROM base_tbl
!   WHERE base_tbl.a < base_tbl.b;
! Options: check_option=local
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view1';
!  table_catalog | table_schema | table_name |          view_definition           | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+------------------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view1   |  SELECT base_tbl.a,               +| LOCAL        | YES          | YES                | NO                   | NO                   | NO
!                |              |            |     base_tbl.b                    +|              |              |                    |                      |                      | 
!                |              |            |    FROM base_tbl                  +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (base_tbl.a < base_tbl.b); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view1 VALUES(3,4); -- ok
! INSERT INTO rw_view1 VALUES(4,3); -- should fail
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (4, 3).
! INSERT INTO rw_view1 VALUES(5,null); -- should fail
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (5, null).
! UPDATE rw_view1 SET b = 5 WHERE a = 3; -- ok
! UPDATE rw_view1 SET b = -5 WHERE a = 3; -- should fail
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (3, -5).
! INSERT INTO rw_view1(a) VALUES (9); -- ok
! INSERT INTO rw_view1(a) VALUES (10); -- should fail
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (10, 10).
! SELECT * FROM base_tbl;
!  a | b  
! ---+----
!  1 |  2
!  2 |  3
!  1 | -1
!  3 |  5
!  9 | 10
! (5 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- WITH LOCAL/CASCADED CHECK OPTION
! CREATE TABLE base_tbl (a int) DISTRIBUTE BY REPLICATION;
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a > 0;
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
!   WITH CHECK OPTION; -- implicitly cascaded
! \d+ rw_view2
!                           View "public.rw_view2"
!  Column |  Type   | Collation | Nullable | Default | Storage | Description 
! --------+---------+-----------+----------+---------+---------+-------------
!  a      | integer |           |          |         | plain   | 
! View definition:
!  SELECT rw_view1.a
!    FROM rw_view1
!   WHERE rw_view1.a < 10;
! Options: check_option=cascaded
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
!  table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view2   |  SELECT rw_view1.a        +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view2 VALUES (-5); -- should fail
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (-5).
! INSERT INTO rw_view2 VALUES (5); -- ok
! INSERT INTO rw_view2 VALUES (15); -- should fail
! ERROR:  new row violates check option for view "rw_view2"
! DETAIL:  Failing row contains (15).
! SELECT * FROM base_tbl;
!  a 
! ---
!  5
! (1 row)
! 
! UPDATE rw_view2 SET a = a - 10; -- should fail
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (-5).
! UPDATE rw_view2 SET a = a + 10; -- should fail
! ERROR:  new row violates check option for view "rw_view2"
! DETAIL:  Failing row contains (15).
! CREATE OR REPLACE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
!   WITH LOCAL CHECK OPTION;
! \d+ rw_view2
!                           View "public.rw_view2"
!  Column |  Type   | Collation | Nullable | Default | Storage | Description 
! --------+---------+-----------+----------+---------+---------+-------------
!  a      | integer |           |          |         | plain   | 
! View definition:
!  SELECT rw_view1.a
!    FROM rw_view1
!   WHERE rw_view1.a < 10;
! Options: check_option=local
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
!  table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view2   |  SELECT rw_view1.a        +| LOCAL        | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view2 VALUES (-10); -- ok, but not in view
! INSERT INTO rw_view2 VALUES (20); -- should fail
! ERROR:  new row violates check option for view "rw_view2"
! DETAIL:  Failing row contains (20).
! SELECT * FROM base_tbl;
!   a  
! -----
!    5
!  -10
! (2 rows)
! 
! ALTER VIEW rw_view1 SET (check_option=here); -- invalid
! ERROR:  invalid value for "check_option" option
! DETAIL:  Valid values are "local" and "cascaded".
! ALTER VIEW rw_view1 SET (check_option=local);
! INSERT INTO rw_view2 VALUES (-20); -- should fail
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (-20).
! INSERT INTO rw_view2 VALUES (30); -- should fail
! ERROR:  new row violates check option for view "rw_view2"
! DETAIL:  Failing row contains (30).
! ALTER VIEW rw_view2 RESET (check_option);
! \d+ rw_view2
!                           View "public.rw_view2"
!  Column |  Type   | Collation | Nullable | Default | Storage | Description 
! --------+---------+-----------+----------+---------+---------+-------------
!  a      | integer |           |          |         | plain   | 
! View definition:
!  SELECT rw_view1.a
!    FROM rw_view1
!   WHERE rw_view1.a < 10;
! 
! SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
!  table_catalog | table_schema | table_name |      view_definition       | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+----------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view2   |  SELECT rw_view1.a        +| NONE         | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1          +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a < 10); |              |              |                    |                      |                      | 
! (1 row)
! 
! INSERT INTO rw_view2 VALUES (30); -- ok, but not in view
! SELECT * FROM base_tbl;
!   a  
! -----
!    5
!  -10
!   30
! (3 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- WITH CHECK OPTION with no local view qual
! CREATE TABLE base_tbl (a int) DISTRIBUTE BY REPLICATION;
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WITH CHECK OPTION;
! CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a > 0;
! CREATE VIEW rw_view3 AS SELECT * FROM rw_view2 WITH CHECK OPTION;
! SELECT * FROM information_schema.views WHERE table_name LIKE E'rw\\_view_' ORDER BY table_name;
!  table_catalog | table_schema | table_name |      view_definition      | check_option | is_updatable | is_insertable_into | is_trigger_updatable | is_trigger_deletable | is_trigger_insertable_into 
! ---------------+--------------+------------+---------------------------+--------------+--------------+--------------------+----------------------+----------------------+----------------------------
!  regression    | public       | rw_view1   |  SELECT base_tbl.a       +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM base_tbl;         |              |              |                    |                      |                      | 
!  regression    | public       | rw_view2   |  SELECT rw_view1.a       +| NONE         | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view1         +|              |              |                    |                      |                      | 
!                |              |            |   WHERE (rw_view1.a > 0); |              |              |                    |                      |                      | 
!  regression    | public       | rw_view3   |  SELECT rw_view2.a       +| CASCADED     | YES          | YES                | NO                   | NO                   | NO
!                |              |            |    FROM rw_view2;         |              |              |                    |                      |                      | 
! (3 rows)
! 
! INSERT INTO rw_view1 VALUES (-1); -- ok
! INSERT INTO rw_view1 VALUES (1); -- ok
! INSERT INTO rw_view2 VALUES (-2); -- ok, but not in view
! INSERT INTO rw_view2 VALUES (2); -- ok
! INSERT INTO rw_view3 VALUES (-3); -- should fail
! ERROR:  new row violates check option for view "rw_view2"
! DETAIL:  Failing row contains (-3).
! INSERT INTO rw_view3 VALUES (3); -- ok
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! drop cascades to view rw_view3
! -- WITH CHECK OPTION with scalar array ops
! CREATE TABLE base_tbl (a int, b int[]) DISTRIBUTE BY REPLICATION;
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a = ANY (b)
!   WITH CHECK OPTION;
! INSERT INTO rw_view1 VALUES (1, ARRAY[1,2,3]); -- ok
! INSERT INTO rw_view1 VALUES (10, ARRAY[4,5]); -- should fail
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (10, {4,5}).
! UPDATE rw_view1 SET b[2] = -b[2] WHERE a = 1; -- ok
! UPDATE rw_view1 SET b[1] = -b[1] WHERE a = 1; -- should fail
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (1, {-1,-2,3}).
! PREPARE ins(int, int[]) AS INSERT INTO rw_view1 VALUES($1, $2);
! EXECUTE ins(2, ARRAY[1,2,3]); -- ok
! EXECUTE ins(10, ARRAY[4,5]); -- should fail
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (10, {4,5}).
! DEALLOCATE PREPARE ins;
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- WITH CHECK OPTION with subquery
! CREATE TABLE base_tbl (a int) DISTRIBUTE BY REPLICATION;
! CREATE TABLE ref_tbl (a int PRIMARY KEY) DISTRIBUTE BY REPLICATION;
! INSERT INTO ref_tbl SELECT * FROM generate_series(1,10);
! CREATE VIEW rw_view1 AS
!   SELECT * FROM base_tbl b
!   WHERE EXISTS(SELECT 1 FROM ref_tbl r WHERE r.a = b.a)
!   WITH CHECK OPTION;
! --INSERT INTO rw_view1 VALUES (5); -- ok
! INSERT INTO rw_view1 VALUES (15); -- should fail
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (15).
! UPDATE rw_view1 SET a = a + 5; -- ok
! UPDATE rw_view1 SET a = a + 5; -- should fail
! EXPLAIN (costs off, nodes off) INSERT INTO rw_view1 VALUES (5);
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Insert on base_tbl b
!          ->  Result
!                SubPlan 1
!                  ->  Remote Subquery Scan on all
!                        ->  Index Only Scan using ref_tbl_pkey on ref_tbl r
!                              Index Cond: (a = b.a)
! (7 rows)
! 
! EXPLAIN (costs off, nodes off) UPDATE rw_view1 SET a = a + 5;
!                                  QUERY PLAN                                  
! -----------------------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Update on base_tbl b
!          ->  Hash Join
!                Hash Cond: (b.a = r.a)
!                ->  Seq Scan on base_tbl b
!                ->  Hash
!                      ->  Seq Scan on ref_tbl r
!                SubPlan 1
!                  ->  Remote Subquery Scan on all
!                        ->  Index Only Scan using ref_tbl_pkey on ref_tbl r_1
!                              Index Cond: (a = b.a)
! (11 rows)
! 
! DROP TABLE base_tbl, ref_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- WITH CHECK OPTION with BEFORE trigger on base table
! CREATE TABLE base_tbl (a int, b int) DISTRIBUTE BY REPLICATION;
! CREATE FUNCTION base_tbl_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   NEW.b := 10;
!   RETURN NEW;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER base_tbl_trig BEFORE INSERT OR UPDATE ON base_tbl
!   FOR EACH ROW EXECUTE PROCEDURE base_tbl_trig_fn();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b WITH CHECK OPTION;
! INSERT INTO rw_view1 VALUES (5,0); -- ok
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (5, 0).
! INSERT INTO rw_view1 VALUES (15, 20); -- should fail
! UPDATE rw_view1 SET a = 20, b = 30; -- should fail
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! DROP FUNCTION base_tbl_trig_fn();
! -- WITH LOCAL CHECK OPTION with INSTEAD OF trigger on base view
! CREATE TABLE base_tbl (a int, b int) DISTRIBUTE BY REPLICATION;
! CREATE VIEW rw_view1 AS SELECT a FROM base_tbl WHERE a < b;
! CREATE FUNCTION rw_view1_trig_fn()
! RETURNS trigger AS
! $$
! BEGIN
!   IF TG_OP = 'INSERT' THEN
!     INSERT INTO base_tbl VALUES (NEW.a, 10);
!     RETURN NEW;
!   ELSIF TG_OP = 'UPDATE' THEN
!     UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
!     RETURN NEW;
!   ELSIF TG_OP = 'DELETE' THEN
!     DELETE FROM base_tbl WHERE a=OLD.a;
!     RETURN OLD;
!   END IF;
! END;
! $$
! LANGUAGE plpgsql;
! CREATE TRIGGER rw_view1_trig
!   INSTEAD OF INSERT OR UPDATE OR DELETE ON rw_view1
!   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
! CREATE VIEW rw_view2 AS
!   SELECT * FROM rw_view1 WHERE a > 0 WITH LOCAL CHECK OPTION;
! INSERT INTO rw_view2 VALUES (-5); -- should fail
! ERROR:  new row violates check option for view "rw_view2"
! DETAIL:  Failing row contains (-5, null).
! INSERT INTO rw_view2 VALUES (5); -- ok
! INSERT INTO rw_view2 VALUES (50); -- ok, but not in view
! UPDATE rw_view2 SET a = a - 10; -- should fail
! SELECT * FROM base_tbl;
!  a  | b 
! ----+---
!   5 |  
!  50 |  
! (2 rows)
! 
! -- Check option won't cascade down to base view with INSTEAD OF triggers
! ALTER VIEW rw_view2 SET (check_option=cascaded);
! INSERT INTO rw_view2 VALUES (100); -- ok, but not in view (doesn't fail rw_view1's check)
! ERROR:  new row violates check option for view "rw_view1"
! DETAIL:  Failing row contains (100, null).
! UPDATE rw_view2 SET a = 200 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view1's check)
! SELECT * FROM base_tbl;
!  a  | b 
! ----+---
!   5 |  
!  50 |  
! (2 rows)
! 
! -- Neither local nor cascaded check options work with INSTEAD rules
! DROP TRIGGER rw_view1_trig ON rw_view1;
! ERROR:  trigger "rw_view1_trig" for table "rw_view1" does not exist
! CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
!   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, 10);
! CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1
!   DO INSTEAD UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
! INSERT INTO rw_view2 VALUES (-10); -- ok, but not in view (doesn't fail rw_view2's check)
! INSERT INTO rw_view2 VALUES (5); -- ok
! INSERT INTO rw_view2 VALUES (20); -- ok, but not in view (doesn't fail rw_view1's check)
! UPDATE rw_view2 SET a = 30 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view1's check)
! INSERT INTO rw_view2 VALUES (5); -- ok
! UPDATE rw_view2 SET a = -5 WHERE a = 5; -- ok, but not in view (doesn't fail rw_view2's check)
! SELECT * FROM base_tbl;
!   a  | b  
! -----+----
!   50 |   
!  -10 | 10
!   20 | 10
!   30 |   
!   30 | 10
!   -5 | 10
! (6 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! DROP FUNCTION rw_view1_trig_fn();
! CREATE TABLE base_tbl (a int) DISTRIBUTE BY REPLICATION;
! CREATE VIEW rw_view1 AS SELECT a,10 AS b FROM base_tbl;
! CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
!   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a);
! CREATE VIEW rw_view2 AS
!   SELECT * FROM rw_view1 WHERE a > b WITH LOCAL CHECK OPTION;
! INSERT INTO rw_view2 VALUES (2,3); -- ok, but not in view (doesn't fail rw_view2's check)
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- security barrier view
! CREATE TABLE base_tbl (person text, visibility text) DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl VALUES ('Tom', 'public'),
!                             ('Dick', 'private'),
!                             ('Harry', 'public');
! CREATE VIEW rw_view1 AS
!   SELECT person FROM base_tbl WHERE visibility = 'public';
! CREATE FUNCTION snoop(anyelement)
! RETURNS boolean AS
! $$
! BEGIN
!   RAISE NOTICE 'snooped value: %', $1;
!   RETURN true;
! END;
! $$
! LANGUAGE plpgsql COST 0.000001;
! CREATE OR REPLACE FUNCTION leakproof(anyelement)
! RETURNS boolean AS
! $$
! BEGIN
!   RETURN true;
! END;
! $$
! LANGUAGE plpgsql STRICT IMMUTABLE LEAKPROOF;
! SELECT * FROM rw_view1 WHERE snoop(person);
!  person 
! --------
!  Tom
!  Harry
! (2 rows)
! 
! UPDATE rw_view1 SET person=person WHERE snoop(person);
! DELETE FROM rw_view1 WHERE NOT snoop(person);
! ALTER VIEW rw_view1 SET (security_barrier = true);
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view1';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view1   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view1';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view1   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view1'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view1   | person      | YES
! (1 row)
! 
! SELECT * FROM rw_view1 WHERE snoop(person);
!  person 
! --------
!  Tom
!  Harry
! (2 rows)
! 
! UPDATE rw_view1 SET person=person WHERE snoop(person);
! DELETE FROM rw_view1 WHERE NOT snoop(person);
! EXPLAIN (costs off, nodes off) SELECT * FROM rw_view1 WHERE snoop(person);
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Subquery Scan on rw_view1
!          Filter: snoop(rw_view1.person)
!          ->  Seq Scan on base_tbl
!                Filter: (visibility = 'public'::text)
! (5 rows)
! 
! EXPLAIN (costs off, nodes off) UPDATE rw_view1 SET person=person WHERE snoop(person);
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Update on base_tbl
!          ->  Seq Scan on base_tbl
!                Filter: ((visibility = 'public'::text) AND snoop(person))
! (4 rows)
! 
! EXPLAIN (costs off, nodes off) DELETE FROM rw_view1 WHERE NOT snoop(person);
!                                   QUERY PLAN                                   
! -------------------------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Delete on base_tbl
!          ->  Seq Scan on base_tbl
!                Filter: ((visibility = 'public'::text) AND (NOT snoop(person)))
! (4 rows)
! 
! -- security barrier view on top of security barrier view
! CREATE VIEW rw_view2 WITH (security_barrier = true) AS
!   SELECT * FROM rw_view1 WHERE snoop(person);
! SELECT table_name, is_insertable_into
!   FROM information_schema.tables
!  WHERE table_name = 'rw_view2';
!  table_name | is_insertable_into 
! ------------+--------------------
!  rw_view2   | YES
! (1 row)
! 
! SELECT table_name, is_updatable, is_insertable_into
!   FROM information_schema.views
!  WHERE table_name = 'rw_view2';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  rw_view2   | YES          | YES
! (1 row)
! 
! SELECT table_name, column_name, is_updatable
!   FROM information_schema.columns
!  WHERE table_name = 'rw_view2'
!  ORDER BY ordinal_position;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  rw_view2   | person      | YES
! (1 row)
! 
! SELECT * FROM rw_view2 WHERE snoop(person);
!  person 
! --------
!  Tom
!  Harry
! (2 rows)
! 
! UPDATE rw_view2 SET person=person WHERE snoop(person);
! DELETE FROM rw_view2 WHERE NOT snoop(person);
! EXPLAIN (costs off, nodes off) SELECT * FROM rw_view2 WHERE snoop(person);
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Subquery Scan on rw_view2
!          Filter: snoop(rw_view2.person)
!          ->  Subquery Scan on rw_view1
!                Filter: snoop(rw_view1.person)
!                ->  Seq Scan on base_tbl
!                      Filter: (visibility = 'public'::text)
! (7 rows)
! 
! EXPLAIN (costs off, nodes off) UPDATE rw_view2 SET person=person WHERE snoop(person);
!                                         QUERY PLAN                                         
! -------------------------------------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Update on base_tbl
!          ->  Seq Scan on base_tbl
!                Filter: ((visibility = 'public'::text) AND snoop(person) AND snoop(person))
! (4 rows)
! 
! EXPLAIN (costs off, nodes off) DELETE FROM rw_view2 WHERE NOT snoop(person);
!                                            QUERY PLAN                                            
! -------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Delete on base_tbl
!          ->  Seq Scan on base_tbl
!                Filter: ((visibility = 'public'::text) AND snoop(person) AND (NOT snoop(person)))
! (4 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
! -- security barrier view on top of table with rules
! CREATE TABLE base_tbl(id int PRIMARY KEY, data text, deleted boolean) DISTRIBUTE BY REPLICATION;
! INSERT INTO base_tbl VALUES (1, 'Row 1', false), (2, 'Row 2', true);
! CREATE RULE base_tbl_ins_rule AS ON INSERT TO base_tbl
!   WHERE EXISTS (SELECT 1 FROM base_tbl t WHERE t.id = new.id)
!   DO INSTEAD
!     UPDATE base_tbl SET data = new.data, deleted = false WHERE id = new.id;
! CREATE RULE base_tbl_del_rule AS ON DELETE TO base_tbl
!   DO INSTEAD
!     UPDATE base_tbl SET deleted = true WHERE id = old.id;
! CREATE VIEW rw_view1 WITH (security_barrier=true) AS
!   SELECT id, data FROM base_tbl WHERE NOT deleted;
! SELECT * FROM rw_view1;
!  id | data  
! ----+-------
!   1 | Row 1
! (1 row)
! 
! EXPLAIN (costs off, nodes off) DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Update on base_tbl base_tbl_1
!          ->  Nested Loop
!                ->  Index Scan using base_tbl_pkey on base_tbl base_tbl_1
!                      Index Cond: (id = 1)
!                ->  Index Scan using base_tbl_pkey on base_tbl
!                      Index Cond: (id = 1)
!                      Filter: ((NOT deleted) AND snoop(data))
! (8 rows)
! 
! DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
! EXPLAIN (costs off, nodes off) INSERT INTO rw_view1 VALUES (2, 'New row 2');
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Remote Subquery Scan on any
!    ->  Insert on base_tbl
!          InitPlan 1 (returns $0)
!            ->  Remote Subquery Scan on all
!                  ->  Index Only Scan using base_tbl_pkey on base_tbl t
!                        Index Cond: (id = 2)
!          ->  Result
!                One-Time Filter: ($0 IS NOT TRUE)
!  
!  Remote Subquery Scan on any
!    ->  Update on base_tbl
!          InitPlan 1 (returns $0)
!            ->  Remote Subquery Scan on all
!                  ->  Index Only Scan using base_tbl_pkey on base_tbl t
!                        Index Cond: (id = 2)
!          ->  Result
!                One-Time Filter: $0
!                ->  Index Scan using base_tbl_pkey on base_tbl
!                      Index Cond: (id = 2)
! (19 rows)
! 
! INSERT INTO rw_view1 VALUES (2, 'New row 2');
! SELECT * FROM base_tbl;
!  id |   data    | deleted 
! ----+-----------+---------
!   1 | Row 1     | t
!   2 | New row 2 | f
! (2 rows)
! 
! DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to view rw_view1
! -- security barrier view based on inheritance set
! CREATE TABLE t1 (a int, b float, c text) DISTRIBUTE BY REPLICATION;
! CREATE INDEX t1_a_idx ON t1(a);
! INSERT INTO t1
! SELECT i,i,'t1' FROM generate_series(1,10) g(i);
! ANALYZE t1;
! CREATE TABLE t11 (d text) INHERITS (t1) DISTRIBUTE BY REPLICATION;
! WARNING:  Inherited/partition tables inherit distribution from the parent
! DETAIL:  Explicitly specified distribution will be ignored
! CREATE INDEX t11_a_idx ON t11(a);
! INSERT INTO t11
! SELECT i,i,'t11','t11d' FROM generate_series(1,10) g(i);
! ANALYZE t11;
! CREATE TABLE t12 (e int[]) INHERITS (t1) DISTRIBUTE BY REPLICATION;
! WARNING:  Inherited/partition tables inherit distribution from the parent
! DETAIL:  Explicitly specified distribution will be ignored
! CREATE INDEX t12_a_idx ON t12(a);
! INSERT INTO t12
! SELECT i,i,'t12','{1,2}'::int[] FROM generate_series(1,10) g(i);
! ANALYZE t12;
! CREATE TABLE t111 () INHERITS (t11, t12) DISTRIBUTE BY REPLICATION;
! WARNING:  Inherited/partition tables inherit distribution from the parent
! DETAIL:  Explicitly specified distribution will be ignored
! NOTICE:  merging multiple inherited definitions of column "a"
! NOTICE:  merging multiple inherited definitions of column "b"
! NOTICE:  merging multiple inherited definitions of column "c"
! CREATE INDEX t111_a_idx ON t111(a);
! INSERT INTO t111
! SELECT i,i,'t111','t111d','{1,1,1}'::int[] FROM generate_series(1,10) g(i);
! ANALYZE t111;
! CREATE VIEW v1 WITH (security_barrier=true) AS
! SELECT *, (SELECT d FROM t11 WHERE t11.a = t1.a LIMIT 1) AS d
! FROM t1
! WHERE a > 5 AND EXISTS(SELECT 1 FROM t12 WHERE t12.a = t1.a);
! SELECT * FROM v1 WHERE a=3; -- should not see anything
!  a | b | c | d 
! ---+---+---+---
! (0 rows)
! 
! SELECT * FROM v1 WHERE a=8;
!  a | b |  c   |  d   
! ---+---+------+------
!  8 | 8 | t1   | t11d
!  8 | 8 | t11  | t11d
!  8 | 8 | t12  | t11d
!  8 | 8 | t111 | t11d
! (4 rows)
! 
! EXPLAIN (VERBOSE, COSTS OFF)
! UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
!                                           QUERY PLAN                                           
! -----------------------------------------------------------------------------------------------
!  Remote Subquery Scan on any (datanode_1,datanode_2)
!    ->  Update on public.t1
!          Update on public.t1
!          Update on public.t11
!          Update on public.t12
!          Update on public.t111
!          ->  Index Scan using t1_a_idx on public.t1
!                Output: 100, t1.b, t1.c, t1.ctid
!                Index Cond: ((t1.a > 5) AND (t1.a < 7))
!                Filter: ((t1.a <> 6) AND (SubPlan 1) AND snoop(t1.a) AND leakproof(t1.a))
!                SubPlan 1
!                  ->  Remote Subquery Scan on all (datanode_1)
!                        ->  Append
!                              ->  Seq Scan on public.t12 t12_1
!                                    Filter: (t12_1.a = t1.a)
!                              ->  Seq Scan on public.t111 t111_1
!                                    Filter: (t111_1.a = t1.a)
!          ->  Index Scan using t11_a_idx on public.t11
!                Output: 100, t11.b, t11.c, t11.d, t11.ctid
!                Index Cond: ((t11.a > 5) AND (t11.a < 7))
!                Filter: ((t11.a <> 6) AND (SubPlan 1) AND snoop(t11.a) AND leakproof(t11.a))
!          ->  Index Scan using t12_a_idx on public.t12
!                Output: 100, t12.b, t12.c, t12.e, t12.ctid
!                Index Cond: ((t12.a > 5) AND (t12.a < 7))
!                Filter: ((t12.a <> 6) AND (SubPlan 1) AND snoop(t12.a) AND leakproof(t12.a))
!          ->  Index Scan using t111_a_idx on public.t111
!                Output: 100, t111.b, t111.c, t111.d, t111.e, t111.ctid
!                Index Cond: ((t111.a > 5) AND (t111.a < 7))
!                Filter: ((t111.a <> 6) AND (SubPlan 1) AND snoop(t111.a) AND leakproof(t111.a))
! (29 rows)
! 
! UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
! SELECT * FROM v1 WHERE a=100; -- Nothing should have been changed to 100
!  a | b | c | d 
! ---+---+---+---
! (0 rows)
! 
! SELECT * FROM t1 WHERE a=100; -- Nothing should have been changed to 100
!  a | b | c 
! ---+---+---
! (0 rows)
! 
! EXPLAIN (VERBOSE, COSTS OFF)
! UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
!                                   QUERY PLAN                                   
! -------------------------------------------------------------------------------
!  Remote Subquery Scan on any (datanode_1,datanode_2)
!    ->  Update on public.t1
!          Update on public.t1
!          Update on public.t11
!          Update on public.t12
!          Update on public.t111
!          ->  Index Scan using t1_a_idx on public.t1
!                Output: (t1.a + 1), t1.b, t1.c, t1.ctid
!                Index Cond: ((t1.a > 5) AND (t1.a = 8))
!                Filter: ((SubPlan 1) AND snoop(t1.a) AND leakproof(t1.a))
!                SubPlan 1
!                  ->  Remote Subquery Scan on all (datanode_1)
!                        ->  Append
!                              ->  Seq Scan on public.t12 t12_1
!                                    Filter: (t12_1.a = t1.a)
!                              ->  Seq Scan on public.t111 t111_1
!                                    Filter: (t111_1.a = t1.a)
!          ->  Index Scan using t11_a_idx on public.t11
!                Output: (t11.a + 1), t11.b, t11.c, t11.d, t11.ctid
!                Index Cond: ((t11.a > 5) AND (t11.a = 8))
!                Filter: ((SubPlan 1) AND snoop(t11.a) AND leakproof(t11.a))
!          ->  Index Scan using t12_a_idx on public.t12
!                Output: (t12.a + 1), t12.b, t12.c, t12.e, t12.ctid
!                Index Cond: ((t12.a > 5) AND (t12.a = 8))
!                Filter: ((SubPlan 1) AND snoop(t12.a) AND leakproof(t12.a))
!          ->  Index Scan using t111_a_idx on public.t111
!                Output: (t111.a + 1), t111.b, t111.c, t111.d, t111.e, t111.ctid
!                Index Cond: ((t111.a > 5) AND (t111.a = 8))
!                Filter: ((SubPlan 1) AND snoop(t111.a) AND leakproof(t111.a))
! (29 rows)
! 
! UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
! SELECT * FROM v1 WHERE b=8;
!  a | b |  c   |  d   
! ---+---+------+------
!  9 | 8 | t1   | t11d
!  9 | 8 | t11  | t11d
!  9 | 8 | t12  | t11d
!  9 | 8 | t111 | t11d
! (4 rows)
! 
! DELETE FROM v1 WHERE snoop(a) AND leakproof(a); -- should not delete everything, just where a>5
! TABLE t1; -- verify all a<=5 are intact
!  a | b |  c   
! ---+---+------
!  1 | 1 | t1
!  2 | 2 | t1
!  3 | 3 | t1
!  4 | 4 | t1
!  5 | 5 | t1
!  1 | 1 | t11
!  2 | 2 | t11
!  3 | 3 | t11
!  4 | 4 | t11
!  5 | 5 | t11
!  1 | 1 | t12
!  2 | 2 | t12
!  3 | 3 | t12
!  4 | 4 | t12
!  5 | 5 | t12
!  1 | 1 | t111
!  2 | 2 | t111
!  3 | 3 | t111
!  4 | 4 | t111
!  5 | 5 | t111
! (20 rows)
! 
! DROP TABLE t1, t11, t12, t111 CASCADE;
! NOTICE:  drop cascades to view v1
! DROP FUNCTION snoop(anyelement);
! DROP FUNCTION leakproof(anyelement);
! CREATE TABLE tx1 (a integer);
! CREATE TABLE tx2 (b integer);
! CREATE TABLE tx3 (c integer);
! CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
! INSERT INTO vx1 values (1);
! SELECT * FROM tx1;
!  a 
! ---
!  1
! (1 row)
! 
! SELECT * FROM vx1;
!  a 
! ---
! (0 rows)
! 
! DROP VIEW vx1;
! DROP TABLE tx1;
! DROP TABLE tx2;
! DROP TABLE tx3;
! CREATE TABLE tx1 (a integer);
! CREATE TABLE tx2 (b integer);
! CREATE TABLE tx3 (c integer);
! CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
! INSERT INTO vx1 VALUES (1);
! INSERT INTO vx1 VALUES (1);
! SELECT * FROM tx1;
!  a 
! ---
!  1
!  1
! (2 rows)
! 
! SELECT * FROM vx1;
!  a 
! ---
! (0 rows)
! 
! DROP VIEW vx1;
! DROP TABLE tx1;
! DROP TABLE tx2;
! DROP TABLE tx3;
! CREATE TABLE tx1 (a integer, b integer);
! CREATE TABLE tx2 (b integer, c integer);
! CREATE TABLE tx3 (c integer, d integer);
! ALTER TABLE tx1 DROP COLUMN b;
! ALTER TABLE tx2 DROP COLUMN c;
! ALTER TABLE tx3 DROP COLUMN d;
! CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
! INSERT INTO vx1 VALUES (1);
! INSERT INTO vx1 VALUES (1);
! SELECT * FROM tx1;
!  a 
! ---
!  1
!  1
! (2 rows)
! 
! SELECT * FROM vx1;
!  a 
! ---
! (0 rows)
! 
! DROP VIEW vx1;
! DROP TABLE tx1;
! DROP TABLE tx2;
! DROP TABLE tx3;
! --
! -- Test handling of vars from correlated subqueries in quals from outer
! -- security barrier views, per bug #13988
! --
! CREATE TABLE t1 (a int, b text, c int) DISTRIBUTE BY REPLICATION;
! INSERT INTO t1 VALUES (1, 'one', 10);
! CREATE TABLE t2 (cc int) DISTRIBUTE BY REPLICATION;
! INSERT INTO t2 VALUES (10), (20);
! CREATE VIEW v1 WITH (security_barrier = true) AS
!   SELECT * FROM t1 WHERE (a > 0)
!   WITH CHECK OPTION;
! CREATE VIEW v2 WITH (security_barrier = true) AS
!   SELECT * FROM v1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.cc = v1.c)
!   WITH CHECK OPTION;
! INSERT INTO v2 VALUES (2, 'two', 20); -- ok
! INSERT INTO v2 VALUES (-2, 'minus two', 20); -- not allowed
! ERROR:  new row violates check option for view "v1"
! DETAIL:  Failing row contains (-2, minus two, 20).
! INSERT INTO v2 VALUES (3, 'three', 30); -- not allowed
! ERROR:  new row violates check option for view "v2"
! DETAIL:  Failing row contains (3, three, 30).
! UPDATE v2 SET b = 'ONE' WHERE a = 1; -- ok
! UPDATE v2 SET a = -1 WHERE a = 1; -- not allowed
! ERROR:  new row violates check option for view "v1"
! DETAIL:  Failing row contains (-1, ONE, 10).
! UPDATE v2 SET c = 30 WHERE a = 1; -- not allowed
! ERROR:  new row violates check option for view "v2"
! DETAIL:  Failing row contains (1, ONE, 30).
! DELETE FROM v2 WHERE a = 2; -- ok
! SELECT * FROM v2;
!  a |  b  | c  
! ---+-----+----
!  1 | ONE | 10
! (1 row)
! 
! DROP VIEW v2;
! DROP VIEW v1;
! DROP TABLE t2;
! DROP TABLE t1;
! --
! -- Test CREATE OR REPLACE VIEW turning a non-updatable view into an
! -- auto-updatable view and adding check options in a single step
! --
! CREATE TABLE t1 (a int, b text);
! CREATE VIEW v1 AS SELECT null::int AS a;
! CREATE OR REPLACE VIEW v1 AS SELECT * FROM t1 WHERE a > 0 WITH CHECK OPTION;
! INSERT INTO v1 VALUES (1, 'ok'); -- ok
! INSERT INTO v1 VALUES (-1, 'invalid'); -- should fail
! ERROR:  new row violates check option for view "v1"
! DETAIL:  Failing row contains (-1, invalid).
! DROP VIEW v1;
! DROP TABLE t1;
! -- check that an auto-updatable view on a partitioned table works correctly
! create table pt (a int, b int, v varchar) partition by range (a, b);
! create table pt1 (a int not null, b int not null, v varchar) partition by range (b);
! create table pt11 (like pt1);
! -- alter table pt11 drop a;
! -- alter table pt11 add a int;
! -- alter table pt11 drop a;
! -- alter table pt11 add a int not null;
! alter table pt1 attach partition pt11 for values from (2) to (5);
! alter table pt attach partition pt1 for values from (1, 2) to (1, 10);
! create view ptv as select * from pt;
! select events & 4 != 0 AS upd,
!        events & 8 != 0 AS ins,
!        events & 16 != 0 AS del
!   from pg_catalog.pg_relation_is_updatable('pt'::regclass, false) t(events);
!  upd | ins | del 
! -----+-----+-----
!  t   | t   | t
! (1 row)
! 
! select pg_catalog.pg_column_is_updatable('pt'::regclass, 1::smallint, false);
!  pg_column_is_updatable 
! ------------------------
!  t
! (1 row)
! 
! select pg_catalog.pg_column_is_updatable('pt'::regclass, 2::smallint, false);
!  pg_column_is_updatable 
! ------------------------
!  t
! (1 row)
! 
! select table_name, is_updatable, is_insertable_into
!   from information_schema.views where table_name = 'ptv';
!  table_name | is_updatable | is_insertable_into 
! ------------+--------------+--------------------
!  ptv        | YES          | YES
! (1 row)
! 
! select table_name, column_name, is_updatable
!   from information_schema.columns where table_name = 'ptv' order by column_name;
!  table_name | column_name | is_updatable 
! ------------+-------------+--------------
!  ptv        | a           | YES
!  ptv        | b           | YES
!  ptv        | v           | YES
! (3 rows)
! 
! insert into ptv values (1, 2);
! select tableoid::regclass, * from pt;
!  tableoid | a | b | v 
! ----------+---+---+---
!  pt11     | 1 | 2 | 
! (1 row)
! 
! create view ptv_wco as select * from pt where a = 0 with check option;
! insert into ptv_wco values (1, 2);
! ERROR:  new row violates check option for view "ptv_wco"
! DETAIL:  Failing row contains (1, 2, null).
! drop view ptv, ptv_wco;
! drop table pt, pt1, pt11;
! -- check that wholerow vars appearing in WITH CHECK OPTION constraint expressions
! -- work fine with partitioned tables
! create table wcowrtest (a int) partition by list (a);
! create table wcowrtest1 partition of wcowrtest for values in (1);
! create view wcowrtest_v as select * from wcowrtest where wcowrtest = '(2)'::wcowrtest with check option;
! insert into wcowrtest_v values (1);
! ERROR:  new row violates check option for view "wcowrtest_v"
! DETAIL:  Failing row contains (1).
! alter table wcowrtest add b text;
! create table wcowrtest2 (a int, b text, c int);
! alter table wcowrtest2 drop c;
! alter table wcowrtest attach partition wcowrtest2 for values in (2);
! create table sometable (a int, b text);
! insert into sometable values (1, 'a'), (2, 'b');
! create view wcowrtest_v2 as
!     select *
!       from wcowrtest r
!       where r in (select s from sometable s where r.a = s.a)
! with check option;
! -- WITH CHECK qual will be processed with wcowrtest2's
! -- rowtype after tuple-routing
! insert into wcowrtest_v2 values (2, 'no such row in sometable');
! ERROR:  new row violates check option for view "wcowrtest_v2"
! DETAIL:  Failing row contains (2, no such row in sometable).
! drop view wcowrtest_v, wcowrtest_v2;
! drop table wcowrtest, sometable;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/rolenames.out"	2025-07-31 16:07:14.998067930 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/rolenames.out"	2025-07-31 16:39:29.052088406 +0800
***************
*** 1,952 ****
! CREATE OR REPLACE FUNCTION chkrolattr()
!  RETURNS TABLE ("role" name, rolekeyword text, canlogin bool, replication bool)
!  AS $$
! SELECT r.rolname, v.keyword, r.rolcanlogin, r.rolreplication
!  FROM pg_roles r
!  JOIN (VALUES(CURRENT_USER, 'current_user'),
!              (SESSION_USER, 'session_user'),
!              ('current_user', '-'),
!              ('session_user', '-'),
!              ('Public', '-'),
!              ('None', '-'))
!       AS v(uname, keyword)
!       ON (r.rolname = v.uname)
!  ORDER BY 1;
! $$ LANGUAGE SQL;
! CREATE OR REPLACE FUNCTION chksetconfig()
!  RETURNS TABLE (db name, "role" name, rolkeyword text, setconfig text[])
!  AS $$
! SELECT COALESCE(d.datname, 'ALL'), COALESCE(r.rolname, 'ALL'),
! 	   COALESCE(v.keyword, '-'), s.setconfig
!  FROM pg_db_role_setting s
!  LEFT JOIN pg_roles r ON (r.oid = s.setrole)
!  LEFT JOIN pg_database d ON (d.oid = s.setdatabase)
!  LEFT JOIN (VALUES(CURRENT_USER, 'current_user'),
!              (SESSION_USER, 'session_user'))
!       AS v(uname, keyword)
!       ON (r.rolname = v.uname)
!    WHERE (r.rolname) IN ('Public', 'current_user', 'regress_testrol1', 'regress_testrol2')
! ORDER BY 1, 2;
! $$ LANGUAGE SQL;
! CREATE OR REPLACE FUNCTION chkumapping()
!  RETURNS TABLE (umname name, umserver name, umoptions text[])
!  AS $$
! SELECT r.rolname, s.srvname, m.umoptions
!  FROM pg_user_mapping m
!  LEFT JOIN pg_roles r ON (r.oid = m.umuser)
!  JOIN pg_foreign_server s ON (s.oid = m.umserver)
!  ORDER BY 2;
! $$ LANGUAGE SQL;
! CREATE ROLE "Public";
! CREATE ROLE "None";
! CREATE ROLE "current_user";
! CREATE ROLE "session_user";
! CREATE ROLE "user";
! CREATE ROLE current_user; -- error
! ERROR:  CURRENT_USER cannot be used as a role name here
! LINE 1: CREATE ROLE current_user;
!                     ^
! CREATE ROLE current_role; -- error
! ERROR:  syntax error at or near "current_role"
! LINE 1: CREATE ROLE current_role;
!                     ^
! CREATE ROLE session_user; -- error
! ERROR:  SESSION_USER cannot be used as a role name here
! LINE 1: CREATE ROLE session_user;
!                     ^
! CREATE ROLE user; -- error
! ERROR:  syntax error at or near "user"
! LINE 1: CREATE ROLE user;
!                     ^
! CREATE ROLE all; -- error
! ERROR:  syntax error at or near "all"
! LINE 1: CREATE ROLE all;
!                     ^
! CREATE ROLE public; -- error
! ERROR:  role name "public" is reserved
! LINE 1: CREATE ROLE public;
!                     ^
! CREATE ROLE "public"; -- error
! ERROR:  role name "public" is reserved
! LINE 1: CREATE ROLE "public";
!                     ^
! CREATE ROLE none; -- error
! ERROR:  role name "none" is reserved
! LINE 1: CREATE ROLE none;
!                     ^
! CREATE ROLE "none"; -- error
! ERROR:  role name "none" is reserved
! LINE 1: CREATE ROLE "none";
!                     ^
! CREATE ROLE pg_abc; -- error
! ERROR:  role name "pg_abc" is reserved
! DETAIL:  Role names starting with "pg_" are reserved.
! CREATE ROLE "pg_abc"; -- error
! ERROR:  role name "pg_abc" is reserved
! DETAIL:  Role names starting with "pg_" are reserved.
! CREATE ROLE pg_abcdef; -- error
! ERROR:  role name "pg_abcdef" is reserved
! DETAIL:  Role names starting with "pg_" are reserved.
! CREATE ROLE "pg_abcdef"; -- error
! ERROR:  role name "pg_abcdef" is reserved
! DETAIL:  Role names starting with "pg_" are reserved.
! CREATE ROLE regress_testrol0 SUPERUSER LOGIN;
! CREATE ROLE regress_testrolx SUPERUSER LOGIN;
! CREATE ROLE regress_testrol2 SUPERUSER;
! CREATE ROLE regress_testrol1 SUPERUSER LOGIN IN ROLE regress_testrol2;
! \c -
! SET SESSION AUTHORIZATION regress_testrol1;
! SET ROLE regress_testrol2;
! --  ALTER ROLE
! BEGIN;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | f
!  Public           | -            | f        | f
!  current_user     | -            | f        | f
!  regress_testrol1 | session_user | t        | f
!  regress_testrol2 | current_user | f        | f
!  session_user     | -            | f        | f
! (6 rows)
! 
! ALTER ROLE CURRENT_USER WITH REPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | f
!  Public           | -            | f        | f
!  current_user     | -            | f        | f
!  regress_testrol1 | session_user | t        | f
!  regress_testrol2 | current_user | f        | t
!  session_user     | -            | f        | f
! (6 rows)
! 
! ALTER ROLE "current_user" WITH REPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | f
!  Public           | -            | f        | f
!  current_user     | -            | f        | t
!  regress_testrol1 | session_user | t        | f
!  regress_testrol2 | current_user | f        | t
!  session_user     | -            | f        | f
! (6 rows)
! 
! ALTER ROLE SESSION_USER WITH REPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | f
!  Public           | -            | f        | f
!  current_user     | -            | f        | t
!  regress_testrol1 | session_user | t        | t
!  regress_testrol2 | current_user | f        | t
!  session_user     | -            | f        | f
! (6 rows)
! 
! ALTER ROLE "session_user" WITH REPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | f
!  Public           | -            | f        | f
!  current_user     | -            | f        | t
!  regress_testrol1 | session_user | t        | t
!  regress_testrol2 | current_user | f        | t
!  session_user     | -            | f        | t
! (6 rows)
! 
! ALTER USER "Public" WITH REPLICATION;
! ALTER USER "None" WITH REPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | t
!  Public           | -            | f        | t
!  current_user     | -            | f        | t
!  regress_testrol1 | session_user | t        | t
!  regress_testrol2 | current_user | f        | t
!  session_user     | -            | f        | t
! (6 rows)
! 
! ALTER USER regress_testrol1 WITH NOREPLICATION;
! ALTER USER regress_testrol2 WITH NOREPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | t
!  Public           | -            | f        | t
!  current_user     | -            | f        | t
!  regress_testrol1 | session_user | t        | f
!  regress_testrol2 | current_user | f        | f
!  session_user     | -            | f        | t
! (6 rows)
! 
! ROLLBACK;
! ALTER ROLE USER WITH LOGIN; -- error
! ERROR:  syntax error at or near "USER"
! LINE 1: ALTER ROLE USER WITH LOGIN;
!                    ^
! ALTER ROLE CURRENT_ROLE WITH LOGIN; --error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: ALTER ROLE CURRENT_ROLE WITH LOGIN;
!                    ^
! ALTER ROLE ALL WITH REPLICATION; -- error
! ERROR:  syntax error at or near "WITH"
! LINE 1: ALTER ROLE ALL WITH REPLICATION;
!                        ^
! ALTER ROLE SESSION_ROLE WITH NOREPLICATION; -- error
! ERROR:  role "session_role" does not exist
! ALTER ROLE PUBLIC WITH NOREPLICATION; -- error
! ERROR:  role "public" does not exist
! ALTER ROLE "public" WITH NOREPLICATION; -- error
! ERROR:  role "public" does not exist
! ALTER ROLE NONE WITH NOREPLICATION; -- error
! ERROR:  role name "none" is reserved
! LINE 1: ALTER ROLE NONE WITH NOREPLICATION;
!                    ^
! ALTER ROLE "none" WITH NOREPLICATION; -- error
! ERROR:  role name "none" is reserved
! LINE 1: ALTER ROLE "none" WITH NOREPLICATION;
!                    ^
! ALTER ROLE nonexistent WITH NOREPLICATION; -- error
! ERROR:  role "nonexistent" does not exist
! --  ALTER USER
! BEGIN;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | f
!  Public           | -            | f        | f
!  current_user     | -            | f        | f
!  regress_testrol1 | session_user | t        | f
!  regress_testrol2 | current_user | f        | f
!  session_user     | -            | f        | f
! (6 rows)
! 
! ALTER USER CURRENT_USER WITH REPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | f
!  Public           | -            | f        | f
!  current_user     | -            | f        | f
!  regress_testrol1 | session_user | t        | f
!  regress_testrol2 | current_user | f        | t
!  session_user     | -            | f        | f
! (6 rows)
! 
! ALTER USER "current_user" WITH REPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | f
!  Public           | -            | f        | f
!  current_user     | -            | f        | t
!  regress_testrol1 | session_user | t        | f
!  regress_testrol2 | current_user | f        | t
!  session_user     | -            | f        | f
! (6 rows)
! 
! ALTER USER SESSION_USER WITH REPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | f
!  Public           | -            | f        | f
!  current_user     | -            | f        | t
!  regress_testrol1 | session_user | t        | t
!  regress_testrol2 | current_user | f        | t
!  session_user     | -            | f        | f
! (6 rows)
! 
! ALTER USER "session_user" WITH REPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | f
!  Public           | -            | f        | f
!  current_user     | -            | f        | t
!  regress_testrol1 | session_user | t        | t
!  regress_testrol2 | current_user | f        | t
!  session_user     | -            | f        | t
! (6 rows)
! 
! ALTER USER "Public" WITH REPLICATION;
! ALTER USER "None" WITH REPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | t
!  Public           | -            | f        | t
!  current_user     | -            | f        | t
!  regress_testrol1 | session_user | t        | t
!  regress_testrol2 | current_user | f        | t
!  session_user     | -            | f        | t
! (6 rows)
! 
! ALTER USER regress_testrol1 WITH NOREPLICATION;
! ALTER USER regress_testrol2 WITH NOREPLICATION;
! SELECT * FROM chkrolattr();
!        role       | rolekeyword  | canlogin | replication 
! ------------------+--------------+----------+-------------
!  None             | -            | f        | t
!  Public           | -            | f        | t
!  current_user     | -            | f        | t
!  regress_testrol1 | session_user | t        | f
!  regress_testrol2 | current_user | f        | f
!  session_user     | -            | f        | t
! (6 rows)
! 
! ROLLBACK;
! ALTER USER USER WITH LOGIN; -- error
! ERROR:  syntax error at or near "USER"
! LINE 1: ALTER USER USER WITH LOGIN;
!                    ^
! ALTER USER CURRENT_ROLE WITH LOGIN; -- error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: ALTER USER CURRENT_ROLE WITH LOGIN;
!                    ^
! ALTER USER ALL WITH REPLICATION; -- error
! ERROR:  syntax error at or near "WITH"
! LINE 1: ALTER USER ALL WITH REPLICATION;
!                        ^
! ALTER USER SESSION_ROLE WITH NOREPLICATION; -- error
! ERROR:  role "session_role" does not exist
! ALTER USER PUBLIC WITH NOREPLICATION; -- error
! ERROR:  role "public" does not exist
! ALTER USER "public" WITH NOREPLICATION; -- error
! ERROR:  role "public" does not exist
! ALTER USER NONE WITH NOREPLICATION; -- error
! ERROR:  role name "none" is reserved
! LINE 1: ALTER USER NONE WITH NOREPLICATION;
!                    ^
! ALTER USER "none" WITH NOREPLICATION; -- error
! ERROR:  role name "none" is reserved
! LINE 1: ALTER USER "none" WITH NOREPLICATION;
!                    ^
! ALTER USER nonexistent WITH NOREPLICATION; -- error
! ERROR:  role "nonexistent" does not exist
! --  ALTER ROLE SET/RESET
! SELECT * FROM chksetconfig();
!  db | role | rolkeyword | setconfig 
! ----+------+------------+-----------
! (0 rows)
! 
! ALTER ROLE CURRENT_USER SET application_name to 'FOO';
! ALTER ROLE SESSION_USER SET application_name to 'BAR';
! ALTER ROLE "current_user" SET application_name to 'FOOFOO';
! ALTER ROLE "Public" SET application_name to 'BARBAR';
! ALTER ROLE ALL SET application_name to 'SLAP';
! SELECT * FROM chksetconfig();
!  db  |       role       |  rolkeyword  |         setconfig         
! -----+------------------+--------------+---------------------------
!  ALL | Public           | -            | {application_name=BARBAR}
!  ALL | current_user     | -            | {application_name=FOOFOO}
!  ALL | regress_testrol1 | session_user | {application_name=BAR}
!  ALL | regress_testrol2 | current_user | {application_name=FOO}
! (4 rows)
! 
! ALTER ROLE regress_testrol1 SET application_name to 'SLAM';
! SELECT * FROM chksetconfig();
!  db  |       role       |  rolkeyword  |         setconfig         
! -----+------------------+--------------+---------------------------
!  ALL | Public           | -            | {application_name=BARBAR}
!  ALL | current_user     | -            | {application_name=FOOFOO}
!  ALL | regress_testrol1 | session_user | {application_name=SLAM}
!  ALL | regress_testrol2 | current_user | {application_name=FOO}
! (4 rows)
! 
! ALTER ROLE CURRENT_USER RESET application_name;
! ALTER ROLE SESSION_USER RESET application_name;
! ALTER ROLE "current_user" RESET application_name;
! ALTER ROLE "Public" RESET application_name;
! ALTER ROLE ALL RESET application_name;
! SELECT * FROM chksetconfig();
!  db | role | rolkeyword | setconfig 
! ----+------+------------+-----------
! (0 rows)
! 
! ALTER ROLE CURRENT_ROLE SET application_name to 'BAZ'; -- error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: ALTER ROLE CURRENT_ROLE SET application_name to 'BAZ';
!                    ^
! ALTER ROLE USER SET application_name to 'BOOM'; -- error
! ERROR:  syntax error at or near "USER"
! LINE 1: ALTER ROLE USER SET application_name to 'BOOM';
!                    ^
! ALTER ROLE PUBLIC SET application_name to 'BOMB'; -- error
! ERROR:  role "public" does not exist
! ALTER ROLE nonexistent SET application_name to 'BOMB'; -- error
! ERROR:  role "nonexistent" does not exist
! --  ALTER USER SET/RESET
! SELECT * FROM chksetconfig();
!  db | role | rolkeyword | setconfig 
! ----+------+------------+-----------
! (0 rows)
! 
! ALTER USER CURRENT_USER SET application_name to 'FOO';
! ALTER USER SESSION_USER SET application_name to 'BAR';
! ALTER USER "current_user" SET application_name to 'FOOFOO';
! ALTER USER "Public" SET application_name to 'BARBAR';
! ALTER USER ALL SET application_name to 'SLAP';
! SELECT * FROM chksetconfig();
!  db  |       role       |  rolkeyword  |         setconfig         
! -----+------------------+--------------+---------------------------
!  ALL | Public           | -            | {application_name=BARBAR}
!  ALL | current_user     | -            | {application_name=FOOFOO}
!  ALL | regress_testrol1 | session_user | {application_name=BAR}
!  ALL | regress_testrol2 | current_user | {application_name=FOO}
! (4 rows)
! 
! ALTER USER regress_testrol1 SET application_name to 'SLAM';
! SELECT * FROM chksetconfig();
!  db  |       role       |  rolkeyword  |         setconfig         
! -----+------------------+--------------+---------------------------
!  ALL | Public           | -            | {application_name=BARBAR}
!  ALL | current_user     | -            | {application_name=FOOFOO}
!  ALL | regress_testrol1 | session_user | {application_name=SLAM}
!  ALL | regress_testrol2 | current_user | {application_name=FOO}
! (4 rows)
! 
! ALTER USER CURRENT_USER RESET application_name;
! ALTER USER SESSION_USER RESET application_name;
! ALTER USER "current_user" RESET application_name;
! ALTER USER "Public" RESET application_name;
! ALTER USER ALL RESET application_name;
! SELECT * FROM chksetconfig();
!  db | role | rolkeyword | setconfig 
! ----+------+------------+-----------
! (0 rows)
! 
! ALTER USER CURRENT_USER SET application_name to 'BAZ'; -- error
! ALTER USER USER SET application_name to 'BOOM'; -- error
! ERROR:  syntax error at or near "USER"
! LINE 1: ALTER USER USER SET application_name to 'BOOM';
!                    ^
! ALTER USER PUBLIC SET application_name to 'BOMB'; -- error
! ERROR:  role "public" does not exist
! ALTER USER NONE SET application_name to 'BOMB'; -- error
! ERROR:  role name "none" is reserved
! LINE 1: ALTER USER NONE SET application_name to 'BOMB';
!                    ^
! ALTER USER nonexistent SET application_name to 'BOMB'; -- error
! ERROR:  role "nonexistent" does not exist
! -- CREATE SCHEMA
! set client_min_messages to error;
! CREATE SCHEMA newschema1 AUTHORIZATION CURRENT_USER;
! CREATE SCHEMA newschema2 AUTHORIZATION "current_user";
! CREATE SCHEMA newschema3 AUTHORIZATION SESSION_USER;
! CREATE SCHEMA newschema4 AUTHORIZATION regress_testrolx;
! CREATE SCHEMA newschema5 AUTHORIZATION "Public";
! CREATE SCHEMA newschema6 AUTHORIZATION USER; -- error
! ERROR:  syntax error at or near "USER"
! LINE 1: CREATE SCHEMA newschema6 AUTHORIZATION USER;
!                                                ^
! CREATE SCHEMA newschema6 AUTHORIZATION CURRENT_ROLE; -- error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: CREATE SCHEMA newschema6 AUTHORIZATION CURRENT_ROLE;
!                                                ^
! CREATE SCHEMA newschema6 AUTHORIZATION PUBLIC; -- error
! ERROR:  role "public" does not exist
! CREATE SCHEMA newschema6 AUTHORIZATION "public"; -- error
! ERROR:  role "public" does not exist
! CREATE SCHEMA newschema6 AUTHORIZATION NONE; -- error
! ERROR:  role name "none" is reserved
! LINE 1: CREATE SCHEMA newschema6 AUTHORIZATION NONE;
!                                                ^
! CREATE SCHEMA newschema6 AUTHORIZATION nonexistent; -- error
! ERROR:  role "nonexistent" does not exist
! SELECT n.nspname, r.rolname FROM pg_namespace n
!  JOIN pg_roles r ON (r.oid = n.nspowner)
!  WHERE n.nspname LIKE 'newschema_' ORDER BY 1;
!   nspname   |     rolname      
! ------------+------------------
!  newschema1 | regress_testrol2
!  newschema2 | current_user
!  newschema3 | regress_testrol1
!  newschema4 | regress_testrolx
!  newschema5 | Public
! (5 rows)
! 
! CREATE SCHEMA IF NOT EXISTS newschema1 AUTHORIZATION CURRENT_USER;
! CREATE SCHEMA IF NOT EXISTS newschema2 AUTHORIZATION "current_user";
! CREATE SCHEMA IF NOT EXISTS newschema3 AUTHORIZATION SESSION_USER;
! CREATE SCHEMA IF NOT EXISTS newschema4 AUTHORIZATION regress_testrolx;
! CREATE SCHEMA IF NOT EXISTS newschema5 AUTHORIZATION "Public";
! CREATE SCHEMA IF NOT EXISTS newschema6 AUTHORIZATION USER; -- error
! ERROR:  syntax error at or near "USER"
! LINE 1: CREATE SCHEMA IF NOT EXISTS newschema6 AUTHORIZATION USER;
!                                                              ^
! CREATE SCHEMA IF NOT EXISTS newschema6 AUTHORIZATION CURRENT_ROLE; -- error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: ...ATE SCHEMA IF NOT EXISTS newschema6 AUTHORIZATION CURRENT_RO...
!                                                              ^
! CREATE SCHEMA IF NOT EXISTS newschema6 AUTHORIZATION PUBLIC; -- error
! ERROR:  role "public" does not exist
! CREATE SCHEMA IF NOT EXISTS newschema6 AUTHORIZATION "public"; -- error
! ERROR:  role "public" does not exist
! CREATE SCHEMA IF NOT EXISTS newschema6 AUTHORIZATION NONE; -- error
! ERROR:  role name "none" is reserved
! LINE 1: CREATE SCHEMA IF NOT EXISTS newschema6 AUTHORIZATION NONE;
!                                                              ^
! CREATE SCHEMA IF NOT EXISTS newschema6 AUTHORIZATION nonexistent; -- error
! ERROR:  role "nonexistent" does not exist
! SELECT n.nspname, r.rolname FROM pg_namespace n
!  JOIN pg_roles r ON (r.oid = n.nspowner)
!  WHERE n.nspname LIKE 'newschema_' ORDER BY 1;
!   nspname   |     rolname      
! ------------+------------------
!  newschema1 | regress_testrol2
!  newschema2 | current_user
!  newschema3 | regress_testrol1
!  newschema4 | regress_testrolx
!  newschema5 | Public
! (5 rows)
! 
! -- ALTER TABLE OWNER TO
! \c -
! SET SESSION AUTHORIZATION regress_testrol0;
! set client_min_messages to error;
! CREATE TABLE testtab1 (a int);
! CREATE TABLE testtab2 (a int);
! CREATE TABLE testtab3 (a int);
! CREATE TABLE testtab4 (a int);
! CREATE TABLE testtab5 (a int);
! CREATE TABLE testtab6 (a int);
! \c -
! SET SESSION AUTHORIZATION regress_testrol1;
! SET ROLE regress_testrol2;
! ALTER TABLE testtab1 OWNER TO CURRENT_USER;
! ALTER TABLE testtab2 OWNER TO "current_user";
! ALTER TABLE testtab3 OWNER TO SESSION_USER;
! ALTER TABLE testtab4 OWNER TO regress_testrolx;
! ALTER TABLE testtab5 OWNER TO "Public";
! ALTER TABLE testtab6 OWNER TO CURRENT_ROLE; -- error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: ALTER TABLE testtab6 OWNER TO CURRENT_ROLE;
!                                       ^
! ALTER TABLE testtab6 OWNER TO USER; --error
! ERROR:  syntax error at or near "USER"
! LINE 1: ALTER TABLE testtab6 OWNER TO USER;
!                                       ^
! ALTER TABLE testtab6 OWNER TO PUBLIC; -- error
! ERROR:  role "public" does not exist
! ALTER TABLE testtab6 OWNER TO "public"; -- error
! ERROR:  role "public" does not exist
! ALTER TABLE testtab6 OWNER TO nonexistent; -- error
! ERROR:  role "nonexistent" does not exist
! SELECT c.relname, r.rolname
!  FROM pg_class c JOIN pg_roles r ON (r.oid = c.relowner)
!  WHERE relname LIKE 'testtab_'
!  ORDER BY 1;
!  relname  |     rolname      
! ----------+------------------
!  testtab1 | regress_testrol2
!  testtab2 | current_user
!  testtab3 | regress_testrol1
!  testtab4 | regress_testrolx
!  testtab5 | Public
!  testtab6 | regress_testrol0
! (6 rows)
! 
! -- ALTER TABLE, VIEW, MATERIALIZED VIEW, FOREIGN TABLE, SEQUENCE are
! -- changed their owner in the same way.
! -- ALTER AGGREGATE
! \c -
! SET SESSION AUTHORIZATION regress_testrol0;
! CREATE AGGREGATE testagg1(int2) (SFUNC = int2_sum, STYPE = int8);
! CREATE AGGREGATE testagg2(int2) (SFUNC = int2_sum, STYPE = int8);
! CREATE AGGREGATE testagg3(int2) (SFUNC = int2_sum, STYPE = int8);
! CREATE AGGREGATE testagg4(int2) (SFUNC = int2_sum, STYPE = int8);
! CREATE AGGREGATE testagg5(int2) (SFUNC = int2_sum, STYPE = int8);
! CREATE AGGREGATE testagg5(int2) (SFUNC = int2_sum, STYPE = int8);
! ERROR:  function "testagg5" already exists with same argument types
! CREATE AGGREGATE testagg6(int2) (SFUNC = int2_sum, STYPE = int8);
! CREATE AGGREGATE testagg7(int2) (SFUNC = int2_sum, STYPE = int8);
! CREATE AGGREGATE testagg8(int2) (SFUNC = int2_sum, STYPE = int8);
! CREATE AGGREGATE testagg9(int2) (SFUNC = int2_sum, STYPE = int8);
! \c -
! SET SESSION AUTHORIZATION regress_testrol1;
! SET ROLE regress_testrol2;
! ALTER AGGREGATE testagg1(int2) OWNER TO CURRENT_USER;
! ALTER AGGREGATE testagg2(int2) OWNER TO "current_user";
! ALTER AGGREGATE testagg3(int2) OWNER TO SESSION_USER;
! ALTER AGGREGATE testagg4(int2) OWNER TO regress_testrolx;
! ALTER AGGREGATE testagg5(int2) OWNER TO "Public";
! ALTER AGGREGATE testagg5(int2) OWNER TO CURRENT_ROLE; -- error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: ALTER AGGREGATE testagg5(int2) OWNER TO CURRENT_ROLE;
!                                                 ^
! ALTER AGGREGATE testagg5(int2) OWNER TO USER; -- error
! ERROR:  syntax error at or near "USER"
! LINE 1: ALTER AGGREGATE testagg5(int2) OWNER TO USER;
!                                                 ^
! ALTER AGGREGATE testagg5(int2) OWNER TO PUBLIC; -- error
! ERROR:  role "public" does not exist
! ALTER AGGREGATE testagg5(int2) OWNER TO "public"; -- error
! ERROR:  role "public" does not exist
! ALTER AGGREGATE testagg5(int2) OWNER TO nonexistent; -- error
! ERROR:  role "nonexistent" does not exist
! SELECT p.proname, r.rolname
!  FROM pg_proc p JOIN pg_roles r ON (r.oid = p.proowner)
!  WHERE proname LIKE 'testagg_'
!  ORDER BY 1;
!  proname  |     rolname      
! ----------+------------------
!  testagg1 | regress_testrol2
!  testagg2 | current_user
!  testagg3 | regress_testrol1
!  testagg4 | regress_testrolx
!  testagg5 | Public
!  testagg6 | regress_testrol0
!  testagg7 | regress_testrol0
!  testagg8 | regress_testrol0
!  testagg9 | regress_testrol0
! (9 rows)
! 
! -- CREATE USER MAPPING
! CREATE FOREIGN DATA WRAPPER test_wrapper;
! CREATE SERVER sv1 FOREIGN DATA WRAPPER test_wrapper;
! CREATE SERVER sv2 FOREIGN DATA WRAPPER test_wrapper;
! CREATE SERVER sv3 FOREIGN DATA WRAPPER test_wrapper;
! CREATE SERVER sv4 FOREIGN DATA WRAPPER test_wrapper;
! CREATE SERVER sv5 FOREIGN DATA WRAPPER test_wrapper;
! CREATE SERVER sv6 FOREIGN DATA WRAPPER test_wrapper;
! CREATE SERVER sv7 FOREIGN DATA WRAPPER test_wrapper;
! CREATE SERVER sv8 FOREIGN DATA WRAPPER test_wrapper;
! CREATE SERVER sv9 FOREIGN DATA WRAPPER test_wrapper;
! CREATE USER MAPPING FOR CURRENT_USER SERVER sv1 OPTIONS (user 'CURRENT_USER');
! CREATE USER MAPPING FOR "current_user" SERVER sv2 OPTIONS (user '"current_user"');
! CREATE USER MAPPING FOR USER SERVER sv3 OPTIONS (user 'USER');
! CREATE USER MAPPING FOR "user" SERVER sv4 OPTIONS (user '"USER"');
! CREATE USER MAPPING FOR SESSION_USER SERVER sv5 OPTIONS (user 'SESSION_USER');
! CREATE USER MAPPING FOR PUBLIC SERVER sv6 OPTIONS (user 'PUBLIC');
! CREATE USER MAPPING FOR "Public" SERVER sv7 OPTIONS (user '"Public"');
! CREATE USER MAPPING FOR regress_testrolx SERVER sv8 OPTIONS (user 'regress_testrolx');
! CREATE USER MAPPING FOR CURRENT_ROLE SERVER sv9
! 	    OPTIONS (user 'CURRENT_ROLE'); -- error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: CREATE USER MAPPING FOR CURRENT_ROLE SERVER sv9
!                                 ^
! CREATE USER MAPPING FOR nonexistent SERVER sv9
! 	    OPTIONS (user 'nonexistent'); -- error;
! ERROR:  role "nonexistent" does not exist
! SELECT * FROM chkumapping();
!       umname      | umserver |         umoptions         
! ------------------+----------+---------------------------
!  regress_testrol2 | sv1      | {user=CURRENT_USER}
!  current_user     | sv2      | {"user=\"current_user\""}
!  regress_testrol2 | sv3      | {user=USER}
!  user             | sv4      | {"user=\"USER\""}
!  regress_testrol1 | sv5      | {user=SESSION_USER}
!                   | sv6      | {user=PUBLIC}
!  Public           | sv7      | {"user=\"Public\""}
!  regress_testrolx | sv8      | {user=regress_testrolx}
! (8 rows)
! 
! -- ALTER USER MAPPING
! ALTER USER MAPPING FOR CURRENT_USER SERVER sv1
!  OPTIONS (SET user 'CURRENT_USER_alt');
! ALTER USER MAPPING FOR "current_user" SERVER sv2
!  OPTIONS (SET user '"current_user"_alt');
! ALTER USER MAPPING FOR USER SERVER sv3
!  OPTIONS (SET user 'USER_alt');
! ALTER USER MAPPING FOR "user" SERVER sv4
!  OPTIONS (SET user '"user"_alt');
! ALTER USER MAPPING FOR SESSION_USER SERVER sv5
!  OPTIONS (SET user 'SESSION_USER_alt');
! ALTER USER MAPPING FOR PUBLIC SERVER sv6
!  OPTIONS (SET user 'public_alt');
! ALTER USER MAPPING FOR "Public" SERVER sv7
!  OPTIONS (SET user '"Public"_alt');
! ALTER USER MAPPING FOR regress_testrolx SERVER sv8
!  OPTIONS (SET user 'regress_testrolx_alt');
! ALTER USER MAPPING FOR CURRENT_ROLE SERVER sv9
!  OPTIONS (SET user 'CURRENT_ROLE_alt');
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: ALTER USER MAPPING FOR CURRENT_ROLE SERVER sv9
!                                ^
! ALTER USER MAPPING FOR nonexistent SERVER sv9
!  OPTIONS (SET user 'nonexistent_alt'); -- error
! ERROR:  role "nonexistent" does not exist
! SELECT * FROM chkumapping();
!       umname      | umserver |           umoptions           
! ------------------+----------+-------------------------------
!  regress_testrol2 | sv1      | {user=CURRENT_USER_alt}
!  current_user     | sv2      | {"user=\"current_user\"_alt"}
!  regress_testrol2 | sv3      | {user=USER_alt}
!  user             | sv4      | {"user=\"user\"_alt"}
!  regress_testrol1 | sv5      | {user=SESSION_USER_alt}
!                   | sv6      | {user=public_alt}
!  Public           | sv7      | {"user=\"Public\"_alt"}
!  regress_testrolx | sv8      | {user=regress_testrolx_alt}
! (8 rows)
! 
! -- DROP USER MAPPING
! DROP USER MAPPING FOR CURRENT_USER SERVER sv1;
! DROP USER MAPPING FOR "current_user" SERVER sv2;
! DROP USER MAPPING FOR USER SERVER sv3;
! DROP USER MAPPING FOR "user" SERVER sv4;
! DROP USER MAPPING FOR SESSION_USER SERVER sv5;
! DROP USER MAPPING FOR PUBLIC SERVER sv6;
! DROP USER MAPPING FOR "Public" SERVER sv7;
! DROP USER MAPPING FOR regress_testrolx SERVER sv8;
! DROP USER MAPPING FOR CURRENT_ROLE SERVER sv9; -- error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: DROP USER MAPPING FOR CURRENT_ROLE SERVER sv9;
!                               ^
! DROP USER MAPPING FOR nonexistent SERVER sv;  -- error
! ERROR:  role "nonexistent" does not exist
! SELECT * FROM chkumapping();
!  umname | umserver | umoptions 
! --------+----------+-----------
! (0 rows)
! 
! CREATE USER MAPPING FOR CURRENT_USER SERVER sv1 OPTIONS (user 'CURRENT_USER');
! CREATE USER MAPPING FOR "current_user" SERVER sv2 OPTIONS (user '"current_user"');
! CREATE USER MAPPING FOR USER SERVER sv3 OPTIONS (user 'USER');
! CREATE USER MAPPING FOR "user" SERVER sv4 OPTIONS (user '"USER"');
! CREATE USER MAPPING FOR SESSION_USER SERVER sv5 OPTIONS (user 'SESSION_USER');
! CREATE USER MAPPING FOR PUBLIC SERVER sv6 OPTIONS (user 'PUBLIC');
! CREATE USER MAPPING FOR "Public" SERVER sv7 OPTIONS (user '"Public"');
! CREATE USER MAPPING FOR regress_testrolx SERVER sv8 OPTIONS (user 'regress_testrolx');
! SELECT * FROM chkumapping();
!       umname      | umserver |         umoptions         
! ------------------+----------+---------------------------
!  regress_testrol2 | sv1      | {user=CURRENT_USER}
!  current_user     | sv2      | {"user=\"current_user\""}
!  regress_testrol2 | sv3      | {user=USER}
!  user             | sv4      | {"user=\"USER\""}
!  regress_testrol1 | sv5      | {user=SESSION_USER}
!                   | sv6      | {user=PUBLIC}
!  Public           | sv7      | {"user=\"Public\""}
!  regress_testrolx | sv8      | {user=regress_testrolx}
! (8 rows)
! 
! -- DROP USER MAPPING IF EXISTS
! DROP USER MAPPING IF EXISTS FOR CURRENT_USER SERVER sv1;
! SELECT * FROM chkumapping();
!       umname      | umserver |         umoptions         
! ------------------+----------+---------------------------
!  current_user     | sv2      | {"user=\"current_user\""}
!  regress_testrol2 | sv3      | {user=USER}
!  user             | sv4      | {"user=\"USER\""}
!  regress_testrol1 | sv5      | {user=SESSION_USER}
!                   | sv6      | {user=PUBLIC}
!  Public           | sv7      | {"user=\"Public\""}
!  regress_testrolx | sv8      | {user=regress_testrolx}
! (7 rows)
! 
! DROP USER MAPPING IF EXISTS FOR "current_user" SERVER sv2;
! SELECT * FROM chkumapping();
!       umname      | umserver |        umoptions        
! ------------------+----------+-------------------------
!  regress_testrol2 | sv3      | {user=USER}
!  user             | sv4      | {"user=\"USER\""}
!  regress_testrol1 | sv5      | {user=SESSION_USER}
!                   | sv6      | {user=PUBLIC}
!  Public           | sv7      | {"user=\"Public\""}
!  regress_testrolx | sv8      | {user=regress_testrolx}
! (6 rows)
! 
! DROP USER MAPPING IF EXISTS FOR USER SERVER sv3;
! SELECT * FROM chkumapping();
!       umname      | umserver |        umoptions        
! ------------------+----------+-------------------------
!  user             | sv4      | {"user=\"USER\""}
!  regress_testrol1 | sv5      | {user=SESSION_USER}
!                   | sv6      | {user=PUBLIC}
!  Public           | sv7      | {"user=\"Public\""}
!  regress_testrolx | sv8      | {user=regress_testrolx}
! (5 rows)
! 
! DROP USER MAPPING IF EXISTS FOR "user" SERVER sv4;
! SELECT * FROM chkumapping();
!       umname      | umserver |        umoptions        
! ------------------+----------+-------------------------
!  regress_testrol1 | sv5      | {user=SESSION_USER}
!                   | sv6      | {user=PUBLIC}
!  Public           | sv7      | {"user=\"Public\""}
!  regress_testrolx | sv8      | {user=regress_testrolx}
! (4 rows)
! 
! DROP USER MAPPING IF EXISTS FOR SESSION_USER SERVER sv5;
! SELECT * FROM chkumapping();
!       umname      | umserver |        umoptions        
! ------------------+----------+-------------------------
!                   | sv6      | {user=PUBLIC}
!  Public           | sv7      | {"user=\"Public\""}
!  regress_testrolx | sv8      | {user=regress_testrolx}
! (3 rows)
! 
! DROP USER MAPPING IF EXISTS FOR PUBLIC SERVER sv6;
! SELECT * FROM chkumapping();
!       umname      | umserver |        umoptions        
! ------------------+----------+-------------------------
!  Public           | sv7      | {"user=\"Public\""}
!  regress_testrolx | sv8      | {user=regress_testrolx}
! (2 rows)
! 
! DROP USER MAPPING IF EXISTS FOR "Public" SERVER sv7;
! SELECT * FROM chkumapping();
!       umname      | umserver |        umoptions        
! ------------------+----------+-------------------------
!  regress_testrolx | sv8      | {user=regress_testrolx}
! (1 row)
! 
! DROP USER MAPPING IF EXISTS FOR regress_testrolx SERVER sv8;
! SELECT * FROM chkumapping();
!  umname | umserver | umoptions 
! --------+----------+-----------
! (0 rows)
! 
! DROP USER MAPPING IF EXISTS FOR CURRENT_ROLE SERVER sv9; --error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: DROP USER MAPPING IF EXISTS FOR CURRENT_ROLE SERVER sv9;
!                                         ^
! DROP USER MAPPING IF EXISTS FOR nonexistent SERVER sv9;  -- error
! NOTICE:  role "nonexistent" does not exist, skipping
! -- GRANT/REVOKE
! GRANT regress_testrol0 TO pg_signal_backend; -- success
! SET ROLE pg_signal_backend; --success
! RESET ROLE;
! CREATE SCHEMA test_schema AUTHORIZATION pg_signal_backend; --success
! SET ROLE regress_testrol2;
! UPDATE pg_proc SET proacl = null WHERE proname LIKE 'testagg_';
! SELECT proname, proacl FROM pg_proc WHERE proname LIKE 'testagg_';
!  proname  | proacl 
! ----------+--------
!  testagg1 | 
!  testagg2 | 
!  testagg3 | 
!  testagg4 | 
!  testagg5 | 
!  testagg6 | 
!  testagg7 | 
!  testagg8 | 
!  testagg9 | 
! (9 rows)
! 
! REVOKE ALL PRIVILEGES ON FUNCTION testagg1(int2) FROM PUBLIC;
! REVOKE ALL PRIVILEGES ON FUNCTION testagg2(int2) FROM PUBLIC;
! REVOKE ALL PRIVILEGES ON FUNCTION testagg3(int2) FROM PUBLIC;
! REVOKE ALL PRIVILEGES ON FUNCTION testagg4(int2) FROM PUBLIC;
! REVOKE ALL PRIVILEGES ON FUNCTION testagg5(int2) FROM PUBLIC;
! REVOKE ALL PRIVILEGES ON FUNCTION testagg6(int2) FROM PUBLIC;
! REVOKE ALL PRIVILEGES ON FUNCTION testagg7(int2) FROM PUBLIC;
! REVOKE ALL PRIVILEGES ON FUNCTION testagg8(int2) FROM PUBLIC;
! GRANT ALL PRIVILEGES ON FUNCTION testagg1(int2) TO PUBLIC;
! GRANT ALL PRIVILEGES ON FUNCTION testagg2(int2) TO CURRENT_USER;
! GRANT ALL PRIVILEGES ON FUNCTION testagg3(int2) TO "current_user";
! GRANT ALL PRIVILEGES ON FUNCTION testagg4(int2) TO SESSION_USER;
! GRANT ALL PRIVILEGES ON FUNCTION testagg5(int2) TO "Public";
! GRANT ALL PRIVILEGES ON FUNCTION testagg6(int2) TO regress_testrolx;
! GRANT ALL PRIVILEGES ON FUNCTION testagg7(int2) TO "public";
! GRANT ALL PRIVILEGES ON FUNCTION testagg8(int2)
! 	   TO current_user, public, regress_testrolx;
! SELECT proname, proacl FROM pg_proc WHERE proname LIKE 'testagg_';
!  proname  |                                                              proacl                                                               
! ----------+-----------------------------------------------------------------------------------------------------------------------------------
!  testagg1 | {regress_testrol2=X/regress_testrol2,=X/regress_testrol2}
!  testagg2 | {current_user=X/current_user,regress_testrol2=X/current_user}
!  testagg3 | {regress_testrol1=X/regress_testrol1,current_user=X/regress_testrol1}
!  testagg4 | {regress_testrolx=X/regress_testrolx,regress_testrol1=X/regress_testrolx}
!  testagg5 | {Public=X/Public}
!  testagg6 | {regress_testrol0=X/regress_testrol0,regress_testrolx=X/regress_testrol0}
!  testagg7 | {regress_testrol0=X/regress_testrol0,=X/regress_testrol0}
!  testagg8 | {regress_testrol0=X/regress_testrol0,regress_testrol2=X/regress_testrol0,=X/regress_testrol0,regress_testrolx=X/regress_testrol0}
!  testagg9 | 
! (9 rows)
! 
! GRANT ALL PRIVILEGES ON FUNCTION testagg9(int2) TO CURRENT_ROLE; --error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: ...RANT ALL PRIVILEGES ON FUNCTION testagg9(int2) TO CURRENT_RO...
!                                                              ^
! GRANT ALL PRIVILEGES ON FUNCTION testagg9(int2) TO USER; --error
! ERROR:  syntax error at or near "USER"
! LINE 1: GRANT ALL PRIVILEGES ON FUNCTION testagg9(int2) TO USER;
!                                                            ^
! GRANT ALL PRIVILEGES ON FUNCTION testagg9(int2) TO NONE; --error
! ERROR:  role name "none" is reserved
! LINE 1: GRANT ALL PRIVILEGES ON FUNCTION testagg9(int2) TO NONE;
!                                                            ^
! GRANT ALL PRIVILEGES ON FUNCTION testagg9(int2) TO "none"; --error
! ERROR:  role name "none" is reserved
! LINE 1: GRANT ALL PRIVILEGES ON FUNCTION testagg9(int2) TO "none";
!                                                            ^
! SELECT proname, proacl FROM pg_proc WHERE proname LIKE 'testagg_';
!  proname  |                                                              proacl                                                               
! ----------+-----------------------------------------------------------------------------------------------------------------------------------
!  testagg1 | {regress_testrol2=X/regress_testrol2,=X/regress_testrol2}
!  testagg2 | {current_user=X/current_user,regress_testrol2=X/current_user}
!  testagg3 | {regress_testrol1=X/regress_testrol1,current_user=X/regress_testrol1}
!  testagg4 | {regress_testrolx=X/regress_testrolx,regress_testrol1=X/regress_testrolx}
!  testagg5 | {Public=X/Public}
!  testagg6 | {regress_testrol0=X/regress_testrol0,regress_testrolx=X/regress_testrol0}
!  testagg7 | {regress_testrol0=X/regress_testrol0,=X/regress_testrol0}
!  testagg8 | {regress_testrol0=X/regress_testrol0,regress_testrol2=X/regress_testrol0,=X/regress_testrol0,regress_testrolx=X/regress_testrol0}
!  testagg9 | 
! (9 rows)
! 
! REVOKE ALL PRIVILEGES ON FUNCTION testagg1(int2) FROM PUBLIC;
! REVOKE ALL PRIVILEGES ON FUNCTION testagg2(int2) FROM CURRENT_USER;
! REVOKE ALL PRIVILEGES ON FUNCTION testagg3(int2) FROM "current_user";
! REVOKE ALL PRIVILEGES ON FUNCTION testagg4(int2) FROM SESSION_USER;
! REVOKE ALL PRIVILEGES ON FUNCTION testagg5(int2) FROM "Public";
! REVOKE ALL PRIVILEGES ON FUNCTION testagg6(int2) FROM regress_testrolx;
! REVOKE ALL PRIVILEGES ON FUNCTION testagg7(int2) FROM "public";
! REVOKE ALL PRIVILEGES ON FUNCTION testagg8(int2)
! 	   FROM current_user, public, regress_testrolx;
! SELECT proname, proacl FROM pg_proc WHERE proname LIKE 'testagg_';
!  proname  |                proacl                 
! ----------+---------------------------------------
!  testagg1 | {regress_testrol2=X/regress_testrol2}
!  testagg2 | {current_user=X/current_user}
!  testagg3 | {regress_testrol1=X/regress_testrol1}
!  testagg4 | {regress_testrolx=X/regress_testrolx}
!  testagg5 | {}
!  testagg6 | {regress_testrol0=X/regress_testrol0}
!  testagg7 | {regress_testrol0=X/regress_testrol0}
!  testagg8 | {regress_testrol0=X/regress_testrol0}
!  testagg9 | 
! (9 rows)
! 
! REVOKE ALL PRIVILEGES ON FUNCTION testagg9(int2) FROM CURRENT_ROLE; --error
! ERROR:  syntax error at or near "CURRENT_ROLE"
! LINE 1: ...KE ALL PRIVILEGES ON FUNCTION testagg9(int2) FROM CURRENT_RO...
!                                                              ^
! REVOKE ALL PRIVILEGES ON FUNCTION testagg9(int2) FROM USER; --error
! ERROR:  syntax error at or near "USER"
! LINE 1: REVOKE ALL PRIVILEGES ON FUNCTION testagg9(int2) FROM USER;
!                                                               ^
! REVOKE ALL PRIVILEGES ON FUNCTION testagg9(int2) FROM NONE; --error
! ERROR:  role name "none" is reserved
! LINE 1: REVOKE ALL PRIVILEGES ON FUNCTION testagg9(int2) FROM NONE;
!                                                               ^
! REVOKE ALL PRIVILEGES ON FUNCTION testagg9(int2) FROM "none"; --error
! ERROR:  role name "none" is reserved
! LINE 1: ...EVOKE ALL PRIVILEGES ON FUNCTION testagg9(int2) FROM "none";
!                                                                 ^
! SELECT proname, proacl FROM pg_proc WHERE proname LIKE 'testagg_';
!  proname  |                proacl                 
! ----------+---------------------------------------
!  testagg1 | {regress_testrol2=X/regress_testrol2}
!  testagg2 | {current_user=X/current_user}
!  testagg3 | {regress_testrol1=X/regress_testrol1}
!  testagg4 | {regress_testrolx=X/regress_testrolx}
!  testagg5 | {}
!  testagg6 | {regress_testrol0=X/regress_testrol0}
!  testagg7 | {regress_testrol0=X/regress_testrol0}
!  testagg8 | {regress_testrol0=X/regress_testrol0}
!  testagg9 | 
! (9 rows)
! 
! -- clean up
! \c
! DROP SCHEMA test_schema;
! DROP OWNED BY regress_testrol0, "Public", "current_user", regress_testrol1, regress_testrol2, regress_testrolx CASCADE;
! DROP ROLE regress_testrol0, regress_testrol1, regress_testrol2, regress_testrolx;
! DROP ROLE "Public", "None", "current_user", "session_user", "user";
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/roleattributes.out"	2025-07-31 16:07:14.998067930 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/roleattributes.out"	2025-07-31 16:39:29.067088086 +0800
***************
*** 1,249 ****
! -- default for superuser is false
! CREATE ROLE regress_test_def_superuser;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_def_superuser';
!           rolname           | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ----------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_def_superuser | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! CREATE ROLE regress_test_superuser WITH SUPERUSER;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_superuser';
!         rolname         | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_superuser | t        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_superuser WITH NOSUPERUSER;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_superuser';
!         rolname         | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_superuser | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_superuser WITH SUPERUSER;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_superuser';
!         rolname         | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_superuser | t        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! -- default for inherit is true
! CREATE ROLE regress_test_def_inherit;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_def_inherit';
!          rolname          | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! --------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_def_inherit | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! CREATE ROLE regress_test_inherit WITH NOINHERIT;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_inherit';
!        rolname        | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ----------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_inherit | f        | f          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_inherit WITH INHERIT;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_inherit';
!        rolname        | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ----------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_inherit | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_inherit WITH NOINHERIT;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_inherit';
!        rolname        | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ----------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_inherit | f        | f          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! -- default for create role is false
! CREATE ROLE regress_test_def_createrole;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_def_createrole';
!            rolname           | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! -----------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_def_createrole | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! CREATE ROLE regress_test_createrole WITH CREATEROLE;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_createrole';
!          rolname         | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! -------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_createrole | f        | t          | t             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_createrole WITH NOCREATEROLE;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_createrole';
!          rolname         | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! -------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_createrole | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_createrole WITH CREATEROLE;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_createrole';
!          rolname         | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! -------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_createrole | f        | t          | t             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! -- default for create database is false
! CREATE ROLE regress_test_def_createdb;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_def_createdb';
!           rolname          | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ---------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_def_createdb | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! CREATE ROLE regress_test_createdb WITH CREATEDB;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_createdb';
!         rolname        | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! -----------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_createdb | f        | t          | f             | t           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_createdb WITH NOCREATEDB;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_createdb';
!         rolname        | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! -----------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_createdb | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_createdb WITH CREATEDB;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_createdb';
!         rolname        | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! -----------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_createdb | f        | t          | f             | t           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! -- default for can login is false for role
! CREATE ROLE regress_test_def_role_canlogin;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_def_role_canlogin';
!             rolname             | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! --------------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_def_role_canlogin | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! CREATE ROLE regress_test_role_canlogin WITH LOGIN;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_role_canlogin';
!           rolname           | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ----------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_role_canlogin | f        | t          | f             | f           | t           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_role_canlogin WITH NOLOGIN;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_role_canlogin';
!           rolname           | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ----------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_role_canlogin | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_role_canlogin WITH LOGIN;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_role_canlogin';
!           rolname           | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ----------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_role_canlogin | f        | t          | f             | f           | t           | f              | f            |           -1 |             | 
! (1 row)
! 
! -- default for can login is true for user
! CREATE USER regress_test_def_user_canlogin;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_def_user_canlogin';
!             rolname             | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! --------------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_def_user_canlogin | f        | t          | f             | f           | t           | f              | f            |           -1 |             | 
! (1 row)
! 
! CREATE USER regress_test_user_canlogin WITH NOLOGIN;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_user_canlogin';
!           rolname           | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ----------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_user_canlogin | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER USER regress_test_user_canlogin WITH LOGIN;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_user_canlogin';
!           rolname           | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ----------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_user_canlogin | f        | t          | f             | f           | t           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER USER regress_test_user_canlogin WITH NOLOGIN;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_user_canlogin';
!           rolname           | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ----------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_user_canlogin | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! -- default for replication is false
! CREATE ROLE regress_test_def_replication;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_def_replication';
!            rolname            | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ------------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_def_replication | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! CREATE ROLE regress_test_replication WITH REPLICATION;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_replication';
!          rolname          | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! --------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_replication | f        | t          | f             | f           | f           | t              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_replication WITH NOREPLICATION;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_replication';
!          rolname          | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! --------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_replication | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_replication WITH REPLICATION;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_replication';
!          rolname          | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! --------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_replication | f        | t          | f             | f           | f           | t              | f            |           -1 |             | 
! (1 row)
! 
! -- default for bypassrls is false
! CREATE ROLE regress_test_def_bypassrls;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_def_bypassrls';
!           rolname           | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ----------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_def_bypassrls | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! CREATE ROLE regress_test_bypassrls WITH BYPASSRLS;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_bypassrls';
!         rolname         | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_bypassrls | f        | t          | f             | f           | f           | f              | t            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_bypassrls WITH NOBYPASSRLS;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_bypassrls';
!         rolname         | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_bypassrls | f        | t          | f             | f           | f           | f              | f            |           -1 |             | 
! (1 row)
! 
! ALTER ROLE regress_test_bypassrls WITH BYPASSRLS;
! SELECT * FROM pg_authid WHERE rolname = 'regress_test_bypassrls';
!         rolname         | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolbypassrls | rolconnlimit | rolpassword | rolvaliduntil 
! ------------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+--------------+-------------+---------------
!  regress_test_bypassrls | f        | t          | f             | f           | f           | f              | t            |           -1 |             | 
! (1 row)
! 
! -- clean up roles
! DROP ROLE regress_test_def_superuser;
! DROP ROLE regress_test_superuser;
! DROP ROLE regress_test_def_inherit;
! DROP ROLE regress_test_inherit;
! DROP ROLE regress_test_def_createrole;
! DROP ROLE regress_test_createrole;
! DROP ROLE regress_test_def_createdb;
! DROP ROLE regress_test_createdb;
! DROP ROLE regress_test_def_role_canlogin;
! DROP ROLE regress_test_role_canlogin;
! DROP USER regress_test_def_user_canlogin;
! DROP USER regress_test_user_canlogin;
! DROP ROLE regress_test_def_replication;
! DROP ROLE regress_test_replication;
! DROP ROLE regress_test_def_bypassrls;
! DROP ROLE regress_test_bypassrls;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/create_am.out"	2025-07-31 16:07:14.981068200 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/create_am.out"	2025-07-31 16:39:29.057088299 +0800
***************
*** 1,108 ****
! --
! -- Create access method tests
! --
! -- Make gist2 over gisthandler. In fact, it would be a synonym to gist.
! CREATE ACCESS METHOD gist2 TYPE INDEX HANDLER gisthandler;
! -- Try to create gist2 index on fast_emp4000: fail because opclass doesn't exist
! CREATE INDEX grect2ind2 ON fast_emp4000 USING gist2 (home_base);
! ERROR:  data type box has no default operator class for access method "gist2"
! HINT:  You must specify an operator class for the index or define a default operator class for the data type.
! -- Make operator class for boxes using gist2
! CREATE OPERATOR CLASS box_ops DEFAULT
! 	FOR TYPE box USING gist2 AS
! 	OPERATOR 1	<<,
! 	OPERATOR 2	&<,
! 	OPERATOR 3	&&,
! 	OPERATOR 4	&>,
! 	OPERATOR 5	>>,
! 	OPERATOR 6	~=,
! 	OPERATOR 7	@>,
! 	OPERATOR 8	<@,
! 	OPERATOR 9	&<|,
! 	OPERATOR 10	<<|,
! 	OPERATOR 11	|>>,
! 	OPERATOR 12	|&>,
! 	OPERATOR 13	~,
! 	OPERATOR 14	@,
! 	FUNCTION 1	gist_box_consistent(internal, box, smallint, oid, internal),
! 	FUNCTION 2	gist_box_union(internal, internal),
! 	FUNCTION 3	gist_box_compress(internal),
! 	FUNCTION 4	gist_box_decompress(internal),
! 	FUNCTION 5	gist_box_penalty(internal, internal, internal),
! 	FUNCTION 6	gist_box_picksplit(internal, internal),
! 	FUNCTION 7	gist_box_same(box, box, internal),
! 	FUNCTION 9	gist_box_fetch(internal);
! -- Create gist2 index on fast_emp4000
! CREATE INDEX grect2ind2 ON fast_emp4000 USING gist2 (home_base);
! -- Now check the results from plain indexscan; temporarily drop existing
! -- index grect2ind to ensure it doesn't capture the plan
! BEGIN;
! DROP INDEX grect2ind;
! SET enable_seqscan = OFF;
! SET enable_indexscan = ON;
! SET enable_bitmapscan = OFF;
! EXPLAIN (COSTS OFF)
! SELECT * FROM fast_emp4000
!     WHERE home_base @ '(200,200),(2000,1000)'::box
!     ORDER BY (home_base[0])[0];
!                               QUERY PLAN                              
! ----------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Sort
!          Sort Key: ((home_base[0])[0])
!          ->  Index Only Scan using grect2ind2 on fast_emp4000
!                Index Cond: (home_base @ '(2000,1000),(200,200)'::box)
! (5 rows)
! 
! SELECT * FROM fast_emp4000
!     WHERE home_base @ '(200,200),(2000,1000)'::box
!     ORDER BY (home_base[0])[0];
!        home_base       
! -----------------------
!  (337,455),(240,359)
!  (1444,403),(1346,344)
! (2 rows)
! 
! EXPLAIN (COSTS OFF)
! SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          ->  Partial Aggregate
!                ->  Index Only Scan using grect2ind2 on fast_emp4000
!                      Index Cond: (home_base && '(1000,1000),(0,0)'::box)
! (5 rows)
! 
! SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
!  count 
! -------
!      2
! (1 row)
! 
! EXPLAIN (COSTS OFF)
! SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
!                              QUERY PLAN                             
! --------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          ->  Partial Aggregate
!                ->  Index Only Scan using grect2ind2 on fast_emp4000
!                      Index Cond: (home_base IS NULL)
! (5 rows)
! 
! SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
!  count 
! -------
!    278
! (1 row)
! 
! ROLLBACK;
! -- Try to drop access method: fail because of dependent objects
! DROP ACCESS METHOD gist2;
! ERROR:  cannot drop access method gist2 because other objects depend on it
! DETAIL:  index grect2ind2 depends on operator class box_ops for access method gist2
! HINT:  Use DROP ... CASCADE to drop the dependent objects too.
! -- Drop access method cascade
! DROP ACCESS METHOD gist2 CASCADE;
! NOTICE:  drop cascades to index grect2ind2
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/hash_func.out"	2025-07-31 16:07:14.984068152 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/hash_func.out"	2025-07-31 16:39:29.068088065 +0800
***************
*** 1,300 ****
! --
! -- Test hash functions
! --
! -- When the salt is 0, the extended hash function should produce a result
! -- whose low 32 bits match the standard hash function.  When the salt is
! -- not 0, we should get a different result.
! --
! SELECT v as value, hashint2(v)::bit(32) as standard,
!        hashint2extended(v, 0)::bit(32) as extended0,
!        hashint2extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (0::int2), (1::int2), (17::int2), (42::int2)) x(v)
! WHERE  hashint2(v)::bit(32) != hashint2extended(v, 0)::bit(32)
!        OR hashint2(v)::bit(32) = hashint2extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashint4(v)::bit(32) as standard,
! 	   hashint4extended(v, 0)::bit(32) as extended0,
! 	   hashint4extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (0), (1), (17), (42), (550273), (207112489)) x(v)
! WHERE  hashint4(v)::bit(32) != hashint4extended(v, 0)::bit(32)
!        OR hashint4(v)::bit(32) = hashint4extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashint8(v)::bit(32) as standard,
! 	   hashint8extended(v, 0)::bit(32) as extended0,
! 	   hashint8extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (0), (1), (17), (42), (550273), (207112489)) x(v)
! WHERE  hashint8(v)::bit(32) != hashint8extended(v, 0)::bit(32)
!        OR hashint8(v)::bit(32) = hashint8extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashfloat4(v)::bit(32) as standard,
! 	   hashfloat4extended(v, 0)::bit(32) as extended0,
! 	   hashfloat4extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (0), (1), (17), (42), (550273), (207112489)) x(v)
! WHERE  hashfloat4(v)::bit(32) != hashfloat4extended(v, 0)::bit(32)
!        OR hashfloat4(v)::bit(32) = hashfloat4extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashfloat8(v)::bit(32) as standard,
! 	   hashfloat8extended(v, 0)::bit(32) as extended0,
! 	   hashfloat8extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (0), (1), (17), (42), (550273), (207112489)) x(v)
! WHERE  hashfloat8(v)::bit(32) != hashfloat8extended(v, 0)::bit(32)
!        OR hashfloat8(v)::bit(32) = hashfloat8extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashoid(v)::bit(32) as standard,
! 	   hashoidextended(v, 0)::bit(32) as extended0,
! 	   hashoidextended(v, 1)::bit(32) as extended1
! FROM   (VALUES (0), (1), (17), (42), (550273), (207112489)) x(v)
! WHERE  hashoid(v)::bit(32) != hashoidextended(v, 0)::bit(32)
!        OR hashoid(v)::bit(32) = hashoidextended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashchar(v)::bit(32) as standard,
! 	   hashcharextended(v, 0)::bit(32) as extended0,
! 	   hashcharextended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::"char"), ('1'), ('x'), ('X'), ('p'), ('N')) x(v)
! WHERE  hashchar(v)::bit(32) != hashcharextended(v, 0)::bit(32)
!        OR hashchar(v)::bit(32) = hashcharextended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashname(v)::bit(32) as standard,
! 	   hashnameextended(v, 0)::bit(32) as extended0,
! 	   hashnameextended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL), ('PostgreSQL'), ('eIpUEtqmY89'), ('AXKEJBTK'),
!        ('muop28x03'), ('yi3nm0d73')) x(v)
! WHERE  hashname(v)::bit(32) != hashnameextended(v, 0)::bit(32)
!        OR hashname(v)::bit(32) = hashnameextended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashtext(v)::bit(32) as standard,
! 	   hashtextextended(v, 0)::bit(32) as extended0,
! 	   hashtextextended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL), ('PostgreSQL'), ('eIpUEtqmY89'), ('AXKEJBTK'),
!        ('muop28x03'), ('yi3nm0d73')) x(v)
! WHERE  hashtext(v)::bit(32) != hashtextextended(v, 0)::bit(32)
!        OR hashtext(v)::bit(32) = hashtextextended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashoidvector(v)::bit(32) as standard,
! 	   hashoidvectorextended(v, 0)::bit(32) as extended0,
! 	   hashoidvectorextended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::oidvector), ('0 1 2 3 4'), ('17 18 19 20'),
!         ('42 43 42 45'), ('550273 550273 570274'),
!         ('207112489 207112499 21512 2155 372325 1363252')) x(v)
! WHERE  hashoidvector(v)::bit(32) != hashoidvectorextended(v, 0)::bit(32)
!        OR hashoidvector(v)::bit(32) = hashoidvectorextended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hash_aclitem(v)::bit(32) as standard,
! 	   hash_aclitem_extended(v, 0)::bit(32) as extended0,
! 	   hash_aclitem_extended(v, 1)::bit(32) as extended1
! FROM   (SELECT DISTINCT(relacl[1]) FROM pg_class LIMIT 10) x(v)
! WHERE  hash_aclitem(v)::bit(32) != hash_aclitem_extended(v, 0)::bit(32)
!        OR hash_aclitem(v)::bit(32) = hash_aclitem_extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashmacaddr(v)::bit(32) as standard,
! 	   hashmacaddrextended(v, 0)::bit(32) as extended0,
! 	   hashmacaddrextended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::macaddr), ('08:00:2b:01:02:04'), ('08:00:2b:01:02:04'),
! 		('e2:7f:51:3e:70:49'), ('d6:a9:4a:78:1c:d5'),
!         ('ea:29:b1:5e:1f:a5')) x(v)
! WHERE  hashmacaddr(v)::bit(32) != hashmacaddrextended(v, 0)::bit(32)
!        OR hashmacaddr(v)::bit(32) = hashmacaddrextended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashinet(v)::bit(32) as standard,
! 	   hashinetextended(v, 0)::bit(32) as extended0,
! 	   hashinetextended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::inet), ('192.168.100.128/25'), ('192.168.100.0/8'),
! 		('172.168.10.126/16'), ('172.18.103.126/24'), ('192.188.13.16/32')) x(v)
! WHERE  hashinet(v)::bit(32) != hashinetextended(v, 0)::bit(32)
!        OR hashinet(v)::bit(32) = hashinetextended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hash_numeric(v)::bit(32) as standard,
! 	   hash_numeric_extended(v, 0)::bit(32) as extended0,
! 	   hash_numeric_extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (0), (1.149484958), (17.149484958), (42.149484958),
!         (149484958.550273), (2071124898672)) x(v)
! WHERE  hash_numeric(v)::bit(32) != hash_numeric_extended(v, 0)::bit(32)
!        OR hash_numeric(v)::bit(32) = hash_numeric_extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashmacaddr8(v)::bit(32) as standard,
! 	   hashmacaddr8extended(v, 0)::bit(32) as extended0,
! 	   hashmacaddr8extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::macaddr8), ('08:00:2b:01:02:04:36:49'),
!         ('08:00:2b:01:02:04:f0:e8'), ('e2:7f:51:3e:70:49:16:29'),
!         ('d6:a9:4a:78:1c:d5:47:32'), ('ea:29:b1:5e:1f:a5')) x(v)
! WHERE  hashmacaddr8(v)::bit(32) != hashmacaddr8extended(v, 0)::bit(32)
!        OR hashmacaddr8(v)::bit(32) = hashmacaddr8extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hash_array(v)::bit(32) as standard,
! 	   hash_array_extended(v, 0)::bit(32) as extended0,
! 	   hash_array_extended(v, 1)::bit(32) as extended1
! FROM   (VALUES ('{0}'::int4[]), ('{0,1,2,3,4}'), ('{17,18,19,20}'),
!         ('{42,34,65,98}'), ('{550273,590027, 870273}'),
!         ('{207112489, 807112489}')) x(v)
! WHERE  hash_array(v)::bit(32) != hash_array_extended(v, 0)::bit(32)
!        OR hash_array(v)::bit(32) = hash_array_extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hashbpchar(v)::bit(32) as standard,
! 	   hashbpcharextended(v, 0)::bit(32) as extended0,
! 	   hashbpcharextended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL), ('PostgreSQL'), ('eIpUEtqmY89'), ('AXKEJBTK'),
!        ('muop28x03'), ('yi3nm0d73')) x(v)
! WHERE  hashbpchar(v)::bit(32) != hashbpcharextended(v, 0)::bit(32)
!        OR hashbpchar(v)::bit(32) = hashbpcharextended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, time_hash(v)::bit(32) as standard,
! 	   time_hash_extended(v, 0)::bit(32) as extended0,
! 	   time_hash_extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::time), ('11:09:59'), ('1:09:59'), ('11:59:59'),
!         ('7:9:59'), ('5:15:59')) x(v)
! WHERE  time_hash(v)::bit(32) != time_hash_extended(v, 0)::bit(32)
!        OR time_hash(v)::bit(32) = time_hash_extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, timetz_hash(v)::bit(32) as standard,
! 	   timetz_hash_extended(v, 0)::bit(32) as extended0,
! 	   timetz_hash_extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::timetz), ('00:11:52.518762-07'), ('00:11:52.51762-08'),
! 		('00:11:52.62-01'), ('00:11:52.62+01'), ('11:59:59+04')) x(v)
! WHERE  timetz_hash(v)::bit(32) != timetz_hash_extended(v, 0)::bit(32)
!        OR timetz_hash(v)::bit(32) = timetz_hash_extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, interval_hash(v)::bit(32) as standard,
! 	   interval_hash_extended(v, 0)::bit(32) as extended0,
! 	   interval_hash_extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::interval),
!         ('5 month 7 day 46 minutes'), ('1 year 7 day 46 minutes'),
! 		('1 year 7 month 20 day 46 minutes'), ('5 month'),
! 		('17 year 11 month 7 day 9 hours 46 minutes 5 seconds')) x(v)
! WHERE  interval_hash(v)::bit(32) != interval_hash_extended(v, 0)::bit(32)
!        OR interval_hash(v)::bit(32) = interval_hash_extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, timestamp_hash(v)::bit(32) as standard,
! 	   timestamp_hash_extended(v, 0)::bit(32) as extended0,
! 	   timestamp_hash_extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::timestamp), ('2017-08-22 00:09:59.518762'),
!         ('2015-08-20 00:11:52.51762-08'),
! 		('2017-05-22 00:11:52.62-01'),
!         ('2013-08-22 00:11:52.62+01'), ('2013-08-22 11:59:59+04')) x(v)
! WHERE  timestamp_hash(v)::bit(32) != timestamp_hash_extended(v, 0)::bit(32)
!        OR timestamp_hash(v)::bit(32) = timestamp_hash_extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, uuid_hash(v)::bit(32) as standard,
! 	   uuid_hash_extended(v, 0)::bit(32) as extended0,
! 	   uuid_hash_extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::uuid), ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'),
! 		('5a9ba4ac-8d6f-11e7-bb31-be2e44b06b34'),
!         ('99c6705c-d939-461c-a3c9-1690ad64ed7b'),
! 		('7deed3ca-8d6f-11e7-bb31-be2e44b06b34'),
!         ('9ad46d4f-6f2a-4edd-aadb-745993928e1e')) x(v)
! WHERE  uuid_hash(v)::bit(32) != uuid_hash_extended(v, 0)::bit(32)
!        OR uuid_hash(v)::bit(32) = uuid_hash_extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, pg_lsn_hash(v)::bit(32) as standard,
! 	   pg_lsn_hash_extended(v, 0)::bit(32) as extended0,
! 	   pg_lsn_hash_extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::pg_lsn), ('16/B374D84'), ('30/B374D84'),
! 		('255/B374D84'), ('25/B379D90'), ('900/F37FD90')) x(v)
! WHERE  pg_lsn_hash(v)::bit(32) != pg_lsn_hash_extended(v, 0)::bit(32)
!        OR pg_lsn_hash(v)::bit(32) = pg_lsn_hash_extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
! SELECT v as value, hashenum(v)::bit(32) as standard,
! 	   hashenumextended(v, 0)::bit(32) as extended0,
! 	   hashenumextended(v, 1)::bit(32) as extended1
! FROM   (VALUES ('sad'::mood), ('ok'), ('happy')) x(v)
! WHERE  hashenum(v)::bit(32) != hashenumextended(v, 0)::bit(32)
!        OR hashenum(v)::bit(32) = hashenumextended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! DROP TYPE mood;
! SELECT v as value, jsonb_hash(v)::bit(32) as standard,
! 	   jsonb_hash_extended(v, 0)::bit(32) as extended0,
! 	   jsonb_hash_extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (NULL::jsonb),
!     ('{"a": "aaa bbb ddd ccc", "b": ["eee fff ggg"], "c": {"d": "hhh iii"}}'),
! 	('{"foo": [true, "bar"], "tags": {"e": 1, "f": null}}'),
!     ('{"g": {"h": "value"}}')) x(v)
! WHERE  jsonb_hash(v)::bit(32) != jsonb_hash_extended(v, 0)::bit(32)
!        OR jsonb_hash(v)::bit(32) = jsonb_hash_extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
! SELECT v as value, hash_range(v)::bit(32) as standard,
! 	   hash_range_extended(v, 0)::bit(32) as extended0,
! 	   hash_range_extended(v, 1)::bit(32) as extended1
! FROM   (VALUES (int4range(10, 20)), (int4range(23, 43)),
!          (int4range(5675, 550273)),
! 		 (int4range(550274, 1550274)), (int4range(1550275, 208112489))) x(v)
! WHERE  hash_range(v)::bit(32) != hash_range_extended(v, 0)::bit(32)
!        OR hash_range(v)::bit(32) = hash_range_extended(v, 1)::bit(32);
!  value | standard | extended0 | extended1 
! -------+----------+-----------+-----------
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/sanity_check.out"	2025-07-31 16:07:15.000067898 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/sanity_check.out"	2025-07-31 16:39:29.620076293 +0800
***************
*** 1,247 ****
! VACUUM;
! --
! -- sanity check, if we don't have indices the test will take years to
! -- complete.  But skip TOAST relations (since they will have varying
! -- names depending on the current OID counter) as well as temp tables
! -- of other backends (to avoid timing-dependent behavior).
! --
! -- temporarily disable fancy output, so catalog changes create less diff noise
! \a\t
! SELECT relname, relhasindex
!    FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace
!    WHERE relkind IN ('r', 'p') AND (nspname ~ '^pg_temp_') IS NOT TRUE
!    ORDER BY relname;
! a|f
! a_star|f
! abstime_tbl|f
! aggtest|f
! array_index_op_test|t
! array_op_test|f
! b|f
! b_star|f
! box_tbl|f
! bprime|f
! bt_f8_heap|t
! bt_i4_heap|t
! bt_name_heap|t
! bt_txt_heap|t
! c|f
! c_star|f
! char_tbl|f
! check2_tbl|f
! check_tbl|f
! circle_tbl|t
! city|f
! copy_tbl|f
! d|f
! d_star|f
! date_tbl|f
! default_tbl|f
! defaultexpr_tbl|f
! dept|f
! donothingbrtrig_test1|f
! donothingbrtrig_test2|f
! dupindexcols|t
! e_star|f
! emp|f
! equipment_r|f
! f_star|f
! fast_emp4000|t
! float4_tbl|f
! float8_tbl|f
! func_index_heap|f
! hash_f8_heap|t
! hash_i4_heap|t
! hash_name_heap|t
! hash_txt_heap|t
! hobbies_r|f
! ihighway|t
! inet_tbl|t
! inhf|f
! inhx|t
! insert_tbl|f
! insertwithret|f
! int2_tbl|f
! int4_tbl|f
! int8_tbl|f
! interval_tbl|f
! invalid_check_con|f
! invalid_check_con_child|f
! iportaltest|f
! kd_point_tbl|t
! line_tbl|f
! log_table|f
! lseg_tbl|f
! main_table|t
! mlparted|f
! mlparted1|f
! mlparted11|f
! mlparted12|f
! mlparted2|f
! mlparted3|f
! mlparted4|f
! mlparted_def|f
! mlparted_def1|f
! mlparted_def2|f
! mlparted_defd|f
! money_data|f
! num_data|f
! num_exp_add|t
! num_exp_div|t
! num_exp_ln|t
! num_exp_log10|t
! num_exp_mul|t
! num_exp_power_10_ln|t
! num_exp_sqrt|t
! num_exp_sub|t
! num_input_test|f
! num_result|f
! onek|t
! onek2|t
! path_tbl|f
! person|f
! persons|f
! persons2|t
! persons3|t
! pg_aggregate|t
! pg_am|t
! pg_amop|t
! pg_amproc|t
! pg_attrdef|t
! pg_attribute|t
! pg_audit_fga_conf|t
! pg_audit_obj_conf|t
! pg_audit_obj_def_opts|t
! pg_audit_stmt_conf|t
! pg_audit_user_conf|t
! pg_auth_members|t
! pg_authid|t
! pg_cast|t
! pg_class|t
! pg_cls_compartment|t
! pg_cls_group|t
! pg_cls_label|t
! pg_cls_level|t
! pg_cls_policy|t
! pg_cls_table|t
! pg_cls_user|t
! pg_collation|t
! pg_constraint|t
! pg_conversion|t
! pg_data_mask_map|t
! pg_data_mask_user|t
! pg_database|t
! pg_db_role_setting|t
! pg_default_acl|t
! pg_depend|t
! pg_description|t
! pg_enum|t
! pg_event_trigger|t
! pg_extension|t
! pg_foreign_data_wrapper|t
! pg_foreign_server|t
! pg_foreign_table|t
! pg_index|t
! pg_inherits|t
! pg_init_privs|t
! pg_language|t
! pg_largeobject|t
! pg_largeobject_metadata|t
! pg_namespace|t
! pg_opclass|t
! pg_operator|t
! pg_opfamily|t
! pg_partition_interval|t
! pg_partitioned_table|t
! pg_pltemplate|t
! pg_policy|t
! pg_proc|t
! pg_publication|t
! pg_publication_rel|t
! pg_publication_shard|t
! pg_range|t
! pg_replication_origin|t
! pg_rewrite|t
! pg_seclabel|t
! pg_sequence|t
! pg_shdepend|t
! pg_shdescription|t
! pg_shseclabel|t
! pg_statistic|t
! pg_statistic_ext|t
! pg_subscription|t
! pg_subscription_rel|t
! pg_subscription_shard|t
! pg_subscription_table|t
! pg_tablespace|t
! pg_transform|t
! pg_transparent_crypt_policy_algorithm|t
! pg_transparent_crypt_policy_map|t
! pg_transparent_crypt_policy_schema|t
! pg_transparent_crypt_policy_tablespace|t
! pg_trigger|t
! pg_ts_config|t
! pg_ts_config_map|t
! pg_ts_dict|t
! pg_ts_parser|t
! pg_ts_template|t
! pg_type|t
! pg_user_mapping|t
! pgxc_class|t
! pgxc_group|t
! pgxc_key_value|t
! pgxc_node|t
! pgxc_shard_map|t
! point_tbl|t
! polygon_tbl|t
! quad_box_tbl|t
! quad_point_tbl|t
! radix_text_tbl|t
! ramp|f
! real_city|f
! reltime_tbl|f
! road|t
! shighway|t
! slow_emp4000|f
! sql_features|f
! sql_implementation_info|f
! sql_languages|f
! sql_packages|f
! sql_parts|f
! sql_sizing|f
! sql_sizing_profiles|f
! stud_emp|f
! student|f
! tenk1|t
! tenk2|t
! test_range_excl|t
! test_range_gist|t
! test_range_spgist|t
! test_tsvector|f
! testjsonb|f
! text_tbl|f
! time_tbl|f
! timestamp_tbl|f
! timestamptz_tbl|f
! timetz_tbl|f
! tinterval_tbl|f
! varchar_tbl|f
! -- restore normal output mode
! \a\t
! --
! -- another sanity check: every system catalog that has OIDs should have
! -- a unique index on OID.  This ensures that the OIDs will be unique,
! -- even after the OID counter wraps around.
! -- We exclude non-system tables from the check by looking at nspname.
! --
! SELECT relname, nspname
! FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace
! WHERE relhasoids
!     AND ((nspname ~ '^pg_') IS NOT FALSE)
!     AND NOT EXISTS (SELECT 1 FROM pg_index i WHERE indrelid = c.oid
!                     AND indkey[0] = -2 AND indnatts = 1
!                     AND indisunique AND indimmediate);
!  relname | nspname 
! ---------+---------
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/errors.out"	2025-07-31 16:07:14.982068184 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/errors.out"	2025-07-31 16:39:29.645075760 +0800
***************
*** 1,449 ****
! --
! -- ERRORS
! --
! -- bad in postquel, but ok in PostgreSQL
! select 1;
!  ?column? 
! ----------
!         1
! (1 row)
! 
! --
! -- UNSUPPORTED STUFF
! -- doesn't work
! -- notify pg_class
! --
! --
! -- SELECT
! -- this used to be a syntax error, but now we allow an empty target list
! select;
! --
! (1 row)
! 
! -- no such relation
! select * from nonesuch;
! ERROR:  relation "nonesuch" does not exist
! LINE 1: select * from nonesuch;
!                       ^
! -- bad name in target list
! select nonesuch from pg_database;
! ERROR:  column "nonesuch" does not exist
! LINE 1: select nonesuch from pg_database;
!                ^
! -- empty distinct list isn't OK
! select distinct from pg_database;
! ERROR:  syntax error at or near "from"
! LINE 1: select distinct from pg_database;
!                         ^
! -- bad attribute name on lhs of operator
! select * from pg_database where nonesuch = pg_database.datname;
! ERROR:  column "nonesuch" does not exist
! LINE 1: select * from pg_database where nonesuch = pg_database.datna...
!                                         ^
! -- bad attribute name on rhs of operator
! select * from pg_database where pg_database.datname = nonesuch;
! ERROR:  column "nonesuch" does not exist
! LINE 1: ...ect * from pg_database where pg_database.datname = nonesuch;
!                                                               ^
! -- bad attribute name in select distinct on
! select distinct on (foobar) * from pg_database;
! ERROR:  column "foobar" does not exist
! LINE 1: select distinct on (foobar) * from pg_database;
!                             ^
! --
! -- DELETE
! -- missing relation name (this had better not wildcard!)
! delete from;
! ERROR:  syntax error at or near ";"
! LINE 1: delete from;
!                    ^
! -- no such relation
! delete from nonesuch;
! ERROR:  relation "nonesuch" does not exist
! LINE 1: delete from nonesuch;
!                     ^
! --
! -- DROP
! -- missing relation name (this had better not wildcard!)
! drop table;
! ERROR:  syntax error at or near ";"
! LINE 1: drop table;
!                   ^
! -- no such relation
! drop table nonesuch;
! ERROR:  table "nonesuch" does not exist
! --
! -- ALTER TABLE
! -- relation renaming
! -- missing relation name
! alter table rename;
! ERROR:  syntax error at or near ";"
! LINE 1: alter table rename;
!                           ^
! -- no such relation
! alter table nonesuch rename to newnonesuch;
! ERROR:  relation "nonesuch" does not exist
! -- no such relation
! alter table nonesuch rename to stud_emp;
! ERROR:  relation "nonesuch" does not exist
! -- conflict
! alter table stud_emp rename to aggtest;
! ERROR:  relation "aggtest" already exists
! -- self-conflict
! alter table stud_emp rename to stud_emp;
! ERROR:  relation "stud_emp" already exists
! -- attribute renaming
! -- no such relation
! alter table nonesuchrel rename column nonesuchatt to newnonesuchatt;
! ERROR:  relation "nonesuchrel" does not exist
! -- no such attribute
! alter table emp rename column nonesuchatt to newnonesuchatt;
! ERROR:  column "nonesuchatt" does not exist
! -- conflict
! alter table emp rename column salary to manager;
! ERROR:  column "manager" of relation "stud_emp" already exists
! -- conflict
! alter table emp rename column salary to oid;
! ERROR:  column name "oid" conflicts with a system column name
! --
! -- TRANSACTION STUFF
! -- not in a xact
! abort;
! WARNING:  there is no transaction in progress
! -- not in a xact
! end;
! WARNING:  there is no transaction in progress
! --
! -- CREATE AGGREGATE
! -- sfunc/finalfunc type disagreement
! create aggregate newavg2 (sfunc = int4pl,
! 			  basetype = int4,
! 			  stype = int4,
! 			  finalfunc = int2um,
! 			  initcond = '0');
! ERROR:  function int2um(integer) does not exist
! -- left out basetype
! create aggregate newcnt1 (sfunc = int4inc,
! 			  stype = int4,
! 			  initcond = '0');
! ERROR:  aggregate input type must be specified
! --
! -- DROP INDEX
! -- missing index name
! drop index;
! ERROR:  syntax error at or near ";"
! LINE 1: drop index;
!                   ^
! -- bad index name
! drop index 314159;
! ERROR:  syntax error at or near "314159"
! LINE 1: drop index 314159;
!                    ^
! -- no such index
! drop index nonesuch;
! ERROR:  index "nonesuch" does not exist
! --
! -- DROP AGGREGATE
! -- missing aggregate name
! drop aggregate;
! ERROR:  syntax error at or near ";"
! LINE 1: drop aggregate;
!                       ^
! -- missing aggregate type
! drop aggregate newcnt1;
! ERROR:  syntax error at or near ";"
! LINE 1: drop aggregate newcnt1;
!                               ^
! -- bad aggregate name
! drop aggregate 314159 (int);
! ERROR:  syntax error at or near "314159"
! LINE 1: drop aggregate 314159 (int);
!                        ^
! -- bad aggregate type
! drop aggregate newcnt (nonesuch);
! ERROR:  type "nonesuch" does not exist
! -- no such aggregate
! drop aggregate nonesuch (int4);
! ERROR:  aggregate nonesuch(integer) does not exist
! -- no such aggregate for type
! drop aggregate newcnt (float4);
! ERROR:  aggregate newcnt(real) does not exist
! --
! -- DROP FUNCTION
! -- missing function name
! drop function ();
! ERROR:  syntax error at or near "("
! LINE 1: drop function ();
!                       ^
! -- bad function name
! drop function 314159();
! ERROR:  syntax error at or near "314159"
! LINE 1: drop function 314159();
!                       ^
! -- no such function
! drop function nonesuch();
! ERROR:  function nonesuch() does not exist
! --
! -- DROP TYPE
! -- missing type name
! drop type;
! ERROR:  syntax error at or near ";"
! LINE 1: drop type;
!                  ^
! -- bad type name
! drop type 314159;
! ERROR:  syntax error at or near "314159"
! LINE 1: drop type 314159;
!                   ^
! -- no such type
! drop type nonesuch;
! ERROR:  type "nonesuch" does not exist
! --
! -- DROP OPERATOR
! -- missing everything
! drop operator;
! ERROR:  syntax error at or near ";"
! LINE 1: drop operator;
!                      ^
! -- bad operator name
! drop operator equals;
! ERROR:  syntax error at or near ";"
! LINE 1: drop operator equals;
!                             ^
! -- missing type list
! drop operator ===;
! ERROR:  syntax error at or near ";"
! LINE 1: drop operator ===;
!                          ^
! -- missing parentheses
! drop operator int4, int4;
! ERROR:  syntax error at or near ","
! LINE 1: drop operator int4, int4;
!                           ^
! -- missing operator name
! drop operator (int4, int4);
! ERROR:  syntax error at or near "("
! LINE 1: drop operator (int4, int4);
!                       ^
! -- missing type list contents
! drop operator === ();
! ERROR:  syntax error at or near ")"
! LINE 1: drop operator === ();
!                            ^
! -- no such operator
! drop operator === (int4);
! ERROR:  missing argument
! LINE 1: drop operator === (int4);
!                                ^
! HINT:  Use NONE to denote the missing argument of a unary operator.
! -- no such operator by that name
! drop operator === (int4, int4);
! ERROR:  operator does not exist: integer === integer
! -- no such type1
! drop operator = (nonesuch);
! ERROR:  missing argument
! LINE 1: drop operator = (nonesuch);
!                                  ^
! HINT:  Use NONE to denote the missing argument of a unary operator.
! -- no such type1
! drop operator = ( , int4);
! ERROR:  syntax error at or near ","
! LINE 1: drop operator = ( , int4);
!                           ^
! -- no such type1
! drop operator = (nonesuch, int4);
! ERROR:  type "nonesuch" does not exist
! -- no such type2
! drop operator = (int4, nonesuch);
! ERROR:  type "nonesuch" does not exist
! -- no such type2
! drop operator = (int4, );
! ERROR:  syntax error at or near ")"
! LINE 1: drop operator = (int4, );
!                                ^
! --
! -- DROP RULE
! -- missing rule name
! drop rule;
! ERROR:  syntax error at or near ";"
! LINE 1: drop rule;
!                  ^
! -- bad rule name
! drop rule 314159;
! ERROR:  syntax error at or near "314159"
! LINE 1: drop rule 314159;
!                   ^
! -- no such rule
! drop rule nonesuch on noplace;
! ERROR:  relation "noplace" does not exist
! -- these postquel variants are no longer supported
! drop tuple rule nonesuch;
! ERROR:  syntax error at or near "tuple"
! LINE 1: drop tuple rule nonesuch;
!              ^
! drop instance rule nonesuch on noplace;
! ERROR:  syntax error at or near "instance"
! LINE 1: drop instance rule nonesuch on noplace;
!              ^
! drop rewrite rule nonesuch;
! ERROR:  syntax error at or near "rewrite"
! LINE 1: drop rewrite rule nonesuch;
!              ^
! --
! -- Check that division-by-zero is properly caught.
! --
! select 1/0;
! ERROR:  division by zero
! select 1::int8/0;
! ERROR:  division by zero
! select 1/0::int8;
! ERROR:  division by zero
! select 1::int2/0;
! ERROR:  division by zero
! select 1/0::int2;
! ERROR:  division by zero
! select 1::numeric/0;
! ERROR:  division by zero
! select 1/0::numeric;
! ERROR:  division by zero
! select 1::float8/0;
! ERROR:  division by zero
! select 1/0::float8;
! ERROR:  division by zero
! select 1::float4/0;
! ERROR:  division by zero
! select 1/0::float4;
! ERROR:  division by zero
! --
! -- Test psql's reporting of syntax error location
! --
! xxx;
! ERROR:  syntax error at or near "xxx"
! LINE 1: xxx;
!         ^
! CREATE foo;
! ERROR:  syntax error at or near "foo"
! LINE 1: CREATE foo;
!                ^
! CREATE TABLE ;
! ERROR:  syntax error at or near ";"
! LINE 1: CREATE TABLE ;
!                      ^
! CREATE TABLE
! \g
! ERROR:  syntax error at end of input
! LINE 1: CREATE TABLE
!                     ^
! INSERT INTO foo VALUES(123) foo;
! ERROR:  syntax error at or near "foo"
! LINE 1: INSERT INTO foo VALUES(123) foo;
!                                     ^
! INSERT INTO 123
! VALUES(123);
! ERROR:  syntax error at or near "123"
! LINE 1: INSERT INTO 123
!                     ^
! INSERT INTO foo
! VALUES(123) 123
! ;
! ERROR:  syntax error at or near "123"
! LINE 2: VALUES(123) 123
!                     ^
! -- with a tab
! CREATE TABLE foo
!   (id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY,
! 	id3 INTEGER NOT NUL,
!    id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 3:  id3 INTEGER NOT NUL,
!                          ^
! -- long line to be truncated on the left
! CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
! id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 1: ...OT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
!                                                                    ^
! -- long line to be truncated on the right
! CREATE TABLE foo(
! id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY);
! ERROR:  syntax error at or near "NUL"
! LINE 2: id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQ...
!                         ^
! -- long line to be truncated both ways
! CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 1: ...L, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 I...
!                                                              ^
! -- long line to be truncated on the left, many lines
! CREATE
! TEMPORARY
! TABLE
! foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
! id4 INT4
! UNIQUE
! NOT
! NULL,
! id5 TEXT
! UNIQUE
! NOT
! NULL)
! ;
! ERROR:  syntax error at or near "NUL"
! LINE 4: ...OT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
!                                                                    ^
! -- long line to be truncated on the right, many lines
! CREATE
! TEMPORARY
! TABLE
! foo(
! id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY)
! ;
! ERROR:  syntax error at or near "NUL"
! LINE 5: id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQ...
!                         ^
! -- long line to be truncated both ways, many lines
! CREATE
! TEMPORARY
! TABLE
! foo
! (id
! INT4
! UNIQUE NOT NULL, idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL,
! idz INT4 UNIQUE NOT NULL,
! idv INT4 UNIQUE NOT NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 7: ...L, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 I...
!                                                              ^
! -- more than 10 lines...
! CREATE
! TEMPORARY
! TABLE
! foo
! (id
! INT4
! UNIQUE
! NOT
! NULL
! ,
! idm
! INT4
! UNIQUE
! NOT
! NULL,
! idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL,
! idz INT4 UNIQUE NOT NULL,
! idv
! INT4
! UNIQUE
! NOT
! NULL);
! ERROR:  syntax error at or near "NUL"
! LINE 16: ...L, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 I...
!                                                               ^
! -- Check that stack depth detection mechanism works and
! -- max_stack_depth is not set too high
! create function infinite_recurse() returns int as
! 'select infinite_recurse()' language sql;
! \set VERBOSITY terse
! select infinite_recurse();
! ERROR:  stack depth limit exceeded
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/select.out"	2025-07-31 16:07:15.000067898 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/select.out"	2025-07-31 16:39:29.679075035 +0800
***************
*** 1,986 ****
! --
! -- SELECT
! --
! -- btree index
! -- awk '{if($1<10){print;}else{next;}}' onek.data | sort +0n -1
! --
! SELECT * FROM onek
!    WHERE onek.unique1 < 10
!    ORDER BY onek.unique1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!        0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
!        1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
!        2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx
!        3 |     431 |   1 |    3 |   3 |      3 |       3 |        3 |           3 |         3 |        3 |   6 |    7 | DAAAAA   | PQAAAA   | VVVVxx
!        4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
!        5 |     541 |   1 |    1 |   5 |      5 |       5 |        5 |           5 |         5 |        5 |  10 |   11 | FAAAAA   | VUAAAA   | HHHHxx
!        6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
!        7 |     647 |   1 |    3 |   7 |      7 |       7 |        7 |           7 |         7 |        7 |  14 |   15 | HAAAAA   | XYAAAA   | VVVVxx
!        8 |     653 |   0 |    0 |   8 |      8 |       8 |        8 |           8 |         8 |        8 |  16 |   17 | IAAAAA   | DZAAAA   | HHHHxx
!        9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
! (10 rows)
! 
! --
! -- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
! --
! SELECT onek.unique1, onek.stringu1 FROM onek
!    WHERE onek.unique1 < 20
!    ORDER BY unique1 using >;
!  unique1 | stringu1 
! ---------+----------
!       19 | TAAAAA
!       18 | SAAAAA
!       17 | RAAAAA
!       16 | QAAAAA
!       15 | PAAAAA
!       14 | OAAAAA
!       13 | NAAAAA
!       12 | MAAAAA
!       11 | LAAAAA
!       10 | KAAAAA
!        9 | JAAAAA
!        8 | IAAAAA
!        7 | HAAAAA
!        6 | GAAAAA
!        5 | FAAAAA
!        4 | EAAAAA
!        3 | DAAAAA
!        2 | CAAAAA
!        1 | BAAAAA
!        0 | AAAAAA
! (20 rows)
! 
! --
! -- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
! --
! SELECT onek.unique1, onek.stringu1 FROM onek
!    WHERE onek.unique1 > 980
!    ORDER BY stringu1 using <;
!  unique1 | stringu1 
! ---------+----------
!      988 | AMAAAA
!      989 | BMAAAA
!      990 | CMAAAA
!      991 | DMAAAA
!      992 | EMAAAA
!      993 | FMAAAA
!      994 | GMAAAA
!      995 | HMAAAA
!      996 | IMAAAA
!      997 | JMAAAA
!      998 | KMAAAA
!      999 | LMAAAA
!      981 | TLAAAA
!      982 | ULAAAA
!      983 | VLAAAA
!      984 | WLAAAA
!      985 | XLAAAA
!      986 | YLAAAA
!      987 | ZLAAAA
! (19 rows)
! 
! --
! -- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
! -- sort +1d -2 +0nr -1
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 > 980
!    ORDER BY string4 using <, unique1 using >;
!  unique1 | string4 
! ---------+---------
!      999 | AAAAxx
!      995 | AAAAxx
!      983 | AAAAxx
!      982 | AAAAxx
!      981 | AAAAxx
!      998 | HHHHxx
!      997 | HHHHxx
!      993 | HHHHxx
!      990 | HHHHxx
!      986 | HHHHxx
!      996 | OOOOxx
!      991 | OOOOxx
!      988 | OOOOxx
!      987 | OOOOxx
!      985 | OOOOxx
!      994 | VVVVxx
!      992 | VVVVxx
!      989 | VVVVxx
!      984 | VVVVxx
! (19 rows)
! 
! --
! -- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
! -- sort +1dr -2 +0n -1
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 > 980
!    ORDER BY string4 using >, unique1 using <;
!  unique1 | string4 
! ---------+---------
!      984 | VVVVxx
!      989 | VVVVxx
!      992 | VVVVxx
!      994 | VVVVxx
!      985 | OOOOxx
!      987 | OOOOxx
!      988 | OOOOxx
!      991 | OOOOxx
!      996 | OOOOxx
!      986 | HHHHxx
!      990 | HHHHxx
!      993 | HHHHxx
!      997 | HHHHxx
!      998 | HHHHxx
!      981 | AAAAxx
!      982 | AAAAxx
!      983 | AAAAxx
!      995 | AAAAxx
!      999 | AAAAxx
! (19 rows)
! 
! --
! -- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
! -- sort +0nr -1 +1d -2
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 < 20
!    ORDER BY unique1 using >, string4 using <;
!  unique1 | string4 
! ---------+---------
!       19 | OOOOxx
!       18 | VVVVxx
!       17 | HHHHxx
!       16 | OOOOxx
!       15 | VVVVxx
!       14 | AAAAxx
!       13 | OOOOxx
!       12 | AAAAxx
!       11 | OOOOxx
!       10 | AAAAxx
!        9 | HHHHxx
!        8 | HHHHxx
!        7 | VVVVxx
!        6 | OOOOxx
!        5 | HHHHxx
!        4 | HHHHxx
!        3 | VVVVxx
!        2 | OOOOxx
!        1 | OOOOxx
!        0 | OOOOxx
! (20 rows)
! 
! --
! -- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
! -- sort +0n -1 +1dr -2
! --
! SELECT onek.unique1, onek.string4 FROM onek
!    WHERE onek.unique1 < 20
!    ORDER BY unique1 using <, string4 using >;
!  unique1 | string4 
! ---------+---------
!        0 | OOOOxx
!        1 | OOOOxx
!        2 | OOOOxx
!        3 | VVVVxx
!        4 | HHHHxx
!        5 | HHHHxx
!        6 | OOOOxx
!        7 | VVVVxx
!        8 | HHHHxx
!        9 | HHHHxx
!       10 | AAAAxx
!       11 | OOOOxx
!       12 | AAAAxx
!       13 | OOOOxx
!       14 | AAAAxx
!       15 | VVVVxx
!       16 | OOOOxx
!       17 | HHHHxx
!       18 | VVVVxx
!       19 | OOOOxx
! (20 rows)
! 
! --
! -- test partial btree indexes
! --
! -- As of 7.2, planner probably won't pick an indexscan without stats,
! -- so ANALYZE first.  Also, we want to prevent it from picking a bitmapscan
! -- followed by sort, because that could hide index ordering problems.
! --
! ANALYZE onek2;
! SET enable_seqscan TO off;
! SET enable_bitmapscan TO off;
! SET enable_sort TO off;
! --
! -- awk '{if($1<10){print $0;}else{next;}}' onek.data | sort +0n -1
! --
! SELECT onek2.* FROM onek2 WHERE onek2.unique1 < 10 ORDER BY unique1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!        0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
!        1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
!        2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx
!        3 |     431 |   1 |    3 |   3 |      3 |       3 |        3 |           3 |         3 |        3 |   6 |    7 | DAAAAA   | PQAAAA   | VVVVxx
!        4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
!        5 |     541 |   1 |    1 |   5 |      5 |       5 |        5 |           5 |         5 |        5 |  10 |   11 | FAAAAA   | VUAAAA   | HHHHxx
!        6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
!        7 |     647 |   1 |    3 |   7 |      7 |       7 |        7 |           7 |         7 |        7 |  14 |   15 | HAAAAA   | XYAAAA   | VVVVxx
!        8 |     653 |   0 |    0 |   8 |      8 |       8 |        8 |           8 |         8 |        8 |  16 |   17 | IAAAAA   | DZAAAA   | HHHHxx
!        9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
! (10 rows)
! 
! --
! -- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
! --
! SELECT onek2.unique1, onek2.stringu1 FROM onek2
!     WHERE onek2.unique1 < 20
!     ORDER BY unique1 using >;
!  unique1 | stringu1 
! ---------+----------
!       19 | TAAAAA
!       18 | SAAAAA
!       17 | RAAAAA
!       16 | QAAAAA
!       15 | PAAAAA
!       14 | OAAAAA
!       13 | NAAAAA
!       12 | MAAAAA
!       11 | LAAAAA
!       10 | KAAAAA
!        9 | JAAAAA
!        8 | IAAAAA
!        7 | HAAAAA
!        6 | GAAAAA
!        5 | FAAAAA
!        4 | EAAAAA
!        3 | DAAAAA
!        2 | CAAAAA
!        1 | BAAAAA
!        0 | AAAAAA
! (20 rows)
! 
! --
! -- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
! --
! SELECT onek2.unique1, onek2.stringu1 FROM onek2
!    WHERE onek2.unique1 > 980 
!    ORDER BY unique1 using <;
!  unique1 | stringu1 
! ---------+----------
!      981 | TLAAAA
!      982 | ULAAAA
!      983 | VLAAAA
!      984 | WLAAAA
!      985 | XLAAAA
!      986 | YLAAAA
!      987 | ZLAAAA
!      988 | AMAAAA
!      989 | BMAAAA
!      990 | CMAAAA
!      991 | DMAAAA
!      992 | EMAAAA
!      993 | FMAAAA
!      994 | GMAAAA
!      995 | HMAAAA
!      996 | IMAAAA
!      997 | JMAAAA
!      998 | KMAAAA
!      999 | LMAAAA
! (19 rows)
! 
! RESET enable_seqscan;
! RESET enable_bitmapscan;
! RESET enable_sort;
! SELECT two, stringu1, ten, string4
!    INTO TABLE tmp
!    FROM onek;
! --
! -- awk '{print $1,$2;}' person.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
! -- awk 'BEGIN{FS="      ";}{if(NF!=2){print $4,$5;}else{print;}}' - stud_emp.data
! --
! -- SELECT name, age FROM person*; ??? check if different
! SELECT p.name, p.age FROM person* p 
!     ORDER BY p.name, p.age;
!   name   | age 
! ---------+-----
!  alex    |  30
!  belinda |  38
!  bertha  |  88
!  bill    |  20
!  carina  |  58
!  carmen  |  78
!  chris   |  78
!  cim     |  30
!  denise  |  24
!  diane   |  18
!  edna    |  18
!  esther  |  98
!  fanny   |   8
!  fred    |  28
!  gina    |  18
!  jane    |  58
!  jean    |  28
!  jeff    |  23
!  jenifer |  38
!  joan    |  18
!  joe     |  20
!  juanita |  58
!  julie   |  68
!  karen   |  48
!  koko    |  88
!  larry   |  60
!  leah    |  68
!  linda   |  19
!  lita    |  25
!  liza    |  38
!  louise  |  98
!  martie  |  88
!  mary    |   8
!  melissa |  28
!  mike    |  40
!  nan     |  28
!  pamela  |  48
!  pat     |  18
!  paula   |  68
!  rean    |  48
!  sally   |  34
!  sam     |  30
!  sandra  |  19
!  sandy   |  38
!  sarah   |  88
!  sharon  |  25
!  sharon  |  78
!  sue     |  50
!  sumi    |  38
!  susan   |  78
!  teresa  |  38
!  trisha  |  88
!  trudy   |  88
!  uma     |  78
!  velma   |  68
!  wendy   |  78
!  zena    |  98
!  zola    |  58
! (58 rows)
! 
! --
! -- awk '{print $1,$2;}' person.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
! -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
! -- awk 'BEGIN{FS="      ";}{if(NF!=1){print $4,$5;}else{print;}}' - stud_emp.data |
! -- sort +1nr -2
! --
! SELECT p.name, p.age FROM person* p ORDER BY age using >, name;
!   name   | age 
! ---------+-----
!  esther  |  98
!  louise  |  98
!  zena    |  98
!  bertha  |  88
!  koko    |  88
!  martie  |  88
!  sarah   |  88
!  trisha  |  88
!  trudy   |  88
!  carmen  |  78
!  chris   |  78
!  sharon  |  78
!  susan   |  78
!  uma     |  78
!  wendy   |  78
!  julie   |  68
!  leah    |  68
!  paula   |  68
!  velma   |  68
!  larry   |  60
!  carina  |  58
!  jane    |  58
!  juanita |  58
!  zola    |  58
!  sue     |  50
!  karen   |  48
!  pamela  |  48
!  rean    |  48
!  mike    |  40
!  belinda |  38
!  jenifer |  38
!  liza    |  38
!  sandy   |  38
!  sumi    |  38
!  teresa  |  38
!  sally   |  34
!  alex    |  30
!  cim     |  30
!  sam     |  30
!  fred    |  28
!  jean    |  28
!  melissa |  28
!  nan     |  28
!  lita    |  25
!  sharon  |  25
!  denise  |  24
!  jeff    |  23
!  bill    |  20
!  joe     |  20
!  linda   |  19
!  sandra  |  19
!  diane   |  18
!  edna    |  18
!  gina    |  18
!  joan    |  18
!  pat     |  18
!  fanny   |   8
!  mary    |   8
! (58 rows)
! 
! --
! -- Test some cases involving whole-row Var referencing a subquery
! --
! select foo from (select 1) as foo;
!  foo 
! -----
!  (1)
! (1 row)
! 
! select foo from (select null) as foo;
!  foo 
! -----
!  ()
! (1 row)
! 
! select foo from (select 'xyzzy',1,null) as foo;
!     foo     
! ------------
!  (xyzzy,1,)
! (1 row)
! 
! --
! -- Test VALUES lists
! --
! select * from onek, (values(147, 'RFAAAA'), (931, 'VJAAAA')) as v (i, j)
!     WHERE onek.unique1 = v.i and onek.stringu1 = v.j 
!     ORDER BY unique1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 |  i  |   j    
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+-----+--------
!      147 |       0 |   1 |    3 |   7 |      7 |       7 |       47 |         147 |       147 |      147 |  14 |   15 | RFAAAA   | AAAAAA   | AAAAxx  | 147 | RFAAAA
!      931 |       1 |   1 |    3 |   1 |     11 |       1 |       31 |         131 |       431 |      931 |   2 |    3 | VJAAAA   | BAAAAA   | HHHHxx  | 931 | VJAAAA
! (2 rows)
! 
! -- a more complex case
! -- looks like we're coding lisp :-)
! select * from onek,
!   (values ((select i from
!     (values(10000), (2), (389), (1000), (2000), ((select 10029))) as foo(i)
!     order by i asc limit 1))) bar (i)
!   where onek.unique1 = bar.i 
!   ORDER BY unique1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | i 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+---
!        2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx  | 2
! (1 row)
! 
! -- try VALUES in a subquery
! select * from onek
!     where (unique1,ten) in (values (1,1), (20,0), (99,9), (17,99))
!     order by unique1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!        1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
!       20 |     306 |   0 |    0 |   0 |      0 |       0 |       20 |          20 |        20 |       20 |   0 |    1 | UAAAAA   | ULAAAA   | OOOOxx
!       99 |     101 |   1 |    3 |   9 |     19 |       9 |       99 |          99 |        99 |       99 |  18 |   19 | VDAAAA   | XDAAAA   | HHHHxx
! (3 rows)
! 
! -- VALUES is also legal as a standalone query or a set-operation member
! VALUES (1,2), (3,4+4), (7,77.7);
!  column1 | column2 
! ---------+---------
!        1 |       2
!        3 |       8
!        7 |    77.7
! (3 rows)
! 
! VALUES (1,2), (3,4+4), (7,77.7)
! UNION ALL
! SELECT 2+2, 57
! UNION ALL
! TABLE int8_tbl 
! ORDER BY column1,column2;
!      column1      |      column2      
! ------------------+-------------------
!                 1 |                 2
!                 3 |                 8
!                 4 |                57
!                 7 |              77.7
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 | -4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
! (9 rows)
! 
! --
! -- Test ORDER BY options
! --
! CREATE TEMP TABLE foo (f1 int);
! INSERT INTO foo VALUES (42),(3),(10),(7),(null),(null),(1);
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 ASC;	-- same thing
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! -- check if indexscans do the right things
! CREATE INDEX fooi ON foo (f1);
! SET enable_sort = false;
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! DROP INDEX fooi;
! CREATE INDEX fooi ON foo (f1 DESC);
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! DROP INDEX fooi;
! CREATE INDEX fooi ON foo (f1 DESC NULLS LAST);
! SELECT * FROM foo ORDER BY f1;
!  f1 
! ----
!   1
!   3
!   7
!  10
!  42
!    
!    
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 NULLS FIRST;
!  f1 
! ----
!    
!    
!   1
!   3
!   7
!  10
!  42
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC;
!  f1 
! ----
!    
!    
!  42
!  10
!   7
!   3
!   1
! (7 rows)
! 
! SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
!  f1 
! ----
!  42
!  10
!   7
!   3
!   1
!    
!    
! (7 rows)
! 
! --
! -- Test planning of some cases with partial indexes
! --
! -- partial index is usable
! explain (costs off)
! select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
!                   QUERY PLAN                   
! -----------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Index Scan using onek2_u2_prtl on onek2
!          Index Cond: (unique2 = 11)
!          Filter: (stringu1 = 'ATAAAA'::name)
! (5 rows)
! 
! select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!      494 |      11 |   0 |    2 |   4 |     14 |       4 |       94 |          94 |       494 |      494 |   8 |    9 | ATAAAA   | LAAAAA   | VVVVxx
! (1 row)
! 
! -- get the plan for the following query
! explain (costs off, timing off, summary off)
! select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
!                   QUERY PLAN                   
! -----------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Index Scan using onek2_u2_prtl on onek2
!          Index Cond: (unique2 = 11)
!          Filter: (stringu1 = 'ATAAAA'::name)
! (5 rows)
! 
! -- actually run the query with an analyze to use the partial index
! explain (costs off, analyze on, timing off, summary off)
! select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Fast Query Execution (actual rows=1 loops=1)
!    Node/s: datanode_1, datanode_2
! (2 rows)
! 
! explain (costs off)
! select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
!                   QUERY PLAN                   
! -----------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Index Scan using onek2_u2_prtl on onek2
!          Index Cond: (unique2 = 11)
!          Filter: (stringu1 = 'ATAAAA'::name)
! (5 rows)
! 
! select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
!  unique2 
! ---------
!       11
! (1 row)
! 
! -- partial index predicate implies clause, so no need for retest
! explain (costs off)
! select * from onek2 where unique2 = 11 and stringu1 < 'B';
!                   QUERY PLAN                   
! -----------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Index Scan using onek2_u2_prtl on onek2
!          Index Cond: (unique2 = 11)
! (4 rows)
! 
! select * from onek2 where unique2 = 11 and stringu1 < 'B';
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!      494 |      11 |   0 |    2 |   4 |     14 |       4 |       94 |          94 |       494 |      494 |   8 |    9 | ATAAAA   | LAAAAA   | VVVVxx
! (1 row)
! 
! explain (costs off)
! select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
!                      QUERY PLAN                     
! ----------------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Index Only Scan using onek2_u2_prtl on onek2
!          Index Cond: (unique2 = 11)
! (4 rows)
! 
! select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
!  unique2 
! ---------
!       11
! (1 row)
! 
! -- but if it's an update target, must retest anyway
! explain (costs off)
! select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  LockRows
!          ->  Index Scan using onek2_u2_prtl on onek2
!                Index Cond: (unique2 = 11)
!                Filter: (stringu1 < 'B'::name)
! (5 rows)
! 
! select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update;
!  unique2 
! ---------
!       11
! (1 row)
! 
! -- partial index is not applicable
! explain (costs off)
! select unique2 from onek2 where unique2 = 11 and stringu1 < 'C';
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Seq Scan on onek2
!          Filter: ((stringu1 < 'C'::name) AND (unique2 = 11))
! (4 rows)
! 
! select unique2 from onek2 where unique2 = 11 and stringu1 < 'C';
!  unique2 
! ---------
!       11
! (1 row)
! 
! -- partial index implies clause, but bitmap scan must recheck predicate anyway
! SET enable_indexscan TO off;
! explain (costs off)
! select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Bitmap Heap Scan on onek2
!          Recheck Cond: ((unique2 = 11) AND (stringu1 < 'B'::name))
!          ->  Bitmap Index Scan on onek2_u2_prtl
!                Index Cond: (unique2 = 11)
! (6 rows)
! 
! select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
!  unique2 
! ---------
!       11
! (1 row)
! 
! RESET enable_indexscan;
! -- check multi-index cases too
! explain (costs off)
! select unique1, unique2 from onek2
!   where (unique2 = 11 or unique1 = 0) and stringu1 < 'B';
!                                       QUERY PLAN                                      
! --------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Bitmap Heap Scan on onek2
!          Recheck Cond: (((unique2 = 11) AND (stringu1 < 'B'::name)) OR (unique1 = 0))
!          Filter: (stringu1 < 'B'::name)
!          ->  BitmapOr
!                ->  Bitmap Index Scan on onek2_u2_prtl
!                      Index Cond: (unique2 = 11)
!                ->  Bitmap Index Scan on onek2_u1_prtl
!                      Index Cond: (unique1 = 0)
! (10 rows)
! 
! select unique1, unique2 from onek2
!   where (unique2 = 11 or unique1 = 0) and stringu1 < 'B';
!  unique1 | unique2 
! ---------+---------
!      494 |      11
!        0 |     998
! (2 rows)
! 
! explain (costs off)
! select unique1, unique2 from onek2
!   where (unique2 = 11 and stringu1 < 'B') or unique1 = 0;
!                                       QUERY PLAN                                      
! --------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Bitmap Heap Scan on onek2
!          Recheck Cond: (((unique2 = 11) AND (stringu1 < 'B'::name)) OR (unique1 = 0))
!          ->  BitmapOr
!                ->  Bitmap Index Scan on onek2_u2_prtl
!                      Index Cond: (unique2 = 11)
!                ->  Bitmap Index Scan on onek2_u1_prtl
!                      Index Cond: (unique1 = 0)
! (9 rows)
! 
! select unique1, unique2 from onek2
!   where (unique2 = 11 and stringu1 < 'B') or unique1 = 0;
!  unique1 | unique2 
! ---------+---------
!      494 |      11
!        0 |     998
! (2 rows)
! 
! --
! -- Test some corner cases that have been known to confuse the planner
! --
! -- ORDER BY on a constant doesn't really need any sorting
! SELECT 1 AS x ORDER BY x;
!  x 
! ---
!  1
! (1 row)
! 
! -- But ORDER BY on a set-valued expression does
! create function sillysrf(int) returns setof int as
!   'values (1),(10),(2),($1)' language sql immutable;
! select sillysrf(42) order by 1;
!  sillysrf 
! ----------
!         1
!         2
!        10
!        42
! (4 rows)
! 
! select sillysrf(-1) order by 1;
!  sillysrf 
! ----------
!        -1
!         1
!         2
!        10
! (4 rows)
! 
! drop function sillysrf(int);
! -- X = X isn't a no-op, it's effectively X IS NOT NULL assuming = is strict
! -- (see bug #5084)
! select * from (values (2),(null),(1)) v(k) where k = k order by k;
!  k 
! ---
!  1
!  2
! (2 rows)
! 
! select * from (values (2),(null),(1)) v(k) where k = k order by k desc;
!  k 
! ---
!  2
!  1
! (2 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/select_into.out"	2025-07-31 16:07:15.000067898 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/select_into.out"	2025-07-31 16:39:29.727074012 +0800
***************
*** 1,141 ****
! --
! -- SELECT_INTO
! --
! SELECT *
!    INTO TABLE tmp1
!    FROM onek
!    WHERE onek.unique1 < 2;
! DROP TABLE tmp1;
! SELECT *
!    INTO TABLE tmp1
!    FROM onek2
!    WHERE onek2.unique1 < 2;
! DROP TABLE tmp1;
! --
! -- SELECT INTO and INSERT permission, if owner is not allowed to insert.
! --
! CREATE SCHEMA selinto_schema;
! CREATE USER regress_selinto_user;
! ALTER DEFAULT PRIVILEGES FOR ROLE regress_selinto_user
! 	  REVOKE INSERT ON TABLES FROM regress_selinto_user;
! GRANT ALL ON SCHEMA selinto_schema TO public;
! SET SESSION AUTHORIZATION regress_selinto_user;
! SELECT * INTO TABLE selinto_schema.tmp1
! 	  FROM pg_class WHERE relname like '%a%' and relpartbound is NULL;	-- Error
! ERROR:  permission denied for relation tmp1
! --SELECT * INTO TABLE selinto_schema.tmp1
! --	  FROM pg_attribute WHERE attname like '%a%';	-- Error
! SELECT oid AS clsoid, relname, relnatts + 10 AS x
! 	  INTO selinto_schema.tmp2
! 	  FROM pg_class WHERE relname like '%b%';	-- Error
! ERROR:  permission denied for relation tmp2
! CREATE TABLE selinto_schema.tmp3 (a,b,c)
! 	   AS SELECT oid,relname,relacl FROM pg_class
! 	   WHERE relname like '%c%';	-- Error
! ERROR:  permission denied for relation tmp3
! RESET SESSION AUTHORIZATION;
! ALTER DEFAULT PRIVILEGES FOR ROLE regress_selinto_user
! 	  GRANT INSERT ON TABLES TO regress_selinto_user;
! SET SESSION AUTHORIZATION regress_selinto_user;
! SELECT * INTO TABLE selinto_schema.tmp1
! 	  FROM pg_class WHERE relname like '%a%' and relpartbound is NULL;	-- OK
! --SELECT * INTO TABLE selinto_schema.tmp1
! --	  FROM pg_attribute WHERE attname like '%a%';	-- OK
! SELECT oid AS clsoid, relname, relnatts + 10 AS x
! 	  INTO selinto_schema.tmp2
! 	  FROM pg_class WHERE relname like '%b%';	-- OK
! CREATE TABLE selinto_schema.tmp3 (a,b,c)
! 	   AS SELECT oid,relname,relacl FROM pg_class
! 	   WHERE relname like '%c%';	-- OK
! RESET SESSION AUTHORIZATION;
! DROP SCHEMA selinto_schema CASCADE;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table selinto_schema.tmp1
! drop cascades to table selinto_schema.tmp2
! drop cascades to table selinto_schema.tmp3
! DROP USER regress_selinto_user;
! -- Tests for WITH NO DATA and column name consistency
! CREATE TABLE ctas_base (i int, j int);
! INSERT INTO ctas_base VALUES (1, 2);
! CREATE TABLE ctas_nodata (ii, jj, kk) AS SELECT i, j FROM ctas_base; -- Error
! ERROR:  CREATE TABLE AS specifies too many column names
! CREATE TABLE ctas_nodata (ii, jj, kk) AS SELECT i, j FROM ctas_base WITH NO DATA; -- Error
! ERROR:  CREATE TABLE AS specifies too many column names
! CREATE TABLE ctas_nodata (ii, jj) AS SELECT i, j FROM ctas_base; -- OK
! CREATE TABLE ctas_nodata_2 (ii, jj) AS SELECT i, j FROM ctas_base WITH NO DATA; -- OK
! CREATE TABLE ctas_nodata_3 (ii) AS SELECT i, j FROM ctas_base; -- OK
! CREATE TABLE ctas_nodata_4 (ii) AS SELECT i, j FROM ctas_base WITH NO DATA; -- OK
! SELECT * FROM ctas_nodata;
!  ii | jj 
! ----+----
!   1 |  2
! (1 row)
! 
! SELECT * FROM ctas_nodata_2;
!  ii | jj 
! ----+----
! (0 rows)
! 
! SELECT * FROM ctas_nodata_3;
!  ii | j 
! ----+---
!   1 | 2
! (1 row)
! 
! SELECT * FROM ctas_nodata_4;
!  ii | j 
! ----+---
! (0 rows)
! 
! DROP TABLE ctas_base;
! DROP TABLE ctas_nodata;
! DROP TABLE ctas_nodata_2;
! DROP TABLE ctas_nodata_3;
! DROP TABLE ctas_nodata_4;
! --
! -- CREATE TABLE AS/SELECT INTO as last command in a SQL function
! -- have been known to cause problems
! --
! CREATE FUNCTION make_table() RETURNS VOID
! AS $$
!   CREATE TABLE created_table AS SELECT * FROM int8_tbl;
! $$ LANGUAGE SQL;
! ERROR:  In XC, SQL functions cannot contain utility statements
! CONTEXT:  SQL function "make_table"
! SELECT make_table();
! ERROR:  function make_table() does not exist
! LINE 1: SELECT make_table();
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! SELECT * FROM created_table;
! ERROR:  relation "created_table" does not exist
! LINE 1: SELECT * FROM created_table;
!                       ^
! -- Try EXPLAIN ANALYZE SELECT INTO, but hide the output since it won't
! -- be stable.
! DO $$
! BEGIN
! 	EXECUTE 'EXPLAIN ANALYZE SELECT * INTO TABLE easi FROM int8_tbl';
! END$$;
! DROP TABLE created_table;
! ERROR:  table "created_table" does not exist
! DROP TABLE easi;
! --
! -- Disallowed uses of SELECT ... INTO.  All should fail
! --
! DECLARE foo CURSOR FOR SELECT 1 INTO b;
! ERROR:  SELECT ... INTO is not allowed here
! LINE 1: DECLARE foo CURSOR FOR SELECT 1 INTO b;
!                                              ^
! COPY (SELECT 1 INTO frak UNION SELECT 2) TO 'blob';
! ERROR:  COPY (SELECT INTO) is not supported
! SELECT * FROM (SELECT 1 INTO f) bar;
! ERROR:  SELECT ... INTO is not allowed here
! LINE 1: SELECT * FROM (SELECT 1 INTO f) bar;
!                                      ^
! CREATE VIEW foo AS SELECT 1 INTO b;
! ERROR:  views must not contain SELECT INTO
! INSERT INTO b SELECT 1 INTO f;
! ERROR:  SELECT ... INTO is not allowed here
! LINE 1: INSERT INTO b SELECT 1 INTO f;
!                                     ^
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/select_distinct.out"	2025-07-31 16:07:15.000067898 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/select_distinct.out"	2025-07-31 16:39:29.733073884 +0800
***************
*** 1,248 ****
! --
! -- SELECT_DISTINCT
! --
! --
! -- awk '{print $3;}' onek.data | sort -n | uniq
! --
! SELECT DISTINCT two FROM tmp ORDER BY 1;
!  two 
! -----
!    0
!    1
! (2 rows)
! 
! --
! -- awk '{print $5;}' onek.data | sort -n | uniq
! --
! SELECT DISTINCT ten FROM tmp ORDER BY 1;
!  ten 
! -----
!    0
!    1
!    2
!    3
!    4
!    5
!    6
!    7
!    8
!    9
! (10 rows)
! 
! --
! -- awk '{print $16;}' onek.data | sort -d | uniq
! --
! SELECT DISTINCT string4 FROM tmp ORDER BY 1;
!  string4 
! ---------
!  AAAAxx
!  HHHHxx
!  OOOOxx
!  VVVVxx
! (4 rows)
! 
! --
! -- awk '{print $3,$16,$5;}' onek.data | sort -d | uniq |
! -- sort +0n -1 +1d -2 +2n -3
! --
! SELECT DISTINCT two, string4, ten
!    FROM tmp
!    ORDER BY two using <, string4 using <, ten using <;
!  two | string4 | ten 
! -----+---------+-----
!    0 | AAAAxx  |   0
!    0 | AAAAxx  |   2
!    0 | AAAAxx  |   4
!    0 | AAAAxx  |   6
!    0 | AAAAxx  |   8
!    0 | HHHHxx  |   0
!    0 | HHHHxx  |   2
!    0 | HHHHxx  |   4
!    0 | HHHHxx  |   6
!    0 | HHHHxx  |   8
!    0 | OOOOxx  |   0
!    0 | OOOOxx  |   2
!    0 | OOOOxx  |   4
!    0 | OOOOxx  |   6
!    0 | OOOOxx  |   8
!    0 | VVVVxx  |   0
!    0 | VVVVxx  |   2
!    0 | VVVVxx  |   4
!    0 | VVVVxx  |   6
!    0 | VVVVxx  |   8
!    1 | AAAAxx  |   1
!    1 | AAAAxx  |   3
!    1 | AAAAxx  |   5
!    1 | AAAAxx  |   7
!    1 | AAAAxx  |   9
!    1 | HHHHxx  |   1
!    1 | HHHHxx  |   3
!    1 | HHHHxx  |   5
!    1 | HHHHxx  |   7
!    1 | HHHHxx  |   9
!    1 | OOOOxx  |   1
!    1 | OOOOxx  |   3
!    1 | OOOOxx  |   5
!    1 | OOOOxx  |   7
!    1 | OOOOxx  |   9
!    1 | VVVVxx  |   1
!    1 | VVVVxx  |   3
!    1 | VVVVxx  |   5
!    1 | VVVVxx  |   7
!    1 | VVVVxx  |   9
! (40 rows)
! 
! --
! -- awk '{print $2;}' person.data |
! -- awk '{if(NF!=1){print $2;}else{print;}}' - emp.data |
! -- awk '{if(NF!=1){print $2;}else{print;}}' - student.data |
! -- awk 'BEGIN{FS="      ";}{if(NF!=1){print $5;}else{print;}}' - stud_emp.data |
! -- sort -n -r | uniq
! --
! SELECT DISTINCT p.age FROM person* p ORDER BY age using >;
!  age 
! -----
!   98
!   88
!   78
!   68
!   60
!   58
!   50
!   48
!   40
!   38
!   34
!   30
!   28
!   25
!   24
!   23
!   20
!   19
!   18
!    8
! (20 rows)
! 
! --
! -- Check mentioning same column more than once
! --
! EXPLAIN (VERBOSE, COSTS OFF)
! SELECT count(*) FROM
!   (SELECT DISTINCT two, four, two FROM tenk1) ss;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Aggregate
!    Output: count(*)
!    ->  HashAggregate
!          Output: tenk1.two, tenk1.four, tenk1.two
!          Group Key: tenk1.two, tenk1.four, tenk1.two
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Output: tenk1.two, tenk1.four, tenk1.two
!                ->  Seq Scan on public.tenk1
!                      Output: tenk1.two, tenk1.four, tenk1.two
! (9 rows)
! 
! SELECT count(*) FROM
!   (SELECT DISTINCT two, four, two FROM tenk1) ss;
!  count 
! -------
!      4
! (1 row)
! 
! --
! -- Also, some tests of IS DISTINCT FROM, which doesn't quite deserve its
! -- very own regression file.
! --
! CREATE TEMP TABLE disttable (f1 integer);
! INSERT INTO DISTTABLE VALUES(1);
! INSERT INTO DISTTABLE VALUES(2);
! INSERT INTO DISTTABLE VALUES(3);
! INSERT INTO DISTTABLE VALUES(NULL);
! -- basic cases
! SELECT f1, f1 IS DISTINCT FROM 2 as "not 2" FROM disttable ORDER BY f1;
!  f1 | not 2 
! ----+-------
!   1 | t
!   2 | f
!   3 | t
!     | t
! (4 rows)
! 
! SELECT f1, f1 IS DISTINCT FROM NULL as "not null" FROM disttable ORDER BY f1;
!  f1 | not null 
! ----+----------
!   1 | t
!   2 | t
!   3 | t
!     | f
! (4 rows)
! 
! SELECT f1, f1 IS DISTINCT FROM f1 as "false" FROM disttable ORDER BY f1;
!  f1 | false 
! ----+-------
!   1 | f
!   2 | f
!   3 | f
!     | f
! (4 rows)
! 
! SELECT f1, f1 IS DISTINCT FROM f1+1 as "not null" FROM disttable ORDER BY f1;
!  f1 | not null 
! ----+----------
!   1 | t
!   2 | t
!   3 | t
!     | f
! (4 rows)
! 
! -- check that optimizer constant-folds it properly
! SELECT 1 IS DISTINCT FROM 2 as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
! SELECT 2 IS DISTINCT FROM 2 as "no";
!  no 
! ----
!  f
! (1 row)
! 
! SELECT 2 IS DISTINCT FROM null as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
! SELECT null IS DISTINCT FROM null as "no";
!  no 
! ----
!  f
! (1 row)
! 
! -- negated form
! SELECT 1 IS NOT DISTINCT FROM 2 as "no";
!  no 
! ----
!  f
! (1 row)
! 
! SELECT 2 IS NOT DISTINCT FROM 2 as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
! SELECT 2 IS NOT DISTINCT FROM null as "no";
!  no 
! ----
!  f
! (1 row)
! 
! SELECT null IS NOT DISTINCT FROM null as "yes";
!  yes 
! -----
!  t
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/select_distinct_on.out"	2025-07-31 16:07:15.000067898 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/select_distinct_on.out"	2025-07-31 16:39:29.740073735 +0800
***************
*** 1,75 ****
! --
! -- SELECT_DISTINCT_ON
! --
! SELECT DISTINCT ON (string4) string4, two, ten
!    FROM tmp
!    ORDER BY string4 using <, two using >, ten using <;
!  string4 | two | ten 
! ---------+-----+-----
!  AAAAxx  |   1 |   1
!  HHHHxx  |   1 |   1
!  OOOOxx  |   1 |   1
!  VVVVxx  |   1 |   1
! (4 rows)
! 
! -- this will fail due to conflict of ordering requirements
! SELECT DISTINCT ON (string4, ten) string4, two, ten
!    FROM tmp
!    ORDER BY string4 using <, two using <, ten using <;
! ERROR:  SELECT DISTINCT ON expressions must match initial ORDER BY expressions
! LINE 1: SELECT DISTINCT ON (string4, ten) string4, two, ten
!                                      ^
! SELECT DISTINCT ON (string4, ten) string4, ten, two
!    FROM tmp
!    ORDER BY string4 using <, ten using >, two using <;
!  string4 | ten | two 
! ---------+-----+-----
!  AAAAxx  |   9 |   1
!  AAAAxx  |   8 |   0
!  AAAAxx  |   7 |   1
!  AAAAxx  |   6 |   0
!  AAAAxx  |   5 |   1
!  AAAAxx  |   4 |   0
!  AAAAxx  |   3 |   1
!  AAAAxx  |   2 |   0
!  AAAAxx  |   1 |   1
!  AAAAxx  |   0 |   0
!  HHHHxx  |   9 |   1
!  HHHHxx  |   8 |   0
!  HHHHxx  |   7 |   1
!  HHHHxx  |   6 |   0
!  HHHHxx  |   5 |   1
!  HHHHxx  |   4 |   0
!  HHHHxx  |   3 |   1
!  HHHHxx  |   2 |   0
!  HHHHxx  |   1 |   1
!  HHHHxx  |   0 |   0
!  OOOOxx  |   9 |   1
!  OOOOxx  |   8 |   0
!  OOOOxx  |   7 |   1
!  OOOOxx  |   6 |   0
!  OOOOxx  |   5 |   1
!  OOOOxx  |   4 |   0
!  OOOOxx  |   3 |   1
!  OOOOxx  |   2 |   0
!  OOOOxx  |   1 |   1
!  OOOOxx  |   0 |   0
!  VVVVxx  |   9 |   1
!  VVVVxx  |   8 |   0
!  VVVVxx  |   7 |   1
!  VVVVxx  |   6 |   0
!  VVVVxx  |   5 |   1
!  VVVVxx  |   4 |   0
!  VVVVxx  |   3 |   1
!  VVVVxx  |   2 |   0
!  VVVVxx  |   1 |   1
!  VVVVxx  |   0 |   0
! (40 rows)
! 
! -- bug #5049: early 8.4.x chokes on volatile DISTINCT ON clauses
! select distinct on (1) floor(random()) as r, f1 from int4_tbl order by 1,2;
!  r |     f1      
! ---+-------------
!  0 | -2147483647
! (1 row)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/select_implicit.out"	2025-07-31 16:07:15.000067898 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/select_implicit.out"	2025-07-31 16:39:29.771073073 +0800
***************
*** 1,336 ****
! --
! -- SELECT_IMPLICIT
! -- Test cases for queries with ordering terms missing from the target list.
! -- This used to be called "junkfilter.sql".
! -- The parser uses the term "resjunk" to handle these cases.
! -- - thomas 1998-07-09
! --
! -- load test data
! CREATE TABLE test_missing_target (a int, b int, c char(8), d char);
! INSERT INTO test_missing_target VALUES (0, 1, 'XXXX', 'A');
! INSERT INTO test_missing_target VALUES (1, 2, 'ABAB', 'b');
! INSERT INTO test_missing_target VALUES (2, 2, 'ABAB', 'c');
! INSERT INTO test_missing_target VALUES (3, 3, 'BBBB', 'D');
! INSERT INTO test_missing_target VALUES (4, 3, 'BBBB', 'e');
! INSERT INTO test_missing_target VALUES (5, 3, 'bbbb', 'F');
! INSERT INTO test_missing_target VALUES (6, 4, 'cccc', 'g');
! INSERT INTO test_missing_target VALUES (7, 4, 'cccc', 'h');
! INSERT INTO test_missing_target VALUES (8, 4, 'CCCC', 'I');
! INSERT INTO test_missing_target VALUES (9, 4, 'CCCC', 'j');
! --   w/ existing GROUP BY target
! SELECT c, count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
!     c     | count 
! ----------+-------
!  ABAB     |     2
!  BBBB     |     2
!  CCCC     |     2
!  XXXX     |     1
!  bbbb     |     1
!  cccc     |     2
! (6 rows)
! 
! --   w/o existing GROUP BY target using a relation name in GROUP BY clause
! SELECT count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
!  count 
! -------
!      2
!      2
!      2
!      1
!      1
!      2
! (6 rows)
! 
! --   w/o existing GROUP BY target and w/o existing a different ORDER BY target
! --   failure expected
! SELECT count(*) FROM test_missing_target GROUP BY a ORDER BY b;
! ERROR:  column "test_missing_target.b" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: ...ECT count(*) FROM test_missing_target GROUP BY a ORDER BY b;
!                                                                      ^
! --   w/o existing GROUP BY target and w/o existing same ORDER BY target
! SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b;
!  count 
! -------
!      1
!      2
!      3
!      4
! (4 rows)
! 
! --   w/ existing GROUP BY target using a relation name in target
! SELECT test_missing_target.b, count(*)
!   FROM test_missing_target GROUP BY b ORDER BY b;
!  b | count 
! ---+-------
!  1 |     1
!  2 |     2
!  3 |     3
!  4 |     4
! (4 rows)
! 
! --   w/o existing GROUP BY target
! SELECT c FROM test_missing_target ORDER BY a;
!     c     
! ----------
!  XXXX    
!  ABAB    
!  ABAB    
!  BBBB    
!  BBBB    
!  bbbb    
!  cccc    
!  cccc    
!  CCCC    
!  CCCC    
! (10 rows)
! 
! --   w/o existing ORDER BY target
! SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b desc;
!  count 
! -------
!      4
!      3
!      2
!      1
! (4 rows)
! 
! --   group using reference number
! SELECT count(*) FROM test_missing_target ORDER BY 1 desc;
!  count 
! -------
!     10
! (1 row)
! 
! --   order using reference number
! SELECT c, count(*) FROM test_missing_target GROUP BY 1 ORDER BY 1;
!     c     | count 
! ----------+-------
!  ABAB     |     2
!  BBBB     |     2
!  CCCC     |     2
!  XXXX     |     1
!  bbbb     |     1
!  cccc     |     2
! (6 rows)
! 
! --   group using reference number out of range
! --   failure expected
! SELECT c, count(*) FROM test_missing_target GROUP BY 3;
! ERROR:  GROUP BY position 3 is not in select list
! LINE 1: SELECT c, count(*) FROM test_missing_target GROUP BY 3;
!                                                              ^
! --   group w/o existing GROUP BY and ORDER BY target under ambiguous condition
! --   failure expected
! SELECT count(*) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY b ORDER BY b;
! ERROR:  column reference "b" is ambiguous
! LINE 3:  GROUP BY b ORDER BY b;
!                              ^
! --   order w/ target under ambiguous condition
! --   failure NOT expected
! SELECT a, a FROM test_missing_target
! 	ORDER BY a;
!  a | a 
! ---+---
!  0 | 0
!  1 | 1
!  2 | 2
!  3 | 3
!  4 | 4
!  5 | 5
!  6 | 6
!  7 | 7
!  8 | 8
!  9 | 9
! (10 rows)
! 
! --   order expression w/ target under ambiguous condition
! --   failure NOT expected
! SELECT a/2, a/2 FROM test_missing_target
! 	ORDER BY a/2;
!  ?column? | ?column? 
! ----------+----------
!         0 |        0
!         0 |        0
!         1 |        1
!         1 |        1
!         2 |        2
!         2 |        2
!         3 |        3
!         3 |        3
!         4 |        4
!         4 |        4
! (10 rows)
! 
! --   group expression w/ target under ambiguous condition
! --   failure NOT expected
! SELECT a/2, a/2 FROM test_missing_target
! 	GROUP BY a/2 ORDER BY a/2;
!  ?column? | ?column? 
! ----------+----------
!         0 |        0
!         1 |        1
!         2 |        2
!         3 |        3
!         4 |        4
! (5 rows)
! 
! --   group w/ existing GROUP BY target under ambiguous condition
! SELECT x.b, count(*) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b ORDER BY x.b;
!  b | count 
! ---+-------
!  1 |     1
!  2 |     2
!  3 |     3
!  4 |     4
! (4 rows)
! 
! --   group w/o existing GROUP BY target under ambiguous condition
! SELECT count(*) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b ORDER BY x.b;
!  count 
! -------
!      1
!      2
!      3
!      4
! (4 rows)
! 
! --   group w/o existing GROUP BY target under ambiguous condition
! --   into a table
! SELECT count(*) INTO TABLE test_missing_target2
! FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b ORDER BY x.b;
! SELECT * FROM test_missing_target2 ORDER BY 1;
!  count 
! -------
!      1
!      2
!      3
!      4
! (4 rows)
! 
! --  Functions and expressions
! --   w/ existing GROUP BY target
! SELECT a%2, count(b) FROM test_missing_target
! GROUP BY test_missing_target.a%2
! ORDER BY test_missing_target.a%2;
!  ?column? | count 
! ----------+-------
!         0 |     5
!         1 |     5
! (2 rows)
! 
! --   w/o existing GROUP BY target using a relation name in GROUP BY clause
! SELECT count(c) FROM test_missing_target
! GROUP BY lower(test_missing_target.c)
! ORDER BY lower(test_missing_target.c);
!  count 
! -------
!      2
!      3
!      4
!      1
! (4 rows)
! 
! --   w/o existing GROUP BY target and w/o existing a different ORDER BY target
! --   failure expected
! SELECT count(a) FROM test_missing_target GROUP BY a ORDER BY b;
! ERROR:  column "test_missing_target.b" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: ...ECT count(a) FROM test_missing_target GROUP BY a ORDER BY b;
!                                                                      ^
! --   w/o existing GROUP BY target and w/o existing same ORDER BY target
! SELECT count(b) FROM test_missing_target GROUP BY b/2 ORDER BY b/2;
!  count 
! -------
!      1
!      5
!      4
! (3 rows)
! 
! --   w/ existing GROUP BY target using a relation name in target
! SELECT lower(test_missing_target.c), count(c)
!   FROM test_missing_target GROUP BY lower(c) ORDER BY lower(c);
!  lower | count 
! -------+-------
!  abab  |     2
!  bbbb  |     3
!  cccc  |     4
!  xxxx  |     1
! (4 rows)
! 
! --   w/o existing GROUP BY target
! SELECT a FROM test_missing_target ORDER BY upper(d);
!  a 
! ---
!  0
!  1
!  2
!  3
!  4
!  5
!  6
!  7
!  8
!  9
! (10 rows)
! 
! --   w/o existing ORDER BY target
! SELECT count(b) FROM test_missing_target
! 	GROUP BY (b + 1) / 2 ORDER BY (b + 1) / 2 desc;
!  count 
! -------
!      7
!      3
! (2 rows)
! 
! --   group w/o existing GROUP BY and ORDER BY target under ambiguous condition
! --   failure expected
! SELECT count(x.a) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY b/2 ORDER BY b/2;
! ERROR:  column reference "b" is ambiguous
! LINE 3:  GROUP BY b/2 ORDER BY b/2;
!                                ^
! --   group w/ existing GROUP BY target under ambiguous condition
! SELECT x.b/2, count(x.b) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b/2 ORDER BY x.b/2;
!  ?column? | count 
! ----------+-------
!         0 |     1
!         1 |     5
!         2 |     4
! (3 rows)
! 
! --   group w/o existing GROUP BY target under ambiguous condition
! --   failure expected due to ambiguous b in count(b)
! SELECT count(b) FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b/2;
! ERROR:  column reference "b" is ambiguous
! LINE 1: SELECT count(b) FROM test_missing_target x, test_missing_tar...
!                      ^
! --   group w/o existing GROUP BY target under ambiguous condition
! --   into a table
! SELECT count(x.b) INTO TABLE test_missing_target3
! FROM test_missing_target x, test_missing_target y
! 	WHERE x.a = y.a
! 	GROUP BY x.b/2 ORDER BY x.b/2;
! SELECT * FROM test_missing_target3 ORDER BY 1;
!  count 
! -------
!      1
!      4
!      5
! (3 rows)
! 
! --   Cleanup
! DROP TABLE test_missing_target;
! DROP TABLE test_missing_target2;
! DROP TABLE test_missing_target3;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/select_having.out"	2025-07-31 16:07:15.000067898 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/select_having.out"	2025-07-31 16:39:29.784341567 +0800
***************
*** 1,93 ****
! --
! -- SELECT_HAVING
! --
! -- load test data
! CREATE TABLE test_having (a int, b int, c char(8), d char);
! INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');
! INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');
! INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');
! INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');
! INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');
! INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');
! INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');
! INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');
! INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');
! INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');
! SELECT b, c FROM test_having
! 	GROUP BY b, c HAVING count(*) = 1 ORDER BY b, c;
!  b |    c     
! ---+----------
!  1 | XXXX    
!  3 | bbbb    
! (2 rows)
! 
! -- HAVING is effectively equivalent to WHERE in this case
! SELECT b, c FROM test_having
! 	GROUP BY b, c HAVING b = 3 ORDER BY b, c;
!  b |    c     
! ---+----------
!  3 | BBBB    
!  3 | bbbb    
! (2 rows)
! 
! SELECT lower(c), count(c) FROM test_having
! 	GROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)
! 	ORDER BY lower(c);
!  lower | count 
! -------+-------
!  bbbb  |     3
!  cccc  |     4
!  xxxx  |     1
! (3 rows)
! 
! SELECT c, max(a) FROM test_having
! 	GROUP BY c HAVING count(*) > 2 OR min(a) = max(a)
! 	ORDER BY c;
!     c     | max 
! ----------+-----
!  XXXX     |   0
!  bbbb     |   5
! (2 rows)
! 
! -- test degenerate cases involving HAVING without GROUP BY
! -- Per SQL spec, these should generate 0 or 1 row, even without aggregates
! SELECT min(a), max(a) FROM test_having HAVING min(a) = max(a);
!  min | max 
! -----+-----
! (0 rows)
! 
! SELECT min(a), max(a) FROM test_having HAVING min(a) < max(a);
!  min | max 
! -----+-----
!    0 |   9
! (1 row)
! 
! -- errors: ungrouped column references
! SELECT a FROM test_having HAVING min(a) < max(a);
! ERROR:  column "test_having.a" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT a FROM test_having HAVING min(a) < max(a);
!                ^
! SELECT 1 AS one FROM test_having HAVING a > 1;
! ERROR:  column "test_having.a" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: SELECT 1 AS one FROM test_having HAVING a > 1;
!                                                 ^
! -- the really degenerate case: need not scan table at all
! SELECT 1 AS one FROM test_having HAVING 1 > 2;
!  one 
! -----
! (0 rows)
! 
! SELECT 1 AS one FROM test_having HAVING 1 < 2;
!  one 
! -----
!    1
! (1 row)
! 
! -- and just to prove that we aren't scanning the table:
! SELECT 1 AS one FROM test_having WHERE 1/a = 1 HAVING 1 < 2;
!  one 
! -----
!    1
! (1 row)
! 
! DROP TABLE test_having;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/subselect_2.out"	2025-07-31 16:07:15.003067850 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/subselect.out"	2025-07-31 16:39:29.791072647 +0800
***************
*** 1,1164 ****
! --
! -- SUBSELECT
! --
! SELECT 1 AS one WHERE 1 IN (SELECT 1);
!  one 
! -----
!    1
! (1 row)
! 
! SELECT 1 AS zero WHERE 1 NOT IN (SELECT 1);
!  zero 
! ------
! (0 rows)
! 
! SELECT 1 AS zero WHERE 1 IN (SELECT 2);
!  zero 
! ------
! (0 rows)
! 
! -- Check grammar's handling of extra parens in assorted contexts
! SELECT * FROM (SELECT 1 AS x) ss;
!  x 
! ---
!  1
! (1 row)
! 
! SELECT * FROM ((SELECT 1 AS x)) ss;
!  x 
! ---
!  1
! (1 row)
! 
! (SELECT 2) UNION SELECT 2;
!  ?column? 
! ----------
!         2
! (1 row)
! 
! ((SELECT 2)) UNION SELECT 2;
!  ?column? 
! ----------
!         2
! (1 row)
! 
! SELECT ((SELECT 2) UNION SELECT 2);
!  ?column? 
! ----------
!         2
! (1 row)
! 
! SELECT (((SELECT 2)) UNION SELECT 2);
!  ?column? 
! ----------
!         2
! (1 row)
! 
! SELECT (SELECT ARRAY[1,2,3])[1];
!  array 
! -------
!      1
! (1 row)
! 
! SELECT ((SELECT ARRAY[1,2,3]))[2];
!  array 
! -------
!      2
! (1 row)
! 
! SELECT (((SELECT ARRAY[1,2,3])))[3];
!  array 
! -------
!      3
! (1 row)
! 
! -- Set up some simple test tables
! CREATE TABLE SUBSELECT_TBL (
!   f1 integer,
!   f2 integer,
!   f3 float
! );
! INSERT INTO SUBSELECT_TBL VALUES (1, 2, 3);
! INSERT INTO SUBSELECT_TBL VALUES (2, 3, 4);
! INSERT INTO SUBSELECT_TBL VALUES (3, 4, 5);
! INSERT INTO SUBSELECT_TBL VALUES (1, 1, 1);
! INSERT INTO SUBSELECT_TBL VALUES (2, 2, 2);
! INSERT INTO SUBSELECT_TBL VALUES (3, 3, 3);
! INSERT INTO SUBSELECT_TBL VALUES (6, 7, 8);
! INSERT INTO SUBSELECT_TBL VALUES (8, 9, NULL);
! SELECT '' AS eight, * FROM SUBSELECT_TBL ORDER BY f1, f2, f3;
!  eight | f1 | f2 | f3 
! -------+----+----+----
!        |  1 |  1 |  1
!        |  1 |  2 |  3
!        |  2 |  2 |  2
!        |  2 |  3 |  4
!        |  3 |  3 |  3
!        |  3 |  4 |  5
!        |  6 |  7 |  8
!        |  8 |  9 |   
! (8 rows)
! 
! -- Uncorrelated subselects
! SELECT '' AS two, f1 AS "Constant Select" FROM SUBSELECT_TBL
!   WHERE f1 IN (SELECT 1) ORDER BY 2;
!  two | Constant Select 
! -----+-----------------
!      |               1
!      |               1
! (2 rows)
! 
! SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
!   WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL) 
!   ORDER BY 2;
!  six | Uncorrelated Field 
! -----+--------------------
!      |                  1
!      |                  1
!      |                  2
!      |                  2
!      |                  3
!      |                  3
! (6 rows)
! 
! SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
!   WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE
!     f2 IN (SELECT f1 FROM SUBSELECT_TBL)) 
!     ORDER BY 2;
!  six | Uncorrelated Field 
! -----+--------------------
!      |                  1
!      |                  1
!      |                  2
!      |                  2
!      |                  3
!      |                  3
! (6 rows)
! 
! SELECT '' AS three, f1, f2
!   FROM SUBSELECT_TBL
!   WHERE (f1, f2) NOT IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
!                          WHERE f3 IS NOT NULL) 
!                          ORDER BY f1, f2;
!  three | f1 | f2 
! -------+----+----
!        |  1 |  2
!        |  6 |  7
!        |  8 |  9
! (3 rows)
! 
! -- Correlated subselects
! SELECT '' AS six, f1 AS "Correlated Field", f2 AS "Second Field"
!   FROM SUBSELECT_TBL upper
!   WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE f1 = upper.f1) 
!   ORDER BY f1, f2;
!  six | Correlated Field | Second Field 
! -----+------------------+--------------
!      |                1 |            1
!      |                1 |            2
!      |                2 |            2
!      |                2 |            3
!      |                3 |            3
!      |                3 |            4
! (6 rows)
! 
! SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
!   FROM SUBSELECT_TBL upper
!   WHERE f1 IN
!     (SELECT f2 FROM SUBSELECT_TBL WHERE CAST(upper.f2 AS float) = f3)
!     ORDER BY 2, 3;
!  six | Correlated Field | Second Field 
! -----+------------------+--------------
!      |                1 |            1
!      |                2 |            2
!      |                2 |            4
!      |                3 |            3
!      |                3 |            5
! (5 rows)
! 
! SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
!   FROM SUBSELECT_TBL upper
!   WHERE f3 IN (SELECT upper.f1 + f2 FROM SUBSELECT_TBL
!                WHERE f2 = CAST(f3 AS integer)) 
!                ORDER BY 2, 3;
!  six | Correlated Field | Second Field 
! -----+------------------+--------------
!      |                1 |            3
!      |                2 |            4
!      |                3 |            5
!      |                6 |            8
! (4 rows)
! 
! SELECT '' AS five, f1 AS "Correlated Field"
!   FROM SUBSELECT_TBL
!   WHERE (f1, f2) IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
!                      WHERE f3 IS NOT NULL) 
!                      ORDER BY 2;
!  five | Correlated Field 
! ------+------------------
!       |                1
!       |                2
!       |                2
!       |                3
!       |                3
! (5 rows)
! 
! --
! -- Use some existing tables in the regression test
! --
! SELECT '' AS eight, ss.f1 AS "Correlated Field", ss.f3 AS "Second Field"
!   FROM SUBSELECT_TBL ss
!   WHERE f1 NOT IN (SELECT f1+1 FROM INT4_TBL
!                    WHERE f1 != ss.f1 AND f1 < 2147483647) 
!                    ORDER BY 2, 3;
!  eight | Correlated Field | Second Field 
! -------+------------------+--------------
!        |                2 |            2
!        |                2 |            4
!        |                3 |            3
!        |                3 |            5
!        |                6 |            8
!        |                8 |             
! (6 rows)
! 
! select q1, float8(count(*)) / (select count(*) from int8_tbl)
! from int8_tbl group by q1 order by q1;
!         q1        | ?column? 
! ------------------+----------
!               123 |      0.4
!  4567890123456789 |      0.6
! (2 rows)
! 
! -- Unspecified-type literals in output columns should resolve as text
! SELECT *, pg_typeof(f1) FROM
!   (SELECT 'foo' AS f1 FROM generate_series(1,3)) ss ORDER BY 1;
!  f1  | pg_typeof 
! -----+-----------
!  foo | text
!  foo | text
!  foo | text
! (3 rows)
! 
! -- ... unless there's context to suggest differently
! explain verbose select '42' union all select '43';
!                    QUERY PLAN                    
! -------------------------------------------------
!  Append  (cost=0.00..0.04 rows=2 width=32)
!    ->  Result  (cost=0.00..0.01 rows=1 width=32)
!          Output: '42'::text
!    ->  Result  (cost=0.00..0.01 rows=1 width=32)
!          Output: '43'::text
! (5 rows)
! 
! explain verbose select '42' union all select 43;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Append  (cost=0.00..0.04 rows=2 width=4)
!    ->  Result  (cost=0.00..0.01 rows=1 width=4)
!          Output: 42
!    ->  Result  (cost=0.00..0.01 rows=1 width=4)
!          Output: 43
! (5 rows)
! 
! -- check materialization of an initplan reference (bug #14524)
! explain (verbose, costs off)
! select 1 = all (select (select 1));
!             QUERY PLAN             
! -----------------------------------
!  Result
!    Output: (SubPlan 2)
!    SubPlan 2
!      ->  Materialize
!            Output: ($0)
!            InitPlan 1 (returns $0)
!              ->  Result
!                    Output: 1
!            ->  Result
!                  Output: $0
! (10 rows)
! 
! select 1 = all (select (select 1));
!  ?column? 
! ----------
!  t
! (1 row)
! 
! --
! -- Check EXISTS simplification with LIMIT
! --
! explain (costs off)
! select * from int4_tbl o where exists
!   (select 1 from int4_tbl i where i.f1=o.f1 limit null);
!                 QUERY PLAN                
! ------------------------------------------
!  Remote Subquery Scan on all (datanode_1)
!    ->  Hash Semi Join
!          Hash Cond: (o.f1 = i.f1)
!          ->  Seq Scan on int4_tbl o
!          ->  Hash
!                ->  Seq Scan on int4_tbl i
! (6 rows)
! 
! explain (costs off, nodes off)
! select * from int4_tbl o where not exists
!   (select 1 from int4_tbl i where i.f1=o.f1 limit 1);
!                 QUERY PLAN                
! ------------------------------------------
!  Remote Subquery Scan on all
!    ->  Hash Anti Join
!          Hash Cond: (o.f1 = i.f1)
!          ->  Seq Scan on int4_tbl o
!          ->  Hash
!                ->  Seq Scan on int4_tbl i
! (6 rows)
! 
! explain (costs off, nodes off)
! select * from int4_tbl o where exists
!   (select 1 from int4_tbl i where i.f1=o.f1 limit 0);
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Seq Scan on int4_tbl o
!          Filter: (SubPlan 1)
!          SubPlan 1
!            ->  Limit
!                  ->  Remote Subquery Scan on all
!                        ->  Limit
!                              ->  Seq Scan on int4_tbl i
!                                    Filter: (f1 = o.f1)
! (9 rows)
! 
! --
! -- Test cases to catch unpleasant interactions between IN-join processing
! -- and subquery pullup.
! --
! select count(*) from
!   (select 1 from tenk1 a
!    where unique1 IN (select hundred from tenk1 b)) ss;
!  count 
! -------
!    100
! (1 row)
! 
! select count(distinct ss.ten) from
!   (select ten from tenk1 a
!    where unique1 IN (select hundred from tenk1 b)) ss;
!  count 
! -------
!     10
! (1 row)
! 
! select count(*) from
!   (select 1 from tenk1 a
!    where unique1 IN (select distinct hundred from tenk1 b)) ss;
!  count 
! -------
!    100
! (1 row)
! 
! select count(distinct ss.ten) from
!   (select ten from tenk1 a
!    where unique1 IN (select distinct hundred from tenk1 b)) ss;
!  count 
! -------
!     10
! (1 row)
! 
! --
! -- Test cases to check for overenthusiastic optimization of
! -- "IN (SELECT DISTINCT ...)" and related cases.  Per example from
! -- Luca Pireddu and Michael Fuhr.
! --
! CREATE TEMP TABLE foo (id integer);
! CREATE TEMP TABLE bar (id1 integer, id2 integer);
! INSERT INTO foo VALUES (1);
! INSERT INTO bar VALUES (1, 1);
! INSERT INTO bar VALUES (2, 2);
! INSERT INTO bar VALUES (3, 1);
! -- These cases require an extra level of distinct-ing above subquery s
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT DISTINCT id1, id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id1,id2 FROM bar GROUP BY id1,id2) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id1, id2 FROM bar UNION
!                       SELECT id1, id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! -- These cases do not
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT DISTINCT ON (id2) id1, id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id2 FROM bar GROUP BY id2) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! SELECT * FROM foo WHERE id IN
!     (SELECT id2 FROM (SELECT id2 FROM bar UNION
!                       SELECT id2 FROM bar) AS s);
!  id 
! ----
!   1
! (1 row)
! 
! --
! -- Test case to catch problems with multiply nested sub-SELECTs not getting
! -- recalculated properly.  Per bug report from Didier Moens.
! --
! CREATE TABLE orderstest (
!     approver_ref integer,
!     po_ref integer,
!     ordercanceled boolean
! );
! INSERT INTO orderstest VALUES (1, 1, false);
! INSERT INTO orderstest VALUES (66, 5, false);
! INSERT INTO orderstest VALUES (66, 6, false);
! INSERT INTO orderstest VALUES (66, 7, false);
! INSERT INTO orderstest VALUES (66, 1, true);
! INSERT INTO orderstest VALUES (66, 8, false);
! INSERT INTO orderstest VALUES (66, 1, false);
! INSERT INTO orderstest VALUES (77, 1, false);
! INSERT INTO orderstest VALUES (1, 1, false);
! INSERT INTO orderstest VALUES (66, 1, false);
! INSERT INTO orderstest VALUES (1, 1, false);
! CREATE VIEW orders_view AS
! SELECT *,
! (SELECT CASE
!    WHEN ord.approver_ref=1 THEN '---' ELSE 'Approved'
!  END) AS "Approved",
! (SELECT CASE
!  WHEN ord.ordercanceled
!  THEN 'Canceled'
!  ELSE
!   (SELECT CASE
! 		WHEN ord.po_ref=1
! 		THEN
! 		 (SELECT CASE
! 				WHEN ord.approver_ref=1
! 				THEN '---'
! 				ELSE 'Approved'
! 			END)
! 		ELSE 'PO'
! 	END)
! END) AS "Status",
! (CASE
!  WHEN ord.ordercanceled
!  THEN 'Canceled'
!  ELSE
!   (CASE
! 		WHEN ord.po_ref=1
! 		THEN
! 		 (CASE
! 				WHEN ord.approver_ref=1
! 				THEN '---'
! 				ELSE 'Approved'
! 			END)
! 		ELSE 'PO'
! 	END)
! END) AS "Status_OK"
! FROM orderstest ord;
! SELECT * FROM orders_view 
! ORDER BY approver_ref, po_ref, ordercanceled;
!  approver_ref | po_ref | ordercanceled | Approved |  Status  | Status_OK 
! --------------+--------+---------------+----------+----------+-----------
!             1 |      1 | f             | ---      | ---      | ---
!             1 |      1 | f             | ---      | ---      | ---
!             1 |      1 | f             | ---      | ---      | ---
!            66 |      1 | f             | Approved | Approved | Approved
!            66 |      1 | f             | Approved | Approved | Approved
!            66 |      1 | t             | Approved | Canceled | Canceled
!            66 |      5 | f             | Approved | PO       | PO
!            66 |      6 | f             | Approved | PO       | PO
!            66 |      7 | f             | Approved | PO       | PO
!            66 |      8 | f             | Approved | PO       | PO
!            77 |      1 | f             | Approved | Approved | Approved
! (11 rows)
! 
! DROP TABLE orderstest cascade;
! NOTICE:  drop cascades to view orders_view
! --
! -- Test cases to catch situations where rule rewriter fails to propagate
! -- hasSubLinks flag correctly.  Per example from Kyle Bateman.
! --
! create temp table parts (
!     partnum     text,
!     cost        float8
! );
! create temp table shipped (
!     ttype       char(2),
!     ordnum      int4,
!     partnum     text,
!     value       float8
! );
! create temp view shipped_view as
!     select * from shipped where ttype = 'wt';
! create rule shipped_view_insert as on insert to shipped_view do instead
!     insert into shipped values('wt', new.ordnum, new.partnum, new.value);
! insert into parts (partnum, cost) values (1, 1234.56);
! insert into shipped_view (ordnum, partnum, value)
!     values (0, 1, (select cost from parts where partnum = '1'));
! select * from shipped_view;
!  ttype | ordnum | partnum |  value  
! -------+--------+---------+---------
!  wt    |      0 | 1       | 1234.56
! (1 row)
! 
! create rule shipped_view_update as on update to shipped_view do instead
!     update shipped set partnum = new.partnum, value = new.value
!         where ttype = new.ttype and ordnum = new.ordnum;
! update shipped_view set value = 11
!     from int4_tbl a join int4_tbl b
!       on (a.f1 = (select f1 from int4_tbl c where c.f1=b.f1))
!     where ordnum = a.f1;
! ERROR:  could not plan this distributed update
! DETAIL:  correlated UPDATE or updating distribution column currently not supported in Postgres-XL.
! select * from shipped_view;
!  ttype | ordnum | partnum |  value  
! -------+--------+---------+---------
!  wt    |      0 | 1       | 1234.56
! (1 row)
! 
! select f1, ss1 as relabel from
!     (select *, (select sum(f1) from int4_tbl b where f1 >= a.f1) as ss1
!      from int4_tbl a) ss 
!      ORDER BY f1, relabel;
!      f1      |  relabel   
! -------------+------------
!  -2147483647 |          0
!      -123456 | 2147483647
!            0 | 2147607103
!       123456 | 2147607103
!   2147483647 | 2147483647
! (5 rows)
! 
! --
! -- Test cases involving PARAM_EXEC parameters and min/max index optimizations.
! -- Per bug report from David Sanchez i Gregori.
! --
! select * from (
!   select max(unique1) from tenk1 as a
!   where exists (select 1 from tenk1 as b where b.thousand = a.unique2)
! ) ss;
!  max  
! ------
!  9997
! (1 row)
! 
! select * from (
!   select min(unique1) from tenk1 as a
!   where not exists (select 1 from tenk1 as b where b.unique2 = 10000)
! ) ss;
!  min 
! -----
!    0
! (1 row)
! 
! --
! -- Test that an IN implemented using a UniquePath does unique-ification
! -- with the right semantics, as per bug #4113.  (Unfortunately we have
! -- no simple way to ensure that this test case actually chooses that type
! -- of plan, but it does in releases 7.4-8.3.  Note that an ordering difference
! -- here might mean that some other plan type is being used, rendering the test
! -- pointless.)
! --
! create temp table numeric_table (num_col numeric);
! insert into numeric_table values (1), (1.000000000000000000001), (2), (3);
! create temp table float_table (float_col float8);
! insert into float_table values (1), (2), (3);
! select * from float_table
!   where float_col in (select num_col from numeric_table) 
!   ORDER BY float_col;
!  float_col 
! -----------
!          1
!          2
!          3
! (3 rows)
! 
! select * from numeric_table
!   where num_col in (select float_col from float_table) 
!   ORDER BY num_col;
!          num_col         
! -------------------------
!                        1
!  1.000000000000000000001
!                        2
!                        3
! (4 rows)
! 
! --
! -- Test case for bug #4290: bogus calculation of subplan param sets
! --
! create temp table ta (id int primary key, val int);
! insert into ta values(1,1);
! insert into ta values(2,2);
! create temp table tb (id int primary key, aval int);
! insert into tb values(1,1);
! insert into tb values(2,1);
! insert into tb values(3,2);
! insert into tb values(4,2);
! create temp table tc (id int primary key, aid int);
! insert into tc values(1,1);
! insert into tc values(2,2);
! select
!   ( select min(tb.id) from tb
!     where tb.aval = (select ta.val from ta where ta.id = tc.aid) ) as min_tb_id
! from tc 
! ORDER BY min_tb_id;
!  min_tb_id 
! -----------
!          1
!          3
! (2 rows)
! 
! --
! -- Test case for 8.3 "failed to locate grouping columns" bug
! --
! create temp table t1 (f1 numeric(14,0), f2 varchar(30));
! select * from
!   (select distinct f1, f2, (select f2 from t1 x where x.f1 = up.f1) as fs
!    from t1 up) ss
! group by f1,f2,fs;
!  f1 | f2 | fs 
! ----+----+----
! (0 rows)
! 
! --
! -- Test case for bug #5514 (mishandling of whole-row Vars in subselects)
! --
! create temp table table_a(id integer);
! insert into table_a values (42);
! create temp view view_a as select * from table_a;
! select view_a from view_a;
!  view_a 
! --------
!  (42)
! (1 row)
! 
! select (select view_a) from view_a;
!  view_a 
! --------
!  (42)
! (1 row)
! 
! select (select (select view_a)) from view_a;
!  view_a 
! --------
!  (42)
! (1 row)
! 
! select (select (a.*)::text) from view_a a;
!   a   
! ------
!  (42)
! (1 row)
! 
! --
! -- Check that whole-row Vars reading the result of a subselect don't include
! -- any junk columns therein
! --
! select q from (select max(f1) from int4_tbl group by f1 order by f1) q;
!        q       
! ---------------
!  (-2147483647)
!  (-123456)
!  (0)
!  (123456)
!  (2147483647)
! (5 rows)
! 
! with q as (select max(f1) from int4_tbl group by f1 order by f1)
!   select q from q;
!        q       
! ---------------
!  (-2147483647)
!  (-123456)
!  (0)
!  (123456)
!  (2147483647)
! (5 rows)
! 
! --
! -- Test case for sublinks pushed down into subselects via join alias expansion
! --
! select
!   (select sq1) as qq1
! from
!   (select exists(select 1 from int4_tbl where f1 = q2) as sq1, 42 as dummy
!    from int8_tbl) sq0
!   join
!   int4_tbl i4 on dummy = i4.f1;
!  qq1 
! -----
! (0 rows)
! 
! --
! -- Test case for subselect within UPDATE of INSERT...ON CONFLICT DO UPDATE
! --
! create temp table upsert(key int4 primary key, val text);
! insert into upsert values(1, 'val') on conflict (key) do update set val = 'not seen';
! insert into upsert values(1, 'val') on conflict (key) do update set val = 'seen with subselect ' || (select f1 from int4_tbl where f1 != 0 limit 1)::text;
! select * from upsert;
!  key |            val             
! -----+----------------------------
!    1 | seen with subselect 123456
! (1 row)
! 
! with aa as (select 'int4_tbl' u from int4_tbl limit 1)
! insert into upsert values (1, 'x'), (999, 'y')
! on conflict (key) do update set val = (select u from aa)
! returning *;
!  key |   val    
! -----+----------
!    1 | int4_tbl
!  999 | y
! (2 rows)
! 
! --
! -- Test case for cross-type partial matching in hashed subplan (bug #7597)
! --
! create temp table outer_7597 (f1 int4, f2 int4);
! insert into outer_7597 values (0, 0);
! insert into outer_7597 values (1, 0);
! insert into outer_7597 values (0, null);
! insert into outer_7597 values (1, null);
! create temp table inner_7597(c1 int8, c2 int8);
! insert into inner_7597 values(0, null);
! select * from outer_7597 where (f1, f2) not in (select * from inner_7597) order by 1;
!  f1 | f2 
! ----+----
!   1 |  0
!   1 |   
! (2 rows)
! 
! --
! -- Test case for premature memory release during hashing of subplan output
! --
! select '1'::text in (select '1'::name union all select '1'::name);
!  ?column? 
! ----------
!  t
! (1 row)
! 
! --
! -- Test case for planner bug with nested EXISTS handling
! --
! select a.thousand from tenk1 a, tenk1 b
! where a.thousand = b.thousand
!   and exists ( select 1 from tenk1 c where b.hundred = c.hundred
!                    and not exists ( select 1 from tenk1 d
!                                     where a.thousand = d.thousand ) );
!  thousand 
! ----------
! (0 rows)
! 
! --
! -- Check that nested sub-selects are not pulled up if they contain volatiles
! --
! explain (verbose, costs off)
!   select x, x from
!     (select (select now()) as x from (values(1),(2)) v(y)) ss;
!         QUERY PLAN         
! ---------------------------
!  Values Scan on "*VALUES*"
!    Output: $0, $1
!    InitPlan 1 (returns $0)
!      ->  Result
!            Output: now()
!    InitPlan 2 (returns $1)
!      ->  Result
!            Output: now()
! (8 rows)
! 
! explain (verbose, costs off)
!   select x, x from
!     (select (select random()) as x from (values(1),(2)) v(y)) ss;
!             QUERY PLAN            
! ----------------------------------
!  Subquery Scan on ss
!    Output: ss.x, ss.x
!    ->  Values Scan on "*VALUES*"
!          Output: $0
!          InitPlan 1 (returns $0)
!            ->  Result
!                  Output: random()
! (7 rows)
! 
! explain (verbose, costs off)
!   select x, x from
!     (select (select now() where y=y) as x from (values(1),(2)) v(y)) ss;
!                               QUERY PLAN                              
! ----------------------------------------------------------------------
!  Values Scan on "*VALUES*"
!    Output: (SubPlan 1), (SubPlan 2)
!    SubPlan 1
!      ->  Result
!            Output: now()
!            One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
!    SubPlan 2
!      ->  Result
!            Output: now()
!            One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
! (10 rows)
! 
! explain (verbose, costs off)
!   select x, x from
!     (select (select random() where y=y) as x from (values(1),(2)) v(y)) ss;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Subquery Scan on ss
!    Output: ss.x, ss.x
!    ->  Values Scan on "*VALUES*"
!          Output: (SubPlan 1)
!          SubPlan 1
!            ->  Result
!                  Output: random()
!                  One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
! (8 rows)
! 
! --
! -- Check we behave sanely in corner case of empty SELECT list (bug #8648)
! --
! create temp table nocolumns();
! select exists(select * from nocolumns);
!  exists 
! --------
!  f
! (1 row)
! 
! --
! -- Check sane behavior with nested IN SubLinks
! --
! explain (verbose, costs off)
! select * from int4_tbl where
!   (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in
!   (select ten from tenk1 b);
!                                             QUERY PLAN                                             
! ---------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    Output: int4_tbl.f1
!    ->  Hash Join
!          Output: int4_tbl.f1
!          Inner Unique: true
!          Hash Cond: (CASE WHEN (hashed SubPlan 1) THEN int4_tbl.f1 ELSE NULL::integer END = b.ten)
!          ->  Seq Scan on public.int4_tbl
!                Output: int4_tbl.f1
!          ->  Hash
!                Output: b.ten
!                ->  HashAggregate
!                      Output: b.ten
!                      Group Key: b.ten
!                      ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Output: b.ten
!                            Distribute results by H: ten
!                            ->  HashAggregate
!                                  Output: b.ten
!                                  Group Key: b.ten
!                                  ->  Seq Scan on public.tenk1 b
!                                        Output: b.ten
!          SubPlan 1
!            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                  Output: a.unique1
!                  ->  Index Only Scan using tenk1_unique1 on public.tenk1 a
!                        Output: a.unique1
! (26 rows)
! 
! select * from int4_tbl where
!   (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in
!   (select ten from tenk1 b);
!  f1 
! ----
!   0
! (1 row)
! 
! --
! -- Check for incorrect optimization when IN subquery contains a SRF
! --
! explain (verbose, costs off)
! select * from int4_tbl o where (f1, f1) in
!   (select f1, generate_series(1,2) / 10 g from int4_tbl i group by f1);
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1)
!    Output: o.f1
!    ->  Nested Loop Semi Join
!          Output: o.f1
!          Join Filter: (o.f1 = "ANY_subquery".f1)
!          ->  Seq Scan on public.int4_tbl o
!                Output: o.f1
!          ->  Materialize
!                Output: "ANY_subquery".f1, "ANY_subquery".g
!                ->  Subquery Scan on "ANY_subquery"
!                      Output: "ANY_subquery".f1, "ANY_subquery".g
!                      Filter: ("ANY_subquery".f1 = "ANY_subquery".g)
!                      ->  Result
!                            Output: i.f1, ((generate_series(1, 2)) / 10)
!                            ->  ProjectSet
!                                  Output: generate_series(1, 2), i.f1
!                                  ->  HashAggregate
!                                        Output: i.f1
!                                        Group Key: i.f1
!                                        ->  Seq Scan on public.int4_tbl i
!                                              Output: i.f1
! (21 rows)
! 
! select * from int4_tbl o where (f1, f1) in
!   (select f1, generate_series(1,2) / 10 g from int4_tbl i group by f1);
!  f1 
! ----
!   0
! (1 row)
! 
! --
! -- check for over-optimization of whole-row Var referencing an Append plan
! --
! select (select q from
!          (select 1,2,3 where f1 > 0
!           union all
!           select 4,5,6.0 where f1 <= 0
!          ) q )
! from int4_tbl order by 1;
!      q     
! -----------
!  (1,2,3)
!  (1,2,3)
!  (4,5,6.0)
!  (4,5,6.0)
!  (4,5,6.0)
! (5 rows)
! 
! --
! -- Check that volatile quals aren't pushed down past a DISTINCT:
! -- nextval() should not be called more than the nominal number of times
! --
! create temp sequence ts1;
! select * from
!   (select distinct ten from tenk1) ss
!   where ten < 10 + nextval('ts1')
!   order by 1;
!  ten 
! -----
!    0
!    1
!    2
!    3
!    4
!    5
!    6
!    7
!    8
!    9
! (10 rows)
! 
! select nextval('ts1');
!  nextval 
! ---------
!       11
! (1 row)
! 
! SELECT setseed(0);
!  setseed 
! ---------
!  
! (1 row)
! 
! -- DROP TABLE IF EXISTS asd ;
! CREATE TABLE IF NOT EXISTS asd  AS
! SELECT clientid::numeric(20),
!  (clientid / 20 )::integer::numeric(20) as userid,
!  cts + ((random()* 3600 *24 )||'sec')::interval as cts,
!  (ARRAY['A','B','C','D','E','F'])[(random()*5+1)::integer] as state,
!  0 as dim,
!  ((ARRAY['Cat','Dog','Duck'])[(clientid / 10  )% 3  +1 ]) ::text as app_name,
!  ((ARRAY['A','B'])[(clientid / 10  )% 2  +1 ]) ::text as platform
!  FROM generate_series('2016-01-01'::timestamp,'2016-10-01'::timestamp,interval '15 day') cts , generate_series( 1000,2000,10) clientid , generate_series(1,6) t
! ;
! SELECT dates::timestamp as dates ,B.platform,B.app_name, B.clientid, B.userid,
! 	B.state as state
! FROM ( VALUES
! ('2016.08.30. 08:52:43') ,('2016.08.29. 04:57:12') ,('2016.08.26. 08:15:05') ,
! ('2016.08.24. 11:49:51') ,('2016.08.22. 08:45:29') ,('2016.08.21. 04:53:47') ,('2016.08.20. 08:44:03')
! ) AS D (dates)
! JOIN
! ( SELECT DISTINCT clientid FROM asd
! 	WHERE userid=74 ) C ON True
! INNER JOIN LATERAL (
! 	SELECT DISTINCT ON (clientid,app_name,platform,state,dim) x.*
! 	FROM asd x
! 	INNER JOIN (SELECT p.clientid,p.app_name,p.platform , p.state, p.dim ,
! 	     MAX(p.cts) AS selected_cts
! 		FROM asd p
! 		where cts<D.dates::timestamp and state in
! 		('A','B')
! 	GROUP BY p.clientid,p.app_name,p.platform,p.state,p.dim) y
! 	ON y.clientid = x.clientid
! 	AND y.selected_cts = x.cts
! 	AND y.platform = x.platform
! 	AND y.app_name=x.app_name
! 	AND y.state=x.state
! 	AND y.dim = x.dim
! 	and x.clientid = C.clientid
! ) B ON True
! ORDER BY dates desc, state;
!           dates           | platform | app_name | clientid | userid | state 
! --------------------------+----------+----------+----------+--------+-------
!  Tue Aug 30 08:52:43 2016 | A        | Dog      |     1480 |     74 | A
!  Tue Aug 30 08:52:43 2016 | B        | Duck     |     1490 |     74 | A
!  Tue Aug 30 08:52:43 2016 | A        | Dog      |     1480 |     74 | B
!  Tue Aug 30 08:52:43 2016 | B        | Duck     |     1490 |     74 | B
!  Mon Aug 29 04:57:12 2016 | A        | Dog      |     1480 |     74 | A
!  Mon Aug 29 04:57:12 2016 | B        | Duck     |     1490 |     74 | A
!  Mon Aug 29 04:57:12 2016 | A        | Dog      |     1480 |     74 | B
!  Mon Aug 29 04:57:12 2016 | B        | Duck     |     1490 |     74 | B
!  Fri Aug 26 08:15:05 2016 | B        | Duck     |     1490 |     74 | A
!  Fri Aug 26 08:15:05 2016 | A        | Dog      |     1480 |     74 | A
!  Fri Aug 26 08:15:05 2016 | B        | Duck     |     1490 |     74 | B
!  Fri Aug 26 08:15:05 2016 | A        | Dog      |     1480 |     74 | B
!  Wed Aug 24 11:49:51 2016 | A        | Dog      |     1480 |     74 | A
!  Wed Aug 24 11:49:51 2016 | B        | Duck     |     1490 |     74 | A
!  Wed Aug 24 11:49:51 2016 | A        | Dog      |     1480 |     74 | B
!  Wed Aug 24 11:49:51 2016 | B        | Duck     |     1490 |     74 | B
!  Mon Aug 22 08:45:29 2016 | B        | Duck     |     1490 |     74 | A
!  Mon Aug 22 08:45:29 2016 | A        | Dog      |     1480 |     74 | A
!  Mon Aug 22 08:45:29 2016 | B        | Duck     |     1490 |     74 | B
!  Mon Aug 22 08:45:29 2016 | A        | Dog      |     1480 |     74 | B
!  Sun Aug 21 04:53:47 2016 | B        | Duck     |     1490 |     74 | A
!  Sun Aug 21 04:53:47 2016 | A        | Dog      |     1480 |     74 | A
!  Sun Aug 21 04:53:47 2016 | B        | Duck     |     1490 |     74 | B
!  Sun Aug 21 04:53:47 2016 | A        | Dog      |     1480 |     74 | B
!  Sat Aug 20 08:44:03 2016 | A        | Dog      |     1480 |     74 | A
!  Sat Aug 20 08:44:03 2016 | B        | Duck     |     1490 |     74 | A
!  Sat Aug 20 08:44:03 2016 | B        | Duck     |     1490 |     74 | B
!  Sat Aug 20 08:44:03 2016 | A        | Dog      |     1480 |     74 | B
! (28 rows)
! 
! DROP TABLE asd;
! SELECT setseed(0);
!  setseed 
! ---------
!  
! (1 row)
! 
! --
! -- Check that volatile quals aren't pushed down past a set-returning function;
! -- while a nonvolatile qual can be, if it doesn't reference the SRF.
! --
! create function tattle(x int, y int) returns bool
! volatile language plpgsql as $$
! begin
!   raise notice 'x = %, y = %', x, y;
!   return x > y;
! end$$;
! explain (verbose, costs off)
! select * from
!   (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
!   where tattle(x, 8);
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Subquery Scan on ss
!    Output: x, u
!    Filter: tattle(ss.x, 8)
!    ->  ProjectSet
!          Output: 9, unnest('{1,2,3,11,12,13}'::integer[])
!          ->  Result
! (6 rows)
! 
! select * from
!   (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
!   where tattle(x, 8);
! NOTICE:  x = 9, y = 8
! NOTICE:  x = 9, y = 8
! NOTICE:  x = 9, y = 8
! NOTICE:  x = 9, y = 8
! NOTICE:  x = 9, y = 8
! NOTICE:  x = 9, y = 8
!  x | u  
! ---+----
!  9 |  1
!  9 |  2
!  9 |  3
!  9 | 11
!  9 | 12
!  9 | 13
! (6 rows)
! 
! -- if we pretend it's stable, we get different results:
! alter function tattle(x int, y int) stable;
! explain (verbose, costs off)
! select * from
!   (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
!   where tattle(x, 8);
!                      QUERY PLAN                     
! ----------------------------------------------------
!  ProjectSet
!    Output: 9, unnest('{1,2,3,11,12,13}'::integer[])
!    ->  Result
!          One-Time Filter: tattle(9, 8)
! (4 rows)
! 
! select * from
!   (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
!   where tattle(x, 8);
! NOTICE:  x = 9, y = 8
!  x | u  
! ---+----
!  9 |  1
!  9 |  2
!  9 |  3
!  9 | 11
!  9 | 12
!  9 | 13
! (6 rows)
! 
! -- although even a stable qual should not be pushed down if it references SRF
! explain (verbose, costs off)
! select * from
!   (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
!   where tattle(x, u);
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Subquery Scan on ss
!    Output: x, u
!    Filter: tattle(ss.x, ss.u)
!    ->  ProjectSet
!          Output: 9, unnest('{1,2,3,11,12,13}'::integer[])
!          ->  Result
! (6 rows)
! 
! select * from
!   (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
!   where tattle(x, u);
! NOTICE:  x = 9, y = 1
! NOTICE:  x = 9, y = 2
! NOTICE:  x = 9, y = 3
! NOTICE:  x = 9, y = 11
! NOTICE:  x = 9, y = 12
! NOTICE:  x = 9, y = 13
!  x | u 
! ---+---
!  9 | 1
!  9 | 2
!  9 | 3
! (3 rows)
! 
! drop function tattle(x int, y int);
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/union.out"	2025-07-31 16:07:15.006067803 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/union.out"	2025-07-31 16:39:29.762073266 +0800
***************
*** 1,889 ****
! --
! -- UNION (also INTERSECT, EXCEPT)
! --
! -- Simple UNION constructs
! SELECT 1 AS two UNION SELECT 2 ORDER BY 1;
!  two 
! -----
!    1
!    2
! (2 rows)
! 
! SELECT 1 AS one UNION SELECT 1 ORDER BY 1;
!  one 
! -----
!    1
! (1 row)
! 
! SELECT 1 AS two UNION ALL SELECT 2 ORDER BY 1;
!  two 
! -----
!    1
!    2
! (2 rows)
! 
! SELECT 1 AS two UNION ALL SELECT 1 ORDER BY 1;
!  two 
! -----
!    1
!    1
! (2 rows)
! 
! SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;
!  three 
! -------
!      1
!      2
!      3
! (3 rows)
! 
! SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;
!  two 
! -----
!    1
!    2
! (2 rows)
! 
! SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;
!  three 
! -------
!      1
!      2
!      2
! (3 rows)
! 
! SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;
!  two 
! -----
!  1.1
!  2.2
! (2 rows)
! 
! -- Mixed types
! SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;
!  two 
! -----
!    1
!  2.2
! (2 rows)
! 
! SELECT 1 AS one UNION SELECT 1.0::float8 ORDER BY 1;
!  one 
! -----
!    1
! (1 row)
! 
! SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! SELECT 1.0::float8 AS two UNION ALL SELECT 1 ORDER BY 1;
!  two 
! -----
!    1
!    1
! (2 rows)
! 
! SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;
!  three 
! -------
!    1.1
!      2
!      3
! (3 rows)
! 
! SELECT 1.1::float8 AS two UNION SELECT 2 UNION SELECT 2.0::float8 ORDER BY 1;
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;
!  three 
! -------
!    1.1
!      2
!      2
! (3 rows)
! 
! SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;
!  two 
! -----
!  1.1
!    2
! (2 rows)
! 
! --
! -- Try testing from tables...
! --
! SELECT f1 AS five FROM FLOAT8_TBL
! UNION
! SELECT f1 FROM FLOAT8_TBL
! ORDER BY 1;
!          five          
! -----------------------
!  -1.2345678901234e+200
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
!                      0
! (5 rows)
! 
! SELECT f1 AS ten FROM FLOAT8_TBL
! UNION ALL
! SELECT f1 FROM FLOAT8_TBL 
! ORDER BY 1;
!           ten          
! -----------------------
!  -1.2345678901234e+200
!  -1.2345678901234e+200
!                -1004.3
!                -1004.3
!                 -34.84
!                 -34.84
!  -1.2345678901234e-200
!  -1.2345678901234e-200
!                      0
!                      0
! (10 rows)
! 
! SELECT f1 AS nine FROM FLOAT8_TBL
! UNION
! SELECT f1 FROM INT4_TBL
! ORDER BY 1;
!          nine          
! -----------------------
!  -1.2345678901234e+200
!            -2147483647
!                -123456
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
!                      0
!                 123456
!             2147483647
! (9 rows)
! 
! SELECT f1 AS ten FROM FLOAT8_TBL
! UNION ALL
! SELECT f1 FROM INT4_TBL 
! ORDER BY 1;
!           ten          
! -----------------------
!  -1.2345678901234e+200
!            -2147483647
!                -123456
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
!                      0
!                      0
!                 123456
!             2147483647
! (10 rows)
! 
! SELECT f1 AS five FROM FLOAT8_TBL
!   WHERE f1 BETWEEN -1e6 AND 1e6
! UNION
! SELECT f1 FROM INT4_TBL
!   WHERE f1 BETWEEN 0 AND 1000000
! ORDER BY 1;
!          five          
! -----------------------
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
!                      0
!                 123456
! (5 rows)
! 
! SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL
! UNION
! SELECT f1 FROM CHAR_TBL
! ORDER BY 1;
!  three 
! -------
!  a   
!  ab  
!  abcd
! (3 rows)
! 
! SELECT f1 AS three FROM VARCHAR_TBL
! UNION
! SELECT CAST(f1 AS varchar) FROM CHAR_TBL
! ORDER BY 1;
!  three 
! -------
!  a
!  ab
!  abcd
! (3 rows)
! 
! SELECT f1 AS eight FROM VARCHAR_TBL
! UNION ALL
! SELECT f1 FROM CHAR_TBL 
! ORDER BY 1;
!  eight 
! -------
!  a
!  a
!  ab
!  ab
!  abcd
!  abcd
!  abcd
!  abcd
! (8 rows)
! 
! SELECT f1 AS five FROM TEXT_TBL
! UNION
! SELECT f1 FROM VARCHAR_TBL
! UNION
! SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL
! ORDER BY 1;
!        five        
! -------------------
!  a
!  ab
!  abcd
!  doh!
!  hi de ho neighbor
! (5 rows)
! 
! --
! -- INTERSECT and EXCEPT
! --
! SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;
!         q2        
! ------------------
!               123
!  4567890123456789
! (2 rows)
! 
! SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;
!         q2        
! ------------------
!               123
!  4567890123456789
!  4567890123456789
! (3 rows)
! 
! SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
!         q2         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;
!         q2         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;
!         q2         
! -------------------
!  -4567890123456789
!                456
!   4567890123456789
! (3 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;
!  q1 
! ----
! (0 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;
!         q1        
! ------------------
!               123
!  4567890123456789
! (2 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;
!         q1        
! ------------------
!               123
!  4567890123456789
!  4567890123456789
! (3 rows)
! 
! SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;
! ERROR:  FOR NO KEY UPDATE is not allowed with UNION/INTERSECT/EXCEPT
! -- nested cases
! (SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;
!  ?column? | ?column? | ?column? 
! ----------+----------+----------
!         4 |        5 |        6
! (1 row)
! 
! (SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;
!  ?column? | ?column? | ?column? 
! ----------+----------+----------
!         4 |        5 |        6
! (1 row)
! 
! (SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;
!  ?column? | ?column? | ?column? 
! ----------+----------+----------
!         1 |        2 |        3
! (1 row)
! 
! (SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;
!  ?column? | ?column? | ?column? 
! ----------+----------+----------
!         1 |        2 |        3
! (1 row)
! 
! -- exercise both hashed and sorted implementations of INTERSECT/EXCEPT
! set enable_hashagg to on;
! explain (costs off)
! select count(*) from
!   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
!                                         QUERY PLAN                                        
! ------------------------------------------------------------------------------------------
!  Aggregate
!    ->  Subquery Scan on ss
!          ->  HashSetOp Intersect
!                ->  Append
!                      ->  Subquery Scan on "*SELECT* 2"
!                            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                  ->  Seq Scan on tenk1
!                      ->  Subquery Scan on "*SELECT* 1"
!                            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                  ->  Index Only Scan using tenk1_unique1 on tenk1 tenk1_1
! (10 rows)
! 
! select count(*) from
!   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
!  count 
! -------
!   5000
! (1 row)
! 
! explain (costs off)
! select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
!                                   QUERY PLAN                                  
! ------------------------------------------------------------------------------
!  HashSetOp Except
!    ->  Append
!          ->  Subquery Scan on "*SELECT* 1"
!                ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      ->  Index Only Scan using tenk1_unique1 on tenk1
!          ->  Subquery Scan on "*SELECT* 2"
!                ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      ->  Index Only Scan using tenk1_unique2 on tenk1 tenk1_1
!                            Filter: (unique2 <> 10)
! (9 rows)
! 
! select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
!  unique1 
! ---------
!       10
! (1 row)
! 
! set enable_hashagg to off;
! explain (costs off)
! select count(*) from
!   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
!                                            QUERY PLAN                                           
! ------------------------------------------------------------------------------------------------
!  Aggregate
!    ->  Subquery Scan on ss
!          ->  SetOp Intersect
!                ->  Sort
!                      Sort Key: "*SELECT* 2".fivethous
!                      ->  Append
!                            ->  Subquery Scan on "*SELECT* 2"
!                                  ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                        ->  Seq Scan on tenk1
!                            ->  Subquery Scan on "*SELECT* 1"
!                                  ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                        ->  Index Only Scan using tenk1_unique1 on tenk1 tenk1_1
! (12 rows)
! 
! select count(*) from
!   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
!  count 
! -------
!   5000
! (1 row)
! 
! explain (costs off)
! select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
!                                      QUERY PLAN                                     
! ------------------------------------------------------------------------------------
!  SetOp Except
!    ->  Sort
!          Sort Key: "*SELECT* 1".unique1
!          ->  Append
!                ->  Subquery Scan on "*SELECT* 1"
!                      ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            ->  Index Only Scan using tenk1_unique1 on tenk1
!                ->  Subquery Scan on "*SELECT* 2"
!                      ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            ->  Index Only Scan using tenk1_unique2 on tenk1 tenk1_1
!                                  Filter: (unique2 <> 10)
! (11 rows)
! 
! select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
!  unique1 
! ---------
!       10
! (1 row)
! 
! reset enable_hashagg;
! --
! -- Mixed types
! --
! SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;
!  f1 
! ----
!   0
! (1 row)
! 
! SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;
!           f1           
! -----------------------
!  -1.2345678901234e+200
!                -1004.3
!                 -34.84
!  -1.2345678901234e-200
! (4 rows)
! 
! --
! -- Operator precedence and (((((extra))))) parentheses
! --
! SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl ORDER BY 1;
!         q1         
! -------------------
!  -4567890123456789
!                123
!                123
!                456
!   4567890123456789
!   4567890123456789
!   4567890123456789
! (7 rows)
! 
! SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;
!         q1        
! ------------------
!               123
!  4567890123456789
! (2 rows)
! 
! (((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl))) UNION ALL SELECT q2 FROM int8_tbl ORDER BY 1;
!         q1         
! -------------------
!  -4567890123456789
!                123
!                123
!                456
!   4567890123456789
!   4567890123456789
!   4567890123456789
! (7 rows)
! 
! SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
!         q1         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1))) ORDER BY 1;
!         q1         
! -------------------
!  -4567890123456789
!                123
!                123
!                456
!   4567890123456789
!   4567890123456789
!   4567890123456789
! (7 rows)
! 
! (((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;
!         q1         
! -------------------
!  -4567890123456789
!                456
! (2 rows)
! 
! --
! -- Subqueries with ORDER BY & LIMIT clauses
! --
! -- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT
! SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl
! ORDER BY q2,q1;
!         q1        |        q2         
! ------------------+-------------------
!  4567890123456789 | -4567890123456789
!               123 |               456
! (2 rows)
! 
! -- This should fail, because q2 isn't a name of an EXCEPT output column
! SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;
! ERROR:  column "q2" does not exist
! LINE 1: ... int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1...
!                                                              ^
! HINT:  There is a column named "q2" in table "*SELECT* 2", but it cannot be referenced from this part of the query.
! -- But this should work:
! SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;
!         q1        
! ------------------
!               123
!  4567890123456789
! (2 rows)
! 
! --
! -- New syntaxes (7.1) permit new tests
! --
! (((((select * from int8_tbl  ORDER BY q1, q2)))));
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 | -4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
! (5 rows)
! 
! --
! -- Check handling of a case with unknown constants.  We don't guarantee
! -- an undecorated constant will work in all cases, but historically this
! -- usage has worked, so test we don't break it.
! --
! SELECT a.f1 FROM (SELECT 'test' AS f1 FROM varchar_tbl) a
! UNION
! SELECT b.f1 FROM (SELECT f1 FROM varchar_tbl) b
! ORDER BY 1;
!   f1  
! ------
!  a
!  ab
!  abcd
!  test
! (4 rows)
! 
! -- This should fail, but it should produce an error cursor
! SELECT '3.4'::numeric UNION SELECT 'foo';
! ERROR:  invalid input syntax for type numeric: "foo"
! LINE 1: SELECT '3.4'::numeric UNION SELECT 'foo';
!                                            ^
! --
! -- Test that expression-index constraints can be pushed down through
! -- UNION or UNION ALL
! --
! CREATE TEMP TABLE t1 (a text, b text);
! CREATE INDEX t1_ab_idx on t1 ((a || b));
! CREATE TEMP TABLE t2 (ab text primary key);
! INSERT INTO t1 VALUES ('a', 'b'), ('x', 'y');
! INSERT INTO t2 VALUES ('ab'), ('xy');
! set enable_seqscan = off;
! set enable_indexscan = on;
! set enable_bitmapscan = off;
! explain (num_nodes off, nodes off, costs off)
!  SELECT * FROM
!  (SELECT a || b AS ab FROM t1
!   UNION ALL
!   SELECT * FROM t2) t
!  WHERE ab = 'ab';
!                     QUERY PLAN                     
! ---------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Append
!          ->  Index Scan using t1_ab_idx on t1
!                Index Cond: ((a || b) = 'ab'::text)
!          ->  Index Only Scan using t2_pkey on t2
!                Index Cond: (ab = 'ab'::text)
! (6 rows)
! 
! explain (num_nodes off, nodes off, costs off)
!  SELECT * FROM
!  (SELECT a || b AS ab FROM t1
!   UNION
!   SELECT * FROM t2) t
!  WHERE ab = 'ab';
!                        QUERY PLAN                        
! ---------------------------------------------------------
!  HashAggregate
!    Group Key: ((t1.a || t1.b))
!    ->  Append
!          ->  Remote Subquery Scan on all
!                ->  Index Scan using t1_ab_idx on t1
!                      Index Cond: ((a || b) = 'ab'::text)
!          ->  Remote Subquery Scan on all
!                ->  Index Only Scan using t2_pkey on t2
!                      Index Cond: (ab = 'ab'::text)
! (9 rows)
! 
! --
! -- Test that ORDER BY for UNION ALL can be pushed down to inheritance
! -- children.
! --
! CREATE TEMP TABLE t1c (a text, b text);
! ALTER TABLE t1c INHERIT t1;
! CREATE TEMP TABLE t2c (primary key (ab)) INHERITS (t2);
! INSERT INTO t1c (b, a)  VALUES ('v', 'w'), ('c', 'd'), ('m', 'n'), ('e', 'f');
! INSERT INTO t2c VALUES ('vw'), ('cd'), ('mn'), ('ef');
! CREATE INDEX t1c_ab_idx on t1c ((a || b));
! set enable_seqscan = on;
! set enable_indexonlyscan = off;
! explain (costs off)
!   SELECT * FROM
!   (SELECT a || b AS ab FROM t1
!    UNION ALL
!    SELECT ab FROM t2) t
!   ORDER BY 1 LIMIT 8;
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Limit
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          ->  Limit
!                ->  Sort
!                      Sort Key: ((t1.a || t1.b))
!                      ->  Append
!                            ->  Seq Scan on t1
!                            ->  Seq Scan on t1c
!                            ->  Seq Scan on t2
!                            ->  Seq Scan on t2c
! (10 rows)
! 
!   SELECT * FROM
!   (SELECT a || b AS ab FROM t1
!    UNION ALL
!    SELECT ab FROM t2) t
!   ORDER BY 1 LIMIT 8;
!  ab 
! ----
!  ab
!  ab
!  cd
!  dc
!  ef
!  fe
!  mn
!  nm
! (8 rows)
! 
! reset enable_seqscan;
! reset enable_indexscan;
! reset enable_bitmapscan;
! -- This simpler variant of the above test has been observed to fail differently
! create table events (event_id int primary key);
! create table other_events (event_id int primary key);
! create table events_child () inherits (events);
! explain (costs off)
! select event_id
!  from (select event_id from events
!        union all
!        select event_id from other_events) ss
!  order by event_id;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Sort
!          Sort Key: events.event_id
!          ->  Append
!                ->  Seq Scan on events
!                ->  Seq Scan on events_child
!                ->  Seq Scan on other_events
! (7 rows)
! 
! drop table events_child, events, other_events;
! reset enable_indexonlyscan;
! -- Test constraint exclusion of UNION ALL subqueries
! explain (num_nodes off, nodes off, costs off)
!  SELECT * FROM
!   (SELECT 1 AS t, * FROM tenk1 a
!    UNION ALL
!    SELECT 2 AS t, * FROM tenk1 b) c
!  WHERE t = 2;
!            QUERY PLAN            
! ---------------------------------
!  Remote Subquery Scan on all
!    ->  Append
!          ->  Seq Scan on tenk1 b
! (3 rows)
! 
! -- Test that we push quals into UNION sub-selects only when it's safe
! explain (costs off)
! SELECT * FROM
!   (SELECT 1 AS t, 2 AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4
! ORDER BY x;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Sort
!    Sort Key: (2)
!    ->  Unique
!          ->  Sort
!                Sort Key: (1), (2)
!                ->  Append
!                      ->  Result
!                      ->  Result
!                            One-Time Filter: false
! (9 rows)
! 
! SELECT * FROM
!   (SELECT 1 AS t, 2 AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4
! ORDER BY x;
!  t | x 
! ---+---
!  1 | 2
! (1 row)
! 
! explain (costs off)
! SELECT * FROM
!   (SELECT 1 AS t, generate_series(1,10) AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4
! ORDER BY x;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Sort
!    Sort Key: ss.x
!    ->  Subquery Scan on ss
!          Filter: (ss.x < 4)
!          ->  HashAggregate
!                Group Key: (1), (generate_series(1, 10))
!                ->  Append
!                      ->  ProjectSet
!                            ->  Result
!                      ->  Result
! (10 rows)
! 
! SELECT * FROM
!   (SELECT 1 AS t, generate_series(1,10) AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x < 4
! ORDER BY x;
!  t | x 
! ---+---
!  1 | 1
!  1 | 2
!  1 | 3
! (3 rows)
! 
! explain (costs off)
! SELECT * FROM
!   (SELECT 1 AS t, (random()*3)::int AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x > 3
! ORDER BY x;
!                                      QUERY PLAN                                     
! ------------------------------------------------------------------------------------
!  Sort
!    Sort Key: ss.x
!    ->  Subquery Scan on ss
!          Filter: (ss.x > 3)
!          ->  Unique
!                ->  Sort
!                      Sort Key: (1), (((random() * '3'::double precision))::integer)
!                      ->  Append
!                            ->  Result
!                            ->  Result
! (10 rows)
! 
! SELECT * FROM
!   (SELECT 1 AS t, (random()*3)::int AS x
!    UNION
!    SELECT 2 AS t, 4 AS x) ss
! WHERE x > 3
! ORDER BY x;
!  t | x 
! ---+---
!  2 | 4
! (1 row)
! 
! -- Test proper handling of parameterized appendrel paths when the
! -- potential join qual is expensive
! create function expensivefunc(int) returns int
! language plpgsql immutable strict cost 10000
! as $$begin return $1; end$$;
! create temp table t3 as select generate_series(-1000,1000) as x;
! create index t3i on t3 (expensivefunc(x));
! analyze t3;
! explain (num_nodes off, nodes off, costs off)
! select * from
!   (select * from t3 a union all select * from t3 b) ss
!   join int4_tbl on f1 = expensivefunc(x);
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Nested Loop
!          ->  Seq Scan on int4_tbl
!          ->  Append
!                ->  Index Scan using t3i on t3 a
!                      Index Cond: (expensivefunc(x) = int4_tbl.f1)
!                ->  Index Scan using t3i on t3 b
!                      Index Cond: (expensivefunc(x) = int4_tbl.f1)
! (8 rows)
! 
! select * from
!   (select * from t3 a union all select * from t3 b) ss
!   join int4_tbl on f1 = expensivefunc(x);
!  x | f1 
! ---+----
!  0 |  0
!  0 |  0
! (2 rows)
! 
! drop table t3;
! drop function expensivefunc(int);
! -- Test handling of appendrel quals that const-simplify into an AND
! explain (costs off)
! select * from
!   (select *, 0 as x from int8_tbl a
!    union all
!    select *, 1 as x from int8_tbl b) ss
! where (x = 0) or (q1 >= q2 and q1 <= q2) order by 1,2,3;
!                        QUERY PLAN                        
! ---------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1)
!    ->  Sort
!          Sort Key: a.q1, a.q2, (0)
!          ->  Append
!                ->  Seq Scan on int8_tbl a
!                ->  Seq Scan on int8_tbl b
!                      Filter: ((q1 >= q2) AND (q1 <= q2))
! (7 rows)
! 
! select * from
!   (select *, 0 as x from int8_tbl a
!    union all
!    select *, 1 as x from int8_tbl b) ss
! where (x = 0) or (q1 >= q2 and q1 <= q2) order by 1,2,3;
!         q1        |        q2         | x 
! ------------------+-------------------+---
!               123 |               456 | 0
!               123 |  4567890123456789 | 0
!  4567890123456789 | -4567890123456789 | 0
!  4567890123456789 |               123 | 0
!  4567890123456789 |  4567890123456789 | 0
!  4567890123456789 |  4567890123456789 | 1
! (6 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/case.out"	2025-07-31 16:07:14.980068216 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/case.out"	2025-07-31 16:39:29.774073009 +0800
***************
*** 1,388 ****
! --
! -- CASE
! -- Test the case statement
! --
! CREATE TABLE CASE_TBL (
!   i integer,
!   f double precision
! ) DISTRIBUTE BY REPLICATION;
! CREATE TABLE CASE2_TBL (
!   i integer,
!   j integer
! ) DISTRIBUTE BY REPLICATION;
! INSERT INTO CASE_TBL VALUES (1, 10.1);
! INSERT INTO CASE_TBL VALUES (2, 20.2);
! INSERT INTO CASE_TBL VALUES (3, -30.3);
! INSERT INTO CASE_TBL VALUES (4, NULL);
! INSERT INTO CASE2_TBL VALUES (1, -1);
! INSERT INTO CASE2_TBL VALUES (2, -2);
! INSERT INTO CASE2_TBL VALUES (3, -3);
! INSERT INTO CASE2_TBL VALUES (2, -4);
! INSERT INTO CASE2_TBL VALUES (1, NULL);
! INSERT INTO CASE2_TBL VALUES (NULL, -6);
! --
! -- Simplest examples without tables
! --
! SELECT '3' AS "One",
!   CASE
!     WHEN 1 < 2 THEN 3
!   END AS "Simple WHEN";
!  One | Simple WHEN 
! -----+-------------
!  3   |           3
! (1 row)
! 
! SELECT '<NULL>' AS "One",
!   CASE
!     WHEN 1 > 2 THEN 3
!   END AS "Simple default";
!   One   | Simple default 
! --------+----------------
!  <NULL> |               
! (1 row)
! 
! SELECT '3' AS "One",
!   CASE
!     WHEN 1 < 2 THEN 3
!     ELSE 4
!   END AS "Simple ELSE";
!  One | Simple ELSE 
! -----+-------------
!  3   |           3
! (1 row)
! 
! SELECT '4' AS "One",
!   CASE
!     WHEN 1 > 2 THEN 3
!     ELSE 4
!   END AS "ELSE default";
!  One | ELSE default 
! -----+--------------
!  4   |            4
! (1 row)
! 
! SELECT '6' AS "One",
!   CASE
!     WHEN 1 > 2 THEN 3
!     WHEN 4 < 5 THEN 6
!     ELSE 7
!   END AS "Two WHEN with default";
!  One | Two WHEN with default 
! -----+-----------------------
!  6   |                     6
! (1 row)
! 
! SELECT '7' AS "None",
!    CASE WHEN random() < 0 THEN 1
!    END AS "NULL on no matches";
!  None | NULL on no matches 
! ------+--------------------
!  7    |                   
! (1 row)
! 
! -- Constant-expression folding shouldn't evaluate unreachable subexpressions
! SELECT CASE WHEN 1=0 THEN 1/0 WHEN 1=1 THEN 1 ELSE 2/0 END;
!  case 
! ------
!     1
! (1 row)
! 
! SELECT CASE 1 WHEN 0 THEN 1/0 WHEN 1 THEN 1 ELSE 2/0 END;
!  case 
! ------
!     1
! (1 row)
! 
! -- However we do not currently suppress folding of potentially
! -- reachable subexpressions
! SELECT CASE WHEN i > 100 THEN 1/0 ELSE 0 END FROM case_tbl;
! ERROR:  division by zero
! -- Test for cases involving untyped literals in test expression
! SELECT CASE 'a' WHEN 'a' THEN 1 ELSE 2 END;
!  case 
! ------
!     1
! (1 row)
! 
! --
! -- Examples of targets involving tables
! --
! SELECT '' AS "Five",
!   CASE
!     WHEN i >= 3 THEN i
!   END AS ">= 3 or Null"
!   FROM CASE_TBL 
!   ORDER BY 2;
!  Five | >= 3 or Null 
! ------+--------------
!       |            3
!       |            4
!       |             
!       |             
! (4 rows)
! 
! SELECT '' AS "Five",
!   CASE WHEN i >= 3 THEN (i + i)
!        ELSE i
!   END AS "Simplest Math"
!   FROM CASE_TBL 
!   ORDER BY 2;
!  Five | Simplest Math 
! ------+---------------
!       |             1
!       |             2
!       |             6
!       |             8
! (4 rows)
! 
! SELECT '' AS "Five", i AS "Value",
!   CASE WHEN (i < 0) THEN 'small'
!        WHEN (i = 0) THEN 'zero'
!        WHEN (i = 1) THEN 'one'
!        WHEN (i = 2) THEN 'two'
!        ELSE 'big'
!   END AS "Category"
!   FROM CASE_TBL 
!   ORDER BY 2, 3;
!  Five | Value | Category 
! ------+-------+----------
!       |     1 | one
!       |     2 | two
!       |     3 | big
!       |     4 | big
! (4 rows)
! 
! SELECT '' AS "Five",
!   CASE WHEN ((i < 0) or (i < 0)) THEN 'small'
!        WHEN ((i = 0) or (i = 0)) THEN 'zero'
!        WHEN ((i = 1) or (i = 1)) THEN 'one'
!        WHEN ((i = 2) or (i = 2)) THEN 'two'
!        ELSE 'big'
!   END AS "Category"
!   FROM CASE_TBL
!   ORDER BY 2;
!  Five | Category 
! ------+----------
!       | big
!       | big
!       | one
!       | two
! (4 rows)
! 
! --
! -- Examples of qualifications involving tables
! --
! --
! -- NULLIF() and COALESCE()
! -- Shorthand forms for typical CASE constructs
! --  defined in the SQL standard.
! --
! SELECT * FROM CASE_TBL WHERE COALESCE(f,i) = 4;
!  i | f 
! ---+---
!  4 |  
! (1 row)
! 
! SELECT * FROM CASE_TBL WHERE NULLIF(f,i) = 2;
!  i | f 
! ---+---
! (0 rows)
! 
! SELECT COALESCE(a.f, b.i, b.j)
!   FROM CASE_TBL a, CASE2_TBL b 
!   ORDER BY coalesce;
!  coalesce 
! ----------
!     -30.3
!     -30.3
!     -30.3
!     -30.3
!     -30.3
!     -30.3
!        -6
!         1
!         1
!         2
!         2
!         3
!      10.1
!      10.1
!      10.1
!      10.1
!      10.1
!      10.1
!      20.2
!      20.2
!      20.2
!      20.2
!      20.2
!      20.2
! (24 rows)
! 
! SELECT *
!   FROM CASE_TBL a, CASE2_TBL b
!   WHERE COALESCE(a.f, b.i, b.j) = 2 
!   ORDER BY a.i, a.f, b.i, b.j;
!  i | f | i | j  
! ---+---+---+----
!  4 |   | 2 | -4
!  4 |   | 2 | -2
! (2 rows)
! 
! SELECT '' AS Five, NULLIF(a.i,b.i) AS "NULLIF(a.i,b.i)",
!   NULLIF(b.i, 4) AS "NULLIF(b.i,4)"
!   FROM CASE_TBL a, CASE2_TBL b 
!   ORDER BY 2, 3;
!  five | NULLIF(a.i,b.i) | NULLIF(b.i,4) 
! ------+-----------------+---------------
!       |               1 |             2
!       |               1 |             2
!       |               1 |             3
!       |               1 |              
!       |               2 |             1
!       |               2 |             1
!       |               2 |             3
!       |               2 |              
!       |               3 |             1
!       |               3 |             1
!       |               3 |             2
!       |               3 |             2
!       |               3 |              
!       |               4 |             1
!       |               4 |             1
!       |               4 |             2
!       |               4 |             2
!       |               4 |             3
!       |               4 |              
!       |                 |             1
!       |                 |             1
!       |                 |             2
!       |                 |             2
!       |                 |             3
! (24 rows)
! 
! SELECT '' AS "Two", *
!   FROM CASE_TBL a, CASE2_TBL b
!   WHERE COALESCE(f,b.i) = 2 
!   ORDER BY a.i, a.f, b.i, b.j;
!  Two | i | f | i | j  
! -----+---+---+---+----
!      | 4 |   | 2 | -4
!      | 4 |   | 2 | -2
! (2 rows)
! 
! --
! -- Examples of updates involving tables
! --
! UPDATE CASE_TBL
!   SET i = CASE WHEN i >= 3 THEN (- i)
!                 ELSE (2 * i) END;
! SELECT * FROM CASE_TBL ORDER BY i, f;
!  i  |   f   
! ----+-------
!  -4 |      
!  -3 | -30.3
!   2 |  10.1
!   4 |  20.2
! (4 rows)
! 
! UPDATE CASE_TBL
!   SET i = CASE WHEN i >= 2 THEN (2 * i)
!                 ELSE (3 * i) END;
! SELECT * FROM CASE_TBL ORDER BY i, f;
!   i  |   f   
! -----+-------
!  -12 |      
!   -9 | -30.3
!    4 |  10.1
!    8 |  20.2
! (4 rows)
! 
! UPDATE CASE_TBL
!   SET i = CASE WHEN b.i >= 2 THEN (2 * j)
!                 ELSE (3 * j) END
!   FROM CASE2_TBL b
!   WHERE j = -CASE_TBL.i;
! SELECT * FROM CASE_TBL ORDER BY i, f;
!   i  |   f   
! -----+-------
!  -12 |      
!   -9 | -30.3
!   -8 |  10.1
!    8 |  20.2
! (4 rows)
! 
! --
! -- Nested CASE expressions
! --
! -- This test exercises a bug caused by aliasing econtext->caseValue_isNull
! -- with the isNull argument of the inner CASE's CaseExpr evaluation.  After
! -- evaluating the vol(null) expression in the inner CASE's second WHEN-clause,
! -- the isNull flag for the case test value incorrectly became true, causing
! -- the third WHEN-clause not to match.  The volatile function calls are needed
! -- to prevent constant-folding in the planner, which would hide the bug.
! -- Wrap this in a single transaction so the transient '=' operator doesn't
! -- cause problems in concurrent sessions
! BEGIN;
! CREATE FUNCTION vol(text) returns text as
!   'begin return $1; end' language plpgsql volatile;
! SELECT CASE
!   (CASE vol('bar')
!     WHEN 'foo' THEN 'it was foo!'
!     WHEN vol(null) THEN 'null input'
!     WHEN 'bar' THEN 'it was bar!' END
!   )
!   WHEN 'it was foo!' THEN 'foo recognized'
!   WHEN 'it was bar!' THEN 'bar recognized'
!   ELSE 'unrecognized' END;
!       case      
! ----------------
!  bar recognized
! (1 row)
! 
! -- In this case, we can't inline the SQL function without confusing things.
! CREATE DOMAIN foodomain AS text;
! CREATE FUNCTION volfoo(text) returns foodomain as
!   'begin return $1::foodomain; end' language plpgsql volatile;
! CREATE FUNCTION inline_eq(foodomain, foodomain) returns boolean as
!   'SELECT CASE $2::text WHEN $1::text THEN true ELSE false END' language sql;
! CREATE OPERATOR = (procedure = inline_eq,
!                    leftarg = foodomain, rightarg = foodomain);
! SELECT CASE volfoo('bar') WHEN 'foo'::foodomain THEN 'is foo' ELSE 'is not foo' END;
!     case    
! ------------
!  is not foo
! (1 row)
! 
! ROLLBACK;
! -- Test multiple evaluation of a CASE arg that is a read/write object (#14472)
! -- Wrap this in a single transaction so the transient '=' operator doesn't
! -- cause problems in concurrent sessions
! BEGIN;
! CREATE DOMAIN arrdomain AS int[];
! CREATE FUNCTION make_ad(int,int) returns arrdomain as
!   'declare x arrdomain;
!    begin
!      x := array[$1,$2];
!      return x;
!    end' language plpgsql volatile;
! CREATE FUNCTION ad_eq(arrdomain, arrdomain) returns boolean as
!   'begin return array_eq($1, $2); end' language plpgsql;
! CREATE OPERATOR = (procedure = ad_eq,
!                    leftarg = arrdomain, rightarg = arrdomain);
! SELECT CASE make_ad(1,2)
!   WHEN array[2,4]::arrdomain THEN 'wrong'
!   WHEN array[2,5]::arrdomain THEN 'still wrong'
!   WHEN array[1,2]::arrdomain THEN 'right'
!   END;
!  case  
! -------
!  right
! (1 row)
! 
! ROLLBACK;
! --
! -- Clean up
! --
! DROP TABLE CASE_TBL;
! DROP TABLE CASE2_TBL;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/join_2.out"	2025-07-31 16:07:14.988068089 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/join.out"	2025-07-31 16:39:29.791072647 +0800
***************
*** 1,6122 ****
! --
! -- JOIN
! -- Test JOIN clauses
! --
! CREATE TABLE J1_TBL (
!   i integer,
!   j integer,
!   t text
! );
! CREATE TABLE J2_TBL (
!   i integer,
!   k integer
! );
! INSERT INTO J1_TBL VALUES (1, 4, 'one');
! INSERT INTO J1_TBL VALUES (2, 3, 'two');
! INSERT INTO J1_TBL VALUES (3, 2, 'three');
! INSERT INTO J1_TBL VALUES (4, 1, 'four');
! INSERT INTO J1_TBL VALUES (5, 0, 'five');
! INSERT INTO J1_TBL VALUES (6, 6, 'six');
! INSERT INTO J1_TBL VALUES (7, 7, 'seven');
! INSERT INTO J1_TBL VALUES (8, 8, 'eight');
! INSERT INTO J1_TBL VALUES (0, NULL, 'zero');
! INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');
! INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');
! INSERT INTO J2_TBL VALUES (1, -1);
! INSERT INTO J2_TBL VALUES (2, 2);
! INSERT INTO J2_TBL VALUES (3, -3);
! INSERT INTO J2_TBL VALUES (2, 4);
! INSERT INTO J2_TBL VALUES (5, -5);
! INSERT INTO J2_TBL VALUES (5, -5);
! INSERT INTO J2_TBL VALUES (0, NULL);
! INSERT INTO J2_TBL VALUES (NULL, NULL);
! INSERT INTO J2_TBL VALUES (NULL, 0);
! --
! -- CORRELATION NAMES
! -- Make sure that table/column aliases are supported
! -- before diving into more complex join syntax.
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL AS tx 
!   ORDER BY i, j, t;
!  xxx | i | j |   t   
! -----+---+---+-------
!      | 0 |   | zero
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      |   | 0 | zero
!      |   |   | null
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL tx 
!   ORDER BY i, j, t;
!  xxx | i | j |   t   
! -----+---+---+-------
!      | 0 |   | zero
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      |   | 0 | zero
!      |   |   | null
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL AS t1 (a, b, c) 
!   ORDER BY a, b, c;
!  xxx | a | b |   c   
! -----+---+---+-------
!      | 0 |   | zero
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      |   | 0 | zero
!      |   |   | null
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c)
!   ORDER BY a, b, c;
!  xxx | a | b |   c   
! -----+---+---+-------
!      | 0 |   | zero
!      | 1 | 4 | one
!      | 2 | 3 | two
!      | 3 | 2 | three
!      | 4 | 1 | four
!      | 5 | 0 | five
!      | 6 | 6 | six
!      | 7 | 7 | seven
!      | 8 | 8 | eight
!      |   | 0 | zero
!      |   |   | null
! (11 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e) 
!   ORDER BY a, b, c, d, e;
!  xxx | a | b |   c   | d | e  
! -----+---+---+-------+---+----
!      | 0 |   | zero  | 0 |   
!      | 0 |   | zero  | 1 | -1
!      | 0 |   | zero  | 2 |  2
!      | 0 |   | zero  | 2 |  4
!      | 0 |   | zero  | 3 | -3
!      | 0 |   | zero  | 5 | -5
!      | 0 |   | zero  | 5 | -5
!      | 0 |   | zero  |   |  0
!      | 0 |   | zero  |   |   
!      | 1 | 4 | one   | 0 |   
!      | 1 | 4 | one   | 1 | -1
!      | 1 | 4 | one   | 2 |  2
!      | 1 | 4 | one   | 2 |  4
!      | 1 | 4 | one   | 3 | -3
!      | 1 | 4 | one   | 5 | -5
!      | 1 | 4 | one   | 5 | -5
!      | 1 | 4 | one   |   |  0
!      | 1 | 4 | one   |   |   
!      | 2 | 3 | two   | 0 |   
!      | 2 | 3 | two   | 1 | -1
!      | 2 | 3 | two   | 2 |  2
!      | 2 | 3 | two   | 2 |  4
!      | 2 | 3 | two   | 3 | -3
!      | 2 | 3 | two   | 5 | -5
!      | 2 | 3 | two   | 5 | -5
!      | 2 | 3 | two   |   |  0
!      | 2 | 3 | two   |   |   
!      | 3 | 2 | three | 0 |   
!      | 3 | 2 | three | 1 | -1
!      | 3 | 2 | three | 2 |  2
!      | 3 | 2 | three | 2 |  4
!      | 3 | 2 | three | 3 | -3
!      | 3 | 2 | three | 5 | -5
!      | 3 | 2 | three | 5 | -5
!      | 3 | 2 | three |   |  0
!      | 3 | 2 | three |   |   
!      | 4 | 1 | four  | 0 |   
!      | 4 | 1 | four  | 1 | -1
!      | 4 | 1 | four  | 2 |  2
!      | 4 | 1 | four  | 2 |  4
!      | 4 | 1 | four  | 3 | -3
!      | 4 | 1 | four  | 5 | -5
!      | 4 | 1 | four  | 5 | -5
!      | 4 | 1 | four  |   |  0
!      | 4 | 1 | four  |   |   
!      | 5 | 0 | five  | 0 |   
!      | 5 | 0 | five  | 1 | -1
!      | 5 | 0 | five  | 2 |  2
!      | 5 | 0 | five  | 2 |  4
!      | 5 | 0 | five  | 3 | -3
!      | 5 | 0 | five  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
!      | 5 | 0 | five  |   |  0
!      | 5 | 0 | five  |   |   
!      | 6 | 6 | six   | 0 |   
!      | 6 | 6 | six   | 1 | -1
!      | 6 | 6 | six   | 2 |  2
!      | 6 | 6 | six   | 2 |  4
!      | 6 | 6 | six   | 3 | -3
!      | 6 | 6 | six   | 5 | -5
!      | 6 | 6 | six   | 5 | -5
!      | 6 | 6 | six   |   |  0
!      | 6 | 6 | six   |   |   
!      | 7 | 7 | seven | 0 |   
!      | 7 | 7 | seven | 1 | -1
!      | 7 | 7 | seven | 2 |  2
!      | 7 | 7 | seven | 2 |  4
!      | 7 | 7 | seven | 3 | -3
!      | 7 | 7 | seven | 5 | -5
!      | 7 | 7 | seven | 5 | -5
!      | 7 | 7 | seven |   |  0
!      | 7 | 7 | seven |   |   
!      | 8 | 8 | eight | 0 |   
!      | 8 | 8 | eight | 1 | -1
!      | 8 | 8 | eight | 2 |  2
!      | 8 | 8 | eight | 2 |  4
!      | 8 | 8 | eight | 3 | -3
!      | 8 | 8 | eight | 5 | -5
!      | 8 | 8 | eight | 5 | -5
!      | 8 | 8 | eight |   |  0
!      | 8 | 8 | eight |   |   
!      |   | 0 | zero  | 0 |   
!      |   | 0 | zero  | 1 | -1
!      |   | 0 | zero  | 2 |  2
!      |   | 0 | zero  | 2 |  4
!      |   | 0 | zero  | 3 | -3
!      |   | 0 | zero  | 5 | -5
!      |   | 0 | zero  | 5 | -5
!      |   | 0 | zero  |   |  0
!      |   | 0 | zero  |   |   
!      |   |   | null  | 0 |   
!      |   |   | null  | 1 | -1
!      |   |   | null  | 2 |  2
!      |   |   | null  | 2 |  4
!      |   |   | null  | 3 | -3
!      |   |   | null  | 5 | -5
!      |   |   | null  | 5 | -5
!      |   |   | null  |   |  0
!      |   |   | null  |   |   
! (99 rows)
! 
! SELECT '' AS "xxx", t1.a, t2.e
!   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)
!   WHERE t1.a = t2.d
!   ORDER BY a, e;
!  xxx | a | e  
! -----+---+----
!      | 0 |   
!      | 1 | -1
!      | 2 |  2
!      | 2 |  4
!      | 3 | -3
!      | 5 | -5
!      | 5 | -5
! (7 rows)
! 
! --
! -- CROSS JOIN
! -- Qualifications are not allowed on cross joins,
! -- which degenerate into a standard unqualified inner join.
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL CROSS JOIN J2_TBL
!   ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k;
!  xxx | i | j |   t   | i | k  
! -----+---+---+-------+---+----
!      | 0 |   | zero  | 0 |   
!      | 0 |   | zero  | 1 | -1
!      | 0 |   | zero  | 2 |  2
!      | 0 |   | zero  | 2 |  4
!      | 0 |   | zero  | 3 | -3
!      | 0 |   | zero  | 5 | -5
!      | 0 |   | zero  | 5 | -5
!      | 0 |   | zero  |   |  0
!      | 0 |   | zero  |   |   
!      | 1 | 4 | one   | 0 |   
!      | 1 | 4 | one   | 1 | -1
!      | 1 | 4 | one   | 2 |  2
!      | 1 | 4 | one   | 2 |  4
!      | 1 | 4 | one   | 3 | -3
!      | 1 | 4 | one   | 5 | -5
!      | 1 | 4 | one   | 5 | -5
!      | 1 | 4 | one   |   |  0
!      | 1 | 4 | one   |   |   
!      | 2 | 3 | two   | 0 |   
!      | 2 | 3 | two   | 1 | -1
!      | 2 | 3 | two   | 2 |  2
!      | 2 | 3 | two   | 2 |  4
!      | 2 | 3 | two   | 3 | -3
!      | 2 | 3 | two   | 5 | -5
!      | 2 | 3 | two   | 5 | -5
!      | 2 | 3 | two   |   |  0
!      | 2 | 3 | two   |   |   
!      | 3 | 2 | three | 0 |   
!      | 3 | 2 | three | 1 | -1
!      | 3 | 2 | three | 2 |  2
!      | 3 | 2 | three | 2 |  4
!      | 3 | 2 | three | 3 | -3
!      | 3 | 2 | three | 5 | -5
!      | 3 | 2 | three | 5 | -5
!      | 3 | 2 | three |   |  0
!      | 3 | 2 | three |   |   
!      | 4 | 1 | four  | 0 |   
!      | 4 | 1 | four  | 1 | -1
!      | 4 | 1 | four  | 2 |  2
!      | 4 | 1 | four  | 2 |  4
!      | 4 | 1 | four  | 3 | -3
!      | 4 | 1 | four  | 5 | -5
!      | 4 | 1 | four  | 5 | -5
!      | 4 | 1 | four  |   |  0
!      | 4 | 1 | four  |   |   
!      | 5 | 0 | five  | 0 |   
!      | 5 | 0 | five  | 1 | -1
!      | 5 | 0 | five  | 2 |  2
!      | 5 | 0 | five  | 2 |  4
!      | 5 | 0 | five  | 3 | -3
!      | 5 | 0 | five  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
!      | 5 | 0 | five  |   |  0
!      | 5 | 0 | five  |   |   
!      | 6 | 6 | six   | 0 |   
!      | 6 | 6 | six   | 1 | -1
!      | 6 | 6 | six   | 2 |  2
!      | 6 | 6 | six   | 2 |  4
!      | 6 | 6 | six   | 3 | -3
!      | 6 | 6 | six   | 5 | -5
!      | 6 | 6 | six   | 5 | -5
!      | 6 | 6 | six   |   |  0
!      | 6 | 6 | six   |   |   
!      | 7 | 7 | seven | 0 |   
!      | 7 | 7 | seven | 1 | -1
!      | 7 | 7 | seven | 2 |  2
!      | 7 | 7 | seven | 2 |  4
!      | 7 | 7 | seven | 3 | -3
!      | 7 | 7 | seven | 5 | -5
!      | 7 | 7 | seven | 5 | -5
!      | 7 | 7 | seven |   |  0
!      | 7 | 7 | seven |   |   
!      | 8 | 8 | eight | 0 |   
!      | 8 | 8 | eight | 1 | -1
!      | 8 | 8 | eight | 2 |  2
!      | 8 | 8 | eight | 2 |  4
!      | 8 | 8 | eight | 3 | -3
!      | 8 | 8 | eight | 5 | -5
!      | 8 | 8 | eight | 5 | -5
!      | 8 | 8 | eight |   |  0
!      | 8 | 8 | eight |   |   
!      |   | 0 | zero  | 0 |   
!      |   | 0 | zero  | 1 | -1
!      |   | 0 | zero  | 2 |  2
!      |   | 0 | zero  | 2 |  4
!      |   | 0 | zero  | 3 | -3
!      |   | 0 | zero  | 5 | -5
!      |   | 0 | zero  | 5 | -5
!      |   | 0 | zero  |   |  0
!      |   | 0 | zero  |   |   
!      |   |   | null  | 0 |   
!      |   |   | null  | 1 | -1
!      |   |   | null  | 2 |  2
!      |   |   | null  | 2 |  4
!      |   |   | null  | 3 | -3
!      |   |   | null  | 5 | -5
!      |   |   | null  | 5 | -5
!      |   |   | null  |   |  0
!      |   |   | null  |   |   
! (99 rows)
! 
! -- ambiguous column
! SELECT '' AS "xxx", i, k, t
!   FROM J1_TBL CROSS JOIN J2_TBL;
! ERROR:  column reference "i" is ambiguous
! LINE 1: SELECT '' AS "xxx", i, k, t
!                             ^
! -- resolve previous ambiguity by specifying the table name
! SELECT '' AS "xxx", t1.i, k, t
!   FROM J1_TBL t1 CROSS JOIN J2_TBL t2
!   ORDER BY i, k, t;
!  xxx | i | k  |   t   
! -----+---+----+-------
!      | 0 | -5 | zero
!      | 0 | -5 | zero
!      | 0 | -3 | zero
!      | 0 | -1 | zero
!      | 0 |  0 | zero
!      | 0 |  2 | zero
!      | 0 |  4 | zero
!      | 0 |    | zero
!      | 0 |    | zero
!      | 1 | -5 | one
!      | 1 | -5 | one
!      | 1 | -3 | one
!      | 1 | -1 | one
!      | 1 |  0 | one
!      | 1 |  2 | one
!      | 1 |  4 | one
!      | 1 |    | one
!      | 1 |    | one
!      | 2 | -5 | two
!      | 2 | -5 | two
!      | 2 | -3 | two
!      | 2 | -1 | two
!      | 2 |  0 | two
!      | 2 |  2 | two
!      | 2 |  4 | two
!      | 2 |    | two
!      | 2 |    | two
!      | 3 | -5 | three
!      | 3 | -5 | three
!      | 3 | -3 | three
!      | 3 | -1 | three
!      | 3 |  0 | three
!      | 3 |  2 | three
!      | 3 |  4 | three
!      | 3 |    | three
!      | 3 |    | three
!      | 4 | -5 | four
!      | 4 | -5 | four
!      | 4 | -3 | four
!      | 4 | -1 | four
!      | 4 |  0 | four
!      | 4 |  2 | four
!      | 4 |  4 | four
!      | 4 |    | four
!      | 4 |    | four
!      | 5 | -5 | five
!      | 5 | -5 | five
!      | 5 | -3 | five
!      | 5 | -1 | five
!      | 5 |  0 | five
!      | 5 |  2 | five
!      | 5 |  4 | five
!      | 5 |    | five
!      | 5 |    | five
!      | 6 | -5 | six
!      | 6 | -5 | six
!      | 6 | -3 | six
!      | 6 | -1 | six
!      | 6 |  0 | six
!      | 6 |  2 | six
!      | 6 |  4 | six
!      | 6 |    | six
!      | 6 |    | six
!      | 7 | -5 | seven
!      | 7 | -5 | seven
!      | 7 | -3 | seven
!      | 7 | -1 | seven
!      | 7 |  0 | seven
!      | 7 |  2 | seven
!      | 7 |  4 | seven
!      | 7 |    | seven
!      | 7 |    | seven
!      | 8 | -5 | eight
!      | 8 | -5 | eight
!      | 8 | -3 | eight
!      | 8 | -1 | eight
!      | 8 |  0 | eight
!      | 8 |  2 | eight
!      | 8 |  4 | eight
!      | 8 |    | eight
!      | 8 |    | eight
!      |   | -5 | null
!      |   | -5 | null
!      |   | -5 | zero
!      |   | -5 | zero
!      |   | -3 | null
!      |   | -3 | zero
!      |   | -1 | null
!      |   | -1 | zero
!      |   |  0 | null
!      |   |  0 | zero
!      |   |  2 | null
!      |   |  2 | zero
!      |   |  4 | null
!      |   |  4 | zero
!      |   |    | null
!      |   |    | null
!      |   |    | zero
!      |   |    | zero
! (99 rows)
! 
! SELECT '' AS "xxx", ii, tt, kk
!   FROM (J1_TBL CROSS JOIN J2_TBL)
!     AS tx (ii, jj, tt, ii2, kk)
!     ORDER BY ii, tt, kk;
!  xxx | ii |  tt   | kk 
! -----+----+-------+----
!      |  0 | zero  | -5
!      |  0 | zero  | -5
!      |  0 | zero  | -3
!      |  0 | zero  | -1
!      |  0 | zero  |  0
!      |  0 | zero  |  2
!      |  0 | zero  |  4
!      |  0 | zero  |   
!      |  0 | zero  |   
!      |  1 | one   | -5
!      |  1 | one   | -5
!      |  1 | one   | -3
!      |  1 | one   | -1
!      |  1 | one   |  0
!      |  1 | one   |  2
!      |  1 | one   |  4
!      |  1 | one   |   
!      |  1 | one   |   
!      |  2 | two   | -5
!      |  2 | two   | -5
!      |  2 | two   | -3
!      |  2 | two   | -1
!      |  2 | two   |  0
!      |  2 | two   |  2
!      |  2 | two   |  4
!      |  2 | two   |   
!      |  2 | two   |   
!      |  3 | three | -5
!      |  3 | three | -5
!      |  3 | three | -3
!      |  3 | three | -1
!      |  3 | three |  0
!      |  3 | three |  2
!      |  3 | three |  4
!      |  3 | three |   
!      |  3 | three |   
!      |  4 | four  | -5
!      |  4 | four  | -5
!      |  4 | four  | -3
!      |  4 | four  | -1
!      |  4 | four  |  0
!      |  4 | four  |  2
!      |  4 | four  |  4
!      |  4 | four  |   
!      |  4 | four  |   
!      |  5 | five  | -5
!      |  5 | five  | -5
!      |  5 | five  | -3
!      |  5 | five  | -1
!      |  5 | five  |  0
!      |  5 | five  |  2
!      |  5 | five  |  4
!      |  5 | five  |   
!      |  5 | five  |   
!      |  6 | six   | -5
!      |  6 | six   | -5
!      |  6 | six   | -3
!      |  6 | six   | -1
!      |  6 | six   |  0
!      |  6 | six   |  2
!      |  6 | six   |  4
!      |  6 | six   |   
!      |  6 | six   |   
!      |  7 | seven | -5
!      |  7 | seven | -5
!      |  7 | seven | -3
!      |  7 | seven | -1
!      |  7 | seven |  0
!      |  7 | seven |  2
!      |  7 | seven |  4
!      |  7 | seven |   
!      |  7 | seven |   
!      |  8 | eight | -5
!      |  8 | eight | -5
!      |  8 | eight | -3
!      |  8 | eight | -1
!      |  8 | eight |  0
!      |  8 | eight |  2
!      |  8 | eight |  4
!      |  8 | eight |   
!      |  8 | eight |   
!      |    | null  | -5
!      |    | null  | -5
!      |    | null  | -3
!      |    | null  | -1
!      |    | null  |  0
!      |    | null  |  2
!      |    | null  |  4
!      |    | null  |   
!      |    | null  |   
!      |    | zero  | -5
!      |    | zero  | -5
!      |    | zero  | -3
!      |    | zero  | -1
!      |    | zero  |  0
!      |    | zero  |  2
!      |    | zero  |  4
!      |    | zero  |   
!      |    | zero  |   
! (99 rows)
! 
! SELECT '' AS "xxx", tx.ii, tx.jj, tx.kk
!   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))
!     AS tx (ii, jj, tt, ii2, kk)
!     ORDER BY ii, jj, kk;
!  xxx | ii | jj | kk 
! -----+----+----+----
!      |  0 |    | -5
!      |  0 |    | -5
!      |  0 |    | -3
!      |  0 |    | -1
!      |  0 |    |  0
!      |  0 |    |  2
!      |  0 |    |  4
!      |  0 |    |   
!      |  0 |    |   
!      |  1 |  4 | -5
!      |  1 |  4 | -5
!      |  1 |  4 | -3
!      |  1 |  4 | -1
!      |  1 |  4 |  0
!      |  1 |  4 |  2
!      |  1 |  4 |  4
!      |  1 |  4 |   
!      |  1 |  4 |   
!      |  2 |  3 | -5
!      |  2 |  3 | -5
!      |  2 |  3 | -3
!      |  2 |  3 | -1
!      |  2 |  3 |  0
!      |  2 |  3 |  2
!      |  2 |  3 |  4
!      |  2 |  3 |   
!      |  2 |  3 |   
!      |  3 |  2 | -5
!      |  3 |  2 | -5
!      |  3 |  2 | -3
!      |  3 |  2 | -1
!      |  3 |  2 |  0
!      |  3 |  2 |  2
!      |  3 |  2 |  4
!      |  3 |  2 |   
!      |  3 |  2 |   
!      |  4 |  1 | -5
!      |  4 |  1 | -5
!      |  4 |  1 | -3
!      |  4 |  1 | -1
!      |  4 |  1 |  0
!      |  4 |  1 |  2
!      |  4 |  1 |  4
!      |  4 |  1 |   
!      |  4 |  1 |   
!      |  5 |  0 | -5
!      |  5 |  0 | -5
!      |  5 |  0 | -3
!      |  5 |  0 | -1
!      |  5 |  0 |  0
!      |  5 |  0 |  2
!      |  5 |  0 |  4
!      |  5 |  0 |   
!      |  5 |  0 |   
!      |  6 |  6 | -5
!      |  6 |  6 | -5
!      |  6 |  6 | -3
!      |  6 |  6 | -1
!      |  6 |  6 |  0
!      |  6 |  6 |  2
!      |  6 |  6 |  4
!      |  6 |  6 |   
!      |  6 |  6 |   
!      |  7 |  7 | -5
!      |  7 |  7 | -5
!      |  7 |  7 | -3
!      |  7 |  7 | -1
!      |  7 |  7 |  0
!      |  7 |  7 |  2
!      |  7 |  7 |  4
!      |  7 |  7 |   
!      |  7 |  7 |   
!      |  8 |  8 | -5
!      |  8 |  8 | -5
!      |  8 |  8 | -3
!      |  8 |  8 | -1
!      |  8 |  8 |  0
!      |  8 |  8 |  2
!      |  8 |  8 |  4
!      |  8 |  8 |   
!      |  8 |  8 |   
!      |    |  0 | -5
!      |    |  0 | -5
!      |    |  0 | -3
!      |    |  0 | -1
!      |    |  0 |  0
!      |    |  0 |  2
!      |    |  0 |  4
!      |    |  0 |   
!      |    |  0 |   
!      |    |    | -5
!      |    |    | -5
!      |    |    | -3
!      |    |    | -1
!      |    |    |  0
!      |    |    |  2
!      |    |    |  4
!      |    |    |   
!      |    |    |   
! (99 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b
!   ORDER BY J1_TBL.i,J1_TBL.j,J1_TBL.t,a.i,a.k,b.i,b.k;
!  xxx | i | j |   t   | i | k  | i | k  
! -----+---+---+-------+---+----+---+----
!      | 0 |   | zero  | 0 |    | 0 |   
!      | 0 |   | zero  | 0 |    | 1 | -1
!      | 0 |   | zero  | 0 |    | 2 |  2
!      | 0 |   | zero  | 0 |    | 2 |  4
!      | 0 |   | zero  | 0 |    | 3 | -3
!      | 0 |   | zero  | 0 |    | 5 | -5
!      | 0 |   | zero  | 0 |    | 5 | -5
!      | 0 |   | zero  | 0 |    |   |  0
!      | 0 |   | zero  | 0 |    |   |   
!      | 0 |   | zero  | 1 | -1 | 0 |   
!      | 0 |   | zero  | 1 | -1 | 1 | -1
!      | 0 |   | zero  | 1 | -1 | 2 |  2
!      | 0 |   | zero  | 1 | -1 | 2 |  4
!      | 0 |   | zero  | 1 | -1 | 3 | -3
!      | 0 |   | zero  | 1 | -1 | 5 | -5
!      | 0 |   | zero  | 1 | -1 | 5 | -5
!      | 0 |   | zero  | 1 | -1 |   |  0
!      | 0 |   | zero  | 1 | -1 |   |   
!      | 0 |   | zero  | 2 |  2 | 0 |   
!      | 0 |   | zero  | 2 |  2 | 1 | -1
!      | 0 |   | zero  | 2 |  2 | 2 |  2
!      | 0 |   | zero  | 2 |  2 | 2 |  4
!      | 0 |   | zero  | 2 |  2 | 3 | -3
!      | 0 |   | zero  | 2 |  2 | 5 | -5
!      | 0 |   | zero  | 2 |  2 | 5 | -5
!      | 0 |   | zero  | 2 |  2 |   |  0
!      | 0 |   | zero  | 2 |  2 |   |   
!      | 0 |   | zero  | 2 |  4 | 0 |   
!      | 0 |   | zero  | 2 |  4 | 1 | -1
!      | 0 |   | zero  | 2 |  4 | 2 |  2
!      | 0 |   | zero  | 2 |  4 | 2 |  4
!      | 0 |   | zero  | 2 |  4 | 3 | -3
!      | 0 |   | zero  | 2 |  4 | 5 | -5
!      | 0 |   | zero  | 2 |  4 | 5 | -5
!      | 0 |   | zero  | 2 |  4 |   |  0
!      | 0 |   | zero  | 2 |  4 |   |   
!      | 0 |   | zero  | 3 | -3 | 0 |   
!      | 0 |   | zero  | 3 | -3 | 1 | -1
!      | 0 |   | zero  | 3 | -3 | 2 |  2
!      | 0 |   | zero  | 3 | -3 | 2 |  4
!      | 0 |   | zero  | 3 | -3 | 3 | -3
!      | 0 |   | zero  | 3 | -3 | 5 | -5
!      | 0 |   | zero  | 3 | -3 | 5 | -5
!      | 0 |   | zero  | 3 | -3 |   |  0
!      | 0 |   | zero  | 3 | -3 |   |   
!      | 0 |   | zero  | 5 | -5 | 0 |   
!      | 0 |   | zero  | 5 | -5 | 0 |   
!      | 0 |   | zero  | 5 | -5 | 1 | -1
!      | 0 |   | zero  | 5 | -5 | 1 | -1
!      | 0 |   | zero  | 5 | -5 | 2 |  2
!      | 0 |   | zero  | 5 | -5 | 2 |  2
!      | 0 |   | zero  | 5 | -5 | 2 |  4
!      | 0 |   | zero  | 5 | -5 | 2 |  4
!      | 0 |   | zero  | 5 | -5 | 3 | -3
!      | 0 |   | zero  | 5 | -5 | 3 | -3
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 | 5 | -5
!      | 0 |   | zero  | 5 | -5 |   |  0
!      | 0 |   | zero  | 5 | -5 |   |  0
!      | 0 |   | zero  | 5 | -5 |   |   
!      | 0 |   | zero  | 5 | -5 |   |   
!      | 0 |   | zero  |   |  0 | 0 |   
!      | 0 |   | zero  |   |  0 | 1 | -1
!      | 0 |   | zero  |   |  0 | 2 |  2
!      | 0 |   | zero  |   |  0 | 2 |  4
!      | 0 |   | zero  |   |  0 | 3 | -3
!      | 0 |   | zero  |   |  0 | 5 | -5
!      | 0 |   | zero  |   |  0 | 5 | -5
!      | 0 |   | zero  |   |  0 |   |  0
!      | 0 |   | zero  |   |  0 |   |   
!      | 0 |   | zero  |   |    | 0 |   
!      | 0 |   | zero  |   |    | 1 | -1
!      | 0 |   | zero  |   |    | 2 |  2
!      | 0 |   | zero  |   |    | 2 |  4
!      | 0 |   | zero  |   |    | 3 | -3
!      | 0 |   | zero  |   |    | 5 | -5
!      | 0 |   | zero  |   |    | 5 | -5
!      | 0 |   | zero  |   |    |   |  0
!      | 0 |   | zero  |   |    |   |   
!      | 1 | 4 | one   | 0 |    | 0 |   
!      | 1 | 4 | one   | 0 |    | 1 | -1
!      | 1 | 4 | one   | 0 |    | 2 |  2
!      | 1 | 4 | one   | 0 |    | 2 |  4
!      | 1 | 4 | one   | 0 |    | 3 | -3
!      | 1 | 4 | one   | 0 |    | 5 | -5
!      | 1 | 4 | one   | 0 |    | 5 | -5
!      | 1 | 4 | one   | 0 |    |   |  0
!      | 1 | 4 | one   | 0 |    |   |   
!      | 1 | 4 | one   | 1 | -1 | 0 |   
!      | 1 | 4 | one   | 1 | -1 | 1 | -1
!      | 1 | 4 | one   | 1 | -1 | 2 |  2
!      | 1 | 4 | one   | 1 | -1 | 2 |  4
!      | 1 | 4 | one   | 1 | -1 | 3 | -3
!      | 1 | 4 | one   | 1 | -1 | 5 | -5
!      | 1 | 4 | one   | 1 | -1 | 5 | -5
!      | 1 | 4 | one   | 1 | -1 |   |  0
!      | 1 | 4 | one   | 1 | -1 |   |   
!      | 1 | 4 | one   | 2 |  2 | 0 |   
!      | 1 | 4 | one   | 2 |  2 | 1 | -1
!      | 1 | 4 | one   | 2 |  2 | 2 |  2
!      | 1 | 4 | one   | 2 |  2 | 2 |  4
!      | 1 | 4 | one   | 2 |  2 | 3 | -3
!      | 1 | 4 | one   | 2 |  2 | 5 | -5
!      | 1 | 4 | one   | 2 |  2 | 5 | -5
!      | 1 | 4 | one   | 2 |  2 |   |  0
!      | 1 | 4 | one   | 2 |  2 |   |   
!      | 1 | 4 | one   | 2 |  4 | 0 |   
!      | 1 | 4 | one   | 2 |  4 | 1 | -1
!      | 1 | 4 | one   | 2 |  4 | 2 |  2
!      | 1 | 4 | one   | 2 |  4 | 2 |  4
!      | 1 | 4 | one   | 2 |  4 | 3 | -3
!      | 1 | 4 | one   | 2 |  4 | 5 | -5
!      | 1 | 4 | one   | 2 |  4 | 5 | -5
!      | 1 | 4 | one   | 2 |  4 |   |  0
!      | 1 | 4 | one   | 2 |  4 |   |   
!      | 1 | 4 | one   | 3 | -3 | 0 |   
!      | 1 | 4 | one   | 3 | -3 | 1 | -1
!      | 1 | 4 | one   | 3 | -3 | 2 |  2
!      | 1 | 4 | one   | 3 | -3 | 2 |  4
!      | 1 | 4 | one   | 3 | -3 | 3 | -3
!      | 1 | 4 | one   | 3 | -3 | 5 | -5
!      | 1 | 4 | one   | 3 | -3 | 5 | -5
!      | 1 | 4 | one   | 3 | -3 |   |  0
!      | 1 | 4 | one   | 3 | -3 |   |   
!      | 1 | 4 | one   | 5 | -5 | 0 |   
!      | 1 | 4 | one   | 5 | -5 | 0 |   
!      | 1 | 4 | one   | 5 | -5 | 1 | -1
!      | 1 | 4 | one   | 5 | -5 | 1 | -1
!      | 1 | 4 | one   | 5 | -5 | 2 |  2
!      | 1 | 4 | one   | 5 | -5 | 2 |  2
!      | 1 | 4 | one   | 5 | -5 | 2 |  4
!      | 1 | 4 | one   | 5 | -5 | 2 |  4
!      | 1 | 4 | one   | 5 | -5 | 3 | -3
!      | 1 | 4 | one   | 5 | -5 | 3 | -3
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 | 5 | -5
!      | 1 | 4 | one   | 5 | -5 |   |  0
!      | 1 | 4 | one   | 5 | -5 |   |  0
!      | 1 | 4 | one   | 5 | -5 |   |   
!      | 1 | 4 | one   | 5 | -5 |   |   
!      | 1 | 4 | one   |   |  0 | 0 |   
!      | 1 | 4 | one   |   |  0 | 1 | -1
!      | 1 | 4 | one   |   |  0 | 2 |  2
!      | 1 | 4 | one   |   |  0 | 2 |  4
!      | 1 | 4 | one   |   |  0 | 3 | -3
!      | 1 | 4 | one   |   |  0 | 5 | -5
!      | 1 | 4 | one   |   |  0 | 5 | -5
!      | 1 | 4 | one   |   |  0 |   |  0
!      | 1 | 4 | one   |   |  0 |   |   
!      | 1 | 4 | one   |   |    | 0 |   
!      | 1 | 4 | one   |   |    | 1 | -1
!      | 1 | 4 | one   |   |    | 2 |  2
!      | 1 | 4 | one   |   |    | 2 |  4
!      | 1 | 4 | one   |   |    | 3 | -3
!      | 1 | 4 | one   |   |    | 5 | -5
!      | 1 | 4 | one   |   |    | 5 | -5
!      | 1 | 4 | one   |   |    |   |  0
!      | 1 | 4 | one   |   |    |   |   
!      | 2 | 3 | two   | 0 |    | 0 |   
!      | 2 | 3 | two   | 0 |    | 1 | -1
!      | 2 | 3 | two   | 0 |    | 2 |  2
!      | 2 | 3 | two   | 0 |    | 2 |  4
!      | 2 | 3 | two   | 0 |    | 3 | -3
!      | 2 | 3 | two   | 0 |    | 5 | -5
!      | 2 | 3 | two   | 0 |    | 5 | -5
!      | 2 | 3 | two   | 0 |    |   |  0
!      | 2 | 3 | two   | 0 |    |   |   
!      | 2 | 3 | two   | 1 | -1 | 0 |   
!      | 2 | 3 | two   | 1 | -1 | 1 | -1
!      | 2 | 3 | two   | 1 | -1 | 2 |  2
!      | 2 | 3 | two   | 1 | -1 | 2 |  4
!      | 2 | 3 | two   | 1 | -1 | 3 | -3
!      | 2 | 3 | two   | 1 | -1 | 5 | -5
!      | 2 | 3 | two   | 1 | -1 | 5 | -5
!      | 2 | 3 | two   | 1 | -1 |   |  0
!      | 2 | 3 | two   | 1 | -1 |   |   
!      | 2 | 3 | two   | 2 |  2 | 0 |   
!      | 2 | 3 | two   | 2 |  2 | 1 | -1
!      | 2 | 3 | two   | 2 |  2 | 2 |  2
!      | 2 | 3 | two   | 2 |  2 | 2 |  4
!      | 2 | 3 | two   | 2 |  2 | 3 | -3
!      | 2 | 3 | two   | 2 |  2 | 5 | -5
!      | 2 | 3 | two   | 2 |  2 | 5 | -5
!      | 2 | 3 | two   | 2 |  2 |   |  0
!      | 2 | 3 | two   | 2 |  2 |   |   
!      | 2 | 3 | two   | 2 |  4 | 0 |   
!      | 2 | 3 | two   | 2 |  4 | 1 | -1
!      | 2 | 3 | two   | 2 |  4 | 2 |  2
!      | 2 | 3 | two   | 2 |  4 | 2 |  4
!      | 2 | 3 | two   | 2 |  4 | 3 | -3
!      | 2 | 3 | two   | 2 |  4 | 5 | -5
!      | 2 | 3 | two   | 2 |  4 | 5 | -5
!      | 2 | 3 | two   | 2 |  4 |   |  0
!      | 2 | 3 | two   | 2 |  4 |   |   
!      | 2 | 3 | two   | 3 | -3 | 0 |   
!      | 2 | 3 | two   | 3 | -3 | 1 | -1
!      | 2 | 3 | two   | 3 | -3 | 2 |  2
!      | 2 | 3 | two   | 3 | -3 | 2 |  4
!      | 2 | 3 | two   | 3 | -3 | 3 | -3
!      | 2 | 3 | two   | 3 | -3 | 5 | -5
!      | 2 | 3 | two   | 3 | -3 | 5 | -5
!      | 2 | 3 | two   | 3 | -3 |   |  0
!      | 2 | 3 | two   | 3 | -3 |   |   
!      | 2 | 3 | two   | 5 | -5 | 0 |   
!      | 2 | 3 | two   | 5 | -5 | 0 |   
!      | 2 | 3 | two   | 5 | -5 | 1 | -1
!      | 2 | 3 | two   | 5 | -5 | 1 | -1
!      | 2 | 3 | two   | 5 | -5 | 2 |  2
!      | 2 | 3 | two   | 5 | -5 | 2 |  2
!      | 2 | 3 | two   | 5 | -5 | 2 |  4
!      | 2 | 3 | two   | 5 | -5 | 2 |  4
!      | 2 | 3 | two   | 5 | -5 | 3 | -3
!      | 2 | 3 | two   | 5 | -5 | 3 | -3
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 | 5 | -5
!      | 2 | 3 | two   | 5 | -5 |   |  0
!      | 2 | 3 | two   | 5 | -5 |   |  0
!      | 2 | 3 | two   | 5 | -5 |   |   
!      | 2 | 3 | two   | 5 | -5 |   |   
!      | 2 | 3 | two   |   |  0 | 0 |   
!      | 2 | 3 | two   |   |  0 | 1 | -1
!      | 2 | 3 | two   |   |  0 | 2 |  2
!      | 2 | 3 | two   |   |  0 | 2 |  4
!      | 2 | 3 | two   |   |  0 | 3 | -3
!      | 2 | 3 | two   |   |  0 | 5 | -5
!      | 2 | 3 | two   |   |  0 | 5 | -5
!      | 2 | 3 | two   |   |  0 |   |  0
!      | 2 | 3 | two   |   |  0 |   |   
!      | 2 | 3 | two   |   |    | 0 |   
!      | 2 | 3 | two   |   |    | 1 | -1
!      | 2 | 3 | two   |   |    | 2 |  2
!      | 2 | 3 | two   |   |    | 2 |  4
!      | 2 | 3 | two   |   |    | 3 | -3
!      | 2 | 3 | two   |   |    | 5 | -5
!      | 2 | 3 | two   |   |    | 5 | -5
!      | 2 | 3 | two   |   |    |   |  0
!      | 2 | 3 | two   |   |    |   |   
!      | 3 | 2 | three | 0 |    | 0 |   
!      | 3 | 2 | three | 0 |    | 1 | -1
!      | 3 | 2 | three | 0 |    | 2 |  2
!      | 3 | 2 | three | 0 |    | 2 |  4
!      | 3 | 2 | three | 0 |    | 3 | -3
!      | 3 | 2 | three | 0 |    | 5 | -5
!      | 3 | 2 | three | 0 |    | 5 | -5
!      | 3 | 2 | three | 0 |    |   |  0
!      | 3 | 2 | three | 0 |    |   |   
!      | 3 | 2 | three | 1 | -1 | 0 |   
!      | 3 | 2 | three | 1 | -1 | 1 | -1
!      | 3 | 2 | three | 1 | -1 | 2 |  2
!      | 3 | 2 | three | 1 | -1 | 2 |  4
!      | 3 | 2 | three | 1 | -1 | 3 | -3
!      | 3 | 2 | three | 1 | -1 | 5 | -5
!      | 3 | 2 | three | 1 | -1 | 5 | -5
!      | 3 | 2 | three | 1 | -1 |   |  0
!      | 3 | 2 | three | 1 | -1 |   |   
!      | 3 | 2 | three | 2 |  2 | 0 |   
!      | 3 | 2 | three | 2 |  2 | 1 | -1
!      | 3 | 2 | three | 2 |  2 | 2 |  2
!      | 3 | 2 | three | 2 |  2 | 2 |  4
!      | 3 | 2 | three | 2 |  2 | 3 | -3
!      | 3 | 2 | three | 2 |  2 | 5 | -5
!      | 3 | 2 | three | 2 |  2 | 5 | -5
!      | 3 | 2 | three | 2 |  2 |   |  0
!      | 3 | 2 | three | 2 |  2 |   |   
!      | 3 | 2 | three | 2 |  4 | 0 |   
!      | 3 | 2 | three | 2 |  4 | 1 | -1
!      | 3 | 2 | three | 2 |  4 | 2 |  2
!      | 3 | 2 | three | 2 |  4 | 2 |  4
!      | 3 | 2 | three | 2 |  4 | 3 | -3
!      | 3 | 2 | three | 2 |  4 | 5 | -5
!      | 3 | 2 | three | 2 |  4 | 5 | -5
!      | 3 | 2 | three | 2 |  4 |   |  0
!      | 3 | 2 | three | 2 |  4 |   |   
!      | 3 | 2 | three | 3 | -3 | 0 |   
!      | 3 | 2 | three | 3 | -3 | 1 | -1
!      | 3 | 2 | three | 3 | -3 | 2 |  2
!      | 3 | 2 | three | 3 | -3 | 2 |  4
!      | 3 | 2 | three | 3 | -3 | 3 | -3
!      | 3 | 2 | three | 3 | -3 | 5 | -5
!      | 3 | 2 | three | 3 | -3 | 5 | -5
!      | 3 | 2 | three | 3 | -3 |   |  0
!      | 3 | 2 | three | 3 | -3 |   |   
!      | 3 | 2 | three | 5 | -5 | 0 |   
!      | 3 | 2 | three | 5 | -5 | 0 |   
!      | 3 | 2 | three | 5 | -5 | 1 | -1
!      | 3 | 2 | three | 5 | -5 | 1 | -1
!      | 3 | 2 | three | 5 | -5 | 2 |  2
!      | 3 | 2 | three | 5 | -5 | 2 |  2
!      | 3 | 2 | three | 5 | -5 | 2 |  4
!      | 3 | 2 | three | 5 | -5 | 2 |  4
!      | 3 | 2 | three | 5 | -5 | 3 | -3
!      | 3 | 2 | three | 5 | -5 | 3 | -3
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 | 5 | -5
!      | 3 | 2 | three | 5 | -5 |   |  0
!      | 3 | 2 | three | 5 | -5 |   |  0
!      | 3 | 2 | three | 5 | -5 |   |   
!      | 3 | 2 | three | 5 | -5 |   |   
!      | 3 | 2 | three |   |  0 | 0 |   
!      | 3 | 2 | three |   |  0 | 1 | -1
!      | 3 | 2 | three |   |  0 | 2 |  2
!      | 3 | 2 | three |   |  0 | 2 |  4
!      | 3 | 2 | three |   |  0 | 3 | -3
!      | 3 | 2 | three |   |  0 | 5 | -5
!      | 3 | 2 | three |   |  0 | 5 | -5
!      | 3 | 2 | three |   |  0 |   |  0
!      | 3 | 2 | three |   |  0 |   |   
!      | 3 | 2 | three |   |    | 0 |   
!      | 3 | 2 | three |   |    | 1 | -1
!      | 3 | 2 | three |   |    | 2 |  2
!      | 3 | 2 | three |   |    | 2 |  4
!      | 3 | 2 | three |   |    | 3 | -3
!      | 3 | 2 | three |   |    | 5 | -5
!      | 3 | 2 | three |   |    | 5 | -5
!      | 3 | 2 | three |   |    |   |  0
!      | 3 | 2 | three |   |    |   |   
!      | 4 | 1 | four  | 0 |    | 0 |   
!      | 4 | 1 | four  | 0 |    | 1 | -1
!      | 4 | 1 | four  | 0 |    | 2 |  2
!      | 4 | 1 | four  | 0 |    | 2 |  4
!      | 4 | 1 | four  | 0 |    | 3 | -3
!      | 4 | 1 | four  | 0 |    | 5 | -5
!      | 4 | 1 | four  | 0 |    | 5 | -5
!      | 4 | 1 | four  | 0 |    |   |  0
!      | 4 | 1 | four  | 0 |    |   |   
!      | 4 | 1 | four  | 1 | -1 | 0 |   
!      | 4 | 1 | four  | 1 | -1 | 1 | -1
!      | 4 | 1 | four  | 1 | -1 | 2 |  2
!      | 4 | 1 | four  | 1 | -1 | 2 |  4
!      | 4 | 1 | four  | 1 | -1 | 3 | -3
!      | 4 | 1 | four  | 1 | -1 | 5 | -5
!      | 4 | 1 | four  | 1 | -1 | 5 | -5
!      | 4 | 1 | four  | 1 | -1 |   |  0
!      | 4 | 1 | four  | 1 | -1 |   |   
!      | 4 | 1 | four  | 2 |  2 | 0 |   
!      | 4 | 1 | four  | 2 |  2 | 1 | -1
!      | 4 | 1 | four  | 2 |  2 | 2 |  2
!      | 4 | 1 | four  | 2 |  2 | 2 |  4
!      | 4 | 1 | four  | 2 |  2 | 3 | -3
!      | 4 | 1 | four  | 2 |  2 | 5 | -5
!      | 4 | 1 | four  | 2 |  2 | 5 | -5
!      | 4 | 1 | four  | 2 |  2 |   |  0
!      | 4 | 1 | four  | 2 |  2 |   |   
!      | 4 | 1 | four  | 2 |  4 | 0 |   
!      | 4 | 1 | four  | 2 |  4 | 1 | -1
!      | 4 | 1 | four  | 2 |  4 | 2 |  2
!      | 4 | 1 | four  | 2 |  4 | 2 |  4
!      | 4 | 1 | four  | 2 |  4 | 3 | -3
!      | 4 | 1 | four  | 2 |  4 | 5 | -5
!      | 4 | 1 | four  | 2 |  4 | 5 | -5
!      | 4 | 1 | four  | 2 |  4 |   |  0
!      | 4 | 1 | four  | 2 |  4 |   |   
!      | 4 | 1 | four  | 3 | -3 | 0 |   
!      | 4 | 1 | four  | 3 | -3 | 1 | -1
!      | 4 | 1 | four  | 3 | -3 | 2 |  2
!      | 4 | 1 | four  | 3 | -3 | 2 |  4
!      | 4 | 1 | four  | 3 | -3 | 3 | -3
!      | 4 | 1 | four  | 3 | -3 | 5 | -5
!      | 4 | 1 | four  | 3 | -3 | 5 | -5
!      | 4 | 1 | four  | 3 | -3 |   |  0
!      | 4 | 1 | four  | 3 | -3 |   |   
!      | 4 | 1 | four  | 5 | -5 | 0 |   
!      | 4 | 1 | four  | 5 | -5 | 0 |   
!      | 4 | 1 | four  | 5 | -5 | 1 | -1
!      | 4 | 1 | four  | 5 | -5 | 1 | -1
!      | 4 | 1 | four  | 5 | -5 | 2 |  2
!      | 4 | 1 | four  | 5 | -5 | 2 |  2
!      | 4 | 1 | four  | 5 | -5 | 2 |  4
!      | 4 | 1 | four  | 5 | -5 | 2 |  4
!      | 4 | 1 | four  | 5 | -5 | 3 | -3
!      | 4 | 1 | four  | 5 | -5 | 3 | -3
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 | 5 | -5
!      | 4 | 1 | four  | 5 | -5 |   |  0
!      | 4 | 1 | four  | 5 | -5 |   |  0
!      | 4 | 1 | four  | 5 | -5 |   |   
!      | 4 | 1 | four  | 5 | -5 |   |   
!      | 4 | 1 | four  |   |  0 | 0 |   
!      | 4 | 1 | four  |   |  0 | 1 | -1
!      | 4 | 1 | four  |   |  0 | 2 |  2
!      | 4 | 1 | four  |   |  0 | 2 |  4
!      | 4 | 1 | four  |   |  0 | 3 | -3
!      | 4 | 1 | four  |   |  0 | 5 | -5
!      | 4 | 1 | four  |   |  0 | 5 | -5
!      | 4 | 1 | four  |   |  0 |   |  0
!      | 4 | 1 | four  |   |  0 |   |   
!      | 4 | 1 | four  |   |    | 0 |   
!      | 4 | 1 | four  |   |    | 1 | -1
!      | 4 | 1 | four  |   |    | 2 |  2
!      | 4 | 1 | four  |   |    | 2 |  4
!      | 4 | 1 | four  |   |    | 3 | -3
!      | 4 | 1 | four  |   |    | 5 | -5
!      | 4 | 1 | four  |   |    | 5 | -5
!      | 4 | 1 | four  |   |    |   |  0
!      | 4 | 1 | four  |   |    |   |   
!      | 5 | 0 | five  | 0 |    | 0 |   
!      | 5 | 0 | five  | 0 |    | 1 | -1
!      | 5 | 0 | five  | 0 |    | 2 |  2
!      | 5 | 0 | five  | 0 |    | 2 |  4
!      | 5 | 0 | five  | 0 |    | 3 | -3
!      | 5 | 0 | five  | 0 |    | 5 | -5
!      | 5 | 0 | five  | 0 |    | 5 | -5
!      | 5 | 0 | five  | 0 |    |   |  0
!      | 5 | 0 | five  | 0 |    |   |   
!      | 5 | 0 | five  | 1 | -1 | 0 |   
!      | 5 | 0 | five  | 1 | -1 | 1 | -1
!      | 5 | 0 | five  | 1 | -1 | 2 |  2
!      | 5 | 0 | five  | 1 | -1 | 2 |  4
!      | 5 | 0 | five  | 1 | -1 | 3 | -3
!      | 5 | 0 | five  | 1 | -1 | 5 | -5
!      | 5 | 0 | five  | 1 | -1 | 5 | -5
!      | 5 | 0 | five  | 1 | -1 |   |  0
!      | 5 | 0 | five  | 1 | -1 |   |   
!      | 5 | 0 | five  | 2 |  2 | 0 |   
!      | 5 | 0 | five  | 2 |  2 | 1 | -1
!      | 5 | 0 | five  | 2 |  2 | 2 |  2
!      | 5 | 0 | five  | 2 |  2 | 2 |  4
!      | 5 | 0 | five  | 2 |  2 | 3 | -3
!      | 5 | 0 | five  | 2 |  2 | 5 | -5
!      | 5 | 0 | five  | 2 |  2 | 5 | -5
!      | 5 | 0 | five  | 2 |  2 |   |  0
!      | 5 | 0 | five  | 2 |  2 |   |   
!      | 5 | 0 | five  | 2 |  4 | 0 |   
!      | 5 | 0 | five  | 2 |  4 | 1 | -1
!      | 5 | 0 | five  | 2 |  4 | 2 |  2
!      | 5 | 0 | five  | 2 |  4 | 2 |  4
!      | 5 | 0 | five  | 2 |  4 | 3 | -3
!      | 5 | 0 | five  | 2 |  4 | 5 | -5
!      | 5 | 0 | five  | 2 |  4 | 5 | -5
!      | 5 | 0 | five  | 2 |  4 |   |  0
!      | 5 | 0 | five  | 2 |  4 |   |   
!      | 5 | 0 | five  | 3 | -3 | 0 |   
!      | 5 | 0 | five  | 3 | -3 | 1 | -1
!      | 5 | 0 | five  | 3 | -3 | 2 |  2
!      | 5 | 0 | five  | 3 | -3 | 2 |  4
!      | 5 | 0 | five  | 3 | -3 | 3 | -3
!      | 5 | 0 | five  | 3 | -3 | 5 | -5
!      | 5 | 0 | five  | 3 | -3 | 5 | -5
!      | 5 | 0 | five  | 3 | -3 |   |  0
!      | 5 | 0 | five  | 3 | -3 |   |   
!      | 5 | 0 | five  | 5 | -5 | 0 |   
!      | 5 | 0 | five  | 5 | -5 | 0 |   
!      | 5 | 0 | five  | 5 | -5 | 1 | -1
!      | 5 | 0 | five  | 5 | -5 | 1 | -1
!      | 5 | 0 | five  | 5 | -5 | 2 |  2
!      | 5 | 0 | five  | 5 | -5 | 2 |  2
!      | 5 | 0 | five  | 5 | -5 | 2 |  4
!      | 5 | 0 | five  | 5 | -5 | 2 |  4
!      | 5 | 0 | five  | 5 | -5 | 3 | -3
!      | 5 | 0 | five  | 5 | -5 | 3 | -3
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 | 5 | -5
!      | 5 | 0 | five  | 5 | -5 |   |  0
!      | 5 | 0 | five  | 5 | -5 |   |  0
!      | 5 | 0 | five  | 5 | -5 |   |   
!      | 5 | 0 | five  | 5 | -5 |   |   
!      | 5 | 0 | five  |   |  0 | 0 |   
!      | 5 | 0 | five  |   |  0 | 1 | -1
!      | 5 | 0 | five  |   |  0 | 2 |  2
!      | 5 | 0 | five  |   |  0 | 2 |  4
!      | 5 | 0 | five  |   |  0 | 3 | -3
!      | 5 | 0 | five  |   |  0 | 5 | -5
!      | 5 | 0 | five  |   |  0 | 5 | -5
!      | 5 | 0 | five  |   |  0 |   |  0
!      | 5 | 0 | five  |   |  0 |   |   
!      | 5 | 0 | five  |   |    | 0 |   
!      | 5 | 0 | five  |   |    | 1 | -1
!      | 5 | 0 | five  |   |    | 2 |  2
!      | 5 | 0 | five  |   |    | 2 |  4
!      | 5 | 0 | five  |   |    | 3 | -3
!      | 5 | 0 | five  |   |    | 5 | -5
!      | 5 | 0 | five  |   |    | 5 | -5
!      | 5 | 0 | five  |   |    |   |  0
!      | 5 | 0 | five  |   |    |   |   
!      | 6 | 6 | six   | 0 |    | 0 |   
!      | 6 | 6 | six   | 0 |    | 1 | -1
!      | 6 | 6 | six   | 0 |    | 2 |  2
!      | 6 | 6 | six   | 0 |    | 2 |  4
!      | 6 | 6 | six   | 0 |    | 3 | -3
!      | 6 | 6 | six   | 0 |    | 5 | -5
!      | 6 | 6 | six   | 0 |    | 5 | -5
!      | 6 | 6 | six   | 0 |    |   |  0
!      | 6 | 6 | six   | 0 |    |   |   
!      | 6 | 6 | six   | 1 | -1 | 0 |   
!      | 6 | 6 | six   | 1 | -1 | 1 | -1
!      | 6 | 6 | six   | 1 | -1 | 2 |  2
!      | 6 | 6 | six   | 1 | -1 | 2 |  4
!      | 6 | 6 | six   | 1 | -1 | 3 | -3
!      | 6 | 6 | six   | 1 | -1 | 5 | -5
!      | 6 | 6 | six   | 1 | -1 | 5 | -5
!      | 6 | 6 | six   | 1 | -1 |   |  0
!      | 6 | 6 | six   | 1 | -1 |   |   
!      | 6 | 6 | six   | 2 |  2 | 0 |   
!      | 6 | 6 | six   | 2 |  2 | 1 | -1
!      | 6 | 6 | six   | 2 |  2 | 2 |  2
!      | 6 | 6 | six   | 2 |  2 | 2 |  4
!      | 6 | 6 | six   | 2 |  2 | 3 | -3
!      | 6 | 6 | six   | 2 |  2 | 5 | -5
!      | 6 | 6 | six   | 2 |  2 | 5 | -5
!      | 6 | 6 | six   | 2 |  2 |   |  0
!      | 6 | 6 | six   | 2 |  2 |   |   
!      | 6 | 6 | six   | 2 |  4 | 0 |   
!      | 6 | 6 | six   | 2 |  4 | 1 | -1
!      | 6 | 6 | six   | 2 |  4 | 2 |  2
!      | 6 | 6 | six   | 2 |  4 | 2 |  4
!      | 6 | 6 | six   | 2 |  4 | 3 | -3
!      | 6 | 6 | six   | 2 |  4 | 5 | -5
!      | 6 | 6 | six   | 2 |  4 | 5 | -5
!      | 6 | 6 | six   | 2 |  4 |   |  0
!      | 6 | 6 | six   | 2 |  4 |   |   
!      | 6 | 6 | six   | 3 | -3 | 0 |   
!      | 6 | 6 | six   | 3 | -3 | 1 | -1
!      | 6 | 6 | six   | 3 | -3 | 2 |  2
!      | 6 | 6 | six   | 3 | -3 | 2 |  4
!      | 6 | 6 | six   | 3 | -3 | 3 | -3
!      | 6 | 6 | six   | 3 | -3 | 5 | -5
!      | 6 | 6 | six   | 3 | -3 | 5 | -5
!      | 6 | 6 | six   | 3 | -3 |   |  0
!      | 6 | 6 | six   | 3 | -3 |   |   
!      | 6 | 6 | six   | 5 | -5 | 0 |   
!      | 6 | 6 | six   | 5 | -5 | 0 |   
!      | 6 | 6 | six   | 5 | -5 | 1 | -1
!      | 6 | 6 | six   | 5 | -5 | 1 | -1
!      | 6 | 6 | six   | 5 | -5 | 2 |  2
!      | 6 | 6 | six   | 5 | -5 | 2 |  2
!      | 6 | 6 | six   | 5 | -5 | 2 |  4
!      | 6 | 6 | six   | 5 | -5 | 2 |  4
!      | 6 | 6 | six   | 5 | -5 | 3 | -3
!      | 6 | 6 | six   | 5 | -5 | 3 | -3
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 | 5 | -5
!      | 6 | 6 | six   | 5 | -5 |   |  0
!      | 6 | 6 | six   | 5 | -5 |   |  0
!      | 6 | 6 | six   | 5 | -5 |   |   
!      | 6 | 6 | six   | 5 | -5 |   |   
!      | 6 | 6 | six   |   |  0 | 0 |   
!      | 6 | 6 | six   |   |  0 | 1 | -1
!      | 6 | 6 | six   |   |  0 | 2 |  2
!      | 6 | 6 | six   |   |  0 | 2 |  4
!      | 6 | 6 | six   |   |  0 | 3 | -3
!      | 6 | 6 | six   |   |  0 | 5 | -5
!      | 6 | 6 | six   |   |  0 | 5 | -5
!      | 6 | 6 | six   |   |  0 |   |  0
!      | 6 | 6 | six   |   |  0 |   |   
!      | 6 | 6 | six   |   |    | 0 |   
!      | 6 | 6 | six   |   |    | 1 | -1
!      | 6 | 6 | six   |   |    | 2 |  2
!      | 6 | 6 | six   |   |    | 2 |  4
!      | 6 | 6 | six   |   |    | 3 | -3
!      | 6 | 6 | six   |   |    | 5 | -5
!      | 6 | 6 | six   |   |    | 5 | -5
!      | 6 | 6 | six   |   |    |   |  0
!      | 6 | 6 | six   |   |    |   |   
!      | 7 | 7 | seven | 0 |    | 0 |   
!      | 7 | 7 | seven | 0 |    | 1 | -1
!      | 7 | 7 | seven | 0 |    | 2 |  2
!      | 7 | 7 | seven | 0 |    | 2 |  4
!      | 7 | 7 | seven | 0 |    | 3 | -3
!      | 7 | 7 | seven | 0 |    | 5 | -5
!      | 7 | 7 | seven | 0 |    | 5 | -5
!      | 7 | 7 | seven | 0 |    |   |  0
!      | 7 | 7 | seven | 0 |    |   |   
!      | 7 | 7 | seven | 1 | -1 | 0 |   
!      | 7 | 7 | seven | 1 | -1 | 1 | -1
!      | 7 | 7 | seven | 1 | -1 | 2 |  2
!      | 7 | 7 | seven | 1 | -1 | 2 |  4
!      | 7 | 7 | seven | 1 | -1 | 3 | -3
!      | 7 | 7 | seven | 1 | -1 | 5 | -5
!      | 7 | 7 | seven | 1 | -1 | 5 | -5
!      | 7 | 7 | seven | 1 | -1 |   |  0
!      | 7 | 7 | seven | 1 | -1 |   |   
!      | 7 | 7 | seven | 2 |  2 | 0 |   
!      | 7 | 7 | seven | 2 |  2 | 1 | -1
!      | 7 | 7 | seven | 2 |  2 | 2 |  2
!      | 7 | 7 | seven | 2 |  2 | 2 |  4
!      | 7 | 7 | seven | 2 |  2 | 3 | -3
!      | 7 | 7 | seven | 2 |  2 | 5 | -5
!      | 7 | 7 | seven | 2 |  2 | 5 | -5
!      | 7 | 7 | seven | 2 |  2 |   |  0
!      | 7 | 7 | seven | 2 |  2 |   |   
!      | 7 | 7 | seven | 2 |  4 | 0 |   
!      | 7 | 7 | seven | 2 |  4 | 1 | -1
!      | 7 | 7 | seven | 2 |  4 | 2 |  2
!      | 7 | 7 | seven | 2 |  4 | 2 |  4
!      | 7 | 7 | seven | 2 |  4 | 3 | -3
!      | 7 | 7 | seven | 2 |  4 | 5 | -5
!      | 7 | 7 | seven | 2 |  4 | 5 | -5
!      | 7 | 7 | seven | 2 |  4 |   |  0
!      | 7 | 7 | seven | 2 |  4 |   |   
!      | 7 | 7 | seven | 3 | -3 | 0 |   
!      | 7 | 7 | seven | 3 | -3 | 1 | -1
!      | 7 | 7 | seven | 3 | -3 | 2 |  2
!      | 7 | 7 | seven | 3 | -3 | 2 |  4
!      | 7 | 7 | seven | 3 | -3 | 3 | -3
!      | 7 | 7 | seven | 3 | -3 | 5 | -5
!      | 7 | 7 | seven | 3 | -3 | 5 | -5
!      | 7 | 7 | seven | 3 | -3 |   |  0
!      | 7 | 7 | seven | 3 | -3 |   |   
!      | 7 | 7 | seven | 5 | -5 | 0 |   
!      | 7 | 7 | seven | 5 | -5 | 0 |   
!      | 7 | 7 | seven | 5 | -5 | 1 | -1
!      | 7 | 7 | seven | 5 | -5 | 1 | -1
!      | 7 | 7 | seven | 5 | -5 | 2 |  2
!      | 7 | 7 | seven | 5 | -5 | 2 |  2
!      | 7 | 7 | seven | 5 | -5 | 2 |  4
!      | 7 | 7 | seven | 5 | -5 | 2 |  4
!      | 7 | 7 | seven | 5 | -5 | 3 | -3
!      | 7 | 7 | seven | 5 | -5 | 3 | -3
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 | 5 | -5
!      | 7 | 7 | seven | 5 | -5 |   |  0
!      | 7 | 7 | seven | 5 | -5 |   |  0
!      | 7 | 7 | seven | 5 | -5 |   |   
!      | 7 | 7 | seven | 5 | -5 |   |   
!      | 7 | 7 | seven |   |  0 | 0 |   
!      | 7 | 7 | seven |   |  0 | 1 | -1
!      | 7 | 7 | seven |   |  0 | 2 |  2
!      | 7 | 7 | seven |   |  0 | 2 |  4
!      | 7 | 7 | seven |   |  0 | 3 | -3
!      | 7 | 7 | seven |   |  0 | 5 | -5
!      | 7 | 7 | seven |   |  0 | 5 | -5
!      | 7 | 7 | seven |   |  0 |   |  0
!      | 7 | 7 | seven |   |  0 |   |   
!      | 7 | 7 | seven |   |    | 0 |   
!      | 7 | 7 | seven |   |    | 1 | -1
!      | 7 | 7 | seven |   |    | 2 |  2
!      | 7 | 7 | seven |   |    | 2 |  4
!      | 7 | 7 | seven |   |    | 3 | -3
!      | 7 | 7 | seven |   |    | 5 | -5
!      | 7 | 7 | seven |   |    | 5 | -5
!      | 7 | 7 | seven |   |    |   |  0
!      | 7 | 7 | seven |   |    |   |   
!      | 8 | 8 | eight | 0 |    | 0 |   
!      | 8 | 8 | eight | 0 |    | 1 | -1
!      | 8 | 8 | eight | 0 |    | 2 |  2
!      | 8 | 8 | eight | 0 |    | 2 |  4
!      | 8 | 8 | eight | 0 |    | 3 | -3
!      | 8 | 8 | eight | 0 |    | 5 | -5
!      | 8 | 8 | eight | 0 |    | 5 | -5
!      | 8 | 8 | eight | 0 |    |   |  0
!      | 8 | 8 | eight | 0 |    |   |   
!      | 8 | 8 | eight | 1 | -1 | 0 |   
!      | 8 | 8 | eight | 1 | -1 | 1 | -1
!      | 8 | 8 | eight | 1 | -1 | 2 |  2
!      | 8 | 8 | eight | 1 | -1 | 2 |  4
!      | 8 | 8 | eight | 1 | -1 | 3 | -3
!      | 8 | 8 | eight | 1 | -1 | 5 | -5
!      | 8 | 8 | eight | 1 | -1 | 5 | -5
!      | 8 | 8 | eight | 1 | -1 |   |  0
!      | 8 | 8 | eight | 1 | -1 |   |   
!      | 8 | 8 | eight | 2 |  2 | 0 |   
!      | 8 | 8 | eight | 2 |  2 | 1 | -1
!      | 8 | 8 | eight | 2 |  2 | 2 |  2
!      | 8 | 8 | eight | 2 |  2 | 2 |  4
!      | 8 | 8 | eight | 2 |  2 | 3 | -3
!      | 8 | 8 | eight | 2 |  2 | 5 | -5
!      | 8 | 8 | eight | 2 |  2 | 5 | -5
!      | 8 | 8 | eight | 2 |  2 |   |  0
!      | 8 | 8 | eight | 2 |  2 |   |   
!      | 8 | 8 | eight | 2 |  4 | 0 |   
!      | 8 | 8 | eight | 2 |  4 | 1 | -1
!      | 8 | 8 | eight | 2 |  4 | 2 |  2
!      | 8 | 8 | eight | 2 |  4 | 2 |  4
!      | 8 | 8 | eight | 2 |  4 | 3 | -3
!      | 8 | 8 | eight | 2 |  4 | 5 | -5
!      | 8 | 8 | eight | 2 |  4 | 5 | -5
!      | 8 | 8 | eight | 2 |  4 |   |  0
!      | 8 | 8 | eight | 2 |  4 |   |   
!      | 8 | 8 | eight | 3 | -3 | 0 |   
!      | 8 | 8 | eight | 3 | -3 | 1 | -1
!      | 8 | 8 | eight | 3 | -3 | 2 |  2
!      | 8 | 8 | eight | 3 | -3 | 2 |  4
!      | 8 | 8 | eight | 3 | -3 | 3 | -3
!      | 8 | 8 | eight | 3 | -3 | 5 | -5
!      | 8 | 8 | eight | 3 | -3 | 5 | -5
!      | 8 | 8 | eight | 3 | -3 |   |  0
!      | 8 | 8 | eight | 3 | -3 |   |   
!      | 8 | 8 | eight | 5 | -5 | 0 |   
!      | 8 | 8 | eight | 5 | -5 | 0 |   
!      | 8 | 8 | eight | 5 | -5 | 1 | -1
!      | 8 | 8 | eight | 5 | -5 | 1 | -1
!      | 8 | 8 | eight | 5 | -5 | 2 |  2
!      | 8 | 8 | eight | 5 | -5 | 2 |  2
!      | 8 | 8 | eight | 5 | -5 | 2 |  4
!      | 8 | 8 | eight | 5 | -5 | 2 |  4
!      | 8 | 8 | eight | 5 | -5 | 3 | -3
!      | 8 | 8 | eight | 5 | -5 | 3 | -3
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 | 5 | -5
!      | 8 | 8 | eight | 5 | -5 |   |  0
!      | 8 | 8 | eight | 5 | -5 |   |  0
!      | 8 | 8 | eight | 5 | -5 |   |   
!      | 8 | 8 | eight | 5 | -5 |   |   
!      | 8 | 8 | eight |   |  0 | 0 |   
!      | 8 | 8 | eight |   |  0 | 1 | -1
!      | 8 | 8 | eight |   |  0 | 2 |  2
!      | 8 | 8 | eight |   |  0 | 2 |  4
!      | 8 | 8 | eight |   |  0 | 3 | -3
!      | 8 | 8 | eight |   |  0 | 5 | -5
!      | 8 | 8 | eight |   |  0 | 5 | -5
!      | 8 | 8 | eight |   |  0 |   |  0
!      | 8 | 8 | eight |   |  0 |   |   
!      | 8 | 8 | eight |   |    | 0 |   
!      | 8 | 8 | eight |   |    | 1 | -1
!      | 8 | 8 | eight |   |    | 2 |  2
!      | 8 | 8 | eight |   |    | 2 |  4
!      | 8 | 8 | eight |   |    | 3 | -3
!      | 8 | 8 | eight |   |    | 5 | -5
!      | 8 | 8 | eight |   |    | 5 | -5
!      | 8 | 8 | eight |   |    |   |  0
!      | 8 | 8 | eight |   |    |   |   
!      |   | 0 | zero  | 0 |    | 0 |   
!      |   | 0 | zero  | 0 |    | 1 | -1
!      |   | 0 | zero  | 0 |    | 2 |  2
!      |   | 0 | zero  | 0 |    | 2 |  4
!      |   | 0 | zero  | 0 |    | 3 | -3
!      |   | 0 | zero  | 0 |    | 5 | -5
!      |   | 0 | zero  | 0 |    | 5 | -5
!      |   | 0 | zero  | 0 |    |   |  0
!      |   | 0 | zero  | 0 |    |   |   
!      |   | 0 | zero  | 1 | -1 | 0 |   
!      |   | 0 | zero  | 1 | -1 | 1 | -1
!      |   | 0 | zero  | 1 | -1 | 2 |  2
!      |   | 0 | zero  | 1 | -1 | 2 |  4
!      |   | 0 | zero  | 1 | -1 | 3 | -3
!      |   | 0 | zero  | 1 | -1 | 5 | -5
!      |   | 0 | zero  | 1 | -1 | 5 | -5
!      |   | 0 | zero  | 1 | -1 |   |  0
!      |   | 0 | zero  | 1 | -1 |   |   
!      |   | 0 | zero  | 2 |  2 | 0 |   
!      |   | 0 | zero  | 2 |  2 | 1 | -1
!      |   | 0 | zero  | 2 |  2 | 2 |  2
!      |   | 0 | zero  | 2 |  2 | 2 |  4
!      |   | 0 | zero  | 2 |  2 | 3 | -3
!      |   | 0 | zero  | 2 |  2 | 5 | -5
!      |   | 0 | zero  | 2 |  2 | 5 | -5
!      |   | 0 | zero  | 2 |  2 |   |  0
!      |   | 0 | zero  | 2 |  2 |   |   
!      |   | 0 | zero  | 2 |  4 | 0 |   
!      |   | 0 | zero  | 2 |  4 | 1 | -1
!      |   | 0 | zero  | 2 |  4 | 2 |  2
!      |   | 0 | zero  | 2 |  4 | 2 |  4
!      |   | 0 | zero  | 2 |  4 | 3 | -3
!      |   | 0 | zero  | 2 |  4 | 5 | -5
!      |   | 0 | zero  | 2 |  4 | 5 | -5
!      |   | 0 | zero  | 2 |  4 |   |  0
!      |   | 0 | zero  | 2 |  4 |   |   
!      |   | 0 | zero  | 3 | -3 | 0 |   
!      |   | 0 | zero  | 3 | -3 | 1 | -1
!      |   | 0 | zero  | 3 | -3 | 2 |  2
!      |   | 0 | zero  | 3 | -3 | 2 |  4
!      |   | 0 | zero  | 3 | -3 | 3 | -3
!      |   | 0 | zero  | 3 | -3 | 5 | -5
!      |   | 0 | zero  | 3 | -3 | 5 | -5
!      |   | 0 | zero  | 3 | -3 |   |  0
!      |   | 0 | zero  | 3 | -3 |   |   
!      |   | 0 | zero  | 5 | -5 | 0 |   
!      |   | 0 | zero  | 5 | -5 | 0 |   
!      |   | 0 | zero  | 5 | -5 | 1 | -1
!      |   | 0 | zero  | 5 | -5 | 1 | -1
!      |   | 0 | zero  | 5 | -5 | 2 |  2
!      |   | 0 | zero  | 5 | -5 | 2 |  2
!      |   | 0 | zero  | 5 | -5 | 2 |  4
!      |   | 0 | zero  | 5 | -5 | 2 |  4
!      |   | 0 | zero  | 5 | -5 | 3 | -3
!      |   | 0 | zero  | 5 | -5 | 3 | -3
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 | 5 | -5
!      |   | 0 | zero  | 5 | -5 |   |  0
!      |   | 0 | zero  | 5 | -5 |   |  0
!      |   | 0 | zero  | 5 | -5 |   |   
!      |   | 0 | zero  | 5 | -5 |   |   
!      |   | 0 | zero  |   |  0 | 0 |   
!      |   | 0 | zero  |   |  0 | 1 | -1
!      |   | 0 | zero  |   |  0 | 2 |  2
!      |   | 0 | zero  |   |  0 | 2 |  4
!      |   | 0 | zero  |   |  0 | 3 | -3
!      |   | 0 | zero  |   |  0 | 5 | -5
!      |   | 0 | zero  |   |  0 | 5 | -5
!      |   | 0 | zero  |   |  0 |   |  0
!      |   | 0 | zero  |   |  0 |   |   
!      |   | 0 | zero  |   |    | 0 |   
!      |   | 0 | zero  |   |    | 1 | -1
!      |   | 0 | zero  |   |    | 2 |  2
!      |   | 0 | zero  |   |    | 2 |  4
!      |   | 0 | zero  |   |    | 3 | -3
!      |   | 0 | zero  |   |    | 5 | -5
!      |   | 0 | zero  |   |    | 5 | -5
!      |   | 0 | zero  |   |    |   |  0
!      |   | 0 | zero  |   |    |   |   
!      |   |   | null  | 0 |    | 0 |   
!      |   |   | null  | 0 |    | 1 | -1
!      |   |   | null  | 0 |    | 2 |  2
!      |   |   | null  | 0 |    | 2 |  4
!      |   |   | null  | 0 |    | 3 | -3
!      |   |   | null  | 0 |    | 5 | -5
!      |   |   | null  | 0 |    | 5 | -5
!      |   |   | null  | 0 |    |   |  0
!      |   |   | null  | 0 |    |   |   
!      |   |   | null  | 1 | -1 | 0 |   
!      |   |   | null  | 1 | -1 | 1 | -1
!      |   |   | null  | 1 | -1 | 2 |  2
!      |   |   | null  | 1 | -1 | 2 |  4
!      |   |   | null  | 1 | -1 | 3 | -3
!      |   |   | null  | 1 | -1 | 5 | -5
!      |   |   | null  | 1 | -1 | 5 | -5
!      |   |   | null  | 1 | -1 |   |  0
!      |   |   | null  | 1 | -1 |   |   
!      |   |   | null  | 2 |  2 | 0 |   
!      |   |   | null  | 2 |  2 | 1 | -1
!      |   |   | null  | 2 |  2 | 2 |  2
!      |   |   | null  | 2 |  2 | 2 |  4
!      |   |   | null  | 2 |  2 | 3 | -3
!      |   |   | null  | 2 |  2 | 5 | -5
!      |   |   | null  | 2 |  2 | 5 | -5
!      |   |   | null  | 2 |  2 |   |  0
!      |   |   | null  | 2 |  2 |   |   
!      |   |   | null  | 2 |  4 | 0 |   
!      |   |   | null  | 2 |  4 | 1 | -1
!      |   |   | null  | 2 |  4 | 2 |  2
!      |   |   | null  | 2 |  4 | 2 |  4
!      |   |   | null  | 2 |  4 | 3 | -3
!      |   |   | null  | 2 |  4 | 5 | -5
!      |   |   | null  | 2 |  4 | 5 | -5
!      |   |   | null  | 2 |  4 |   |  0
!      |   |   | null  | 2 |  4 |   |   
!      |   |   | null  | 3 | -3 | 0 |   
!      |   |   | null  | 3 | -3 | 1 | -1
!      |   |   | null  | 3 | -3 | 2 |  2
!      |   |   | null  | 3 | -3 | 2 |  4
!      |   |   | null  | 3 | -3 | 3 | -3
!      |   |   | null  | 3 | -3 | 5 | -5
!      |   |   | null  | 3 | -3 | 5 | -5
!      |   |   | null  | 3 | -3 |   |  0
!      |   |   | null  | 3 | -3 |   |   
!      |   |   | null  | 5 | -5 | 0 |   
!      |   |   | null  | 5 | -5 | 0 |   
!      |   |   | null  | 5 | -5 | 1 | -1
!      |   |   | null  | 5 | -5 | 1 | -1
!      |   |   | null  | 5 | -5 | 2 |  2
!      |   |   | null  | 5 | -5 | 2 |  2
!      |   |   | null  | 5 | -5 | 2 |  4
!      |   |   | null  | 5 | -5 | 2 |  4
!      |   |   | null  | 5 | -5 | 3 | -3
!      |   |   | null  | 5 | -5 | 3 | -3
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 | 5 | -5
!      |   |   | null  | 5 | -5 |   |  0
!      |   |   | null  | 5 | -5 |   |  0
!      |   |   | null  | 5 | -5 |   |   
!      |   |   | null  | 5 | -5 |   |   
!      |   |   | null  |   |  0 | 0 |   
!      |   |   | null  |   |  0 | 1 | -1
!      |   |   | null  |   |  0 | 2 |  2
!      |   |   | null  |   |  0 | 2 |  4
!      |   |   | null  |   |  0 | 3 | -3
!      |   |   | null  |   |  0 | 5 | -5
!      |   |   | null  |   |  0 | 5 | -5
!      |   |   | null  |   |  0 |   |  0
!      |   |   | null  |   |  0 |   |   
!      |   |   | null  |   |    | 0 |   
!      |   |   | null  |   |    | 1 | -1
!      |   |   | null  |   |    | 2 |  2
!      |   |   | null  |   |    | 2 |  4
!      |   |   | null  |   |    | 3 | -3
!      |   |   | null  |   |    | 5 | -5
!      |   |   | null  |   |    | 5 | -5
!      |   |   | null  |   |    |   |  0
!      |   |   | null  |   |    |   |   
! (891 rows)
! 
! --
! --
! -- Inner joins (equi-joins)
! --
! --
! --
! -- Inner joins (equi-joins) with USING clause
! -- The USING syntax changes the shape of the resulting table
! -- by including a column in the USING clause only once in the result.
! --
! -- Inner equi-join on specified column
! SELECT '' AS "xxx", *
!   FROM J1_TBL INNER JOIN J2_TBL USING (i)
!   ORDER BY i, j, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! -- Same as above, slightly different syntax
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL USING (i)
!   ORDER BY i, j, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)
!   ORDER BY a, d;
!  xxx | a | b |   c   | d  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)
!   ORDER BY b, t1.a;
!  xxx | b | a |   c   | a 
! -----+---+---+-------+---
!      | 0 | 5 | five  |  
!      | 0 |   | zero  |  
!      | 2 | 3 | three | 2
!      | 4 | 1 | one   | 2
! (4 rows)
! 
! --
! -- NATURAL JOIN
! -- Inner equi-join on all columns with the same name
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL NATURAL JOIN J2_TBL
!   ORDER BY i, j, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d)
!   ORDER BY a, b, c, d;
!  xxx | a | b |   c   | d  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a)
!   ORDER BY a, b, c, d;
!  xxx | a | b |  c   | d 
! -----+---+---+------+---
!      | 0 |   | zero |  
!      | 2 | 3 | two  | 2
!      | 4 | 1 | four | 2
! (3 rows)
! 
! -- mismatch number of columns
! -- currently, Postgres will fill in with underlying names
! SELECT '' AS "xxx", *
!   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a)
!   ORDER BY a, b, t, k;
!  xxx | a | b |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
! (7 rows)
! 
! --
! -- Inner joins (equi-joins)
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i)
!   ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k;
!  xxx | i | j |   t   | i | k  
! -----+---+---+-------+---+----
!      | 0 |   | zero  | 0 |   
!      | 1 | 4 | one   | 1 | -1
!      | 2 | 3 | two   | 2 |  2
!      | 2 | 3 | two   | 2 |  4
!      | 3 | 2 | three | 3 | -3
!      | 5 | 0 | five  | 5 | -5
!      | 5 | 0 | five  | 5 | -5
! (7 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k)
!   ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k;
!  xxx | i | j |  t   | i | k 
! -----+---+---+------+---+---
!      | 0 |   | zero |   | 0
!      | 2 | 3 | two  | 2 | 2
!      | 4 | 1 | four | 2 | 4
! (3 rows)
! 
! --
! -- Non-equi-joins
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k)
!   ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k;
!  xxx | i | j |   t   | i | k 
! -----+---+---+-------+---+---
!      | 0 |   | zero  | 2 | 2
!      | 0 |   | zero  | 2 | 4
!      | 0 |   | zero  |   | 0
!      | 1 | 4 | one   | 2 | 2
!      | 1 | 4 | one   | 2 | 4
!      | 2 | 3 | two   | 2 | 2
!      | 2 | 3 | two   | 2 | 4
!      | 3 | 2 | three | 2 | 4
!      | 4 | 1 | four  | 2 | 4
! (9 rows)
! 
! --
! -- Outer joins
! -- Note that OUTER is a noise word
! --
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   | null  |   
!      |   | 0 | zero  |   
! (13 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   | null  |   
!      |   | 0 | zero  |   
! (13 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i)
!   ORDER BY i, j, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      |   |   |       |  0
!      |   |   |       |   
! (9 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL RIGHT JOIN J2_TBL USING (i)
!   ORDER BY i, j, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      |   |   |       |  0
!      |   |   |       |   
! (9 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   |       |  0
!      |   |   | null  |   
!      |   | 0 | zero  |   
!      |   |   |       |   
! (15 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL FULL JOIN J2_TBL USING (i)
!   ORDER BY i, k, t;
!  xxx | i | j |   t   | k  
! -----+---+---+-------+----
!      | 0 |   | zero  |   
!      | 1 | 4 | one   | -1
!      | 2 | 3 | two   |  2
!      | 2 | 3 | two   |  4
!      | 3 | 2 | three | -3
!      | 4 | 1 | four  |   
!      | 5 | 0 | five  | -5
!      | 5 | 0 | five  | -5
!      | 6 | 6 | six   |   
!      | 7 | 7 | seven |   
!      | 8 | 8 | eight |   
!      |   |   |       |  0
!      |   |   | null  |   
!      |   | 0 | zero  |   
!      |   |   |       |   
! (15 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);
!  xxx | i | j | t | k 
! -----+---+---+---+---
! (0 rows)
! 
! SELECT '' AS "xxx", *
!   FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);
!  xxx | i | j |  t  | k  
! -----+---+---+-----+----
!      | 1 | 4 | one | -1
! (1 row)
! 
! --
! -- More complicated constructs
! --
! --
! -- Multiway full join
! --
! CREATE TABLE t1 (name TEXT, n INTEGER);
! CREATE TABLE t2 (name TEXT, n INTEGER);
! CREATE TABLE t3 (name TEXT, n INTEGER);
! INSERT INTO t1 VALUES ( 'bb', 11 );
! INSERT INTO t2 VALUES ( 'bb', 12 );
! INSERT INTO t2 VALUES ( 'cc', 22 );
! INSERT INTO t2 VALUES ( 'ee', 42 );
! INSERT INTO t3 VALUES ( 'bb', 13 );
! INSERT INTO t3 VALUES ( 'cc', 23 );
! INSERT INTO t3 VALUES ( 'dd', 33 );
! SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name) 
! ORDER BY name,t1.n, t2.n, t3.n;
!  name | n  | n  | n  
! ------+----+----+----
!  bb   | 11 | 12 | 13
!  cc   |    | 22 | 23
!  dd   |    |    | 33
!  ee   |    | 42 |   
! (4 rows)
! 
! --
! -- Test interactions of join syntax and subqueries
! --
! -- Basic cases (we expect planner to pull up the subquery here)
! SELECT * FROM
! (SELECT * FROM t2) as s2
! INNER JOIN
! (SELECT * FROM t3) s3
! USING (name)
! ORDER BY name, s2.n, s3.n;
!  name | n  | n  
! ------+----+----
!  bb   | 12 | 13
!  cc   | 22 | 23
! (2 rows)
! 
! SELECT * FROM
! (SELECT * FROM t2) as s2
! LEFT JOIN
! (SELECT * FROM t3) s3
! USING (name)
! ORDER BY name, s2.n, s3.n;
!  name | n  | n  
! ------+----+----
!  bb   | 12 | 13
!  cc   | 22 | 23
!  ee   | 42 |   
! (3 rows)
! 
! SELECT * FROM
! (SELECT * FROM t2) as s2
! FULL JOIN
! (SELECT * FROM t3) s3
! USING (name)
! ORDER BY name, s2.n, s3.n;
!  name | n  | n  
! ------+----+----
!  bb   | 12 | 13
!  cc   | 22 | 23
!  dd   |    | 33
!  ee   | 42 |   
! (4 rows)
! 
! -- Cases with non-nullable expressions in subquery results;
! -- make sure these go to null as expected
! SELECT * FROM
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL INNER JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3
! ORDER BY name, s2_n, s3_n;
!  name | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------
!  bb   |   12 |    2 |   13 |    3
!  cc   |   22 |    2 |   23 |    3
! (2 rows)
! 
! SELECT * FROM
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL LEFT JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3
! ORDER BY name, s2_n, s3_n;
!  name | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------
!  bb   |   12 |    2 |   13 |    3
!  cc   |   22 |    2 |   23 |    3
!  ee   |   42 |    2 |      |     
! (3 rows)
! 
! SELECT * FROM
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL FULL JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3
! ORDER BY name, s2_n, s3_n;
!  name | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------
!  bb   |   12 |    2 |   13 |    3
!  cc   |   22 |    2 |   23 |    3
!  dd   |      |      |   33 |    3
!  ee   |   42 |    2 |      |     
! (4 rows)
! 
! SELECT * FROM
! (SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
! NATURAL INNER JOIN
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL INNER JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3
! ORDER BY name, s1_n, s2_n, s3_n;
!  name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------+------+------
!  bb   |   11 |    1 |   12 |    2 |   13 |    3
! (1 row)
! 
! SELECT * FROM
! (SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
! NATURAL FULL JOIN
! (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
! NATURAL FULL JOIN
! (SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3
! ORDER BY name, s1_n, s2_n, s3_n;
!  name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
! ------+------+------+------+------+------+------
!  bb   |   11 |    1 |   12 |    2 |   13 |    3
!  cc   |      |      |   22 |    2 |   23 |    3
!  dd   |      |      |      |      |   33 |    3
!  ee   |      |      |   42 |    2 |      |     
! (4 rows)
! 
! SELECT * FROM
! (SELECT name, n as s1_n FROM t1) as s1
! NATURAL FULL JOIN
!   (SELECT * FROM
!     (SELECT name, n as s2_n FROM t2) as s2
!     NATURAL FULL JOIN
!     (SELECT name, n as s3_n FROM t3) as s3
!   ) ss2
!   ORDER BY name, s1_n, s2_n, s3_n;
!  name | s1_n | s2_n | s3_n 
! ------+------+------+------
!  bb   |   11 |   12 |   13
!  cc   |      |   22 |   23
!  dd   |      |      |   33
!  ee   |      |   42 |     
! (4 rows)
! 
! SELECT * FROM
! (SELECT name, n as s1_n FROM t1) as s1
! NATURAL FULL JOIN
!   (SELECT * FROM
!     (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
!     NATURAL FULL JOIN
!     (SELECT name, n as s3_n FROM t3) as s3
!   ) ss2
!   ORDER BY name, s1_n, s2_n, s3_n;
!  name | s1_n | s2_n | s2_2 | s3_n 
! ------+------+------+------+------
!  bb   |   11 |   12 |    2 |   13
!  cc   |      |   22 |    2 |   23
!  dd   |      |      |      |   33
!  ee   |      |   42 |    2 |     
! (4 rows)
! 
! -- Test for propagation of nullability constraints into sub-joins
! create temp table x (x1 int, x2 int);
! insert into x values (1,11);
! insert into x values (2,22);
! insert into x values (3,null);
! insert into x values (4,44);
! insert into x values (5,null);
! create temp table y (y1 int, y2 int);
! insert into y values (1,111);
! insert into y values (2,222);
! insert into y values (3,333);
! insert into y values (4,null);
! select * from x ORDER BY x1;
!  x1 | x2 
! ----+----
!   1 | 11
!   2 | 22
!   3 |   
!   4 | 44
!   5 |   
! (5 rows)
! 
! select * from y ORDER BY y1;
!  y1 | y2  
! ----+-----
!   1 | 111
!   2 | 222
!   3 | 333
!   4 |    
! (4 rows)
! 
! select * from x left join y on (x1 = y1 and x2 is not null) ORDER BY x1, x2, y1, y2;
!  x1 | x2 | y1 | y2  
! ----+----+----+-----
!   1 | 11 |  1 | 111
!   2 | 22 |  2 | 222
!   3 |    |    |    
!   4 | 44 |  4 |    
!   5 |    |    |    
! (5 rows)
! 
! select * from x left join y on (x1 = y1 and y2 is not null) ORDER BY x1, x2, y1, y2;
!  x1 | x2 | y1 | y2  
! ----+----+----+-----
!   1 | 11 |  1 | 111
!   2 | 22 |  2 | 222
!   3 |    |  3 | 333
!   4 | 44 |    |    
!   5 |    |    |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1) ORDER BY x1, x2, y1, y2;
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |   3 |    
!   4 | 44 |  4 |     |   4 |  44
!   5 |    |    |     |   5 |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1 and x2 is not null) ORDER BY x1, x2, y1, y2;
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |     |    
!   4 | 44 |  4 |     |   4 |  44
!   5 |    |    |     |     |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1 and y2 is not null) ORDER BY x1, x2, y1, y2;
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |   3 |    
!   4 | 44 |  4 |     |     |    
!   5 |    |    |     |     |    
! (5 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1 and xx2 is not null) ORDER BY x1, x2, y1, y2;
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |     |    
!   4 | 44 |  4 |     |   4 |  44
!   5 |    |    |     |     |    
! (5 rows)
! 
! -- these should NOT give the same answers as above
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1) where (x2 is not null)
! ORDER BY x1, x2, y1, y2;
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   4 | 44 |  4 |     |   4 |  44
! (3 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1) where (y2 is not null)
! ORDER BY x1, x2, y1, y2;
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   3 |    |  3 | 333 |   3 |    
! (3 rows)
! 
! select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
! on (x1 = xx1) where (xx2 is not null)
! ORDER BY x1, x2, y1, y2;
!  x1 | x2 | y1 | y2  | xx1 | xx2 
! ----+----+----+-----+-----+-----
!   1 | 11 |  1 | 111 |   1 |  11
!   2 | 22 |  2 | 222 |   2 |  22
!   4 | 44 |  4 |     |   4 |  44
! (3 rows)
! 
! --
! -- regression test: check for bug with propagation of implied equality
! -- to outside an IN
! --
! select count(*) from tenk1 a where unique1 in
!   (select unique1 from tenk1 b join tenk1 c using (unique1)
!    where b.unique2 = 42);
!  count 
! -------
!      1
! (1 row)
! 
! --
! -- regression test: check for failure to generate a plan with multiple
! -- degenerate IN clauses
! --
! select count(*) from tenk1 x where
!   x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
!   x.unique1 = 0 and
!   x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
!  count 
! -------
!      1
! (1 row)
! 
! -- try that with GEQO too
! begin;
! set geqo = on;
! set geqo_threshold = 2;
! select count(*) from tenk1 x where
!   x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
!   x.unique1 = 0 and
!   x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
!  count 
! -------
!      1
! (1 row)
! 
! rollback;
! --
! -- regression test: be sure we cope with proven-dummy append rels
! --
! explain (costs off)
! select aa, bb, unique1, unique1
!   from tenk1 right join b on aa = unique1
!   where bb < bb and bb is null;
!         QUERY PLAN        
! --------------------------
!  Result
!    One-Time Filter: false
! (2 rows)
! 
! select aa, bb, unique1, unique1
!   from tenk1 right join b on aa = unique1
!   where bb < bb and bb is null;
!  aa | bb | unique1 | unique1 
! ----+----+---------+---------
! (0 rows)
! 
! --
! -- regression test: check handling of empty-FROM subquery underneath outer join
! --
! explain (costs off)
! select * from int8_tbl i1 left join (int8_tbl i2 join
!   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
! order by 1, 2;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Sort
!    Sort Key: i1.q1, i1.q2
!    ->  Hash Left Join
!          Hash Cond: (i1.q2 = i2.q2)
!          ->  Remote Subquery Scan on all (datanode_1)
!                ->  Seq Scan on int8_tbl i1
!          ->  Hash
!                ->  Hash Join
!                      Hash Cond: (i2.q1 = (123))
!                      ->  Remote Subquery Scan on all (datanode_1)
!                            ->  Seq Scan on int8_tbl i2
!                      ->  Hash
!                            ->  Result
! (13 rows)
! 
! select * from int8_tbl i1 left join (int8_tbl i2 join
!   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
! order by 1, 2;
!         q1        |        q2         | q1  |        q2        |  x  
! ------------------+-------------------+-----+------------------+-----
!               123 |               456 | 123 |              456 | 123
!               123 |  4567890123456789 | 123 | 4567890123456789 | 123
!  4567890123456789 | -4567890123456789 |     |                  |    
!  4567890123456789 |               123 |     |                  |    
!  4567890123456789 |  4567890123456789 | 123 | 4567890123456789 | 123
! (5 rows)
! 
! --
! -- regression test: check a case where join_clause_is_movable_into() gives
! -- an imprecise result, causing an assertion failure
! --
! select count(*)
! from
!   (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2
!    from tenk1 t1
!    left join tenk1 t2 on t1.unique1 = t2.unique1
!    join tenk1 t3 on t1.unique2 = t3.unique2) ss,
!   tenk1 t4,
!   tenk1 t5
! where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;
!  count 
! -------
!   1000
! (1 row)
! 
! --
! -- regression test: check a case where we formerly missed including an EC
! -- enforcement clause because it was expected to be handled at scan level
! --
! explain (costs off)
! select a.f1, b.f1, t.thousand, t.tenthous from
!   tenk1 t,
!   (select sum(f1)+1 as f1 from int4_tbl i4a) a,
!   (select sum(f1) as f1 from int4_tbl i4b) b
! where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
!                                                          QUERY PLAN                                                          
! -----------------------------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Nested Loop
!          ->  Aggregate
!                ->  Seq Scan on int4_tbl i4b
!          ->  Nested Loop
!                Join Filter: ((sum(i4b.f1)) = ((sum(i4a.f1) + 1)))
!                ->  Aggregate
!                      ->  Seq Scan on int4_tbl i4a
!                ->  Index Only Scan using tenk1_thous_tenthous on tenk1 t
!                      Index Cond: ((thousand = (sum(i4b.f1))) AND (tenthous = ((((sum(i4a.f1) + 1)) + (sum(i4b.f1))) + 999)))
! (10 rows)
! 
! select a.f1, b.f1, t.thousand, t.tenthous from
!   tenk1 t,
!   (select sum(f1)+1 as f1 from int4_tbl i4a) a,
!   (select sum(f1) as f1 from int4_tbl i4b) b
! where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
!  f1 | f1 | thousand | tenthous 
! ----+----+----------+----------
! (0 rows)
! 
! --
! -- Clean up
! --
! DROP TABLE t1;
! DROP TABLE t2;
! DROP TABLE t3;
! DROP TABLE J1_TBL;
! DROP TABLE J2_TBL;
! -- Both DELETE and UPDATE allow the specification of additional tables
! -- to "join" against to determine which rows should be modified.
! CREATE TEMP TABLE t1 (a int, b int);
! CREATE TEMP TABLE t2 (a int, b int);
! CREATE TEMP TABLE t3 (x int, y int);
! INSERT INTO t1 VALUES (5, 10);
! INSERT INTO t1 VALUES (15, 20);
! INSERT INTO t1 VALUES (100, 100);
! INSERT INTO t1 VALUES (200, 1000);
! INSERT INTO t2 VALUES (200, 2000);
! INSERT INTO t3 VALUES (5, 20);
! INSERT INTO t3 VALUES (6, 7);
! INSERT INTO t3 VALUES (7, 8);
! INSERT INTO t3 VALUES (500, 100);
! DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;
! SELECT * FROM t3 ORDER By x, y;
!   x  |  y  
! -----+-----
!    6 |   7
!    7 |   8
!  500 | 100
! (3 rows)
! 
! DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;
! ERROR:  could not plan this distributed delete
! DETAIL:  correlated or complex DELETE is currently not supported in Postgres-XL.
! SELECT * FROM t3 ORDER By x, y;
!   x  |  y  
! -----+-----
!    6 |   7
!    7 |   8
!  500 | 100
! (3 rows)
! 
! DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;
! SELECT * FROM t3 ORDER By x, y;
!  x | y 
! ---+---
! (0 rows)
! 
! -- Test join against inheritance tree
! create temp table t2a () inherits (t2);
! insert into t2a values (200, 2001);
! select * from t1 left join t2 on (t1.a = t2.a) order by 1,2,3,4;
!   a  |  b   |  a  |  b   
! -----+------+-----+------
!    5 |   10 |     |     
!   15 |   20 |     |     
!  100 |  100 |     |     
!  200 | 1000 | 200 | 2000
!  200 | 1000 | 200 | 2001
! (5 rows)
! 
! -- Test matching of column name with wrong alias
! select t1.x from t1 join t3 on (t1.a = t3.x);
! ERROR:  column t1.x does not exist
! LINE 1: select t1.x from t1 join t3 on (t1.a = t3.x);
!                ^
! HINT:  Perhaps you meant to reference the column "t3.x".
! --
! -- regression test for 8.1 merge right join bug
! --
! CREATE TEMP TABLE tt1 ( tt1_id int4, joincol int4 );
! INSERT INTO tt1 VALUES (1, 11);
! INSERT INTO tt1 VALUES (2, NULL);
! CREATE TEMP TABLE tt2 ( tt2_id int4, joincol int4 );
! INSERT INTO tt2 VALUES (21, 11);
! INSERT INTO tt2 VALUES (22, 11);
! set enable_hashjoin to off;
! set enable_nestloop to off;
! -- these should give the same results
! select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol 
!       ORDER BY tt1_id, tt2_id; 
!  tt1_id | joincol | tt2_id | joincol 
! --------+---------+--------+---------
!       1 |      11 |     21 |      11
!       1 |      11 |     22 |      11
!       2 |         |        |        
! (3 rows)
! 
! select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol 
!       ORDER BY tt1_id, tt2_id; 
!  tt1_id | joincol | tt2_id | joincol 
! --------+---------+--------+---------
!       1 |      11 |     21 |      11
!       1 |      11 |     22 |      11
!       2 |         |        |        
! (3 rows)
! 
! reset enable_hashjoin;
! reset enable_nestloop;
! --
! -- regression test for bug #13908 (hash join with skew tuples & nbatch increase)
! --
! set work_mem to '64kB';
! set enable_mergejoin to off;
! explain (costs off)
! select count(*) from tenk1 a, tenk1 b
!   where a.hundred = b.thousand and (b.fivethous % 10) < 10;
!                                     QUERY PLAN                                     
! -----------------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          ->  Partial Aggregate
!                ->  Hash Join
!                      Hash Cond: (a.hundred = b.thousand)
!                      ->  Index Only Scan using tenk1_hundred on tenk1 a
!                      ->  Hash
!                            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                  ->  Seq Scan on tenk1 b
!                                        Filter: ((fivethous % 10) < 10)
! (10 rows)
! 
! select count(*) from tenk1 a, tenk1 b
!   where a.hundred = b.thousand and (b.fivethous % 10) < 10;
!  count  
! --------
!  100000
! (1 row)
! 
! reset work_mem;
! reset enable_mergejoin;
! --
! -- regression test for 8.2 bug with improper re-ordering of left joins
! --
! create temp table tt3(f1 int, f2 text);
! insert into tt3 select x, repeat('xyzzy', 100) from generate_series(1,10000) x;
! create index tt3i on tt3(f1);
! analyze tt3;
! create temp table tt4(f1 int);
! insert into tt4 values (0),(1),(9999);
! analyze tt4;
! SELECT a.f1
! FROM tt4 a
! LEFT JOIN (
!         SELECT b.f1
!         FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)
!         WHERE c.f1 IS NULL
! ) AS d ON (a.f1 = d.f1)
! WHERE d.f1 IS NULL ORDER BY f1;
!   f1  
! ------
!     0
!     1
!  9999
! (3 rows)
! 
! --
! -- regression test for proper handling of outer joins within antijoins
! --
! create temp table tt4x(c1 int, c2 int, c3 int);
! explain (costs off)
! select * from tt4x t1
! where not exists (
!   select 1 from tt4x t2
!     left join tt4x t3 on t2.c3 = t3.c1
!     left join ( select t5.c1 as c1
!                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1
!               ) a1 on t3.c2 = a1.c1
!   where t1.c1 = t2.c2
! );
!                                           QUERY PLAN                                           
! -----------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Hash Anti Join
!          Hash Cond: (t1.c1 = t2.c2)
!          ->  Seq Scan on tt4x t1
!          ->  Hash
!                ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: c2
!                      ->  Merge Right Join
!                            Merge Cond: (t5.c1 = t3.c2)
!                            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                  ->  Merge Join
!                                        Merge Cond: (t4.c2 = t5.c1)
!                                        ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                              Distribute results by H: c2
!                                              ->  Sort
!                                                    Sort Key: t4.c2
!                                                    ->  Seq Scan on tt4x t4
!                                        ->  Sort
!                                              Sort Key: t5.c1
!                                              ->  Seq Scan on tt4x t5
!                            ->  Sort
!                                  Sort Key: t3.c2
!                                  ->  Merge Left Join
!                                        Merge Cond: (t2.c3 = t3.c1)
!                                        ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                              Distribute results by H: c3
!                                              ->  Sort
!                                                    Sort Key: t2.c3
!                                                    ->  Seq Scan on tt4x t2
!                                        ->  Sort
!                                              Sort Key: t3.c1
!                                              ->  Seq Scan on tt4x t3
! (32 rows)
! 
! --
! -- regression test for problems of the sort depicted in bug #3494
! --
! create temp table tt5(f1 int, f2 int);
! create temp table tt6(f1 int, f2 int);
! insert into tt5 values(1, 10);
! insert into tt5 values(1, 11);
! insert into tt6 values(1, 9);
! insert into tt6 values(1, 2);
! insert into tt6 values(2, 9);
! select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2 
!       ORDER BY tt5.f1, tt5.f2, tt6.f1, tt6.f2;
!  f1 | f2 | f1 | f2 
! ----+----+----+----
!   1 | 10 |  1 |  9
! (1 row)
! 
! --
! -- regression test for problems of the sort depicted in bug #3588
! --
! create temp table xx (pkxx int);
! create temp table yy (pkyy int, pkxx int);
! insert into xx values (1);
! insert into xx values (2);
! insert into xx values (3);
! insert into yy values (101, 1);
! insert into yy values (201, 2);
! insert into yy values (301, NULL);
! select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,
!        xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx
! from yy
!      left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy
!      left join xx xxa on yya.pkxx = xxa.pkxx
!      left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx 
!      ORDER BY yy_pkyy, yy_pkxx, yya_pkyy, xxa_pkxx, xxb_pkxx;
!  yy_pkyy | yy_pkxx | yya_pkyy | xxa_pkxx | xxb_pkxx 
! ---------+---------+----------+----------+----------
!      101 |       1 |      101 |        1 |        1
!      201 |       2 |          |          |        1
!      301 |         |          |          |        1
! (3 rows)
! 
! --
! -- regression test for improper pushing of constants across outer-join clauses
! -- (as seen in early 8.2.x releases)
! --
! create temp table zt1 (f1 int primary key);
! create temp table zt2 (f2 int primary key);
! create temp table zt3 (f3 int primary key);
! insert into zt1 values(53);
! insert into zt2 values(53);
! select * from
!   zt2 left join zt3 on (f2 = f3)
!       left join zt1 on (f3 = f1)
! where f2 = 53 
! ORDER BY f1, f2, f3;
!  f2 | f3 | f1 
! ----+----+----
!  53 |    |   
! (1 row)
! 
! create temp view zv1 as select *,'dummy'::text AS junk from zt1;
! select * from
!   zt2 left join zt3 on (f2 = f3)
!       left join zv1 on (f3 = f1)
! where f2 = 53 
! ORDER BY f1, f2, f3;
!  f2 | f3 | f1 | junk 
! ----+----+----+------
!  53 |    |    | 
! (1 row)
! 
! --
! -- regression test for improper extraction of OR indexqual conditions
! -- (as seen in early 8.3.x releases)
! --
! select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred
! from tenk1 a left join tenk1 b on a.unique2 = b.tenthous
! where a.unique1 = 42 and
!       ((b.unique2 is null and a.ten = 2) or b.hundred = 3);
!  unique2 | ten | tenthous | unique2 | hundred 
! ---------+-----+----------+---------+---------
! (0 rows)
! 
! --
! -- test proper positioning of one-time quals in EXISTS (8.4devel bug)
! --
! prepare foo(bool) as
!   select count(*) from tenk1 a left join tenk1 b
!     on (a.unique2 = b.unique1 and exists
!         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));
! execute foo(true);
!  count 
! -------
!  10000
! (1 row)
! 
! execute foo(false);
!  count 
! -------
!  10000
! (1 row)
! 
! --
! -- test for sane behavior with noncanonical merge clauses, per bug #4926
! --
! begin;
! set enable_mergejoin = 1;
! set enable_hashjoin = 0;
! set enable_nestloop = 0;
! create temp table a (i integer);
! create temp table b (x integer, y integer);
! select * from a left join b on i = x and i = y and x = i;
!  i | x | y 
! ---+---+---
! (0 rows)
! 
! rollback;
! --
! -- test NULL behavior of whole-row Vars, per bug #5025
! --
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! select t1.q2, count(t2.*)
! from int8_tbl t1 left join
!   (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2
!   on (t1.q2 = t2.q1)
! group by t1.q2 order by 1;
!         q2         | count 
! -------------------+-------
!  -4567890123456789 |     0
!                123 |     2
!                456 |     0
!   4567890123456789 |     6
! (4 rows)
! 
! --
! -- test incorrect failure to NULL pulled-up subexpressions
! --
! begin;
! create temp table a (
!      code char not null,
!      constraint a_pk primary key (code)
! );
! create temp table b (
!      a char not null,
!      num integer not null,
!      constraint b_pk primary key (a, num)
! );
! create temp table c (
!      name char not null,
!      a char,
!      constraint c_pk primary key (name)
! );
! insert into a (code) values ('p');
! insert into a (code) values ('q');
! insert into b (a, num) values ('p', 1);
! insert into b (a, num) values ('p', 2);
! insert into c (name, a) values ('A', 'p');
! insert into c (name, a) values ('B', 'q');
! insert into c (name, a) values ('C', null);
! select c.name, ss.code, ss.b_cnt, ss.const
! from c left join
!   (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const
!    from a left join
!      (select count(1) as cnt, b.a from b group by b.a) as b_grp
!      on a.code = b_grp.a
!   ) as ss
!   on (c.a = ss.code)
! order by c.name;
!  name | code | b_cnt | const 
! ------+------+-------+-------
!  A    | p    |     2 |    -1
!  B    | q    |     0 |    -1
!  C    |      |       |      
! (3 rows)
! 
! rollback;
! --
! -- test incorrect handling of placeholders that only appear in targetlists,
! -- per bug #6154
! --
! SELECT * FROM
! ( SELECT 1 as key1 ) sub1
! LEFT JOIN
! ( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM
!     ( SELECT 1 as key3 ) sub3
!     LEFT JOIN
!     ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
!         ( SELECT 1 as key5 ) sub5
!         LEFT JOIN
!         ( SELECT 2 as key6, 42 as value1 ) sub6
!         ON sub5.key5 = sub6.key6
!     ) sub4
!     ON sub4.key5 = sub3.key3
! ) sub2
! ON sub1.key1 = sub2.key3;
!  key1 | key3 | value2 | value3 
! ------+------+--------+--------
!     1 |    1 |      1 |      1
! (1 row)
! 
! -- test the path using join aliases, too
! SELECT * FROM
! ( SELECT 1 as key1 ) sub1
! LEFT JOIN
! ( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM
!     ( SELECT 1 as key3 ) sub3
!     LEFT JOIN
!     ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
!         ( SELECT 1 as key5 ) sub5
!         LEFT JOIN
!         ( SELECT 2 as key6, 42 as value1 ) sub6
!         ON sub5.key5 = sub6.key6
!     ) sub4
!     ON sub4.key5 = sub3.key3
! ) sub2
! ON sub1.key1 = sub2.key3;
!  key1 | key3 | value2 | value3 
! ------+------+--------+--------
!     1 |    1 |      1 |      1
! (1 row)
! 
! --
! -- test case where a PlaceHolderVar is used as a nestloop parameter
! --
! EXPLAIN (NUM_NODES OFF, NODES OFF, COSTS OFF)
! SELECT qq, unique1
!   FROM
!   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
!   FULL OUTER JOIN
!   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
!   USING (qq)
!   INNER JOIN tenk1 c ON qq = unique2;
!                                                   QUERY PLAN                                                   
! ---------------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Nested Loop
!          ->  Hash Full Join
!                Hash Cond: (COALESCE(a.q1, '0'::bigint) = COALESCE(b.q2, '-1'::bigint))
!                ->  Seq Scan on int8_tbl a
!                ->  Hash
!                      ->  Seq Scan on int8_tbl b
!          ->  Index Scan using tenk1_unique2 on tenk1 c
!                Index Cond: (unique2 = COALESCE((COALESCE(a.q1, '0'::bigint)), (COALESCE(b.q2, '-1'::bigint))))
! (9 rows)
! 
! SELECT qq, unique1
!   FROM
!   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
!   FULL OUTER JOIN
!   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
!   USING (qq)
!   INNER JOIN tenk1 c ON qq = unique2;
!  qq  | unique1 
! -----+---------
!  123 |    4596
!  123 |    4596
!  456 |    7318
! (3 rows)
! 
! --
! -- nested nestloops can require nested PlaceHolderVars
! --
! create temp table nt1 (
!   id int primary key,
!   a1 boolean,
!   a2 boolean
! );
! create temp table nt2 (
!   id int primary key,
!   nt1_id int,
!   b1 boolean,
!   b2 boolean
! );
! create temp table nt3 (
!   id int primary key,
!   nt2_id int,
!   c1 boolean
! );
! insert into nt1 values (1,true,true);
! insert into nt1 values (2,true,false);
! insert into nt1 values (3,false,false);
! insert into nt2 values (1,1,true,true);
! insert into nt2 values (2,2,true,false);
! insert into nt2 values (3,3,false,false);
! insert into nt3 values (1,1,true);
! insert into nt3 values (2,2,false);
! insert into nt3 values (3,3,true);
! explain(num_nodes off, nodes off, costs off) 
! select nt3.id
! from nt3 as nt3
!   left join
!     (select nt2.*, (nt2.b1 and ss1.a3) AS b3
!      from nt2 as nt2
!        left join
!          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
!          on ss1.id = nt2.nt1_id
!     ) as ss2
!     on ss2.id = nt3.nt2_id
! where nt3.id = 1 and ss2.b3;
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Nested Loop
!          ->  Remote Subquery Scan on all
!                Distribute results by H: nt1_id
!                ->  Nested Loop
!                      ->  Remote Subquery Scan on all
!                            Distribute results by H: nt2_id
!                            ->  Index Scan using nt3_pkey on nt3
!                                  Index Cond: (id = 1)
!                      ->  Index Scan using nt2_pkey on nt2
!                            Index Cond: (id = nt3.nt2_id)
!          ->  Index Only Scan using nt1_pkey on nt1
!                Index Cond: (id = nt2.nt1_id)
!                Filter: (nt2.b1 AND (id IS NOT NULL))
! (14 rows)
! 
! select nt3.id
! from nt3 as nt3
!   left join
!     (select nt2.*, (nt2.b1 and ss1.a3) AS b3
!      from nt2 as nt2
!        left join
!          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
!          on ss1.id = nt2.nt1_id
!     ) as ss2
!     on ss2.id = nt3.nt2_id
! where nt3.id = 1 and ss2.b3;
!  id 
! ----
!   1
! (1 row)
! 
! --
! -- test case where a PlaceHolderVar is propagated into a subquery
! --
! explain (num_nodes off, nodes off, costs off)
! select * from
!   int8_tbl t1 left join
!   (select q1 as x, 42 as y from int8_tbl t2) ss
!   on t1.q2 = ss.x
! where
!   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
! order by 1,2;
!                                  QUERY PLAN                                  
! -----------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Sort
!          Sort Key: t1.q1, t1.q2
!          ->  Hash Left Join
!                Hash Cond: (t1.q2 = t2.q1)
!                Filter: (1 = (SubPlan 1))
!                ->  Seq Scan on int8_tbl t1
!                ->  Hash
!                      ->  Seq Scan on int8_tbl t2
!                SubPlan 1
!                  ->  Limit
!                        ->  Remote Subquery Scan on all
!                              ->  Limit
!                                    ->  Result
!                                          One-Time Filter: ((42) IS NOT NULL)
!                                          ->  Seq Scan on int8_tbl t3
! (16 rows)
! 
! select * from
!   int8_tbl t1 left join
!   (select q1 as x, 42 as y from int8_tbl t2) ss
!   on t1.q2 = ss.x
! where
!   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
! order by 1,2;
!         q1        |        q2        |        x         | y  
! ------------------+------------------+------------------+----
!               123 | 4567890123456789 | 4567890123456789 | 42
!               123 | 4567890123456789 | 4567890123456789 | 42
!               123 | 4567890123456789 | 4567890123456789 | 42
!  4567890123456789 |              123 |              123 | 42
!  4567890123456789 |              123 |              123 | 42
!  4567890123456789 | 4567890123456789 | 4567890123456789 | 42
!  4567890123456789 | 4567890123456789 | 4567890123456789 | 42
!  4567890123456789 | 4567890123456789 | 4567890123456789 | 42
! (8 rows)
! 
! --
! -- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE
! --
! select * from int4_tbl a full join int4_tbl b on true order by 1,2;
!      f1      |     f1      
! -------------+-------------
!  -2147483647 | -2147483647
!  -2147483647 |     -123456
!  -2147483647 |           0
!  -2147483647 |      123456
!  -2147483647 |  2147483647
!      -123456 | -2147483647
!      -123456 |     -123456
!      -123456 |           0
!      -123456 |      123456
!      -123456 |  2147483647
!            0 | -2147483647
!            0 |     -123456
!            0 |           0
!            0 |      123456
!            0 |  2147483647
!       123456 | -2147483647
!       123456 |     -123456
!       123456 |           0
!       123456 |      123456
!       123456 |  2147483647
!   2147483647 | -2147483647
!   2147483647 |     -123456
!   2147483647 |           0
!   2147483647 |      123456
!   2147483647 |  2147483647
! (25 rows)
! 
! select * from int4_tbl a full join int4_tbl b on false order by 1,2;
!      f1      |     f1      
! -------------+-------------
!  -2147483647 |            
!      -123456 |            
!            0 |            
!       123456 |            
!   2147483647 |            
!              | -2147483647
!              |     -123456
!              |           0
!              |      123456
!              |  2147483647
! (10 rows)
! 
! --
! -- test for ability to use a cartesian join when necessary
! --
! explain (num_nodes off, nodes off, costs off)
! select * from
!   tenk1 join int4_tbl on f1 = twothousand,
!   int4(sin(1)) q1,
!   int4(sin(0)) q2
! where q1 = thousand or q2 = thousand;
!                                      QUERY PLAN                                     
! ------------------------------------------------------------------------------------
!  Hash Join
!    Hash Cond: (tenk1.twothousand = int4_tbl.f1)
!    ->  Nested Loop
!          ->  Nested Loop
!                ->  Function Scan on q1
!                ->  Function Scan on q2
!          ->  Materialize
!                ->  Remote Subquery Scan on all
!                      ->  Bitmap Heap Scan on tenk1
!                            Recheck Cond: ((q1.q1 = thousand) OR (q2.q2 = thousand))
!                            ->  BitmapOr
!                                  ->  Bitmap Index Scan on tenk1_thous_tenthous
!                                        Index Cond: (q1.q1 = thousand)
!                                  ->  Bitmap Index Scan on tenk1_thous_tenthous
!                                        Index Cond: (q2.q2 = thousand)
!    ->  Hash
!          ->  Remote Subquery Scan on all
!                ->  Seq Scan on int4_tbl
! (18 rows)
! 
! explain (num_nodes off, nodes off, costs off)
! select * from
!   tenk1 join int4_tbl on f1 = twothousand,
!   int4(sin(1)) q1,
!   int4(sin(0)) q2
! where thousand = (q1 + q2);
!                                 QUERY PLAN                                
! --------------------------------------------------------------------------
!  Hash Join
!    Hash Cond: (tenk1.twothousand = int4_tbl.f1)
!    ->  Nested Loop
!          ->  Nested Loop
!                ->  Function Scan on q1
!                ->  Function Scan on q2
!          ->  Materialize
!                ->  Remote Subquery Scan on all
!                      ->  Bitmap Heap Scan on tenk1
!                            Recheck Cond: (thousand = (q1.q1 + q2.q2))
!                            ->  Bitmap Index Scan on tenk1_thous_tenthous
!                                  Index Cond: (thousand = (q1.q1 + q2.q2))
!    ->  Hash
!          ->  Remote Subquery Scan on all
!                ->  Seq Scan on int4_tbl
! (15 rows)
! 
! --
! -- test ability to generate a suitable plan for a star-schema query
! --
! explain (costs off)
! select * from
!   tenk1, int8_tbl a, int8_tbl b
! where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;
!                        QUERY PLAN                        
! ---------------------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Merge Join
!          Merge Cond: (tenk1.thousand = a.q1)
!          ->  Sort
!                Sort Key: tenk1.thousand
!                ->  Merge Join
!                      Merge Cond: (tenk1.tenthous = b.q1)
!                      ->  Sort
!                            Sort Key: tenk1.tenthous
!                            ->  Seq Scan on tenk1
!                      ->  Sort
!                            Sort Key: b.q1
!                            ->  Seq Scan on int8_tbl b
!                                  Filter: (q2 = 2)
!          ->  Sort
!                Sort Key: a.q1
!                ->  Seq Scan on int8_tbl a
!                      Filter: (q2 = 1)
! (19 rows)
! 
! --
! -- test a corner case in which we shouldn't apply the star-schema optimization
! --
! explain (costs off, nodes off)
! select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
!   tenk1 t1
!   inner join int4_tbl i1
!     left join (select v1.x2, v2.y1, 11 AS d1
!                from (values(1,0)) v1(x1,x2)
!                left join (values(3,1)) v2(y1,y2)
!                on v1.x1 = v2.y2) subq1
!     on (i1.f1 = subq1.x2)
!   on (t1.unique2 = subq1.d1)
!   left join tenk1 t2
!   on (subq1.y1 = t2.unique1)
! where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
!                                     QUERY PLAN                                     
! -----------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (t1.stringu1 > t2.stringu2)
!    ->  Nested Loop
!          Join Filter: ((0) = i1.f1)
!          ->  Nested Loop
!                ->  Nested Loop
!                      Join Filter: ((1) = (1))
!                      ->  Result
!                      ->  Result
!                ->  Materialize
!                      ->  Remote Subquery Scan on all
!                            ->  Index Scan using tenk1_unique2 on tenk1 t1
!                                  Index Cond: ((unique2 = (11)) AND (unique2 < 42))
!          ->  Materialize
!                ->  Remote Subquery Scan on all
!                      ->  Seq Scan on int4_tbl i1
!    ->  Materialize
!          ->  Remote Subquery Scan on all
!                ->  Index Scan using tenk1_unique1 on tenk1 t2
!                      Index Cond: (unique1 = (3))
! (20 rows)
! 
! select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
!   tenk1 t1
!   inner join int4_tbl i1
!     left join (select v1.x2, v2.y1, 11 AS d1
!                from (values(1,0)) v1(x1,x2)
!                left join (values(3,1)) v2(y1,y2)
!                on v1.x1 = v2.y2) subq1
!     on (i1.f1 = subq1.x2)
!   on (t1.unique2 = subq1.d1)
!   left join tenk1 t2
!   on (subq1.y1 = t2.unique1)
! where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
!  unique2 | stringu1 | unique1 | stringu2 
! ---------+----------+---------+----------
!       11 | WFAAAA   |       3 | LKIAAA
! (1 row)
! 
! -- variant that isn't quite a star-schema case
! select ss1.d1 from
!   tenk1 as t1
!   inner join tenk1 as t2
!   on t1.tenthous = t2.ten
!   inner join
!     int8_tbl as i8
!     left join int4_tbl as i4
!       inner join (select 64::information_schema.cardinal_number as d1
!                   from tenk1 t3,
!                        lateral (select abs(t3.unique1) + random()) ss0(x)
!                   where t3.fivethous < 0) as ss1
!       on i4.f1 = ss1.d1
!     on i8.q1 = i4.f1
!   on t1.tenthous = ss1.d1
! where t1.unique1 < i4.f1;
!  d1 
! ----
! (0 rows)
! 
! --
! -- test extraction of restriction OR clauses from join OR clause
! -- (we used to only do this for indexable clauses)
! --
! explain (costs off)
! select * from tenk1 a join tenk1 b on
!   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);
!                                            QUERY PLAN                                            
! -------------------------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.hundred = 4)))
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          ->  Bitmap Heap Scan on tenk1 b
!                Recheck Cond: ((unique1 = 2) OR (hundred = 4))
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_unique1
!                            Index Cond: (unique1 = 2)
!                      ->  Bitmap Index Scan on tenk1_hundred
!                            Index Cond: (hundred = 4)
!    ->  Materialize
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                ->  Bitmap Heap Scan on tenk1 a
!                      Recheck Cond: ((unique1 = 1) OR (unique2 = 3))
!                      ->  BitmapOr
!                            ->  Bitmap Index Scan on tenk1_unique1
!                                  Index Cond: (unique1 = 1)
!                            ->  Bitmap Index Scan on tenk1_unique2
!                                  Index Cond: (unique2 = 3)
! (19 rows)
! 
! explain (costs off)
! select * from tenk1 a join tenk1 b on
!   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);
!                                          QUERY PLAN                                          
! ---------------------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.ten = 4)))
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          ->  Seq Scan on tenk1 b
!                Filter: ((unique1 = 2) OR (ten = 4))
!    ->  Materialize
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                ->  Bitmap Heap Scan on tenk1 a
!                      Recheck Cond: ((unique1 = 1) OR (unique2 = 3))
!                      ->  BitmapOr
!                            ->  Bitmap Index Scan on tenk1_unique1
!                                  Index Cond: (unique1 = 1)
!                            ->  Bitmap Index Scan on tenk1_unique2
!                                  Index Cond: (unique2 = 3)
! (14 rows)
! 
! explain (costs off)
! select * from tenk1 a join tenk1 b on
!   (a.unique1 = 1 and b.unique1 = 2) or
!   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);
!                                                       QUERY PLAN                                                      
! ----------------------------------------------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR (((a.unique2 = 3) OR (a.unique2 = 7)) AND (b.hundred = 4)))
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          ->  Bitmap Heap Scan on tenk1 b
!                Recheck Cond: ((unique1 = 2) OR (hundred = 4))
!                ->  BitmapOr
!                      ->  Bitmap Index Scan on tenk1_unique1
!                            Index Cond: (unique1 = 2)
!                      ->  Bitmap Index Scan on tenk1_hundred
!                            Index Cond: (hundred = 4)
!    ->  Materialize
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                ->  Bitmap Heap Scan on tenk1 a
!                      Recheck Cond: ((unique1 = 1) OR (unique2 = 3) OR (unique2 = 7))
!                      ->  BitmapOr
!                            ->  Bitmap Index Scan on tenk1_unique1
!                                  Index Cond: (unique1 = 1)
!                            ->  Bitmap Index Scan on tenk1_unique2
!                                  Index Cond: (unique2 = 3)
!                            ->  Bitmap Index Scan on tenk1_unique2
!                                  Index Cond: (unique2 = 7)
! (21 rows)
! 
! --
! -- test placement of movable quals in a parameterized join tree
! --
! explain (num_nodes off, nodes off, costs off)
! select * from tenk1 t1 left join
!   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
!   on t1.hundred = t2.hundred and t1.ten = t3.ten
! where t1.unique1 = 1;
!                                       QUERY PLAN                                      
! --------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Nested Loop Left Join
!          ->  Remote Subquery Scan on all
!                Distribute results by H: hundred
!                ->  Index Scan using tenk1_unique1 on tenk1 t1
!                      Index Cond: (unique1 = 1)
!          ->  Materialize
!                ->  Remote Subquery Scan on all
!                      Distribute results by H: hundred
!                      ->  Nested Loop
!                            Join Filter: (t1.ten = t3.ten)
!                            ->  Remote Subquery Scan on all
!                                  Distribute results by H: thousand
!                                  ->  Bitmap Heap Scan on tenk1 t2
!                                        Recheck Cond: (t1.hundred = hundred)
!                                        ->  Bitmap Index Scan on tenk1_hundred
!                                              Index Cond: (t1.hundred = hundred)
!                            ->  Materialize
!                                  ->  Remote Subquery Scan on all
!                                        Distribute results by H: unique2
!                                        ->  Index Scan using tenk1_unique2 on tenk1 t3
!                                              Index Cond: (unique2 = t2.thousand)
! (22 rows)
! 
! explain (num_nodes off, nodes off, costs off)
! select * from tenk1 t1 left join
!   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
!   on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten
! where t1.unique1 = 1;
!                                       QUERY PLAN                                      
! --------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Nested Loop Left Join
!          ->  Remote Subquery Scan on all
!                Distribute results by H: hundred
!                ->  Index Scan using tenk1_unique1 on tenk1 t1
!                      Index Cond: (unique1 = 1)
!          ->  Materialize
!                ->  Remote Subquery Scan on all
!                      Distribute results by H: hundred
!                      ->  Nested Loop
!                            Join Filter: ((t1.ten + t2.ten) = t3.ten)
!                            ->  Remote Subquery Scan on all
!                                  Distribute results by H: thousand
!                                  ->  Bitmap Heap Scan on tenk1 t2
!                                        Recheck Cond: (t1.hundred = hundred)
!                                        ->  Bitmap Index Scan on tenk1_hundred
!                                              Index Cond: (t1.hundred = hundred)
!                            ->  Materialize
!                                  ->  Remote Subquery Scan on all
!                                        Distribute results by H: unique2
!                                        ->  Index Scan using tenk1_unique2 on tenk1 t3
!                                              Index Cond: (unique2 = t2.thousand)
! (22 rows)
! 
! explain (num_nodes off, nodes off, costs off)
! select count(*) from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
!   join int4_tbl on b.thousand = f1;
!                                            QUERY PLAN                                            
! -------------------------------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Nested Loop Left Join
!                      Join Filter: (a.unique2 = b.unique1)
!                      ->  Remote Subquery Scan on all
!                            Distribute results by H: thousand
!                            ->  Nested Loop
!                                  ->  Remote Subquery Scan on all
!                                        Distribute results by H: unique2
!                                        ->  Nested Loop
!                                              ->  Seq Scan on int4_tbl
!                                              ->  Bitmap Heap Scan on tenk1 b
!                                                    Recheck Cond: (thousand = int4_tbl.f1)
!                                                    ->  Bitmap Index Scan on tenk1_thous_tenthous
!                                                          Index Cond: (thousand = int4_tbl.f1)
!                                  ->  Index Scan using tenk1_unique1 on tenk1 a
!                                        Index Cond: (unique1 = b.unique2)
!                      ->  Materialize
!                            ->  Remote Subquery Scan on all
!                                  Distribute results by H: thousand
!                                  ->  Index Only Scan using tenk1_thous_tenthous on tenk1 c
!                                        Index Cond: (thousand = a.thousand)
! (23 rows)
! 
! select count(*) from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
!   join int4_tbl on b.thousand = f1;
!  count 
! -------
!     10
! (1 row)
! 
! explain (num_nodes off, nodes off, costs off)
! select b.unique1 from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
!   join int4_tbl i1 on b.thousand = f1
!   right join int4_tbl i2 on i2.f1 = b.tenthous
!   order by 1;
!                                                  QUERY PLAN                                                  
! -------------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Sort
!          Sort Key: b.unique1
!          ->  Nested Loop Left Join
!                ->  Remote Subquery Scan on all
!                      Distribute results by H: f1
!                      ->  Seq Scan on int4_tbl i2
!                ->  Materialize
!                      ->  Remote Subquery Scan on all
!                            Distribute results by H: tenthous
!                            ->  Nested Loop
!                                  Join Filter: (b.thousand = i1.f1)
!                                  ->  Nested Loop Left Join
!                                        Join Filter: (b.unique1 = 42)
!                                        ->  Nested Loop
!                                              ->  Remote Subquery Scan on all
!                                                    Distribute results by H: unique2
!                                                    ->  Index Scan using tenk1_thous_tenthous on tenk1 b
!                                                          Index Cond: (i2.f1 = tenthous)
!                                              ->  Index Scan using tenk1_unique1 on tenk1 a
!                                                    Index Cond: (unique1 = b.unique2)
!                                        ->  Materialize
!                                              ->  Remote Subquery Scan on all
!                                                    ->  Index Only Scan using tenk1_thous_tenthous on tenk1 c
!                                                          Index Cond: (thousand = a.thousand)
!                                  ->  Seq Scan on int4_tbl i1
! (26 rows)
! 
! select b.unique1 from
!   tenk1 a join tenk1 b on a.unique1 = b.unique2
!   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
!   join int4_tbl i1 on b.thousand = f1
!   right join int4_tbl i2 on i2.f1 = b.tenthous
!   order by 1;
!  unique1 
! ---------
!        0
!         
!         
!         
!         
! (5 rows)
! 
! explain (num_nodes off, nodes off, costs off)
! select * from
! (
!   select unique1, q1, coalesce(unique1, -1) + q1 as fault
!   from int8_tbl left join tenk1 on (q2 = unique2)
! ) ss
! where fault = 122
! order by fault;
!                                    QUERY PLAN                                   
! --------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Nested Loop Left Join
!          Filter: ((COALESCE(tenk1.unique1, '-1'::integer) + int8_tbl.q1) = 122)
!          ->  Remote Subquery Scan on all
!                Distribute results by H: q2
!                ->  Seq Scan on int8_tbl
!          ->  Materialize
!                ->  Remote Subquery Scan on all
!                      Distribute results by H: unique2
!                      ->  Index Scan using tenk1_unique2 on tenk1
!                            Index Cond: (int8_tbl.q2 = unique2)
! (11 rows)
! 
! select * from
! (
!   select unique1, q1, coalesce(unique1, -1) + q1 as fault
!   from int8_tbl left join tenk1 on (q2 = unique2)
! ) ss
! where fault = 122
! order by fault;
!  unique1 | q1  | fault 
! ---------+-----+-------
!          | 123 |   122
! (1 row)
! 
! --
! -- test handling of potential equivalence clauses above outer joins
! --
! explain (num_nodes off, nodes off, costs off)
! select q1, unique2, thousand, hundred
!   from int8_tbl a left join tenk1 b on q1 = unique2
!   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
!                                          QUERY PLAN                                         
! --------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Nested Loop Left Join
!          Filter: ((COALESCE(b.thousand, 123) = a.q1) AND (a.q1 = COALESCE(b.hundred, 123)))
!          ->  Remote Subquery Scan on all
!                Distribute results by H: q1
!                ->  Seq Scan on int8_tbl a
!          ->  Materialize
!                ->  Remote Subquery Scan on all
!                      Distribute results by H: COALESCE(thousand, 123)
!                      ->  Index Scan using tenk1_unique2 on tenk1 b
!                            Index Cond: (a.q1 = unique2)
! (11 rows)
! 
! select q1, unique2, thousand, hundred
!   from int8_tbl a left join tenk1 b on q1 = unique2
!   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
!  q1 | unique2 | thousand | hundred 
! ----+---------+----------+---------
! (0 rows)
! 
! explain (num_nodes off, nodes off, costs off)
! select f1, unique2, case when unique2 is null then f1 else 0 end
!   from int4_tbl a left join tenk1 b on f1 = unique2
!   where (case when unique2 is null then f1 else 0 end) = 0;
!                                 QUERY PLAN                                
! --------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Nested Loop Left Join
!          Filter: (CASE WHEN (b.unique2 IS NULL) THEN a.f1 ELSE 0 END = 0)
!          ->  Remote Subquery Scan on all
!                Distribute results by H: f1
!                ->  Seq Scan on int4_tbl a
!          ->  Materialize
!                ->  Remote Subquery Scan on all
!                      Distribute results by H: unique2
!                      ->  Index Only Scan using tenk1_unique2 on tenk1 b
!                            Index Cond: (unique2 = a.f1)
! (11 rows)
! 
! select f1, unique2, case when unique2 is null then f1 else 0 end
!   from int4_tbl a left join tenk1 b on f1 = unique2
!   where (case when unique2 is null then f1 else 0 end) = 0;
!  f1 | unique2 | case 
! ----+---------+------
!   0 |       0 |    0
! (1 row)
! 
! --
! -- another case with equivalence clauses above outer joins (bug #8591)
! --
! explain (costs off)
! select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
!   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
!   where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
!                                                   QUERY PLAN                                                   
! ---------------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Nested Loop Left Join
!          ->  Nested Loop Left Join
!                Filter: (COALESCE(b.twothousand, a.twothousand) = 44)
!                ->  Index Scan using tenk1_unique2 on tenk1 a
!                      Index Cond: (unique2 < 10)
!                ->  Materialize
!                      ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: thousand
!                            ->  Bitmap Heap Scan on tenk1 b
!                                  Recheck Cond: (thousand = a.unique1)
!                                  ->  Bitmap Index Scan on tenk1_thous_tenthous
!                                        Index Cond: (thousand = a.unique1)
!          ->  Materialize
!                ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      ->  Index Scan using tenk1_unique2 on tenk1 c
!                            Index Cond: ((unique2 = COALESCE(b.twothousand, a.twothousand)) AND (unique2 = 44))
! (17 rows)
! 
! select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
!   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
!   where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
!  unique1 | unique1 | unique1 | coalesce 
! ---------+---------+---------+----------
! (0 rows)
! 
! --
! -- check handling of join aliases when flattening multiple levels of subquery
! --
! explain (verbose, costs off)
! select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
!   (values (0),(1)) foo1(join_key)
! left join
!   (select join_key, bug_field from
!     (select ss1.join_key, ss1.bug_field from
!       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
!     ) foo2
!    left join
!     (select unique2 as join_key from tenk1 i2) ss2
!    using (join_key)
!   ) foo3
! using (join_key);
!                                          QUERY PLAN                                         
! --------------------------------------------------------------------------------------------
!  Nested Loop Left Join
!    Output: "*VALUES*".column1, i1.f1, (666)
!    Join Filter: ("*VALUES*".column1 = i1.f1)
!    ->  Values Scan on "*VALUES*"
!          Output: "*VALUES*".column1
!    ->  Materialize
!          Output: i1.f1, (666)
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Output: i1.f1, 666
!                ->  Nested Loop Left Join
!                      Output: i1.f1, 666
!                      ->  Remote Subquery Scan on all (datanode_1)
!                            Output: i1.f1
!                            Distribute results by H: f1
!                            ->  Seq Scan on public.int4_tbl i1
!                                  Output: i1.f1
!                      ->  Materialize
!                            Output: i2.unique2
!                            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                  Output: i2.unique2
!                                  Distribute results by H: unique2
!                                  Sort Key: i2.unique2
!                                  ->  Index Only Scan using tenk1_unique2 on public.tenk1 i2
!                                        Output: i2.unique2
!                                        Index Cond: (i2.unique2 = i1.f1)
! (25 rows)
! 
! select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
!   (values (0),(1)) foo1(join_key)
! left join
!   (select join_key, bug_field from
!     (select ss1.join_key, ss1.bug_field from
!       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
!     ) foo2
!    left join
!     (select unique2 as join_key from tenk1 i2) ss2
!    using (join_key)
!   ) foo3
! using (join_key);
!  foo1_id | foo3_id | bug_field 
! ---------+---------+-----------
!        0 |       0 |       666
!        1 |         |          
! (2 rows)
! 
! --
! -- test successful handling of nested outer joins with degenerate join quals
! --
! explain (verbose, costs off)
! select t1.* from
!   text_tbl t1
!   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
!     left join int8_tbl i8
!       left join (select *, null::int as d2 from int8_tbl i8b2) b2
!       on (i8.q1 = b2.q1)
!     on (b2.d2 = b1.q2)
!   on (t1.f1 = b1.d1)
!   left join int4_tbl i4
!   on (i8.q2 = i4.f1);
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    Output: t1.f1
!    ->  Hash Left Join
!          Output: t1.f1
!          Hash Cond: (i8.q2 = i4.f1)
!          ->  Nested Loop Left Join
!                Output: t1.f1, i8.q2
!                Join Filter: (t1.f1 = '***'::text)
!                ->  Seq Scan on public.text_tbl t1
!                      Output: t1.f1
!                ->  Materialize
!                      Output: i8.q2
!                      ->  Hash Right Join
!                            Output: i8.q2
!                            Hash Cond: ((NULL::integer) = i8b1.q2)
!                            ->  Hash Left Join
!                                  Output: i8.q2, (NULL::integer)
!                                  Hash Cond: (i8.q1 = i8b2.q1)
!                                  ->  Seq Scan on public.int8_tbl i8
!                                        Output: i8.q1, i8.q2
!                                  ->  Hash
!                                        Output: i8b2.q1, (NULL::integer)
!                                        ->  Seq Scan on public.int8_tbl i8b2
!                                              Output: i8b2.q1, NULL::integer
!                            ->  Hash
!                                  Output: i8b1.q2
!                                  ->  Seq Scan on public.int8_tbl i8b1
!                                        Output: i8b1.q2
!          ->  Hash
!                Output: i4.f1
!                ->  Seq Scan on public.int4_tbl i4
!                      Output: i4.f1
! (32 rows)
! 
! select t1.* from
!   text_tbl t1
!   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
!     left join int8_tbl i8
!       left join (select *, null::int as d2 from int8_tbl i8b2) b2
!       on (i8.q1 = b2.q1)
!     on (b2.d2 = b1.q2)
!   on (t1.f1 = b1.d1)
!   left join int4_tbl i4
!   on (i8.q2 = i4.f1);
!         f1         
! -------------------
!  hi de ho neighbor
!  doh!
! (2 rows)
! 
! explain (verbose, costs off)
! select t1.* from
!   text_tbl t1
!   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
!     left join int8_tbl i8
!       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2
!       on (i8.q1 = b2.q1)
!     on (b2.d2 = b1.q2)
!   on (t1.f1 = b1.d1)
!   left join int4_tbl i4
!   on (i8.q2 = i4.f1);
!                                     QUERY PLAN                                    
! ----------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    Output: t1.f1
!    ->  Hash Left Join
!          Output: t1.f1
!          Hash Cond: (i8.q2 = i4.f1)
!          ->  Nested Loop Left Join
!                Output: t1.f1, i8.q2
!                Join Filter: (t1.f1 = '***'::text)
!                ->  Seq Scan on public.text_tbl t1
!                      Output: t1.f1
!                ->  Materialize
!                      Output: i8.q2
!                      ->  Hash Right Join
!                            Output: i8.q2
!                            Hash Cond: ((NULL::integer) = i8b1.q2)
!                            ->  Hash Right Join
!                                  Output: i8.q2, (NULL::integer)
!                                  Hash Cond: (i8b2.q1 = i8.q1)
!                                  ->  Nested Loop
!                                        Output: i8b2.q1, NULL::integer
!                                        ->  Seq Scan on public.int8_tbl i8b2
!                                              Output: i8b2.q1, i8b2.q2
!                                        ->  Materialize
!                                              ->  Seq Scan on public.int4_tbl i4b2
!                                  ->  Hash
!                                        Output: i8.q1, i8.q2
!                                        ->  Seq Scan on public.int8_tbl i8
!                                              Output: i8.q1, i8.q2
!                            ->  Hash
!                                  Output: i8b1.q2
!                                  ->  Seq Scan on public.int8_tbl i8b1
!                                        Output: i8b1.q2
!          ->  Hash
!                Output: i4.f1
!                ->  Seq Scan on public.int4_tbl i4
!                      Output: i4.f1
! (36 rows)
! 
! select t1.* from
!   text_tbl t1
!   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
!     left join int8_tbl i8
!       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2
!       on (i8.q1 = b2.q1)
!     on (b2.d2 = b1.q2)
!   on (t1.f1 = b1.d1)
!   left join int4_tbl i4
!   on (i8.q2 = i4.f1);
!         f1         
! -------------------
!  hi de ho neighbor
!  doh!
! (2 rows)
! 
! explain (verbose, costs off)
! select t1.* from
!   text_tbl t1
!   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
!     left join int8_tbl i8
!       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2
!                  where q1 = f1) b2
!       on (i8.q1 = b2.q1)
!     on (b2.d2 = b1.q2)
!   on (t1.f1 = b1.d1)
!   left join int4_tbl i4
!   on (i8.q2 = i4.f1);
!                                     QUERY PLAN                                    
! ----------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    Output: t1.f1
!    ->  Hash Left Join
!          Output: t1.f1
!          Hash Cond: (i8.q2 = i4.f1)
!          ->  Nested Loop Left Join
!                Output: t1.f1, i8.q2
!                Join Filter: (t1.f1 = '***'::text)
!                ->  Seq Scan on public.text_tbl t1
!                      Output: t1.f1
!                ->  Materialize
!                      Output: i8.q2
!                      ->  Hash Right Join
!                            Output: i8.q2
!                            Hash Cond: ((NULL::integer) = i8b1.q2)
!                            ->  Hash Right Join
!                                  Output: i8.q2, (NULL::integer)
!                                  Hash Cond: (i8b2.q1 = i8.q1)
!                                  ->  Hash Join
!                                        Output: i8b2.q1, NULL::integer
!                                        Hash Cond: (i8b2.q1 = i4b2.f1)
!                                        ->  Seq Scan on public.int8_tbl i8b2
!                                              Output: i8b2.q1, i8b2.q2
!                                        ->  Hash
!                                              Output: i4b2.f1
!                                              ->  Seq Scan on public.int4_tbl i4b2
!                                                    Output: i4b2.f1
!                                  ->  Hash
!                                        Output: i8.q1, i8.q2
!                                        ->  Seq Scan on public.int8_tbl i8
!                                              Output: i8.q1, i8.q2
!                            ->  Hash
!                                  Output: i8b1.q2
!                                  ->  Seq Scan on public.int8_tbl i8b1
!                                        Output: i8b1.q2
!          ->  Hash
!                Output: i4.f1
!                ->  Seq Scan on public.int4_tbl i4
!                      Output: i4.f1
! (39 rows)
! 
! select t1.* from
!   text_tbl t1
!   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
!     left join int8_tbl i8
!       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2
!                  where q1 = f1) b2
!       on (i8.q1 = b2.q1)
!     on (b2.d2 = b1.q2)
!   on (t1.f1 = b1.d1)
!   left join int4_tbl i4
!   on (i8.q2 = i4.f1);
!         f1         
! -------------------
!  hi de ho neighbor
!  doh!
! (2 rows)
! 
! explain (verbose, costs off)
! select * from
!   text_tbl t1
!   inner join int8_tbl i8
!   on i8.q2 = 456
!   right join text_tbl t2
!   on t1.f1 = 'doh!'
!   left join int4_tbl i4
!   on i8.q1 = i4.f1;
!                           QUERY PLAN                          
! --------------------------------------------------------------
!  Nested Loop Left Join
!    Output: t1.f1, i8.q1, i8.q2, t2.f1, i4.f1
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          Output: t2.f1
!          ->  Seq Scan on public.text_tbl t2
!                Output: t2.f1
!    ->  Materialize
!          Output: i8.q1, i8.q2, i4.f1, t1.f1
!          ->  Remote Subquery Scan on all (datanode_2)
!                Output: i8.q1, i8.q2, i4.f1, t1.f1
!                ->  Nested Loop
!                      Output: i8.q1, i8.q2, i4.f1, t1.f1
!                      ->  Nested Loop Left Join
!                            Output: i8.q1, i8.q2, i4.f1
!                            Join Filter: (i8.q1 = i4.f1)
!                            ->  Seq Scan on public.int8_tbl i8
!                                  Output: i8.q1, i8.q2
!                                  Filter: (i8.q2 = 456)
!                            ->  Seq Scan on public.int4_tbl i4
!                                  Output: i4.f1
!                      ->  Seq Scan on public.text_tbl t1
!                            Output: t1.f1
!                            Filter: (t1.f1 = 'doh!'::text)
! (23 rows)
! 
! select * from
!   text_tbl t1
!   inner join int8_tbl i8
!   on i8.q2 = 456
!   right join text_tbl t2
!   on t1.f1 = 'doh!'
!   left join int4_tbl i4
!   on i8.q1 = i4.f1;
!   f1  | q1  | q2  |        f1         | f1 
! ------+-----+-----+-------------------+----
!  doh! | 123 | 456 | hi de ho neighbor |   
!  doh! | 123 | 456 | doh!              |   
! (2 rows)
! 
! --
! -- test for appropriate join order in the presence of lateral references
! --
! explain (verbose, costs off)
! select * from
!   text_tbl t1
!   left join int8_tbl i8
!   on i8.q2 = 123,
!   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss
! where t1.f1 = ss.f1;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Nested Loop
!    Output: t1.f1, i8.q1, i8.q2, (i8.q1), t2.f1
!    Join Filter: (t1.f1 = t2.f1)
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          Output: t1.f1, i8.q1, i8.q2
!          ->  Nested Loop Left Join
!                Output: t1.f1, i8.q1, i8.q2
!                ->  Seq Scan on public.text_tbl t1
!                      Output: t1.f1
!                ->  Materialize
!                      Output: i8.q1, i8.q2
!                      ->  Seq Scan on public.int8_tbl i8
!                            Output: i8.q1, i8.q2
!                            Filter: (i8.q2 = 123)
!    ->  Limit
!          Output: (i8.q1), t2.f1
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Output: i8.q1, t2.f1
!                ->  Limit
!                      Output: (i8.q1), t2.f1
!                      ->  Seq Scan on public.text_tbl t2
!                            Output: i8.q1, t2.f1
! (22 rows)
! 
! select * from
!   text_tbl t1
!   left join int8_tbl i8
!   on i8.q2 = 123,
!   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss
! where t1.f1 = ss.f1;
!         f1         |        q1        | q2  |        q1        |        f1         
! -------------------+------------------+-----+------------------+-------------------
!  hi de ho neighbor | 4567890123456789 | 123 | 4567890123456789 | hi de ho neighbor
! (1 row)
! 
! explain (verbose, costs off)
! select * from
!   text_tbl t1
!   left join int8_tbl i8
!   on i8.q2 = 123,
!   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,
!   lateral (select ss1.* from text_tbl t3 limit 1) as ss2
! where t1.f1 = ss2.f1;
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Nested Loop
!    Output: t1.f1, i8.q1, i8.q2, (i8.q1), t2.f1, ((i8.q1)), (t2.f1)
!    Join Filter: (t1.f1 = (t2.f1))
!    ->  Nested Loop
!          Output: t1.f1, i8.q1, i8.q2, (i8.q1), t2.f1
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Output: t1.f1, i8.q1, i8.q2
!                ->  Nested Loop Left Join
!                      Output: t1.f1, i8.q1, i8.q2
!                      ->  Seq Scan on public.text_tbl t1
!                            Output: t1.f1
!                      ->  Materialize
!                            Output: i8.q1, i8.q2
!                            ->  Seq Scan on public.int8_tbl i8
!                                  Output: i8.q1, i8.q2
!                                  Filter: (i8.q2 = 123)
!          ->  Limit
!                Output: (i8.q1), t2.f1
!                ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Output: i8.q1, t2.f1
!                      ->  Limit
!                            Output: (i8.q1), t2.f1
!                            ->  Seq Scan on public.text_tbl t2
!                                  Output: i8.q1, t2.f1
!    ->  Limit
!          Output: ((i8.q1)), (t2.f1)
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Output: (i8.q1), t2.f1
!                ->  Limit
!                      Output: ((i8.q1)), (t2.f1)
!                      ->  Seq Scan on public.text_tbl t3
!                            Output: (i8.q1), t2.f1
! (32 rows)
! 
! select * from
!   text_tbl t1
!   left join int8_tbl i8
!   on i8.q2 = 123,
!   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,
!   lateral (select ss1.* from text_tbl t3 limit 1) as ss2
! where t1.f1 = ss2.f1;
!         f1         |        q1        | q2  |        q1        |        f1         |        q1        |        f1         
! -------------------+------------------+-----+------------------+-------------------+------------------+-------------------
!  hi de ho neighbor | 4567890123456789 | 123 | 4567890123456789 | hi de ho neighbor | 4567890123456789 | hi de ho neighbor
! (1 row)
! 
! explain (verbose, costs off)
! select 1 from
!   text_tbl as tt1
!   inner join text_tbl as tt2 on (tt1.f1 = 'foo')
!   left join text_tbl as tt3 on (tt3.f1 = 'foo')
!   left join text_tbl as tt4 on (tt3.f1 = tt4.f1),
!   lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1
! where tt1.f1 = ss1.c0;
!                                  QUERY PLAN                                  
! -----------------------------------------------------------------------------
!  Nested Loop
!    Output: 1
!    ->  Nested Loop Left Join
!          Output: tt1.f1, tt4.f1
!          ->  Nested Loop
!                Output: tt1.f1
!                ->  Remote Subquery Scan on all (datanode_2)
!                      Output: tt1.f1
!                      ->  Seq Scan on public.text_tbl tt1
!                            Output: tt1.f1
!                            Filter: (tt1.f1 = 'foo'::text)
!                ->  Materialize
!                      ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            ->  Seq Scan on public.text_tbl tt2
!          ->  Materialize
!                Output: tt4.f1
!                ->  Remote Subquery Scan on all (datanode_2)
!                      Output: tt4.f1
!                      ->  Nested Loop Left Join
!                            Output: tt4.f1
!                            Join Filter: (tt3.f1 = tt4.f1)
!                            ->  Seq Scan on public.text_tbl tt3
!                                  Output: tt3.f1
!                                  Filter: (tt3.f1 = 'foo'::text)
!                            ->  Seq Scan on public.text_tbl tt4
!                                  Output: tt4.f1
!                                  Filter: (tt4.f1 = 'foo'::text)
!    ->  Subquery Scan on ss1
!          Output: ss1.c0
!          Filter: (ss1.c0 = 'foo'::text)
!          ->  Limit
!                Output: (tt4.f1)
!                ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Output: tt4.f1
!                      ->  Limit
!                            Output: (tt4.f1)
!                            ->  Seq Scan on public.text_tbl tt5
!                                  Output: tt4.f1
! (38 rows)
! 
! select 1 from
!   text_tbl as tt1
!   inner join text_tbl as tt2 on (tt1.f1 = 'foo')
!   left join text_tbl as tt3 on (tt3.f1 = 'foo')
!   left join text_tbl as tt4 on (tt3.f1 = tt4.f1),
!   lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1
! where tt1.f1 = ss1.c0;
!  ?column? 
! ----------
! (0 rows)
! 
! --
! -- check a case in which a PlaceHolderVar forces join order
! --
! explain (verbose, costs off)
! select ss2.* from
!   int4_tbl i41
!   left join int8_tbl i8
!     join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
!           from int4_tbl i42, int4_tbl i43) ss1
!     on i8.q1 = ss1.c2
!   on i41.f1 = ss1.c1,
!   lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
! where ss1.c2 = 0;
!                                      QUERY PLAN                                     
! ------------------------------------------------------------------------------------
!  Nested Loop
!    Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
!    ->  Remote Subquery Scan on all (datanode_1)
!          Output: i41.f1, i42.f1, i8.q1, i8.q2, i43.f1, 42
!          ->  Hash Join
!                Output: i41.f1, i42.f1, i8.q1, i8.q2, i43.f1, 42
!                Hash Cond: (i41.f1 = i42.f1)
!                ->  Nested Loop
!                      Output: i8.q1, i8.q2, i43.f1, i41.f1
!                      ->  Nested Loop
!                            Output: i8.q1, i8.q2, i43.f1
!                            ->  Seq Scan on public.int8_tbl i8
!                                  Output: i8.q1, i8.q2
!                                  Filter: (i8.q1 = 0)
!                            ->  Seq Scan on public.int4_tbl i43
!                                  Output: i43.f1
!                                  Filter: (i43.f1 = 0)
!                      ->  Seq Scan on public.int4_tbl i41
!                            Output: i41.f1
!                ->  Hash
!                      Output: i42.f1
!                      ->  Seq Scan on public.int4_tbl i42
!                            Output: i42.f1
!    ->  Limit
!          Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Output: i41.f1, i8.q1, i8.q2, i42.f1, i43.f1, (42)
!                ->  Limit
!                      Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
!                      ->  Seq Scan on public.text_tbl
!                            Output: i41.f1, i8.q1, i8.q2, i42.f1, i43.f1, (42)
! (31 rows)
! 
! select ss2.* from
!   int4_tbl i41
!   left join int8_tbl i8
!     join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
!           from int4_tbl i42, int4_tbl i43) ss1
!     on i8.q1 = ss1.c2
!   on i41.f1 = ss1.c1,
!   lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
! where ss1.c2 = 0;
!  f1 | q1 | q2 | c1 | c2 | c3 
! ----+----+----+----+----+----
! (0 rows)
! 
! --
! -- test successful handling of full join underneath left join (bug #14105)
! --
! explain (costs off)
! select * from
!   (select 1 as id) as xx
!   left join
!     (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))
!   on (xx.id = coalesce(yy.id));
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Nested Loop Left Join
!    Join Filter: ((1) = COALESCE((1)))
!    ->  Result
!    ->  Hash Full Join
!          Hash Cond: (a1.unique1 = (1))
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                ->  Seq Scan on tenk1 a1
!          ->  Hash
!                ->  Result
! (9 rows)
! 
! select * from
!   (select 1 as id) as xx
!   left join
!     (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))
!   on (xx.id = coalesce(yy.id));
!  id | unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | id 
! ----+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+----
!   1 |       1 |    2838 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | EFEAAA   | OOOOxx  |  1
! (1 row)
! 
! --
! -- test ability to push constants through outer join clauses
! --
! explain (num_nodes off, nodes off, costs off)
!   select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Nested Loop Left Join
!          Join Filter: (a.f1 = b.unique2)
!          ->  Remote Subquery Scan on all
!                Distribute results by H: f1
!                ->  Seq Scan on int4_tbl a
!                      Filter: (f1 = 0)
!          ->  Materialize
!                ->  Remote Subquery Scan on all
!                      Distribute results by H: unique2
!                      ->  Index Scan using tenk1_unique2 on tenk1 b
!                            Index Cond: (unique2 = 0)
! (12 rows)
! 
! explain (num_nodes off, nodes off, costs off)
!   select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Merge Full Join
!          Merge Cond: (a.unique2 = b.unique2)
!          ->  Remote Subquery Scan on all
!                Distribute results by H: unique2
!                ->  Index Scan using tenk1_unique2 on tenk1 a
!                      Index Cond: (unique2 = 42)
!          ->  Materialize
!                ->  Remote Subquery Scan on all
!                      Distribute results by H: unique2
!                      ->  Index Scan using tenk1_unique2 on tenk1 b
!                            Index Cond: (unique2 = 42)
! (12 rows)
! 
! --
! -- test that quals attached to an outer join have correct semantics,
! -- specifically that they don't re-use expressions computed below the join;
! -- we force a mergejoin so that coalesce(b.q1, 1) appears as a join input
! --
! set enable_hashjoin to off;
! set enable_nestloop to off;
! explain (verbose, costs off)
!   select a.q2, b.q1
!     from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)
!     where coalesce(b.q1, 1) > 0;
!                                                                          QUERY PLAN                                                                         
! ------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: a.q2, b.q1
!    Node/s: datanode_1
!    Remote query: SELECT a.q2, b.q1 FROM (int8_tbl a LEFT JOIN int8_tbl b ON ((a.q2 = COALESCE(b.q1, (1)::bigint)))) WHERE (COALESCE(b.q1, (1)::bigint) > 0)
!    ->  Merge Left Join
!          Output: a.q2, b.q1
!          Merge Cond: (a.q2 = (COALESCE(b.q1, '1'::bigint)))
!          Filter: (COALESCE(b.q1, '1'::bigint) > 0)
!          ->  Sort
!                Output: a.q2
!                Sort Key: a.q2
!                ->  Seq Scan on public.int8_tbl a
!                      Output: a.q2
!          ->  Sort
!                Output: b.q1, (COALESCE(b.q1, '1'::bigint))
!                Sort Key: (COALESCE(b.q1, '1'::bigint))
!                ->  Seq Scan on public.int8_tbl b
!                      Output: b.q1, COALESCE(b.q1, '1'::bigint)
! (18 rows)
! 
! select a.q2, b.q1
!   from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)
!   where coalesce(b.q1, 1) > 0;
!         q2         |        q1        
! -------------------+------------------
!  -4567890123456789 |                 
!                123 |              123
!                123 |              123
!                456 |                 
!   4567890123456789 | 4567890123456789
!   4567890123456789 | 4567890123456789
!   4567890123456789 | 4567890123456789
!   4567890123456789 | 4567890123456789
!   4567890123456789 | 4567890123456789
!   4567890123456789 | 4567890123456789
! (10 rows)
! 
! reset enable_hashjoin;
! reset enable_nestloop;
! --
! -- test join removal
! --
! begin;
! CREATE TEMP TABLE a (id int PRIMARY KEY, b_id int);
! CREATE TEMP TABLE b (id int PRIMARY KEY, c_id int);
! CREATE TEMP TABLE c (id int PRIMARY KEY);
! CREATE TEMP TABLE d (a int, b int);
! INSERT INTO a VALUES (0, 0), (1, NULL);
! INSERT INTO b VALUES (0, 0), (1, NULL);
! INSERT INTO c VALUES (0), (1);
! INSERT INTO d VALUES (1,3), (2,2), (3,1);
! -- all three cases should be optimizable into a simple seqscan
! explain (verbose false, costs false, nodes false) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;
!          QUERY PLAN          
! -----------------------------
!  Remote Subquery Scan on all
!    ->  Seq Scan on a
! (2 rows)
! 
! explain (verbose false, costs false, nodes false) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;
!          QUERY PLAN          
! -----------------------------
!  Remote Subquery Scan on all
!    ->  Seq Scan on b
! (2 rows)
! 
! explain (verbose false, costs false, nodes false)
!   SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)
!   ON (a.b_id = b.id);
!          QUERY PLAN          
! -----------------------------
!  Remote Subquery Scan on all
!    ->  Seq Scan on a
! (2 rows)
! 
! -- check optimization of outer join within another special join
! explain (verbose false, costs false, nodes false)
! select id from a where id in (
! 	select b.id from b left join c on b.id = c.id
! );
!             QUERY PLAN            
! ----------------------------------
!  Remote Subquery Scan on all
!    ->  Hash Join
!          Hash Cond: (a.id = b.id)
!          ->  Seq Scan on a
!          ->  Hash
!                ->  Seq Scan on b
! (6 rows)
! 
! -- check that join removal works for a left join when joining a subquery
! -- that is guaranteed to be unique by its GROUP BY clause
! explain (costs off)
! select d.* from d left join (select * from b group by b.id, b.c_id) s
!   on d.a = s.id and d.b = s.c_id;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Seq Scan on d
! (2 rows)
! 
! -- similarly, but keying off a DISTINCT clause
! explain (costs off)
! select d.* from d left join (select distinct * from b) s
!   on d.a = s.id and d.b = s.c_id;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Seq Scan on d
! (2 rows)
! 
! -- join removal is not possible when the GROUP BY contains a column that is
! -- not in the join condition.  (Note: as of 9.6, we notice that b.id is a
! -- primary key and so drop b.c_id from the GROUP BY of the resulting plan;
! -- but this happens too late for join removal in the outer plan level.)
! explain (costs off)
! select d.* from d left join (select * from b group by b.id, b.c_id) s
!   on d.a = s.id;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Merge Right Join
!          Merge Cond: (b.id = d.a)
!          ->  Group
!                Group Key: b.id
!                ->  Index Scan using b_pkey on b
!          ->  Sort
!                Sort Key: d.a
!                ->  Seq Scan on d
! (9 rows)
! 
! -- similarly, but keying off a DISTINCT clause
! explain (costs off)
! select d.* from d left join (select distinct * from b) s
!   on d.a = s.id;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Merge Right Join
!          Merge Cond: (b.id = d.a)
!          ->  Unique
!                ->  Sort
!                      Sort Key: b.id, b.c_id
!                      ->  Seq Scan on b
!          ->  Sort
!                Sort Key: d.a
!                ->  Seq Scan on d
! (10 rows)
! 
! -- check join removal works when uniqueness of the join condition is enforced
! -- by a UNION
! explain (costs off)
! select d.* from d left join (select id from a union select id from b) s
!   on d.a = s.id;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Seq Scan on d
! (2 rows)
! 
! -- check join removal with a cross-type comparison operator
! -- commenting out queries on replicated tables
! -- as they can go either on datanode_1 or datanode_2
! --explain (costs off)
! --select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4
!   --on i8.q1 = i4.f1;
! rollback;
! create temp table parent (k int primary key, pd int);
! create temp table child (k int unique, cd int);
! insert into parent values (1, 10), (2, 20), (3, 30);
! insert into child values (1, 100), (4, 400);
! -- this case is optimizable
! select p.* from parent p left join child c on (p.k = c.k) order by 1,2;
!  k | pd 
! ---+----
!  1 | 10
!  2 | 20
!  3 | 30
! (3 rows)
! 
! explain (verbose false, costs false, nodes false)
!   select p.* from parent p left join child c on (p.k = c.k) order by 1,2;
!             QUERY PLAN            
! ----------------------------------
!  Remote Subquery Scan on all
!    ->  Sort
!          Sort Key: p.k, p.pd
!          ->  Seq Scan on parent p
! (4 rows)
! 
! -- this case is not
! select p.*, linked from parent p
!   left join (select c.*, true as linked from child c) as ss
!   on (p.k = ss.k) order by p.k;
!  k | pd | linked 
! ---+----+--------
!  1 | 10 | t
!  2 | 20 | 
!  3 | 30 | 
! (3 rows)
! 
! explain (verbose false, costs false, nodes false)
!   select p.*, linked from parent p
!     left join (select c.*, true as linked from child c) as ss
!     on (p.k = ss.k) order by p.k;
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Merge Left Join
!          Merge Cond: (p.k = c.k)
!          ->  Index Scan using parent_pkey on parent p
!          ->  Index Only Scan using child_k_key on child c
! (5 rows)
! 
! -- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling
! select p.* from
!   parent p left join child c on (p.k = c.k)
!   where p.k = 1 and p.k = 2;
!  k | pd 
! ---+----
! (0 rows)
! 
! explain (verbose false, costs false, nodes false)
! select p.* from
!   parent p left join child c on (p.k = c.k)
!   where p.k = 1 and p.k = 2;
!                       QUERY PLAN                      
! ------------------------------------------------------
!  Remote Fast Query Execution
!    ->  Result
!          One-Time Filter: false
!          ->  Index Scan using parent_pkey on parent p
!                Index Cond: (k = 1)
! (5 rows)
! 
! select p.* from
!   (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
!   where p.k = 1 and p.k = 2;
!  k | pd 
! ---+----
! (0 rows)
! 
! explain (verbose false, costs false, nodes false)
! select p.* from
!   (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
!   where p.k = 1 and p.k = 2;
!            QUERY PLAN           
! --------------------------------
!  Remote Fast Query Execution
!    ->  Result
!          One-Time Filter: false
! (3 rows)
! 
! -- bug 5255: this is not optimizable by join removal
! begin;
! CREATE TEMP TABLE a (id int PRIMARY KEY);
! CREATE TEMP TABLE b (id int PRIMARY KEY, a_id int);
! INSERT INTO a VALUES (0), (1);
! INSERT INTO b VALUES (0, 0), (1, NULL);
! SELECT * FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
!  id | a_id | id 
! ----+------+----
!   1 |      |   
! (1 row)
! 
! SELECT b.* FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
!  id | a_id 
! ----+------
!   1 |     
! (1 row)
! 
! rollback;
! -- another join removal bug: this is not optimizable, either
! begin;
! create temp table innertab (id int8 primary key, dat1 int8);
! insert into innertab values(123, 42);
! SELECT * FROM
!     (SELECT 1 AS x) ss1
!   LEFT JOIN
!     (SELECT q1, q2, COALESCE(dat1, q1) AS y
!      FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2
!   ON true order by 1, 2, 3, 4;
!  x |        q1        |        q2         |        y         
! ---+------------------+-------------------+------------------
!  1 |              123 |               456 |              123
!  1 |              123 |  4567890123456789 |              123
!  1 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  1 | 4567890123456789 |               123 |               42
!  1 | 4567890123456789 |  4567890123456789 | 4567890123456789
! (5 rows)
! 
! rollback;
! -- another join removal bug: we must clean up correctly when removing a PHV
! begin;
! create temp table uniquetbl (f1 text unique);
! explain (costs off)
! select t1.* from
!   uniquetbl as t1
!   left join (select *, '***'::text as d1 from uniquetbl) t2
!   on t1.f1 = t2.f1
!   left join uniquetbl t3
!   on t2.d1 = t3.f1;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Seq Scan on uniquetbl t1
! (2 rows)
! 
! explain (costs off)
! select t0.*
! from
!  text_tbl t0
!  left join
!    (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,
!            t1.stringu2
!      from tenk1 t1
!      join int4_tbl i4 ON i4.f1 = t1.unique2
!      left join uniquetbl u1 ON u1.f1 = t1.string4) ss
!   on t0.f1 = ss.case1
! where ss.stringu2 !~* ss.case1;
!                                                QUERY PLAN                                               
! --------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Nested Loop
!          Join Filter: ((CASE t1.ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END) = t0.f1)
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: CASE ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END
!                ->  Nested Loop
!                      ->  Seq Scan on int4_tbl i4
!                      ->  Index Scan using tenk1_unique2 on tenk1 t1
!                            Index Cond: (unique2 = i4.f1)
!                            Filter: (stringu2 !~* CASE ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END)
!          ->  Materialize
!                ->  Seq Scan on text_tbl t0
! (12 rows)
! 
! select t0.*
! from
!  text_tbl t0
!  left join
!    (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,
!            t1.stringu2
!      from tenk1 t1
!      join int4_tbl i4 ON i4.f1 = t1.unique2
!      left join uniquetbl u1 ON u1.f1 = t1.string4) ss
!   on t0.f1 = ss.case1
! where ss.stringu2 !~* ss.case1;
!   f1  
! ------
!  doh!
! (1 row)
! 
! rollback;
! -- bug #8444: we've historically allowed duplicate aliases within aliased JOINs
! select * from
!   int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1; -- error
! ERROR:  column reference "f1" is ambiguous
! LINE 2: ..._tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1;
!                                                                     ^
! select * from
!   int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1; -- error
! ERROR:  invalid reference to FROM-clause entry for table "y"
! LINE 2: ...bl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1;
!                                                                   ^
! HINT:  There is an entry for table "y", but it cannot be referenced from this part of the query.
! select * from
!   int8_tbl x join (int4_tbl x cross join int4_tbl y(ff)) j on q1 = f1; -- ok
!  q1 | q2 | f1 | ff 
! ----+----+----+----
! (0 rows)
! 
! --
! -- Test hints given on incorrect column references are useful
! --
! select t1.uunique1 from
!   tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer "t1" suggestion
! ERROR:  column t1.uunique1 does not exist
! LINE 1: select t1.uunique1 from
!                ^
! HINT:  Perhaps you meant to reference the column "t1.unique1".
! select t2.uunique1 from
!   tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer "t2" suggestion
! ERROR:  column t2.uunique1 does not exist
! LINE 1: select t2.uunique1 from
!                ^
! HINT:  Perhaps you meant to reference the column "t2.unique1".
! select uunique1 from
!   tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, suggest both at once
! ERROR:  column "uunique1" does not exist
! LINE 1: select uunique1 from
!                ^
! HINT:  Perhaps you meant to reference the column "t1.unique1" or the column "t2.unique1".
! --
! -- Take care to reference the correct RTE
! --
! select atts.relid::regclass, s.* from pg_stats s join
!     pg_attribute a on s.attname = a.attname and s.tablename =
!     a.attrelid::regclass::text join (select unnest(indkey) attnum,
!     indexrelid from pg_index i) atts on atts.attnum = a.attnum where
!     schemaname != 'pg_catalog';
! ERROR:  column atts.relid does not exist
! LINE 1: select atts.relid::regclass, s.* from pg_stats s join
!                ^
! --
! -- Test LATERAL
! --
! select unique2, x.*
! from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
!  unique2 | f1 
! ---------+----
!     9998 |  0
! (1 row)
! 
! explain (costs off)
!   select unique2, x.*
!   from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Nested Loop
!          ->  Seq Scan on int4_tbl b
!          ->  Index Scan using tenk1_unique1 on tenk1 a
!                Index Cond: (unique1 = b.f1)
! (5 rows)
! 
! select unique2, x.*
! from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
!  unique2 | f1 
! ---------+----
!     9998 |  0
! (1 row)
! 
! explain (costs off)
!   select unique2, x.*
!   from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Nested Loop
!          ->  Seq Scan on int4_tbl x
!          ->  Index Scan using tenk1_unique1 on tenk1
!                Index Cond: (unique1 = x.f1)
! (5 rows)
! 
! explain (costs off)
!   select unique2, x.*
!   from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Nested Loop
!          ->  Seq Scan on int4_tbl x
!          ->  Index Scan using tenk1_unique1 on tenk1
!                Index Cond: (unique1 = x.f1)
! (5 rows)
! 
! select unique2, x.*
! from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true order by 1;
!  unique2 |     f1      
! ---------+-------------
!     9998 |           0
!          |     -123456
!          |  2147483647
!          |      123456
!          | -2147483647
! (5 rows)
! 
! --explain (costs off)
!   --select unique2, x.*
!   --from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
! -- check scoping of lateral versus parent references
! -- the first of these should return int8_tbl.q2, the second int8_tbl.q1
! select *, (select r from (select q1 as q2) x, (select q2 as r) y) from int8_tbl;
!         q1        |        q2         |         r         
! ------------------+-------------------+-------------------
!               123 |               456 |               456
!               123 |  4567890123456789 |  4567890123456789
!  4567890123456789 |               123 |               123
!  4567890123456789 |  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789 | -4567890123456789
! (5 rows)
! 
! select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from int8_tbl;
!         q1        |        q2         |        r         
! ------------------+-------------------+------------------
!               123 |               456 |              123
!               123 |  4567890123456789 |              123
!  4567890123456789 |               123 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789
! (5 rows)
! 
! -- lateral with function in FROM
! select count(*) from tenk1 a, lateral generate_series(1,two) g;
!  count 
! -------
!   5000
! (1 row)
! 
! explain (costs off)
!   select count(*) from tenk1 a, lateral generate_series(1,two) g;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Aggregate
!    ->  Nested Loop
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                ->  Seq Scan on tenk1 a
!          ->  Function Scan on generate_series g
! (5 rows)
! 
! explain (costs off)
!   select count(*) from tenk1 a cross join lateral generate_series(1,two) g;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Aggregate
!    ->  Nested Loop
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                ->  Seq Scan on tenk1 a
!          ->  Function Scan on generate_series g
! (5 rows)
! 
! -- don't need the explicit LATERAL keyword for functions
! explain (costs off)
!   select count(*) from tenk1 a, generate_series(1,two) g;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Aggregate
!    ->  Nested Loop
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                ->  Seq Scan on tenk1 a
!          ->  Function Scan on generate_series g
! (5 rows)
! 
! -- lateral with UNION ALL subselect
! explain (num_nodes off, nodes off, costs off)
!   select * from generate_series(100,200) g,
!     lateral (select * from int8_tbl a where g = q1 union all
!              select * from int8_tbl b where g = q2) ss;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Nested Loop
!    ->  Function Scan on generate_series g
!    ->  Materialize
!          ->  Remote Subquery Scan on all
!                ->  Append
!                      ->  Seq Scan on int8_tbl a
!                            Filter: (g.g = q1)
!                      ->  Seq Scan on int8_tbl b
!                            Filter: (g.g = q2)
! (9 rows)
! 
! select * from generate_series(100,200) g,
!   lateral (select * from int8_tbl a where g = q1 union all
!            select * from int8_tbl b where g = q2) ss;
!   g  |        q1        |        q2        
! -----+------------------+------------------
!  123 |              123 |              456
!  123 |              123 | 4567890123456789
!  123 | 4567890123456789 |              123
! (3 rows)
! 
! -- lateral with VALUES
! explain (num_nodes off, nodes off, costs off)
!   select count(*) from tenk1 a,
!     tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
!                                   QUERY PLAN                                  
! ------------------------------------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Merge Join
!                      Merge Cond: (b.unique2 = a.unique1)
!                      ->  Remote Subquery Scan on all
!                            Distribute results by H: unique2
!                            ->  Index Only Scan using tenk1_unique2 on tenk1 b
!                      ->  Index Only Scan using tenk1_unique1 on tenk1 a
! (9 rows)
! 
! select count(*) from tenk1 a,
!   tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
!  count 
! -------
!  10000
! (1 row)
! 
! -- lateral with VALUES, no flattening possible
! explain (num_nodes off, nodes off, costs off)
!   select count(*) from tenk1 a,
!     tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Aggregate
!    ->  Hash Join
!          Hash Cond: ("*VALUES*".column1 = b.unique2)
!          ->  Nested Loop
!                ->  Remote Subquery Scan on all
!                      ->  Index Only Scan using tenk1_unique1 on tenk1 a
!                ->  Values Scan on "*VALUES*"
!          ->  Hash
!                ->  Remote Subquery Scan on all
!                      ->  Index Only Scan using tenk1_unique2 on tenk1 b
! (10 rows)
! 
! select count(*) from tenk1 a,
!   tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;
!  count 
! -------
!  10000
! (1 row)
! 
! -- lateral injecting a strange outer join condition
! explain (num_nodes off, nodes off, costs off)
!   select * from int8_tbl a,
!     int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
!       on x.q2 = ss.z
!   order by a.q1, a.q2, x.q1, x.q2, ss.z;
!                       QUERY PLAN                      
! ------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Sort
!          Sort Key: a.q1, a.q2, x.q1, x.q2, (a.q1)
!          ->  Nested Loop
!                ->  Seq Scan on int8_tbl a
!                ->  Hash Right Join
!                      Hash Cond: ((a.q1) = x.q2)
!                      ->  Seq Scan on int4_tbl y
!                      ->  Hash
!                            ->  Seq Scan on int8_tbl x
! (10 rows)
! 
! select * from int8_tbl a,
!   int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
!     on x.q2 = ss.z
!   order by a.q1, a.q2, x.q1, x.q2, ss.z;
!         q1        |        q2         |        q1        |        q2         |        z         
! ------------------+-------------------+------------------+-------------------+------------------
!               123 |               456 |              123 |               456 |                 
!               123 |               456 |              123 |  4567890123456789 |                 
!               123 |               456 | 4567890123456789 | -4567890123456789 |                 
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |               123 |              123
!               123 |               456 | 4567890123456789 |  4567890123456789 |                 
!               123 |  4567890123456789 |              123 |               456 |                 
!               123 |  4567890123456789 |              123 |  4567890123456789 |                 
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |                 
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |                 
!  4567890123456789 | -4567890123456789 |              123 |               456 |                 
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 | -4567890123456789 |                 
!  4567890123456789 | -4567890123456789 | 4567890123456789 |               123 |                 
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |               456 |                 
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 | -4567890123456789 |                 
!  4567890123456789 |               123 | 4567890123456789 |               123 |                 
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |               123 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |               456 |                 
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 |              123 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 |                 
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 |                 
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
! (57 rows)
! 
! -- lateral reference to a join alias variable
! select * from (select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
!   lateral (select x) ss2(y);
!  x | f1 | y 
! ---+----+---
!  0 |  0 | 0
! (1 row)
! 
! select * from (select f1 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
!   lateral (values(x)) ss2(y);
!       x      |     f1      |      y      
! -------------+-------------+-------------
!            0 |           0 |           0
!       123456 |      123456 |      123456
!      -123456 |     -123456 |     -123456
!   2147483647 |  2147483647 |  2147483647
!  -2147483647 | -2147483647 | -2147483647
! (5 rows)
! 
! select * from ((select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1) j,
!   lateral (select x) ss2(y);
!  x | f1 | y 
! ---+----+---
!  0 |  0 | 0
! (1 row)
! 
! -- lateral references requiring pullup
! select * from (values(1)) x(lb),
!   lateral generate_series(lb,4) x4;
!  lb | x4 
! ----+----
!   1 |  1
!   1 |  2
!   1 |  3
!   1 |  4
! (4 rows)
! 
! select * from (select f1/1000000000 from int4_tbl) x(lb),
!   lateral generate_series(lb,4) x4;
!  lb | x4 
! ----+----
!   0 |  0
!   0 |  1
!   0 |  2
!   0 |  3
!   0 |  4
!   0 |  0
!   0 |  1
!   0 |  2
!   0 |  3
!   0 |  4
!   0 |  0
!   0 |  1
!   0 |  2
!   0 |  3
!   0 |  4
!   2 |  2
!   2 |  3
!   2 |  4
!  -2 | -2
!  -2 | -1
!  -2 |  0
!  -2 |  1
!  -2 |  2
!  -2 |  3
!  -2 |  4
! (25 rows)
! 
! select * from (values(1)) x(lb),
!   lateral (values(lb)) y(lbcopy);
!  lb | lbcopy 
! ----+--------
!   1 |      1
! (1 row)
! 
! select * from (values(1)) x(lb),
!   lateral (select lb from int4_tbl) y(lbcopy);
!  lb | lbcopy 
! ----+--------
!   1 |      1
!   1 |      1
!   1 |      1
!   1 |      1
!   1 |      1
! (5 rows)
! 
! select * from
!   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
!   lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);
!         q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
! ------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
!               123 |               456 |                  |                   |              123 |                  |                  
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
!  4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
!  4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
! (10 rows)
! 
! select * from
!   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
!   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
!         q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
! ------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
!               123 |               456 |                  |                   |              123 |                  |                  
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
!  4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
!  4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
!  4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
! (10 rows)
! 
! select x.* from
!   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
!   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!               123 |  4567890123456789
!               123 |  4567890123456789
!  4567890123456789 |               123
!  4567890123456789 |               123
!  4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789
!  4567890123456789 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (10 rows)
! 
! select v.* from
!   (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)
!   left join int4_tbl z on z.f1 = x.q2,
!   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy)
!   order by vx, vy;
!         vx         |        vy         
! -------------------+-------------------
!  -4567890123456789 |                  
!                123 |               456
!                123 |  4567890123456789
!                123 |  4567890123456789
!                123 |  4567890123456789
!                123 |  4567890123456789
!                123 |                  
!                456 |                  
!   4567890123456789 | -4567890123456789
!   4567890123456789 | -4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |               123
!   4567890123456789 |               123
!   4567890123456789 |               123
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |                  
! (20 rows)
! 
! select v.* from
!   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
!   left join int4_tbl z on z.f1 = x.q2,
!   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy)
!   order by vx, vy;
!         vx         |        vy         
! -------------------+-------------------
!  -4567890123456789 |                  
!                123 |               456
!                123 |  4567890123456789
!                123 |  4567890123456789
!                123 |  4567890123456789
!                123 |  4567890123456789
!                123 |                  
!                456 |                  
!   4567890123456789 | -4567890123456789
!   4567890123456789 | -4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |               123
!   4567890123456789 |               123
!   4567890123456789 |               123
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |                  
! (20 rows)
! 
! create temp table dual();
! insert into dual default values;
! analyze dual;
! select v.* from
!   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
!   left join int4_tbl z on z.f1 = x.q2,
!   lateral (select x.q1,y.q1 from dual union all select x.q2,y.q2 from dual) v(vx,vy)
!   order by vx, vy;
!         vx         |        vy         
! -------------------+-------------------
!  -4567890123456789 |                  
!                123 |               456
!                123 |  4567890123456789
!                123 |  4567890123456789
!                123 |  4567890123456789
!                123 |  4567890123456789
!                123 |                  
!                456 |                  
!   4567890123456789 | -4567890123456789
!   4567890123456789 | -4567890123456789
!   4567890123456789 |               123
!   4567890123456789 |               123
!   4567890123456789 |               123
!   4567890123456789 |               123
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |  4567890123456789
!   4567890123456789 |                  
! (20 rows)
! 
! explain (verbose, num_nodes off, nodes off, costs off)
! select * from
!   int8_tbl a left join
!   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Remote Subquery Scan on all
!    Output: a.q1, a.q2, b.q1, b.q2, a.q2
!    ->  Nested Loop Left Join
!          Output: a.q1, a.q2, b.q1, b.q2, (a.q2)
!          ->  Seq Scan on public.int8_tbl a
!                Output: a.q1, a.q2
!          ->  Seq Scan on public.int8_tbl b
!                Output: b.q1, b.q2, a.q2
!                Filter: (a.q2 = b.q1)
! (9 rows)
! 
! select * from
!   int8_tbl a left join
!   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
!         q1        |        q2         |        q1        |        q2         |        x         
! ------------------+-------------------+------------------+-------------------+------------------
!               123 |               456 |                  |                   |                 
!               123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |               456 |              123
!  4567890123456789 |               123 |              123 |  4567890123456789 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |                  |                   |                 
! (10 rows)
! 
! --explain (verbose, costs off)
! --select * from
!   --int8_tbl a left join
!   --lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
! select * from
!   int8_tbl a left join
!   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
!         q1        |        q2         |        q1        |        q2         |        x         
! ------------------+-------------------+------------------+-------------------+------------------
!               123 |               456 |                  |                   |                 
!               123 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!               123 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 |               123 |              123 |               456 |              123
!  4567890123456789 |               123 |              123 |  4567890123456789 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |                  |                   |                 
! (10 rows)
! 
! -- lateral can result in join conditions appearing below their
! -- real semantic level
! explain (num_nodes off, nodes off, verbose, costs off)
! select * from int4_tbl i left join
!   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: i.f1, j.f1
!    ->  Hash Right Join
!          Output: i.f1, j.f1
!          Hash Cond: (j.f1 = i.f1)
!          ->  Seq Scan on public.int2_tbl j
!                Output: j.f1
!          ->  Hash
!                Output: i.f1
!                ->  Remote Subquery Scan on all
!                      Output: i.f1
!                      Distribute results by H: f1
!                      ->  Seq Scan on public.int4_tbl i
!                            Output: i.f1
! (14 rows)
! 
! select * from int4_tbl i left join
!   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true order by 1;
!      f1      | f1 
! -------------+----
!  -2147483647 |   
!      -123456 |   
!            0 |  0
!       123456 |   
!   2147483647 |   
! (5 rows)
! 
! explain (num_nodes off, nodes off, verbose, costs off)
! select * from int4_tbl i left join
!   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Remote Subquery Scan on all
!    Output: i.f1, COALESCE(i.*)
!    ->  Nested Loop Left Join
!          Output: i.f1, (COALESCE(i.*))
!          ->  Remote Subquery Scan on all
!                Output: i.f1, i.*
!                Distribute results by H: f1
!                ->  Seq Scan on public.int4_tbl i
!                      Output: i.f1, i.*
!          ->  Seq Scan on public.int2_tbl j
!                Output: j.f1, COALESCE(i.*)
!                Filter: (i.f1 = j.f1)
! (12 rows)
! 
! select * from int4_tbl i left join
!   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true order by 1;
!      f1      | coalesce 
! -------------+----------
!  -2147483647 | 
!      -123456 | 
!            0 | (0)
!       123456 | 
!   2147483647 | 
! (5 rows)
! 
! explain (num_nodes off, nodes off, verbose, costs off)
! select * from int4_tbl a,
!   lateral (
!     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
!   ) ss;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: a.f1, f1, q1, q2
!    ->  Nested Loop
!          Output: a.f1, b.f1, c.q1, c.q2
!          ->  Seq Scan on public.int4_tbl a
!                Output: a.f1
!          ->  Hash Left Join
!                Output: b.f1, c.q1, c.q2
!                Hash Cond: (b.f1 = c.q1)
!                ->  Seq Scan on public.int4_tbl b
!                      Output: b.f1
!                ->  Hash
!                      Output: c.q1, c.q2
!                      ->  Seq Scan on public.int8_tbl c
!                            Output: c.q1, c.q2
!                            Filter: (a.f1 = c.q2)
! (16 rows)
! 
! select * from int4_tbl a,
!   lateral (
!     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
!   ) ss;
!      f1      |     f1      | q1 | q2 
! -------------+-------------+----+----
!            0 |           0 |    |   
!            0 |      123456 |    |   
!            0 |     -123456 |    |   
!            0 |  2147483647 |    |   
!            0 | -2147483647 |    |   
!       123456 |           0 |    |   
!       123456 |      123456 |    |   
!       123456 |     -123456 |    |   
!       123456 |  2147483647 |    |   
!       123456 | -2147483647 |    |   
!      -123456 |           0 |    |   
!      -123456 |      123456 |    |   
!      -123456 |     -123456 |    |   
!      -123456 |  2147483647 |    |   
!      -123456 | -2147483647 |    |   
!   2147483647 |           0 |    |   
!   2147483647 |      123456 |    |   
!   2147483647 |     -123456 |    |   
!   2147483647 |  2147483647 |    |   
!   2147483647 | -2147483647 |    |   
!  -2147483647 |           0 |    |   
!  -2147483647 |      123456 |    |   
!  -2147483647 |     -123456 |    |   
!  -2147483647 |  2147483647 |    |   
!  -2147483647 | -2147483647 |    |   
! (25 rows)
! 
! -- lateral reference in a PlaceHolderVar evaluated at join level
! explain (num_nodes off, nodes off, verbose, costs off)
! select * from
!   int8_tbl a left join lateral
!   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
!    int8_tbl b cross join int8_tbl c) ss
!   on a.q2 = ss.bq1;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: a.q1, a.q2, b.q1, c.q1, LEAST(a.q1, b.q1, c.q1)
!    ->  Nested Loop Left Join
!          Output: a.q1, a.q2, b.q1, c.q1, (LEAST(a.q1, b.q1, c.q1))
!          ->  Seq Scan on public.int8_tbl a
!                Output: a.q1, a.q2
!          ->  Nested Loop
!                Output: b.q1, c.q1, LEAST(a.q1, b.q1, c.q1)
!                ->  Seq Scan on public.int8_tbl b
!                      Output: b.q1, b.q2
!                      Filter: (a.q2 = b.q1)
!                ->  Seq Scan on public.int8_tbl c
!                      Output: c.q1, c.q2
! (13 rows)
! 
! select * from
!   int8_tbl a left join lateral
!   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
!    int8_tbl b cross join int8_tbl c) ss
!   on a.q2 = ss.bq1;
!         q1        |        q2         |       bq1        |       cq1        |      least       
! ------------------+-------------------+------------------+------------------+------------------
!               123 |               456 |                  |                  |                 
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 |              123 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!               123 |  4567890123456789 | 4567890123456789 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 |              123 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |               123 |              123 | 4567890123456789 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 |              123 |              123
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 | 4567890123456789
!  4567890123456789 | -4567890123456789 |                  |                  |                 
! (42 rows)
! 
! -- case requiring nested PlaceHolderVars
! explain (num_nodes off, nodes off, verbose, costs off)
! select * from
!   int8_tbl c left join (
!     int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1
!       on a.q2 = ss1.q1
!     cross join
!     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
!   ) on c.q2 = ss2.q1,
!   lateral (select ss2.y offset 0) ss3;
!                                                                                    QUERY PLAN                                                                                   
! --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Nested Loop
!    Output: c.q1, c.q2, a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint)), d.q1, (COALESCE(COALESCE(b.q2, '42'::bigint), d.q2)), ((COALESCE(COALESCE(b.q2, '42'::bigint), d.q2)))
!    ->  Remote Subquery Scan on all
!          Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, COALESCE(b.q2, '42'::bigint), COALESCE(COALESCE(b.q2, '42'::bigint), d.q2)
!          ->  Hash Right Join
!                Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, '42'::bigint)), (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
!                Hash Cond: (d.q1 = c.q2)
!                ->  Nested Loop
!                      Output: a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, '42'::bigint)), (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
!                      ->  Hash Left Join
!                            Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint))
!                            Hash Cond: (a.q2 = b.q1)
!                            ->  Seq Scan on public.int8_tbl a
!                                  Output: a.q1, a.q2
!                            ->  Hash
!                                  Output: b.q1, (COALESCE(b.q2, '42'::bigint))
!                                  ->  Seq Scan on public.int8_tbl b
!                                        Output: b.q1, COALESCE(b.q2, '42'::bigint)
!                      ->  Seq Scan on public.int8_tbl d
!                            Output: d.q1, COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)
!                ->  Hash
!                      Output: c.q1, c.q2
!                      ->  Seq Scan on public.int8_tbl c
!                            Output: c.q1, c.q2
!    ->  Result
!          Output: (COALESCE(COALESCE(b.q2, '42'::bigint), d.q2))
! (26 rows)
! 
! -- case that breaks the old ph_may_need optimization
! explain (num_nodes off, nodes off, verbose, costs off)
! select c.*,a.*,ss1.q1,ss2.q1,ss3.* from
!   int8_tbl c left join (
!     int8_tbl a left join
!       (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2
!        where q1 < f1) ss1
!       on a.q2 = ss1.q1
!     cross join
!     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
!   ) on c.q2 = ss2.q1,
!   lateral (select * from int4_tbl i where ss2.y > f1) ss3;
!                                                   QUERY PLAN                                                   
! ---------------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, i.f1
!    ->  Nested Loop
!          Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, i.f1
!          Join Filter: ((COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)) > i.f1)
!          ->  Hash Right Join
!                Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
!                Hash Cond: (d.q1 = c.q2)
!                ->  Nested Loop
!                      Output: a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
!                      ->  Hash Right Join
!                            Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, (b2.f1)::bigint))
!                            Hash Cond: (b.q1 = a.q2)
!                            ->  Nested Loop
!                                  Output: b.q1, COALESCE(b.q2, (b2.f1)::bigint)
!                                  Join Filter: (b.q1 < b2.f1)
!                                  ->  Seq Scan on public.int8_tbl b
!                                        Output: b.q1, b.q2
!                                  ->  Materialize
!                                        Output: b2.f1
!                                        ->  Seq Scan on public.int4_tbl b2
!                                              Output: b2.f1
!                            ->  Hash
!                                  Output: a.q1, a.q2
!                                  ->  Seq Scan on public.int8_tbl a
!                                        Output: a.q1, a.q2
!                      ->  Seq Scan on public.int8_tbl d
!                            Output: d.q1, COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)
!                ->  Hash
!                      Output: c.q1, c.q2
!                      ->  Seq Scan on public.int8_tbl c
!                            Output: c.q1, c.q2
!          ->  Materialize
!                Output: i.f1
!                ->  Seq Scan on public.int4_tbl i
!                      Output: i.f1
! (36 rows)
! 
! -- check processing of postponed quals (bug #9041)
! explain (num_nodes off, nodes off, verbose, costs off)
! select * from
!   (select 1 as x offset 0) x cross join (select 2 as y offset 0) y
!   left join lateral (
!     select * from (select 3 as z offset 0) z where z.z = x.x
!   ) zz on zz.z = y.y;
!                   QUERY PLAN                  
! ----------------------------------------------
!  Nested Loop Left Join
!    Output: (1), (2), (3)
!    Join Filter: (((3) = (1)) AND ((3) = (2)))
!    ->  Nested Loop
!          Output: (1), (2)
!          ->  Result
!                Output: 1
!          ->  Result
!                Output: 2
!    ->  Result
!          Output: 3
! (11 rows)
! 
! -- check we don't try to do a unique-ified semijoin with LATERAL
! explain (verbose, costs off, nodes off)
! select * from
!   (values (0,9998), (1,1000)) v(id,x),
!   lateral (select f1 from int4_tbl
!            where f1 = any (select unique1 from tenk1
!                            where unique2 = v.x offset 0)) ss;
!                                     QUERY PLAN                                    
! ----------------------------------------------------------------------------------
!  Nested Loop
!    Output: "*VALUES*".column1, "*VALUES*".column2, int4_tbl.f1
!    ->  Values Scan on "*VALUES*"
!          Output: "*VALUES*".column1, "*VALUES*".column2
!    ->  Materialize
!          Output: int4_tbl.f1
!          ->  Remote Subquery Scan on all
!                Output: int4_tbl.f1
!                ->  Nested Loop Semi Join
!                      Output: int4_tbl.f1
!                      Join Filter: (int4_tbl.f1 = tenk1.unique1)
!                      ->  Remote Subquery Scan on all
!                            Output: int4_tbl.f1
!                            Distribute results by H: f1
!                            ->  Seq Scan on public.int4_tbl
!                                  Output: int4_tbl.f1
!                      ->  Materialize
!                            Output: tenk1.unique1
!                            ->  Index Scan using tenk1_unique2 on public.tenk1
!                                  Output: tenk1.unique1
!                                  Index Cond: (tenk1.unique2 = "*VALUES*".column2)
! (21 rows)
! 
! select * from
!   (values (0,9998), (1,1000)) v(id,x),
!   lateral (select f1 from int4_tbl
!            where f1 = any (select unique1 from tenk1
!                            where unique2 = v.x offset 0)) ss;
!  id |  x   | f1 
! ----+------+----
!   0 | 9998 |  0
! (1 row)
! 
! -- check proper extParam/allParam handling (this isn't exactly a LATERAL issue,
! -- but we can make the test case much more compact with LATERAL)
! explain (verbose, costs off)
! select * from (values (0), (1)) v(id),
! lateral (select * from int8_tbl t1,
!          lateral (select * from
!                     (select * from int8_tbl t2
!                      where q1 = any (select q2 from int8_tbl t3
!                                      where q2 = (select greatest(t1.q1,t2.q2))
!                                        and (select v.id=0)) offset 0) ss2) ss
!          where t1.q1 = ss.q2) ss0;
!                                     QUERY PLAN                                     
! -----------------------------------------------------------------------------------
!  Nested Loop
!    Output: "*VALUES*".column1, t1.q1, t1.q2, ss2.q1, ss2.q2
!    ->  Remote Subquery Scan on all (datanode_1)
!          Output: t1.q1, t1.q2
!          ->  Seq Scan on public.int8_tbl t1
!                Output: t1.q1, t1.q2
!    ->  Nested Loop
!          Output: "*VALUES*".column1, ss2.q1, ss2.q2
!          ->  Values Scan on "*VALUES*"
!                Output: "*VALUES*".column1
!          ->  Materialize
!                Output: ss2.q1, ss2.q2
!                ->  Remote Subquery Scan on all (datanode_1)
!                      Output: ss2.q1, ss2.q2
!                      ->  Subquery Scan on ss2
!                            Output: ss2.q1, ss2.q2
!                            Filter: (t1.q1 = ss2.q2)
!                            ->  Seq Scan on public.int8_tbl t2
!                                  Output: t2.q1, t2.q2
!                                  Filter: (SubPlan 3)
!                                  SubPlan 3
!                                    ->  Remote Subquery Scan on all (datanode_1)
!                                          Output: t3.q2
!                                          ->  Result
!                                                Output: t3.q2
!                                                One-Time Filter: $4
!                                                InitPlan 1 (returns $2)
!                                                  ->  Result
!                                                        Output: GREATEST($0, t2.q2)
!                                                InitPlan 2 (returns $4)
!                                                  ->  Result
!                                                        Output: ($3 = 0)
!                                                ->  Seq Scan on public.int8_tbl t3
!                                                      Output: t3.q1, t3.q2
!                                                      Filter: (t3.q2 = $2)
! (35 rows)
! 
! select * from (values (0), (1)) v(id),
! lateral (select * from int8_tbl t1,
!          lateral (select * from
!                     (select * from int8_tbl t2
!                      where q1 = any (select q2 from int8_tbl t3
!                                      where q2 = (select greatest(t1.q1,t2.q2))
!                                        and (select v.id=0)) offset 0) ss2) ss
!          where t1.q1 = ss.q2) ss0;
!  id |        q1        |        q2         |        q1        |        q2        
! ----+------------------+-------------------+------------------+------------------
!   0 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789
!   0 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789
!   0 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789
! (3 rows)
! 
! -- test some error cases where LATERAL should have been used but wasn't
! select f1,g from int4_tbl a, (select f1 as g) ss;
! ERROR:  column "f1" does not exist
! LINE 1: select f1,g from int4_tbl a, (select f1 as g) ss;
!                                              ^
! HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
! select f1,g from int4_tbl a, (select a.f1 as g) ss;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: select f1,g from int4_tbl a, (select a.f1 as g) ss;
!                                              ^
! HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
! select f1,g from int4_tbl a cross join (select f1 as g) ss;
! ERROR:  column "f1" does not exist
! LINE 1: select f1,g from int4_tbl a cross join (select f1 as g) ss;
!                                                        ^
! HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
! select f1,g from int4_tbl a cross join (select a.f1 as g) ss;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: select f1,g from int4_tbl a cross join (select a.f1 as g) ss...
!                                                        ^
! HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
! -- SQL:2008 says the left table is in scope but illegal to access here
! select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: ... int4_tbl a right join lateral generate_series(0, a.f1) g on...
!                                                              ^
! DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
! select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;
! ERROR:  invalid reference to FROM-clause entry for table "a"
! LINE 1: ...m int4_tbl a full join lateral generate_series(0, a.f1) g on...
!                                                              ^
! DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
! -- check we complain about ambiguous table references
! select * from
!   int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);
! ERROR:  table reference "x" is ambiguous
! LINE 2: ...cross join (int4_tbl x cross join lateral (select x.f1) ss);
!                                                              ^
! -- LATERAL can be used to put an aggregate into the FROM clause of its query
! select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;
! ERROR:  aggregate functions are not allowed in FROM clause of their own query level
! LINE 1: select 1 from tenk1 a, lateral (select max(a.unique1) from i...
!                                                ^
! -- check behavior of LATERAL in UPDATE/DELETE
! create temp table xx1 as select f1 as x1, -f1 as x2 from int4_tbl;
! -- error, can't do this:
! update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
! ERROR:  column "x1" does not exist
! LINE 1: ... set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
! update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...t x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss...
!                                                              ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
! -- can't do it even with LATERAL:
! update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...= f1 from lateral (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
! -- we might in future allow something like this, but for now it's an error:
! update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;
! ERROR:  table name "xx1" specified more than once
! -- also errors:
! delete from xx1 using (select * from int4_tbl where f1 = x1) ss;
! ERROR:  column "x1" does not exist
! LINE 1: ...te from xx1 using (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
! delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss...
!                                                              ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
! delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
! ERROR:  invalid reference to FROM-clause entry for table "xx1"
! LINE 1: ...xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
!                                                                 ^
! HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
! -- demonstrate problem with extrememly slow join
! CREATE TABLE testr (a int, b int) DISTRIBUTE BY REPLICATION;
! INSERT INTO testr SELECT generate_series(1, 10000), generate_series(5001, 15000);
! CREATE TABLE testh (a int, b int);
! INSERT INTO testh SELECT generate_series(1, 10000), generate_series(8001, 18000);
! set enable_mergejoin TO false;
! set enable_hashjoin TO false;
! EXPLAIN (VERBOSE, COSTS OFF) SELECT count(*) FROM testr WHERE NOT EXISTS (SELECT * FROM testh WHERE testr.b = testh.b);
!                                     QUERY PLAN                                     
! -----------------------------------------------------------------------------------
!  Finalize Aggregate
!    Output: count(*)
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          Output: PARTIAL count(*)
!          ->  Partial Aggregate
!                Output: PARTIAL count(*)
!                ->  Nested Loop Anti Join
!                      Join Filter: (testr.b = testh.b)
!                      ->  Remote Subquery Scan on all (datanode_1)
!                            Output: testr.b
!                            Distribute results by H: b
!                            ->  Seq Scan on public.testr
!                                  Output: testr.b
!                      ->  Materialize
!                            Output: testh.b
!                            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                  Output: testh.b
!                                  Distribute results by H: b
!                                  ->  Seq Scan on public.testh
!                                        Output: testh.b
! (20 rows)
! 
! SELECT count(*) FROM testr WHERE NOT EXISTS (SELECT * FROM testh WHERE testr.b = testh.b);
!  count 
! -------
!   3000
! (1 row)
! 
! --
! -- test that foreign key join estimation performs sanely for outer joins
! --
! begin;
! create table fkest (a int, b int, c int unique, primary key(a,b));
! create table fkest1 (a int, b int, primary key(a,b));
! insert into fkest select x/10, x%10, x from generate_series(1,2000) x;
! insert into fkest1 select x/10, x%10 from generate_series(1,2000) x;
! alter table fkest1
!   add constraint fkest1_a_b_fkey foreign key (a,b) references fkest;
! analyze fkest;
! analyze fkest1;
! explain (costs off)
! select *
! from fkest f
!   left join fkest1 f1 on f.a = f1.a and f.b = f1.b
!   left join fkest1 f2 on f.a = f2.a and f.b = f2.b
!   left join fkest1 f3 on f.a = f3.a and f.b = f3.b
! where f.c = 1;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Nested Loop Left Join
!          ->  Nested Loop Left Join
!                ->  Nested Loop Left Join
!                      ->  Remote Subquery Scan on all (datanode_1)
!                            Distribute results by H: a
!                            ->  Index Scan using fkest_c_key on fkest f
!                                  Index Cond: (c = 1)
!                      ->  Index Only Scan using fkest1_pkey on fkest1 f1
!                            Index Cond: ((a = f.a) AND (b = f.b))
!                ->  Index Only Scan using fkest1_pkey on fkest1 f2
!                      Index Cond: ((a = f.a) AND (b = f.b))
!          ->  Index Only Scan using fkest1_pkey on fkest1 f3
!                Index Cond: ((a = f.a) AND (b = f.b))
! (14 rows)
! 
! rollback;
! --
! -- test planner's ability to mark joins as unique
! --
! create table j1 (id int primary key);
! create table j2 (id int primary key);
! create table j3 (id int);
! insert into j1 values(1),(2),(3);
! insert into j2 values(1),(2),(3);
! insert into j3 values(1),(1);
! analyze j1;
! analyze j2;
! analyze j3;
! -- ensure join is properly marked as unique
! explain (verbose, costs off)
! select * from j1 inner join j2 on j1.id = j2.id;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: j1.id, j2.id
!    Node/s: datanode_1, datanode_2
!    Remote query: SELECT j1.id, j2.id FROM (j1 JOIN j2 ON ((j1.id = j2.id)))
!    ->  Nested Loop
!          Output: j1.id, j2.id
!          Inner Unique: true
!          ->  Seq Scan on public.j1
!                Output: j1.id
!          ->  Bitmap Heap Scan on public.j2
!                Output: j2.id
!                Recheck Cond: (j2.id = j1.id)
!                ->  Bitmap Index Scan on j2_pkey
!                      Index Cond: (j2.id = j1.id)
! (14 rows)
! 
! -- ensure join is not unique when not an equi-join
! explain (verbose, costs off)
! select * from j1 inner join j2 on j1.id > j2.id;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Nested Loop
!    Output: j1.id, j2.id
!    Join Filter: (j1.id > j2.id)
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          Output: j1.id
!          ->  Bitmap Heap Scan on public.j1
!                Output: j1.id
!                ->  Bitmap Index Scan on j1_pkey
!    ->  Materialize
!          Output: j2.id
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Output: j2.id
!                ->  Bitmap Heap Scan on public.j2
!                      Output: j2.id
!                      ->  Bitmap Index Scan on j2_pkey
! (15 rows)
! 
! -- ensure non-unique rel is not chosen as inner
! explain (verbose, costs off)
! select * from j1 inner join j3 on j1.id = j3.id;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: j1.id, j3.id
!    Node/s: datanode_1, datanode_2
!    Remote query: SELECT j1.id, j3.id FROM (j1 JOIN j3 ON ((j1.id = j3.id)))
!    ->  Nested Loop
!          Output: j1.id, j3.id
!          Inner Unique: true
!          ->  Seq Scan on public.j3
!                Output: j3.id
!          ->  Bitmap Heap Scan on public.j1
!                Output: j1.id
!                Recheck Cond: (j1.id = j3.id)
!                ->  Bitmap Index Scan on j1_pkey
!                      Index Cond: (j1.id = j3.id)
! (14 rows)
! 
! -- ensure left join is marked as unique
! explain (verbose, costs off)
! select * from j1 left join j2 on j1.id = j2.id;
!                                    QUERY PLAN                                    
! ---------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: j1.id, j2.id
!    Node/s: datanode_1, datanode_2
!    Remote query: SELECT j1.id, j2.id FROM (j1 LEFT JOIN j2 ON ((j1.id = j2.id)))
!    ->  Nested Loop Left Join
!          Output: j1.id, j2.id
!          Inner Unique: true
!          ->  Seq Scan on public.j1
!                Output: j1.id
!          ->  Bitmap Heap Scan on public.j2
!                Output: j2.id
!                Recheck Cond: (j1.id = j2.id)
!                ->  Bitmap Index Scan on j2_pkey
!                      Index Cond: (j1.id = j2.id)
! (14 rows)
! 
! -- ensure right join is marked as unique
! explain (verbose, costs off)
! select * from j1 right join j2 on j1.id = j2.id;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    Output: j1.id, j2.id
!    ->  Nested Loop Left Join
!          Output: j1.id, j2.id
!          Inner Unique: true
!          ->  Seq Scan on public.j2
!                Output: j2.id
!          ->  Bitmap Heap Scan on public.j1
!                Output: j1.id
!                Recheck Cond: (j1.id = j2.id)
!                ->  Bitmap Index Scan on j1_pkey
!                      Index Cond: (j1.id = j2.id)
! (12 rows)
! 
! -- ensure full join is marked as unique
! explain (verbose, costs off)
! select * from j1 full join j2 on j1.id = j2.id;
!                                    QUERY PLAN                                    
! ---------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: j1.id, j2.id
!    Node/s: datanode_1, datanode_2
!    Remote query: SELECT j1.id, j2.id FROM (j1 FULL JOIN j2 ON ((j1.id = j2.id)))
!    ->  Hash Full Join
!          Output: j1.id, j2.id
!          Inner Unique: true
!          Hash Cond: (j1.id = j2.id)
!          ->  Seq Scan on public.j1
!                Output: j1.id
!          ->  Hash
!                Output: j2.id
!                ->  Seq Scan on public.j2
!                      Output: j2.id
! (14 rows)
! 
! -- a clauseless (cross) join can't be unique
! explain (verbose, costs off)
! select * from j1 cross join j2;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Nested Loop
!    Output: j1.id, j2.id
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!          Output: j1.id
!          ->  Bitmap Heap Scan on public.j1
!                Output: j1.id
!                ->  Bitmap Index Scan on j1_pkey
!    ->  Materialize
!          Output: j2.id
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Output: j2.id
!                ->  Bitmap Heap Scan on public.j2
!                      Output: j2.id
!                      ->  Bitmap Index Scan on j2_pkey
! (14 rows)
! 
! -- ensure a natural join is marked as unique
! explain (verbose, costs off)
! select * from j1 natural join j2;
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Remote Fast Query Execution
!    Output: j1.id
!    Node/s: datanode_1, datanode_2
!    Remote query: SELECT j1.id FROM (j1 JOIN j2 USING (id))
!    ->  Nested Loop
!          Output: j1.id
!          Inner Unique: true
!          ->  Seq Scan on public.j1
!                Output: j1.id
!          ->  Bitmap Heap Scan on public.j2
!                Output: j2.id
!                Recheck Cond: (j2.id = j1.id)
!                ->  Bitmap Index Scan on j2_pkey
!                      Index Cond: (j2.id = j1.id)
! (14 rows)
! 
! -- ensure a distinct clause allows the inner to become unique
! explain (verbose, costs off)
! select * from j1
! inner join (select distinct id from j3) j3 on j1.id = j3.id;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    Output: j1.id, id
!    ->  Nested Loop
!          Output: j1.id, j3.id
!          Inner Unique: true
!          ->  Unique
!                Output: j3.id
!                ->  Sort
!                      Output: j3.id
!                      Sort Key: j3.id
!                      ->  Seq Scan on public.j3
!                            Output: j3.id
!          ->  Bitmap Heap Scan on public.j1
!                Output: j1.id
!                Recheck Cond: (j1.id = j3.id)
!                ->  Bitmap Index Scan on j1_pkey
!                      Index Cond: (j1.id = j3.id)
! (17 rows)
! 
! -- ensure group by clause allows the inner to become unique
! explain (verbose, costs off)
! select * from j1
! inner join (select id from j3 group by id) j3 on j1.id = j3.id;
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    Output: j1.id, id
!    ->  Nested Loop
!          Output: j1.id, j3.id
!          Inner Unique: true
!          ->  Group
!                Output: j3.id
!                Group Key: j3.id
!                ->  Sort
!                      Output: j3.id
!                      Sort Key: j3.id
!                      ->  Seq Scan on public.j3
!                            Output: j3.id
!          ->  Bitmap Heap Scan on public.j1
!                Output: j1.id
!                Recheck Cond: (j1.id = j3.id)
!                ->  Bitmap Index Scan on j1_pkey
!                      Index Cond: (j1.id = j3.id)
! (18 rows)
! 
! drop table j1;
! drop table j2;
! drop table j3;
! -- test more complex permutations of unique joins
! create table j1 (id1 int, id2 int, primary key(id1,id2));
! create table j2 (id1 int, id2 int, primary key(id1,id2));
! create table j3 (id1 int, id2 int, primary key(id1,id2));
! insert into j1 values(1,1),(1,2);
! insert into j2 values(1,1);
! insert into j3 values(1,1);
! analyze j1;
! analyze j2;
! analyze j3;
! -- ensure there's no unique join when not all columns which are part of the
! -- unique index are seen in the join clause
! explain (verbose, costs off)
! select * from j1
! inner join j2 on j1.id1 = j2.id1;
!                                            QUERY PLAN                                           
! ------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: j1.id1, j1.id2, j2.id1, j2.id2
!    Node/s: datanode_1, datanode_2
!    Remote query: SELECT j1.id1, j1.id2, j2.id1, j2.id2 FROM (j1 JOIN j2 ON ((j1.id1 = j2.id1)))
!    ->  Nested Loop
!          Output: j1.id1, j1.id2, j2.id1, j2.id2
!          Join Filter: (j1.id1 = j2.id1)
!          ->  Index Only Scan using j2_pkey on public.j2
!                Output: j2.id1, j2.id2
!          ->  Seq Scan on public.j1
!                Output: j1.id1, j1.id2
! (11 rows)
! 
! -- ensure proper unique detection with multiple join quals
! explain (verbose, costs off)
! select * from j1
! inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2;
!                                                        QUERY PLAN                                                       
! ------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: j1.id1, j1.id2, j2.id1, j2.id2
!    Node/s: datanode_1, datanode_2
!    Remote query: SELECT j1.id1, j1.id2, j2.id1, j2.id2 FROM (j1 JOIN j2 ON (((j1.id1 = j2.id1) AND (j1.id2 = j2.id2))))
!    ->  Nested Loop
!          Output: j1.id1, j1.id2, j2.id1, j2.id2
!          Inner Unique: true
!          ->  Index Only Scan using j2_pkey on public.j2
!                Output: j2.id1, j2.id2
!          ->  Bitmap Heap Scan on public.j1
!                Output: j1.id1, j1.id2
!                Recheck Cond: ((j1.id1 = j2.id1) AND (j1.id2 = j2.id2))
!                ->  Bitmap Index Scan on j1_pkey
!                      Index Cond: ((j1.id1 = j2.id1) AND (j1.id2 = j2.id2))
! (14 rows)
! 
! -- ensure we don't detect the join to be unique when quals are not part of the
! -- join condition
! explain (verbose, costs off)
! select * from j1
! inner join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
!                                                     QUERY PLAN                                                     
! -------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: j1.id1, j1.id2, j2.id1, j2.id2
!    Node/s: datanode_1, datanode_2
!    Remote query: SELECT j1.id1, j1.id2, j2.id1, j2.id2 FROM (j1 JOIN j2 ON ((j1.id1 = j2.id1))) WHERE (j1.id2 = 1)
!    ->  Nested Loop
!          Output: j1.id1, j1.id2, j2.id1, j2.id2
!          Inner Unique: true
!          ->  Index Only Scan using j2_pkey on public.j2
!                Output: j2.id1, j2.id2
!          ->  Bitmap Heap Scan on public.j1
!                Output: j1.id1, j1.id2
!                Recheck Cond: ((j1.id1 = j2.id1) AND (j1.id2 = 1))
!                ->  Bitmap Index Scan on j1_pkey
!                      Index Cond: ((j1.id1 = j2.id1) AND (j1.id2 = 1))
! (14 rows)
! 
! -- as above, but for left joins.
! explain (verbose, costs off)
! select * from j1
! left join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
!                                                        QUERY PLAN                                                       
! ------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: j1.id1, j1.id2, j2.id1, j2.id2
!    Node/s: datanode_1, datanode_2
!    Remote query: SELECT j1.id1, j1.id2, j2.id1, j2.id2 FROM (j1 LEFT JOIN j2 ON ((j1.id1 = j2.id1))) WHERE (j1.id2 = 1)
!    ->  Nested Loop Left Join
!          Output: j1.id1, j1.id2, j2.id1, j2.id2
!          Join Filter: (j1.id1 = j2.id1)
!          ->  Bitmap Heap Scan on public.j1
!                Output: j1.id1, j1.id2
!                Recheck Cond: (j1.id2 = 1)
!                ->  Bitmap Index Scan on j1_pkey
!                      Index Cond: (j1.id2 = 1)
!          ->  Index Only Scan using j2_pkey on public.j2
!                Output: j2.id1, j2.id2
! (14 rows)
! 
! -- validate logic in merge joins which skips mark and restore.
! -- it should only do this if all quals which were used to detect the unique
! -- are present as join quals, and not plain quals.
! set enable_nestloop to 0;
! set enable_hashjoin to 0;
! set enable_sort to 0;
! -- create an index that will be preferred over the PK to perform the join
! create index j1_id1_idx on j1 (id1) where id1 % 1000 = 1;
! explain (costs off) select * from j1 j1
! inner join j1 j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
! where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1;
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  Nested Loop
!          Join Filter: ((j1.id1 = j2.id1) AND (j1.id2 = j2.id2))
!          ->  Bitmap Heap Scan on j1
!                Recheck Cond: ((id1 % 1000) = 1)
!                ->  Bitmap Index Scan on j1_id1_idx
!          ->  Bitmap Heap Scan on j1 j2
!                Recheck Cond: ((id1 % 1000) = 1)
!                ->  Bitmap Index Scan on j1_id1_idx
! (10 rows)
! 
! select * from j1 j1
! inner join j1 j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
! where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1;
!  id1 | id2 | id1 | id2 
! -----+-----+-----+-----
!    1 |   1 |   1 |   1
!    1 |   2 |   1 |   2
! (2 rows)
! 
! reset enable_nestloop;
! reset enable_hashjoin;
! reset enable_sort;
! drop table j1;
! drop table j2;
! drop table j3;
! -- check that semijoin inner is not seen as unique for a portion of the outerrel
! explain (verbose, costs off)
! select t1.unique1, t2.hundred
! from onek t1, tenk1 t2
! where exists (select 1 from tenk1 t3
!               where t3.thousand = t1.unique1 and t3.tenthous = t2.hundred)
!       and t1.unique1 < 1;
!                                          QUERY PLAN                                          
! ---------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    Output: t1.unique1, t2.hundred
!    ->  Nested Loop
!          Output: t1.unique1, t2.hundred
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Output: t1.unique1, t3.tenthous
!                ->  Hash Join
!                      Output: t1.unique1, t3.tenthous
!                      Hash Cond: (t3.thousand = t1.unique1)
!                      ->  HashAggregate
!                            Output: t3.thousand, t3.tenthous
!                            Group Key: t3.thousand, t3.tenthous
!                            ->  Index Only Scan using tenk1_thous_tenthous on public.tenk1 t3
!                                  Output: t3.thousand, t3.tenthous
!                      ->  Hash
!                            Output: t1.unique1
!                            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                  Output: t1.unique1
!                                  Sort Key: t1.unique1
!                                  ->  Index Only Scan using onek_unique1 on public.onek t1
!                                        Output: t1.unique1
!                                        Index Cond: (t1.unique1 < 1)
!          ->  Index Only Scan using tenk1_hundred on public.tenk1 t2
!                Output: t2.hundred
!                Index Cond: (t2.hundred = t3.tenthous)
! (25 rows)
! 
! -- ... unless it actually is unique
! create table j3 as select unique1, tenthous from onek;
! vacuum analyze j3;
! create unique index on j3(unique1, tenthous);
! explain (verbose, costs off)
! select t1.unique1, t2.hundred
! from onek t1, tenk1 t2
! where exists (select 1 from j3
!               where j3.unique1 = t1.unique1 and j3.tenthous = t2.hundred)
!       and t1.unique1 < 1;
!                                      QUERY PLAN                                     
! ------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    Output: t1.unique1, t2.hundred
!    ->  Nested Loop
!          Output: t1.unique1, t2.hundred
!          ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Output: t1.unique1, j3.tenthous
!                ->  Nested Loop
!                      Output: t1.unique1, j3.tenthous
!                      ->  Index Only Scan using onek_unique1 on public.onek t1
!                            Output: t1.unique1
!                            Index Cond: (t1.unique1 < 1)
!                      ->  Index Only Scan using j3_unique1_tenthous_idx on public.j3
!                            Output: j3.unique1, j3.tenthous
!                            Index Cond: (j3.unique1 = t1.unique1)
!          ->  Index Only Scan using tenk1_hundred on public.tenk1 t2
!                Output: t2.hundred
!                Index Cond: (t2.hundred = j3.tenthous)
! (17 rows)
! 
! drop table j3;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/aggregates.out"	2025-07-31 16:07:14.977847998 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/aggregates.out"	2025-07-31 16:39:29.776072967 +0800
***************
*** 1,2024 ****
! --
! -- AGGREGATES
! --
! SELECT avg(four) AS avg_1 FROM onek;
!        avg_1        
! --------------------
!  1.5000000000000000
! (1 row)
! 
! SELECT avg(a) AS avg_32 FROM aggtest WHERE a < 100;
!        avg_32        
! ---------------------
!  32.6666666666666667
! (1 row)
! 
! -- In 7.1, avg(float4) is computed using float8 arithmetic.
! -- Round the result to 3 digits to avoid platform-specific results.
! SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
!  avg_107_943 
! -------------
!      107.943
! (1 row)
! 
! SELECT avg(gpa) AS avg_3_4 FROM ONLY student;
!  avg_3_4 
! ---------
!      3.4
! (1 row)
! 
! SELECT sum(four) AS sum_1500 FROM onek;
!  sum_1500 
! ----------
!      1500
! (1 row)
! 
! SELECT sum(a) AS sum_198 FROM aggtest;
!  sum_198 
! ---------
!      198
! (1 row)
! 
! SELECT sum(b) AS avg_431_773 FROM aggtest;
!  avg_431_773 
! -------------
!      431.773
! (1 row)
! 
! SELECT sum(gpa) AS avg_6_8 FROM ONLY student;
!  avg_6_8 
! ---------
!      6.8
! (1 row)
! 
! SELECT max(four) AS max_3 FROM onek;
!  max_3 
! -------
!      3
! (1 row)
! 
! SELECT max(a) AS max_100 FROM aggtest;
!  max_100 
! ---------
!      100
! (1 row)
! 
! SELECT max(aggtest.b) AS max_324_78 FROM aggtest;
!  max_324_78 
! ------------
!      324.78
! (1 row)
! 
! SELECT max(student.gpa) AS max_3_7 FROM student;
!  max_3_7 
! ---------
!      3.7
! (1 row)
! 
! SELECT stddev_pop(b) FROM aggtest;
!     stddev_pop    
! ------------------
!  131.107032318951
! (1 row)
! 
! SELECT stddev_samp(b) FROM aggtest;
!    stddev_samp    
! ------------------
!  151.389360803998
! (1 row)
! 
! SELECT var_pop(b) FROM aggtest;
!      var_pop      
! ------------------
!  17189.0539234824
! (1 row)
! 
! SELECT var_samp(b) FROM aggtest;
!      var_samp     
! ------------------
!  22918.7385646432
! (1 row)
! 
! SELECT stddev_pop(b::numeric) FROM aggtest;
!     stddev_pop    
! ------------------
!  131.107032862199
! (1 row)
! 
! SELECT stddev_samp(b::numeric) FROM aggtest;
!    stddev_samp    
! ------------------
!  151.389361431288
! (1 row)
! 
! SELECT var_pop(b::numeric) FROM aggtest;
!       var_pop       
! --------------------
!  17189.054065929769
! (1 row)
! 
! SELECT var_samp(b::numeric) FROM aggtest;
!       var_samp      
! --------------------
!  22918.738754573025
! (1 row)
! 
! -- population variance is defined for a single tuple, sample variance
! -- is not
! SELECT var_pop(1.0), var_samp(2.0);
!  var_pop | var_samp 
! ---------+----------
!        0 |         
! (1 row)
! 
! SELECT stddev_pop(3.0::numeric), stddev_samp(4.0::numeric);
!  stddev_pop | stddev_samp 
! ------------+-------------
!           0 |            
! (1 row)
! 
! -- verify correct results for null and NaN inputs
! select sum(null::int4) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select sum(null::int8) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select sum(null::numeric) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select sum(null::float8) from generate_series(1,3);
!  sum 
! -----
!     
! (1 row)
! 
! select avg(null::int4) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select avg(null::int8) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select avg(null::numeric) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select avg(null::float8) from generate_series(1,3);
!  avg 
! -----
!     
! (1 row)
! 
! select sum('NaN'::numeric) from generate_series(1,3);
!  sum 
! -----
!  NaN
! (1 row)
! 
! select avg('NaN'::numeric) from generate_series(1,3);
!  avg 
! -----
!  NaN
! (1 row)
! 
! -- SQL2003 binary aggregates
! SELECT regr_count(b, a) FROM aggtest;
!  regr_count 
! ------------
!           4
! (1 row)
! 
! SELECT regr_sxx(b, a) FROM aggtest;
!  regr_sxx 
! ----------
!      5099
! (1 row)
! 
! SELECT regr_syy(b, a) FROM aggtest;
!      regr_syy     
! ------------------
!  68756.2156939297
! (1 row)
! 
! SELECT regr_sxy(b, a) FROM aggtest;
!      regr_sxy     
! ------------------
!  2614.51582155001
! (1 row)
! 
! SELECT regr_avgx(b, a), regr_avgy(b, a) FROM aggtest;
!  regr_avgx |    regr_avgy     
! -----------+------------------
!       49.5 | 107.943152273074
! (1 row)
! 
! SELECT regr_r2(b, a) FROM aggtest;
!       regr_r2       
! --------------------
!  0.0194977982031797
! (1 row)
! 
! SELECT regr_slope(b, a), regr_intercept(b, a) FROM aggtest;
!     regr_slope     |  regr_intercept  
! -------------------+------------------
!  0.512750700441265 | 82.5619926012313
! (1 row)
! 
! SELECT covar_pop(b, a), covar_samp(b, a) FROM aggtest;
!     covar_pop     |    covar_samp    
! ------------------+------------------
!  653.628955387502 | 871.505273850003
! (1 row)
! 
! SELECT corr(b, a) FROM aggtest;
!        corr        
! -------------------
!  0.139634516517871
! (1 row)
! 
! SELECT count(four) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT count(DISTINCT four) AS cnt_4 FROM onek;
!  cnt_4 
! -------
!      4
! (1 row)
! 
! select ten, count(*), sum(four) from onek
! group by ten order by ten;
!  ten | count | sum 
! -----+-------+-----
!    0 |   100 | 100
!    1 |   100 | 200
!    2 |   100 | 100
!    3 |   100 | 200
!    4 |   100 | 100
!    5 |   100 | 200
!    6 |   100 | 100
!    7 |   100 | 200
!    8 |   100 | 100
!    9 |   100 | 200
! (10 rows)
! 
! select ten, count(four), sum(DISTINCT four) from onek
! group by ten order by ten;
!  ten | count | sum 
! -----+-------+-----
!    0 |   100 |   2
!    1 |   100 |   4
!    2 |   100 |   2
!    3 |   100 |   4
!    4 |   100 |   2
!    5 |   100 |   4
!    6 |   100 |   2
!    7 |   100 |   4
!    8 |   100 |   2
!    9 |   100 |   4
! (10 rows)
! 
! -- user-defined aggregates
! SELECT newavg(four) AS avg_1 FROM onek;
!        avg_1        
! --------------------
!  1.5000000000000000
! (1 row)
! 
! SELECT newsum(four) AS sum_1500 FROM onek;
!  sum_1500 
! ----------
!      1500
! (1 row)
! 
! SELECT newcnt(four) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT newcnt(*) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT oldcnt(*) AS cnt_1000 FROM onek;
!  cnt_1000 
! ----------
!      1000
! (1 row)
! 
! SELECT sum2(q1,q2) FROM int8_tbl;
!        sum2        
! -------------------
!  18271560493827981
! (1 row)
! 
! -- test for outer-level aggregates
! -- this should work
! select ten, sum(distinct four) from onek a
! group by ten
! having exists (select 1 from onek b where sum(distinct a.four) = b.four) 
! order by ten;
!  ten | sum 
! -----+-----
!    0 |   2
!    2 |   2
!    4 |   2
!    6 |   2
!    8 |   2
! (5 rows)
! 
! -- this should fail because subquery has an agg of its own in WHERE
! select ten, sum(distinct four) from onek a
! group by ten
! having exists (select 1 from onek b
!                where sum(distinct a.four + b.four) = b.four);
! ERROR:  aggregate functions are not allowed in WHERE
! LINE 4:                where sum(distinct a.four + b.four) = b.four)...
!                              ^
! -- Test handling of sublinks within outer-level aggregates.
! -- Per bug report from Daniel Grace.
! select
!   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
! from tenk1 o;
!  max  
! ------
!  9999
! (1 row)
! 
! -- Test handling of Params within aggregate arguments in hashed aggregation.
! -- Per bug report from Jeevan Chalke.
! explain (verbose, costs off)
! select s1, s2, sm
! from generate_series(1, 3) s1,
!      lateral (select s2, sum(s1 + s2) sm
!               from generate_series(1, 3) s2 group by s2) ss
! order by 1, 2;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Sort
!    Output: s1.s1, s2.s2, (sum((s1.s1 + s2.s2)))
!    Sort Key: s1.s1, s2.s2
!    ->  Nested Loop
!          Output: s1.s1, s2.s2, (sum((s1.s1 + s2.s2)))
!          ->  Function Scan on pg_catalog.generate_series s1
!                Output: s1.s1
!                Function Call: generate_series(1, 3)
!          ->  HashAggregate
!                Output: s2.s2, sum((s1.s1 + s2.s2))
!                Group Key: s2.s2
!                ->  Function Scan on pg_catalog.generate_series s2
!                      Output: s2.s2
!                      Function Call: generate_series(1, 3)
! (14 rows)
! 
! select s1, s2, sm
! from generate_series(1, 3) s1,
!      lateral (select s2, sum(s1 + s2) sm
!               from generate_series(1, 3) s2 group by s2) ss
! order by 1, 2;
!  s1 | s2 | sm 
! ----+----+----
!   1 |  1 |  2
!   1 |  2 |  3
!   1 |  3 |  4
!   2 |  1 |  3
!   2 |  2 |  4
!   2 |  3 |  5
!   3 |  1 |  4
!   3 |  2 |  5
!   3 |  3 |  6
! (9 rows)
! 
! explain (verbose, costs off)
! select array(select sum(x+y) s
!             from generate_series(1,3) y group by y order by s)
!   from generate_series(1,3) x;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Function Scan on pg_catalog.generate_series x
!    Output: (SubPlan 1)
!    Function Call: generate_series(1, 3)
!    SubPlan 1
!      ->  Sort
!            Output: (sum((x.x + y.y))), y.y
!            Sort Key: (sum((x.x + y.y)))
!            ->  HashAggregate
!                  Output: sum((x.x + y.y)), y.y
!                  Group Key: y.y
!                  ->  Function Scan on pg_catalog.generate_series y
!                        Output: y.y
!                        Function Call: generate_series(1, 3)
! (13 rows)
! 
! select array(select sum(x+y) s
!             from generate_series(1,3) y group by y order by s)
!   from generate_series(1,3) x;
!   array  
! ---------
!  {2,3,4}
!  {3,4,5}
!  {4,5,6}
! (3 rows)
! 
! --
! -- test for bitwise integer aggregates
! --
! CREATE TEMPORARY TABLE bitwise_test(
!   i2 INT2,
!   i4 INT4,
!   i8 INT8,
!   i INTEGER,
!   x INT2,
!   y BIT(4)
! );
! -- empty case
! SELECT
!   BIT_AND(i2) AS "?",
!   BIT_OR(i4)  AS "?"
! FROM bitwise_test;
!  ? | ? 
! ---+---
!    |  
! (1 row)
! 
! COPY bitwise_test FROM STDIN NULL 'null';
! SELECT
!   BIT_AND(i2) AS "1",
!   BIT_AND(i4) AS "1",
!   BIT_AND(i8) AS "1",
!   BIT_AND(i)  AS "?",
!   BIT_AND(x)  AS "0",
!   BIT_AND(y)  AS "0100",
!   BIT_OR(i2)  AS "7",
!   BIT_OR(i4)  AS "7",
!   BIT_OR(i8)  AS "7",
!   BIT_OR(i)   AS "?",
!   BIT_OR(x)   AS "7",
!   BIT_OR(y)   AS "1101"
! FROM bitwise_test;
!  1 | 1 | 1 | ? | 0 | 0100 | 7 | 7 | 7 | ? | 7 | 1101 
! ---+---+---+---+---+------+---+---+---+---+---+------
!  1 | 1 | 1 | 1 | 0 | 0100 | 7 | 7 | 7 | 3 | 7 | 1101
! (1 row)
! 
! --
! -- test boolean aggregates
! --
! -- first test all possible transition and final states
! SELECT
!   -- boolean and transitions
!   -- null because strict
!   booland_statefunc(NULL, NULL)  IS NULL AS "t",
!   booland_statefunc(TRUE, NULL)  IS NULL AS "t",
!   booland_statefunc(FALSE, NULL) IS NULL AS "t",
!   booland_statefunc(NULL, TRUE)  IS NULL AS "t",
!   booland_statefunc(NULL, FALSE) IS NULL AS "t",
!   -- and actual computations
!   booland_statefunc(TRUE, TRUE) AS "t",
!   NOT booland_statefunc(TRUE, FALSE) AS "t",
!   NOT booland_statefunc(FALSE, TRUE) AS "t",
!   NOT booland_statefunc(FALSE, FALSE) AS "t";
!  t | t | t | t | t | t | t | t | t 
! ---+---+---+---+---+---+---+---+---
!  t | t | t | t | t | t | t | t | t
! (1 row)
! 
! SELECT
!   -- boolean or transitions
!   -- null because strict
!   boolor_statefunc(NULL, NULL)  IS NULL AS "t",
!   boolor_statefunc(TRUE, NULL)  IS NULL AS "t",
!   boolor_statefunc(FALSE, NULL) IS NULL AS "t",
!   boolor_statefunc(NULL, TRUE)  IS NULL AS "t",
!   boolor_statefunc(NULL, FALSE) IS NULL AS "t",
!   -- actual computations
!   boolor_statefunc(TRUE, TRUE) AS "t",
!   boolor_statefunc(TRUE, FALSE) AS "t",
!   boolor_statefunc(FALSE, TRUE) AS "t",
!   NOT boolor_statefunc(FALSE, FALSE) AS "t";
!  t | t | t | t | t | t | t | t | t 
! ---+---+---+---+---+---+---+---+---
!  t | t | t | t | t | t | t | t | t
! (1 row)
! 
! CREATE TEMPORARY TABLE bool_test(
!   b1 BOOL,
!   b2 BOOL,
!   b3 BOOL,
!   b4 BOOL);
! -- empty case
! SELECT
!   BOOL_AND(b1)   AS "n",
!   BOOL_OR(b3)    AS "n"
! FROM bool_test;
!  n | n 
! ---+---
!    | 
! (1 row)
! 
! COPY bool_test FROM STDIN NULL 'null';
! SELECT
!   BOOL_AND(b1)     AS "f",
!   BOOL_AND(b2)     AS "t",
!   BOOL_AND(b3)     AS "f",
!   BOOL_AND(b4)     AS "n",
!   BOOL_AND(NOT b2) AS "f",
!   BOOL_AND(NOT b3) AS "t"
! FROM bool_test;
!  f | t | f | n | f | t 
! ---+---+---+---+---+---
!  f | t | f |   | f | t
! (1 row)
! 
! SELECT
!   EVERY(b1)     AS "f",
!   EVERY(b2)     AS "t",
!   EVERY(b3)     AS "f",
!   EVERY(b4)     AS "n",
!   EVERY(NOT b2) AS "f",
!   EVERY(NOT b3) AS "t"
! FROM bool_test;
!  f | t | f | n | f | t 
! ---+---+---+---+---+---
!  f | t | f |   | f | t
! (1 row)
! 
! SELECT
!   BOOL_OR(b1)      AS "t",
!   BOOL_OR(b2)      AS "t",
!   BOOL_OR(b3)      AS "f",
!   BOOL_OR(b4)      AS "n",
!   BOOL_OR(NOT b2)  AS "f",
!   BOOL_OR(NOT b3)  AS "t"
! FROM bool_test;
!  t | t | f | n | f | t 
! ---+---+---+---+---+---
!  t | t | f |   | f | t
! (1 row)
! 
! --
! -- Test cases that should be optimized into indexscans instead of
! -- the generic aggregate implementation.
! -- In Postgres-XL, plans printed by explain are the ones created on the
! -- coordinator. Coordinator does not generate index scan plans.
! --
! -- Basic cases
! explain (costs off, nodes off)
!   select min(unique1) from tenk1;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all
!                  ->  Limit
!                        ->  Index Only Scan using tenk1_unique1 on tenk1
!                              Index Cond: (unique1 IS NOT NULL)
! (7 rows)
! 
! select min(unique1) from tenk1;
!  min 
! -----
!    0
! (1 row)
! 
! explain (costs off, nodes off)
!   select max(unique1) from tenk1;
!                                    QUERY PLAN                                    
! ---------------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all
!                  ->  Limit
!                        ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                              Index Cond: (unique1 IS NOT NULL)
! (7 rows)
! 
! select max(unique1) from tenk1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off, nodes off)
!   select max(unique1) from tenk1 where unique1 < 42;
!                                      QUERY PLAN                                     
! ------------------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all
!                  ->  Limit
!                        ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                              Index Cond: ((unique1 IS NOT NULL) AND (unique1 < 42))
! (7 rows)
! 
! select max(unique1) from tenk1 where unique1 < 42;
!  max 
! -----
!   41
! (1 row)
! 
! explain (costs off, nodes off)
!   select max(unique1) from tenk1 where unique1 > 42;
!                                      QUERY PLAN                                     
! ------------------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all
!                  ->  Limit
!                        ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                              Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42))
! (7 rows)
! 
! select max(unique1) from tenk1 where unique1 > 42;
!  max  
! ------
!  9999
! (1 row)
! 
! -- the planner may choose a generic aggregate here if parallel query is
! -- enabled, since that plan will be parallel safe and the "optimized"
! -- plan, which has almost identical cost, will not be.  we want to test
! -- the optimized plan, so temporarily disable parallel query.
! begin;
! set local max_parallel_workers_per_gather = 0;
! explain (costs off)
!   select max(unique1) from tenk1 where unique1 > 42000;
!                                       QUERY PLAN                                       
! ---------------------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                  ->  Limit
!                        ->  Index Only Scan Backward using tenk1_unique1 on tenk1
!                              Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42000))
! (7 rows)
! 
! select max(unique1) from tenk1 where unique1 > 42000;
!  max 
! -----
!     
! (1 row)
! 
! rollback;
! -- multi-column index (uses tenk1_thous_tenthous)
! explain (costs off, nodes off)
!   select max(tenthous) from tenk1 where thousand = 33;
!                                        QUERY PLAN                                       
! ----------------------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all
!                  ->  Limit
!                        ->  Index Only Scan Backward using tenk1_thous_tenthous on tenk1
!                              Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
! (7 rows)
! 
! select max(tenthous) from tenk1 where thousand = 33;
!  max  
! ------
!  9033
! (1 row)
! 
! explain (costs off, nodes off)
!   select min(tenthous) from tenk1 where thousand = 33;
!                                       QUERY PLAN                                      
! --------------------------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all
!                  ->  Limit
!                        ->  Index Only Scan using tenk1_thous_tenthous on tenk1
!                              Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
! (7 rows)
! 
! select min(tenthous) from tenk1 where thousand = 33;
!  min 
! -----
!   33
! (1 row)
! 
! -- check parameter propagation into an indexscan subquery
! explain (costs off, nodes off)
!   select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
!     from int4_tbl;
!                                                 QUERY PLAN                                                 
! -----------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Seq Scan on int4_tbl
!          SubPlan 2
!            ->  Result
!                  InitPlan 1 (returns $1)
!                    ->  Limit
!                          ->  Remote Subquery Scan on all
!                                ->  Limit
!                                      ->  Index Only Scan using tenk1_unique1 on tenk1
!                                            Index Cond: ((unique1 IS NOT NULL) AND (unique1 > int4_tbl.f1))
! (10 rows)
! 
! select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
! from int4_tbl 
! order by f1;
!      f1      | gt 
! -------------+----
!  -2147483647 |  0
!      -123456 |  0
!            0 |  1
!       123456 |   
!   2147483647 |   
! (5 rows)
! 
! -- check some cases that were handled incorrectly in 8.3.0
! explain (costs off, nodes off)
!   select distinct max(unique2) from tenk1;
!                                    QUERY PLAN                                    
! ---------------------------------------------------------------------------------
!  HashAggregate
!    Group Key: $0
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all
!                  ->  Limit
!                        ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                              Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (9 rows)
! 
! select distinct max(unique2) from tenk1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off, nodes off)
!   select max(unique2) from tenk1 order by 1;
!                                    QUERY PLAN                                    
! ---------------------------------------------------------------------------------
!  Sort
!    Sort Key: ($0)
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all
!                  ->  Limit
!                        ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                              Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (9 rows)
! 
! select max(unique2) from tenk1 order by 1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off, nodes off)
!   select max(unique2) from tenk1 order by max(unique2);
!                                    QUERY PLAN                                    
! ---------------------------------------------------------------------------------
!  Sort
!    Sort Key: ($0)
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all
!                  ->  Limit
!                        ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                              Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (9 rows)
! 
! select max(unique2) from tenk1 order by max(unique2);
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off, nodes off)
!   select max(unique2) from tenk1 order by max(unique2)+1;
!                                    QUERY PLAN                                    
! ---------------------------------------------------------------------------------
!  Sort
!    Sort Key: (($0 + 1))
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all
!                  ->  Limit
!                        ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                              Index Cond: (unique2 IS NOT NULL)
!    ->  Result
! (9 rows)
! 
! select max(unique2) from tenk1 order by max(unique2)+1;
!  max  
! ------
!  9999
! (1 row)
! 
! explain (costs off, nodes off)
!   select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
!                                    QUERY PLAN                                    
! ---------------------------------------------------------------------------------
!  Sort
!    Sort Key: (generate_series(1, 3)) DESC
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all
!                  ->  Limit
!                        ->  Index Only Scan Backward using tenk1_unique2 on tenk1
!                              Index Cond: (unique2 IS NOT NULL)
!    ->  ProjectSet
!          ->  Result
! (10 rows)
! 
! select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
!  max  | g 
! ------+---
!  9999 | 3
!  9999 | 2
!  9999 | 1
! (3 rows)
! 
! -- interesting corner case: constant gets optimized into a seqscan
! explain (costs off)
!   select max(100) from tenk1;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Limit
!            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                  ->  Limit
!                        ->  Result
!                              One-Time Filter: (100 IS NOT NULL)
!                              ->  Seq Scan on tenk1
! (8 rows)
! 
! select max(100) from tenk1;
!  max 
! -----
!  100
! (1 row)
! 
! -- try it on an inheritance tree
! create table minmaxtest(f1 int);
! create table minmaxtest1() inherits (minmaxtest);
! create table minmaxtest2() inherits (minmaxtest);
! create table minmaxtest3() inherits (minmaxtest);
! create index minmaxtesti on minmaxtest(f1);
! create index minmaxtest1i on minmaxtest1(f1);
! create index minmaxtest2i on minmaxtest2(f1 desc);
! create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;
! insert into minmaxtest values(11), (12);
! insert into minmaxtest1 values(13), (14);
! insert into minmaxtest2 values(15), (16);
! insert into minmaxtest3 values(17), (18);
! explain (costs off, nodes off)
!   select min(f1), max(f1) from minmaxtest;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Finalize Aggregate
!    ->  Remote Subquery Scan on all
!          ->  Partial Aggregate
!                ->  Append
!                      ->  Seq Scan on minmaxtest
!                      ->  Seq Scan on minmaxtest1
!                      ->  Seq Scan on minmaxtest2
!                      ->  Seq Scan on minmaxtest3
! (8 rows)
! 
! select min(f1), max(f1) from minmaxtest;
!  min | max 
! -----+-----
!   11 |  18
! (1 row)
! 
! -- DISTINCT doesn't do anything useful here, but it shouldn't fail
! explain (costs off)
!   select distinct min(f1), max(f1) from minmaxtest;
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Unique
!    ->  Sort
!          Sort Key: (min(f1)), (max(f1))
!          ->  Finalize Aggregate
!                ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      ->  Partial Aggregate
!                            ->  Append
!                                  ->  Seq Scan on minmaxtest
!                                  ->  Seq Scan on minmaxtest1
!                                  ->  Seq Scan on minmaxtest2
!                                  ->  Seq Scan on minmaxtest3
! (11 rows)
! 
! select distinct min(f1), max(f1) from minmaxtest;
!  min | max 
! -----+-----
!   11 |  18
! (1 row)
! 
! drop table minmaxtest cascade;
! NOTICE:  drop cascades to 3 other objects
! DETAIL:  drop cascades to table minmaxtest1
! drop cascades to table minmaxtest2
! drop cascades to table minmaxtest3
! -- check for correct detection of nested-aggregate errors
! select max(min(unique1)) from tenk1;
! ERROR:  aggregate function calls cannot be nested
! LINE 1: select max(min(unique1)) from tenk1;
!                    ^
! select (select max(min(unique1)) from int8_tbl) from tenk1;
! ERROR:  aggregate function calls cannot be nested
! LINE 1: select (select max(min(unique1)) from int8_tbl) from tenk1;
!                            ^
! --
! -- Test removal of redundant GROUP BY columns
! --
! create temp table t1 (a int, b int, c int, d int, primary key (a, b));
! create temp table t2 (x int, y int, z int, primary key (x, y));
! create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);
! -- Non-primary-key columns can be removed from GROUP BY
! explain (costs off) select * from t1 group by a,b,c,d;
!             QUERY PLAN            
! ----------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  HashAggregate
!          Group Key: a, b
!          ->  Seq Scan on t1
! (5 rows)
! 
! -- No removal can happen if the complete PK is not present in GROUP BY
! explain (costs off) select a,c from t1 group by a,c,d;
!             QUERY PLAN            
! ----------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  HashAggregate
!          Group Key: a, c, d
!          ->  Seq Scan on t1
! (5 rows)
! 
! -- Test removal across multiple relations
! explain (costs off) select *
! from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
! group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  HashAggregate
!          Group Key: t1.a, t1.b, t2.x, t2.y
!          ->  Hash Join
!                Hash Cond: ((t2.x = t1.a) AND (t2.y = t1.b))
!                ->  Seq Scan on t2
!                ->  Hash
!                      ->  Seq Scan on t1
! (9 rows)
! 
! -- Test case where t1 can be optimized but not t2
! explain (costs off) select t1.*,t2.x,t2.z
! from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
! group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  HashAggregate
!          Group Key: t1.a, t1.b, t2.x, t2.z
!          ->  Hash Join
!                Hash Cond: ((t2.x = t1.a) AND (t2.y = t1.b))
!                ->  Seq Scan on t2
!                ->  Hash
!                      ->  Seq Scan on t1
! (9 rows)
! 
! -- Cannot optimize when PK is deferrable
! explain (costs off) select * from t3 group by a,b,c;
!             QUERY PLAN            
! ----------------------------------
!  Remote Fast Query Execution
!    Node/s: datanode_1, datanode_2
!    ->  HashAggregate
!          Group Key: a, b, c
!          ->  Seq Scan on t3
! (5 rows)
! 
! drop table t1;
! drop table t2;
! drop table t3;
! --
! -- Test combinations of DISTINCT and/or ORDER BY
! --
! select array_agg(a order by b)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {3,4,2,1}
! (1 row)
! 
! select array_agg(a order by a)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {1,2,3,4}
! (1 row)
! 
! select array_agg(a order by a desc)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {4,3,2,1}
! (1 row)
! 
! select array_agg(b order by a desc)
!   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
!  array_agg 
! -----------
!  {2,1,3,4}
! (1 row)
! 
! select array_agg(distinct a)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {1,2,3,NULL}
! (1 row)
! 
! select array_agg(distinct a order by a)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {1,2,3,NULL}
! (1 row)
! 
! select array_agg(distinct a order by a desc)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {NULL,3,2,1}
! (1 row)
! 
! select array_agg(distinct a order by a desc nulls last)
!   from (values (1),(2),(1),(3),(null),(2)) v(a);
!   array_agg   
! --------------
!  {3,2,1,NULL}
! (1 row)
! 
! -- multi-arg aggs, strict/nonstrict, distinct/order by
! select aggfstr(a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
!                 aggfstr                
! ---------------------------------------
!  {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfns(a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
!                     aggfns                     
! -----------------------------------------------
!  {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfstr(distinct a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                 aggfstr                
! ---------------------------------------
!  {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfns(distinct a,b,c)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select aggfstr(distinct a,b,c order by b)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                 aggfstr                
! ---------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)"}
! (1 row)
! 
! select aggfns(distinct a,b,c order by b)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,3) i;
!                     aggfns                     
! -----------------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! -- test specific code paths
! select aggfns(distinct a,a,c order by c using ~<~,a)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                      aggfns                     
! ------------------------------------------------
!  {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
! (1 row)
! 
! select aggfns(distinct a,a,c order by c using ~<~)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                      aggfns                     
! ------------------------------------------------
!  {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
! (1 row)
! 
! select aggfns(distinct a,a,c order by a)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                      aggfns                     
! ------------------------------------------------
!  {"(0,0,)","(1,1,foo)","(2,2,bar)","(3,3,baz)"}
! (1 row)
! 
! select aggfns(distinct a,b,c order by a,c using ~<~,b)
!   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!        generate_series(1,2) i;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! -- check node I/O via view creation and usage, also deparsing logic
! create view agg_view1 as
!   select aggfns(a,b,c)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.b, v.c) AS aggfns                                                                            +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(distinct a,b,c)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!          generate_series(1,3) i;
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(DISTINCT v.a, v.b, v.c) AS aggfns                                                                   +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
!      generate_series(1, 3) i(i);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(distinct a,b,c order by b)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!          generate_series(1,3) i;
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.b) AS aggfns                                                      +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
!      generate_series(1, 3) i(i);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(a,b,c order by b+1)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.b, v.c ORDER BY (v.b + 1)) AS aggfns                                                         +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(a,a,c order by b)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                      aggfns                     
! ------------------------------------------------
!  {"(3,3,baz)","(2,2,bar)","(1,1,foo)","(0,0,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.a, v.c ORDER BY v.b) AS aggfns                                                               +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(a,b,c order by c using ~<~)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(2,2,bar)","(3,1,baz)","(1,3,foo)","(0,,)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(v.a, v.b, v.c ORDER BY v.c USING ~<~ NULLS LAST) AS aggfns                                          +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
! (1 row)
! 
! create or replace view agg_view1 as
!   select aggfns(distinct a,b,c order by a,c using ~<~,b)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!          generate_series(1,2) i;
! select * from agg_view1;
!                     aggfns                     
! -----------------------------------------------
!  {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! select pg_get_viewdef('agg_view1'::regclass);
!                                                    pg_get_viewdef                                                    
! ---------------------------------------------------------------------------------------------------------------------
!   SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.a, v.c USING ~<~ NULLS LAST, v.b) AS aggfns                       +
!     FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
!      generate_series(1, 2) i(i);
! (1 row)
! 
! drop view agg_view1;
! -- incorrect DISTINCT usage errors
! select aggfns(distinct a,b,c order by i)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,b,c order by i)
!                                               ^
! select aggfns(distinct a,b,c order by a,b+1)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,b,c order by a,b+1)
!                                                 ^
! select aggfns(distinct a,b,c order by a,b,i,c)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,b,c order by a,b,i,c)
!                                                   ^
! select aggfns(distinct a,a,c order by a,b)
!   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select aggfns(distinct a,a,c order by a,b)
!                                                 ^
! -- string_agg tests
! select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);
!    string_agg   
! ----------------
!  aaaa,bbbb,cccc
! (1 row)
! 
! select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);
!    string_agg   
! ----------------
!  aaaa,bbbb,cccc
! (1 row)
! 
! select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);
!  string_agg 
! ------------
!  bbbbABcccc
! (1 row)
! 
! select string_agg(a,',') from (values(null),(null)) g(a);
!  string_agg 
! ------------
!  
! (1 row)
! 
! -- check some implicit casting cases, as per bug #5564
! select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok
!  string_agg 
! ------------
!  a,ab,abcd
! (1 row)
! 
! select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select string_agg(distinct f1::text, ',' order by f1) from v...
!                                                           ^
! select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok
! ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
! LINE 1: select string_agg(distinct f1, ',' order by f1::text) from v...
!                                                     ^
! select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok
!  string_agg 
! ------------
!  a,ab,abcd
! (1 row)
! 
! -- string_agg bytea tests
! create table bytea_test_table(v bytea);
! select string_agg(v, '') from bytea_test_table;
!  string_agg 
! ------------
!  
! (1 row)
! 
! insert into bytea_test_table values(decode('ff','hex'));
! select string_agg(v, '') from bytea_test_table;
!  string_agg 
! ------------
!  \xff
! (1 row)
! 
! insert into bytea_test_table values(decode('aa','hex'));
! select string_agg(v, '') from bytea_test_table;
!  string_agg 
! ------------
!  \xffaa
! (1 row)
! 
! select string_agg(v, NULL) from bytea_test_table;
!  string_agg 
! ------------
!  \xffaa
! (1 row)
! 
! select string_agg(v, decode('ee', 'hex')) from bytea_test_table;
!  string_agg 
! ------------
!  \xffeeaa
! (1 row)
! 
! drop table bytea_test_table;
! -- FILTER tests
! select min(unique1) filter (where unique1 > 100) from tenk1;
!  min 
! -----
!  101
! (1 row)
! 
! select ten, sum(distinct four) filter (where four::text ~ '123') from onek a
! group by ten;
!  ten | sum 
! -----+-----
!    0 |    
!    1 |    
!    2 |    
!    3 |    
!    4 |    
!    5 |    
!    6 |    
!    7 |    
!    8 |    
!    9 |    
! (10 rows)
! 
! select ten, sum(distinct four) filter (where four > 10) from onek a
! group by ten
! having exists (select 1 from onek b where sum(distinct a.four) = b.four);
!  ten | sum 
! -----+-----
!    0 |    
!    2 |    
!    4 |    
!    6 |    
!    8 |    
! (5 rows)
! 
! select max(foo COLLATE "C") filter (where (bar collate "POSIX") > '0')
! from (values ('a', 'b')) AS v(foo,bar);
!  max 
! -----
!  a
! (1 row)
! 
! -- outer reference in FILTER (PostgreSQL extension)
! select (select count(*)
!         from (values (1)) t0(inner_c))
! from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
!  count 
! -------
!      1
!      1
! (2 rows)
! 
! select (select count(*) filter (where outer_c <> 0)
!         from (values (1)) t0(inner_c))
! from (values (2),(3)) t1(outer_c); -- outer query is aggregation query
!  count 
! -------
!      2
! (1 row)
! 
! select (select count(inner_c) filter (where outer_c <> 0)
!         from (values (1)) t0(inner_c))
! from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
!  count 
! -------
!      1
!      1
! (2 rows)
! 
! select
!   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))
!      filter (where o.unique1 < 10))
! from tenk1 o;					-- outer query is aggregation query
!  max  
! ------
!  9998
! (1 row)
! 
! -- subquery in FILTER clause (PostgreSQL extension)
! select sum(unique1) FILTER (WHERE
!   unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;
!  sum  
! ------
!  4950
! (1 row)
! 
! -- exercise lots of aggregate parts with FILTER
! select aggfns(distinct a,b,c order by a,c using ~<~,b) filter (where a > 1)
!     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
!     generate_series(1,2) i;
!           aggfns           
! ---------------------------
!  {"(2,2,bar)","(3,1,baz)"}
! (1 row)
! 
! -- ordered-set aggregates
! select p, percentile_cont(p) within group (order by x::float8)
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
!   p   | percentile_cont 
! ------+-----------------
!     0 |               1
!   0.1 |             1.4
!  0.25 |               2
!   0.4 |             2.6
!   0.5 |               3
!   0.6 |             3.4
!  0.75 |               4
!   0.9 |             4.6
!     1 |               5
! (9 rows)
! 
! select p, percentile_cont(p order by p) within group (order by x)  -- error
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
! ERROR:  cannot use multiple ORDER BY clauses with WITHIN GROUP
! LINE 1: select p, percentile_cont(p order by p) within group (order ...
!                                                 ^
! select p, sum() within group (order by x::float8)  -- error
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
! ERROR:  sum is not an ordered-set aggregate, so it cannot have WITHIN GROUP
! LINE 1: select p, sum() within group (order by x::float8)  
!                   ^
! select p, percentile_cont(p,p)  -- error
! from generate_series(1,5) x,
!      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
! group by p order by p;
! ERROR:  WITHIN GROUP is required for ordered-set aggregate percentile_cont
! LINE 1: select p, percentile_cont(p,p)  
!                   ^
! select percentile_cont(0.5) within group (order by b) from aggtest;
!  percentile_cont  
! ------------------
!  53.4485001564026
! (1 row)
! 
! select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
!  percentile_cont  |   sum   
! ------------------+---------
!  53.4485001564026 | 431.773
! (1 row)
! 
! select percentile_cont(0.5) within group (order by thousand) from tenk1;
!  percentile_cont 
! -----------------
!            499.5
! (1 row)
! 
! select percentile_disc(0.5) within group (order by thousand) from tenk1;
!  percentile_disc 
! -----------------
!              499
! (1 row)
! 
! select rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  rank 
! ------
!     5
! (1 row)
! 
! select cume_dist(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  cume_dist 
! -----------
!      0.875
! (1 row)
! 
! select percent_rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4),(5)) v(x);
!  percent_rank 
! --------------
!           0.5
! (1 row)
! 
! select dense_rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  dense_rank 
! ------------
!           3
! (1 row)
! 
! select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
! from tenk1;
!       percentile_disc       
! ----------------------------
!  {0,99,249,499,749,899,999}
! (1 row)
! 
! select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
! from tenk1;
!        percentile_cont       
! -----------------------------
!  {0,249.75,499.5,749.25,999}
! (1 row)
! 
! select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
! from tenk1;
!          percentile_disc         
! ---------------------------------
!  {{NULL,999,499},{749,249,NULL}}
! (1 row)
! 
! select percentile_cont(array[0,1,0.25,0.75,0.5,1,0.3,0.32,0.35,0.38,0.4]) within group (order by x)
! from generate_series(1,6) x;
!              percentile_cont              
! ------------------------------------------
!  {1,6,2.25,4.75,3.5,6,2.5,2.6,2.75,2.9,3}
! (1 row)
! 
! select ten, mode() within group (order by string4) from tenk1 group by ten;
!  ten |  mode  
! -----+--------
!    0 | HHHHxx
!    1 | OOOOxx
!    2 | VVVVxx
!    3 | OOOOxx
!    4 | HHHHxx
!    5 | HHHHxx
!    6 | OOOOxx
!    7 | AAAAxx
!    8 | VVVVxx
!    9 | VVVVxx
! (10 rows)
! 
! select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
! from unnest('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}'::text[]) u(x);
!  percentile_disc 
! -----------------
!  {fred,jill,jim}
! (1 row)
! 
! -- check collation propagates up in suitable cases:
! select pg_collation_for(percentile_disc(1) within group (order by x collate "POSIX"))
!   from (values ('fred'),('jim')) v(x);
!  pg_collation_for 
! ------------------
!  "POSIX"
! (1 row)
! 
! -- ordered-set aggs created with CREATE AGGREGATE
! select test_rank(3) within group (order by x)
! from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
!  test_rank 
! -----------
!          5
! (1 row)
! 
! select test_percentile_disc(0.5) within group (order by thousand) from tenk1;
!  test_percentile_disc 
! ----------------------
!                   499
! (1 row)
! 
! -- ordered-set aggs can't use ungrouped vars in direct args:
! select rank(x) within group (order by x) from generate_series(1,5) x;
! ERROR:  column "x.x" must appear in the GROUP BY clause or be used in an aggregate function
! LINE 1: select rank(x) within group (order by x) from generate_serie...
!                     ^
! DETAIL:  Direct arguments of an ordered-set aggregate must use only grouped columns.
! -- outer-level agg can't use a grouped arg of a lower level, either:
! select array(select percentile_disc(a) within group (order by x)
!                from (values (0.3),(0.7)) v(a) group by a)
!   from generate_series(1,5) g(x);
! ERROR:  outer-level aggregate cannot contain a lower-level variable in its direct arguments
! LINE 1: select array(select percentile_disc(a) within group (order b...
!                                             ^
! -- agg in the direct args is a grouping violation, too:
! select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
! ERROR:  aggregate function calls cannot be nested
! LINE 1: select rank(sum(x)) within group (order by x) from generate_...
!                     ^
! -- hypothetical-set type unification and argument-count failures:
! select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
! ERROR:  WITHIN GROUP types text and integer cannot be matched
! LINE 1: select rank(3) within group (order by x) from (values ('fred...
!                     ^
! select rank(3) within group (order by stringu1,stringu2) from tenk1;
! ERROR:  function rank(integer, name, name) does not exist
! LINE 1: select rank(3) within group (order by stringu1,stringu2) fro...
!                ^
! HINT:  To use the hypothetical-set aggregate rank, the number of hypothetical direct arguments (here 1) must match the number of ordering columns (here 2).
! select rank('fred') within group (order by x) from generate_series(1,5) x;
! ERROR:  invalid input syntax for integer: "fred"
! LINE 1: select rank('fred') within group (order by x) from generate_...
!                     ^
! select rank('adam'::text collate "C") within group (order by x collate "POSIX")
!   from (values ('fred'),('jim')) v(x);
! ERROR:  collation mismatch between explicit collations "C" and "POSIX"
! LINE 1: ...adam'::text collate "C") within group (order by x collate "P...
!                                                              ^
! -- hypothetical-set type unification successes:
! select rank('adam'::varchar) within group (order by x) from (values ('fred'),('jim')) v(x);
!  rank 
! ------
!     1
! (1 row)
! 
! select rank('3') within group (order by x) from generate_series(1,5) x;
!  rank 
! ------
!     3
! (1 row)
! 
! -- divide by zero check
! select percent_rank(0) within group (order by x) from generate_series(1,0) x;
!  percent_rank 
! --------------
!             0
! (1 row)
! 
! -- deparse and multiple features:
! create view aggordview1 as
! select ten,
!        percentile_disc(0.5) within group (order by thousand) as p50,
!        percentile_disc(0.5) within group (order by thousand) filter (where hundred=1) as px,
!        rank(5,'AZZZZ',50) within group (order by hundred, string4 desc, hundred)
!   from tenk1
!  group by ten order by ten;
! select pg_get_viewdef('aggordview1');
!                                                         pg_get_viewdef                                                         
! -------------------------------------------------------------------------------------------------------------------------------
!   SELECT tenk1.ten,                                                                                                           +
!      percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY tenk1.thousand) AS p50,                                  +
!      percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY tenk1.thousand) FILTER (WHERE (tenk1.hundred = 1)) AS px,+
!      rank(5, 'AZZZZ'::name, 50) WITHIN GROUP (ORDER BY tenk1.hundred, tenk1.string4 DESC, tenk1.hundred) AS rank              +
!     FROM tenk1                                                                                                                +
!    GROUP BY tenk1.ten                                                                                                         +
!    ORDER BY tenk1.ten;
! (1 row)
! 
! select * from aggordview1 order by ten;
!  ten | p50 | px  | rank 
! -----+-----+-----+------
!    0 | 490 |     |  101
!    1 | 491 | 401 |  101
!    2 | 492 |     |  101
!    3 | 493 |     |  101
!    4 | 494 |     |  101
!    5 | 495 |     |   67
!    6 | 496 |     |    1
!    7 | 497 |     |    1
!    8 | 498 |     |    1
!    9 | 499 |     |    1
! (10 rows)
! 
! drop view aggordview1;
! -- variadic aggregates
! select least_agg(q1,q2) from int8_tbl;
!      least_agg     
! -------------------
!  -4567890123456789
! (1 row)
! 
! select least_agg(variadic array[q1,q2]) from int8_tbl;
!      least_agg     
! -------------------
!  -4567890123456789
! (1 row)
! 
! -- int8 aggregates for distributed tables
! CREATE TABLE int8_tbl_aggtest AS SELECT * FROM int8_tbl;
! SELECT avg(q1) FROM int8_tbl_aggtest;
!           avg          
! -----------------------
!  2740734074074122.6000
! (1 row)
! 
! SELECT sum(q1) FROM int8_tbl_aggtest;
!         sum        
! -------------------
!  13703670370370613
! (1 row)
! 
! SELECT max(q1) FROM int8_tbl_aggtest;
!        max        
! ------------------
!  4567890123456789
! (1 row)
! 
! SELECT min(q1) FROM int8_tbl_aggtest;
!  min 
! -----
!  123
! (1 row)
! 
! SELECT stddev_pop(q1) FROM int8_tbl_aggtest;
!     stddev_pop    
! ------------------
!  2237800000713538
! (1 row)
! 
! SELECT stddev_samp(q1) FROM int8_tbl_aggtest;
!    stddev_samp    
! ------------------
!  2501936460822274
! (1 row)
! 
! SELECT var_pop(q1) FROM int8_tbl_aggtest;
!              var_pop             
! ---------------------------------
!  5007748843193509284246811160533
! (1 row)
! 
! SELECT var_samp(q1) FROM int8_tbl_aggtest;
!             var_samp             
! ---------------------------------
!  6259686053991886605308513950667
! (1 row)
! 
! DROP TABLE int8_tbl_aggtest;
! -- test aggregates with common transition functions share the same states
! begin work;
! create type avg_state as (total bigint, count bigint);
! create or replace function avg_transfn(state avg_state, n int) returns avg_state as
! $$
! declare new_state avg_state;
! begin
! 	raise notice 'avg_transfn called with %', n;
! 	if state is null then
! 		if n is not null then
! 			new_state.total := n;
! 			new_state.count := 1;
! 			return new_state;
! 		end if;
! 		return null;
! 	elsif n is not null then
! 		state.total := state.total + n;
! 		state.count := state.count + 1;
! 		return state;
! 	end if;
! 
! 	return null;
! end
! $$ language plpgsql;
! create function avg_finalfn(state avg_state) returns int4 as
! $$
! begin
! 	if state is null then
! 		return NULL;
! 	else
! 		return state.total / state.count;
! 	end if;
! end
! $$ language plpgsql;
! create function sum_finalfn(state avg_state) returns int4 as
! $$
! begin
! 	if state is null then
! 		return NULL;
! 	else
! 		return state.total;
! 	end if;
! end
! $$ language plpgsql;
! create aggregate my_avg(int4)
! (
!    stype = avg_state,
!    sfunc = avg_transfn,
!    finalfunc = avg_finalfn
! );
! create aggregate my_sum(int4)
! (
!    stype = avg_state,
!    sfunc = avg_transfn,
!    finalfunc = sum_finalfn
! );
! -- aggregate state should be shared as aggs are the same.
! select my_avg(one),my_avg(one) from (values(1),(3)) t(one);
! NOTICE:  avg_transfn called with 1
! NOTICE:  avg_transfn called with 3
!  my_avg | my_avg 
! --------+--------
!       2 |      2
! (1 row)
! 
! -- aggregate state should be shared as transfn is the same for both aggs.
! select my_avg(one),my_sum(one) from (values(1),(3)) t(one);
! NOTICE:  avg_transfn called with 1
! NOTICE:  avg_transfn called with 3
!  my_avg | my_sum 
! --------+--------
!       2 |      4
! (1 row)
! 
! -- same as previous one, but with DISTINCT, which requires sorting the input.
! select my_avg(distinct one),my_sum(distinct one) from (values(1),(3),(1)) t(one);
! NOTICE:  avg_transfn called with 1
! NOTICE:  avg_transfn called with 3
!  my_avg | my_sum 
! --------+--------
!       2 |      4
! (1 row)
! 
! -- shouldn't share states due to the distinctness not matching.
! select my_avg(distinct one),my_sum(one) from (values(1),(3)) t(one);
! NOTICE:  avg_transfn called with 1
! NOTICE:  avg_transfn called with 3
! NOTICE:  avg_transfn called with 1
! NOTICE:  avg_transfn called with 3
!  my_avg | my_sum 
! --------+--------
!       2 |      4
! (1 row)
! 
! -- shouldn't share states due to the filter clause not matching.
! select my_avg(one) filter (where one > 1),my_sum(one) from (values(1),(3)) t(one);
! NOTICE:  avg_transfn called with 1
! NOTICE:  avg_transfn called with 3
! NOTICE:  avg_transfn called with 3
!  my_avg | my_sum 
! --------+--------
!       3 |      4
! (1 row)
! 
! -- this should not share the state due to different input columns.
! select my_avg(one),my_sum(two) from (values(1,2),(3,4)) t(one,two);
! NOTICE:  avg_transfn called with 2
! NOTICE:  avg_transfn called with 1
! NOTICE:  avg_transfn called with 4
! NOTICE:  avg_transfn called with 3
!  my_avg | my_sum 
! --------+--------
!       2 |      6
! (1 row)
! 
! -- test that aggs with the same sfunc and initcond share the same agg state
! create aggregate my_sum_init(int4)
! (
!    stype = avg_state,
!    sfunc = avg_transfn,
!    finalfunc = sum_finalfn,
!    initcond = '(10,0)'
! );
! create aggregate my_avg_init(int4)
! (
!    stype = avg_state,
!    sfunc = avg_transfn,
!    finalfunc = avg_finalfn,
!    initcond = '(10,0)'
! );
! create aggregate my_avg_init2(int4)
! (
!    stype = avg_state,
!    sfunc = avg_transfn,
!    finalfunc = avg_finalfn,
!    initcond = '(4,0)'
! );
! -- state should be shared if INITCONDs are matching
! select my_sum_init(one),my_avg_init(one) from (values(1),(3)) t(one);
! NOTICE:  avg_transfn called with 1
! NOTICE:  avg_transfn called with 3
!  my_sum_init | my_avg_init 
! -------------+-------------
!           14 |           7
! (1 row)
! 
! -- Varying INITCONDs should cause the states not to be shared.
! select my_sum_init(one),my_avg_init2(one) from (values(1),(3)) t(one);
! NOTICE:  avg_transfn called with 1
! NOTICE:  avg_transfn called with 1
! NOTICE:  avg_transfn called with 3
! NOTICE:  avg_transfn called with 3
!  my_sum_init | my_avg_init2 
! -------------+--------------
!           14 |            4
! (1 row)
! 
! rollback;
! -- test aggregate state sharing to ensure it works if one aggregate has a
! -- finalfn and the other one has none.
! begin work;
! create or replace function sum_transfn(state int4, n int4) returns int4 as
! $$
! declare new_state int4;
! begin
! 	raise notice 'sum_transfn called with %', n;
! 	if state is null then
! 		if n is not null then
! 			new_state := n;
! 			return new_state;
! 		end if;
! 		return null;
! 	elsif n is not null then
! 		state := state + n;
! 		return state;
! 	end if;
! 
! 	return null;
! end
! $$ language plpgsql;
! create function halfsum_finalfn(state int4) returns int4 as
! $$
! begin
! 	if state is null then
! 		return NULL;
! 	else
! 		return state / 2;
! 	end if;
! end
! $$ language plpgsql;
! create aggregate my_sum(int4)
! (
!    stype = int4,
!    sfunc = sum_transfn
! );
! create aggregate my_half_sum(int4)
! (
!    stype = int4,
!    sfunc = sum_transfn,
!    finalfunc = halfsum_finalfn
! );
! -- Agg state should be shared even though my_sum has no finalfn
! select my_sum(one),my_half_sum(one) from (values(1),(2),(3),(4)) t(one);
! NOTICE:  sum_transfn called with 1
! NOTICE:  sum_transfn called with 2
! NOTICE:  sum_transfn called with 3
! NOTICE:  sum_transfn called with 4
!  my_sum | my_half_sum 
! --------+-------------
!      10 |           5
! (1 row)
! 
! rollback;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/transactions_1.out"	2025-07-31 16:07:15.004067834 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/transactions.out"	2025-07-31 16:39:29.786072754 +0800
***************
*** 1,686 ****
! --
! -- TRANSACTIONS
! --
! BEGIN;
! SELECT *
!    INTO TABLE xacttest
!    FROM aggtest;
! INSERT INTO xacttest (a, b) VALUES (777, 777.777);
! END;
! -- should retrieve one value--
! SELECT a FROM xacttest WHERE a > 100;
!   a  
! -----
!  777
! (1 row)
! 
! BEGIN;
! CREATE TABLE disappear (a int4);
! DELETE FROM aggtest;
! -- should be empty
! SELECT * FROM aggtest;
!  a | b 
! ---+---
! (0 rows)
! 
! ABORT;
! -- should not exist
! SELECT oid FROM pg_class WHERE relname = 'disappear';
!  oid 
! -----
! (0 rows)
! 
! -- should have members again 
! SELECT * FROM aggtest order by a, b;
!   a  |    b    
! -----+---------
!    0 | 0.09561
!   42 |  324.78
!   56 |     7.8
!  100 |  99.097
! (4 rows)
! 
! -- Read-only tests
! CREATE TABLE writetest (a int);
! CREATE TEMPORARY TABLE temptest (a int);
! BEGIN;
! SET TRANSACTION ISOLATION LEVEL SERIALIZABLE, READ ONLY, DEFERRABLE; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SET TRANSACTION READ WRITE; --fail
! ERROR:  transaction read-write mode must be set before any query
! COMMIT;
! BEGIN;
! SET TRANSACTION READ ONLY; -- ok
! SET TRANSACTION READ WRITE; -- ok
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SAVEPOINT x;
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SET TRANSACTION READ ONLY; -- ok
! SET TRANSACTION READ WRITE; --fail
! ERROR:  cannot set transaction read-write mode inside a read-only transaction
! COMMIT;
! BEGIN;
! SET TRANSACTION READ WRITE; -- ok
! SAVEPOINT x;
! SET TRANSACTION READ WRITE; -- ok
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! SET TRANSACTION READ ONLY; -- ok
! SET TRANSACTION READ WRITE; --fail
! ERROR:  cannot set transaction read-write mode inside a read-only transaction
! COMMIT;
! BEGIN;
! SET TRANSACTION READ WRITE; -- ok
! SAVEPOINT x;
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! ROLLBACK TO SAVEPOINT x;
! SHOW transaction_read_only;  -- off
!  transaction_read_only 
! -----------------------
!  off
! (1 row)
! 
! SAVEPOINT y;
! SET TRANSACTION READ ONLY; -- ok
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! RELEASE SAVEPOINT y;
! SHOW transaction_read_only;  -- off
!  transaction_read_only 
! -----------------------
!  off
! (1 row)
! 
! COMMIT;
! SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY;
! DROP TABLE writetest; -- fail
! ERROR:  cannot execute DROP TABLE in a read-only transaction
! INSERT INTO writetest VALUES (1); -- fail
! ERROR:  cannot execute INSERT in a read-only transaction
! SELECT * FROM writetest; -- ok
!  a 
! ---
! (0 rows)
! 
! DELETE FROM temptest; -- ok
! UPDATE temptest SET a = 0 FROM writetest WHERE temptest.a = 1 AND writetest.a = temptest.a; -- ok
! ERROR:  Distributed column or partition column "a" can't be updated in current version
! PREPARE test AS UPDATE writetest SET a = 0; -- ok
! ERROR:  Distributed column or partition column "a" can't be updated in current version
! EXECUTE test; -- fail
! ERROR:  prepared statement "test" does not exist
! SELECT * FROM writetest, temptest; -- ok
!  a | a 
! ---+---
! (0 rows)
! 
! CREATE TABLE test AS SELECT * FROM writetest; -- fail
! ERROR:  cannot execute CREATE TABLE in a read-only transaction
! START TRANSACTION READ WRITE;
! DROP TABLE writetest; -- ok
! COMMIT;
! -- Subtransactions, basic tests
! -- create & drop tables
! SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE;
! CREATE TABLE foobar (a int);
! BEGIN;
! 	CREATE TABLE foo (a int);
! 	SAVEPOINT one;
! 		DROP TABLE foo;
! 		CREATE TABLE bar (a int);
! 	ROLLBACK TO SAVEPOINT one;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		CREATE TABLE baz (a int);
! 	RELEASE SAVEPOINT two;
! 	drop TABLE foobar;
! 	CREATE TABLE barbaz (a int);
! COMMIT;
! -- should exist: barbaz, baz, foo
! SELECT * FROM foo;		-- should be empty
!  a 
! ---
! (0 rows)
! 
! SELECT * FROM bar;		-- shouldn't exist
! ERROR:  relation "bar" does not exist
! LINE 1: SELECT * FROM bar;
!                       ^
! SELECT * FROM barbaz;	-- should be empty
!  a 
! ---
! (0 rows)
! 
! SELECT * FROM baz;		-- should be empty
!  a 
! ---
! (0 rows)
! 
! -- inserts
! BEGIN;
! 	INSERT INTO foo VALUES (1);
! 	SAVEPOINT one;
! 		INSERT into bar VALUES (1);
! ERROR:  relation "bar" does not exist
! LINE 1: INSERT into bar VALUES (1);
!                     ^
! 	ROLLBACK TO one;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		INSERT into barbaz VALUES (1);
! 	RELEASE two;
! 	SAVEPOINT three;
! 		SAVEPOINT four;
! 			INSERT INTO foo VALUES (2);
! 		RELEASE SAVEPOINT four;
! 	ROLLBACK TO SAVEPOINT three;
! 	RELEASE SAVEPOINT three;
! 	INSERT INTO foo VALUES (3);
! COMMIT;
! SELECT * FROM foo ORDER BY a;		-- should have 1 and 3
!  a 
! ---
!  1
!  3
! (2 rows)
! 
! SELECT * FROM barbaz ORDER BY a;	-- should have 1
!  a 
! ---
!  1
! (1 row)
! 
! -- test whole-tree commit
! BEGIN;
! 	SAVEPOINT one;
! 		SELECT foo;
! ERROR:  column "foo" does not exist
! LINE 1: SELECT foo;
!                ^
! 	ROLLBACK TO SAVEPOINT one;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		CREATE TABLE savepoints (a int);
! 		SAVEPOINT three;
! 			INSERT INTO savepoints VALUES (1);
! 			SAVEPOINT four;
! 				INSERT INTO savepoints VALUES (2);
! 				SAVEPOINT five;
! 					INSERT INTO savepoints VALUES (3);
! 				ROLLBACK TO SAVEPOINT five;
! COMMIT;
! COMMIT;		-- should not be in a transaction block
! WARNING:  there is no transaction in progress
! SELECT * FROM savepoints ORDER BY 1;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
! -- test whole-tree rollback
! BEGIN;
! 	SAVEPOINT one;
! 		DELETE FROM savepoints WHERE a=1;
! 	RELEASE SAVEPOINT one;
! 	SAVEPOINT two;
! 		DELETE FROM savepoints WHERE a=1;
! 		SAVEPOINT three;
! 			DELETE FROM savepoints WHERE a=2;
! ROLLBACK;
! COMMIT;		-- should not be in a transaction block
! WARNING:  there is no transaction in progress
! 		
! SELECT * FROM savepoints ORDER BY 1;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
! -- test whole-tree commit on an aborted subtransaction
! BEGIN;
! 	INSERT INTO savepoints VALUES (4);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (5);
! 		SELECT foo;
! ERROR:  column "foo" does not exist
! LINE 1: SELECT foo;
!                ^
! COMMIT;
! SELECT * FROM savepoints ORDER BY a;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (6);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (7);
! 	RELEASE SAVEPOINT one;
! 	INSERT INTO savepoints VALUES (8);
! COMMIT;
! -- rows 6 and 8 should have been created by the same xact
! SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=6 AND b.a=8;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- rows 6 and 7 should have been created by different xacts
! SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=6 AND b.a=7;
!  ?column? 
! ----------
!  f
! (1 row)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (9);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (10);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (11);
! COMMIT;
! SELECT a FROM savepoints WHERE a in (9, 10, 11) ORDER BY a;
!  a  
! ----
!   9
!  11
! (2 rows)
! 
! -- rows 9 and 11 should have been created by different xacts
! SELECT a.xmin = b.xmin FROM savepoints a, savepoints b WHERE a.a=9 AND b.a=11;
!  ?column? 
! ----------
!  f
! (1 row)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (12);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (13);
! 		SAVEPOINT two;
! 			INSERT INTO savepoints VALUES (14);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (15);
! 		SAVEPOINT two;
! 			INSERT INTO savepoints VALUES (16);
! 			SAVEPOINT three;
! 				INSERT INTO savepoints VALUES (17);
! COMMIT;
! SELECT a FROM savepoints WHERE a BETWEEN 12 AND 17 ORDER BY a;
!  a  
! ----
!  12
!  15
!  16
!  17
! (4 rows)
! 
! BEGIN;
! 	INSERT INTO savepoints VALUES (18);
! 	SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (19);
! 		SAVEPOINT two;
! 			INSERT INTO savepoints VALUES (20);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (21);
! 	ROLLBACK TO SAVEPOINT one;
! 		INSERT INTO savepoints VALUES (22);
! COMMIT;
! SELECT a FROM savepoints WHERE a BETWEEN 18 AND 22 ORDER BY a;
!  a  
! ----
!  18
!  22
! (2 rows)
! 
! DROP TABLE savepoints;
! -- only in a transaction block:
! SAVEPOINT one;
! ERROR:  SAVEPOINT can only be used in transaction blocks
! ROLLBACK TO SAVEPOINT one;
! ERROR:  ROLLBACK TO SAVEPOINT can only be used in transaction blocks
! RELEASE SAVEPOINT one;
! ERROR:  RELEASE SAVEPOINT can only be used in transaction blocks
! -- Only "rollback to" allowed in aborted state
! BEGIN;
!   SAVEPOINT one;
!   SELECT 0/0;
! ERROR:  division by zero
!   SAVEPOINT two;    -- ignored till the end of ...
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
!   RELEASE SAVEPOINT one;      -- ignored till the end of ...
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
!   ROLLBACK TO SAVEPOINT one;
!   SELECT 1;
!  ?column? 
! ----------
!         1
! (1 row)
! 
! COMMIT;
! SELECT 1;			-- this should work
!  ?column? 
! ----------
!         1
! (1 row)
! 
! -- check non-transactional behavior of cursors
! BEGIN;
! 	DECLARE c CURSOR FOR SELECT unique2 FROM tenk1 ORDER BY unique2;
! 	SAVEPOINT one;
! 		FETCH 10 FROM c;
!  unique2 
! ---------
!        0
!        1
!        2
!        3
!        4
!        5
!        6
!        7
!        8
!        9
! (10 rows)
! 
! 	ROLLBACK TO SAVEPOINT one;
! 		FETCH 10 FROM c;
!  unique2 
! ---------
!       10
!       11
!       12
!       13
!       14
!       15
!       16
!       17
!       18
!       19
! (10 rows)
! 
! 	RELEASE SAVEPOINT one;
! 	FETCH 10 FROM c;
!  unique2 
! ---------
!       20
!       21
!       22
!       23
!       24
!       25
!       26
!       27
!       28
!       29
! (10 rows)
! 
! 	CLOSE c;
! 	DECLARE c CURSOR FOR SELECT unique2/0 FROM tenk1 ORDER BY unique2;
! 	SAVEPOINT two;
! 		FETCH 10 FROM c;
! ERROR:  division by zero
! 	ROLLBACK TO SAVEPOINT two;
! 	-- c is now dead to the world ...
! 		FETCH 10 FROM c;
! ERROR:  portal "c" cannot be run
! 	ROLLBACK TO SAVEPOINT two;
! 	RELEASE SAVEPOINT two;
! 	FETCH 10 FROM c;
! ERROR:  portal "c" cannot be run
! COMMIT;
! --
! -- Check that "stable" functions are really stable.  They should not be
! -- able to see the partial results of the calling query.  (Ideally we would
! -- also check that they don't see commits of concurrent transactions, but
! -- that's a mite hard to do within the limitations of pg_regress.)
! --
! select * from xacttest order by a, b;
!   a  |    b    
! -----+---------
!    0 | 0.09561
!   42 |  324.78
!   56 |     7.8
!  100 |  99.097
!  777 | 777.777
! (5 rows)
! 
! create or replace function max_xacttest() returns smallint language sql as
! 'select max(a) from xacttest' stable;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! ERROR:  Distributed column or partition column "a" can't be updated in current version
! select * from xacttest order by a, b;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! rollback;
! -- But a volatile function can see the partial results of the calling query
! create or replace function max_xacttest() returns smallint language sql as
! 'select max(a) from xacttest' volatile;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! ERROR:  Distributed column or partition column "a" can't be updated in current version
! select * from xacttest order by a, b;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! rollback;
! -- Now the same test with plpgsql (since it depends on SPI which is different)
! create or replace function max_xacttest() returns smallint language plpgsql as
! 'begin return max(a) from xacttest; end' stable;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! ERROR:  Distributed column or partition column "a" can't be updated in current version
! select * from xacttest order by a, b;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! rollback;
! create or replace function max_xacttest() returns smallint language plpgsql as
! 'begin return max(a) from xacttest; end' volatile;
! begin;
! update xacttest set a = max_xacttest() + 10 where a > 0;
! ERROR:  Distributed column or partition column "a" can't be updated in current version
! select * from xacttest order by a, b;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! rollback;
! -- test case for relations which are created and accessed in the same
! -- transaction, especially when the queries require datanode-to-datanode
! -- connections. In the past we had failed to use the correct snapshot in such
! -- cases 
! begin;
! create table a_snap (
!      code char not null,
!      constraint a_snap_pk primary key (code)
! );
! create table b_snap (
!      a char not null,
!      num integer not null,
!      constraint b_snap_pk primary key (a, num)
! );
! create table c_snap (
!      name char not null,
!      a char,
!      constraint c_snap_pk primary key (name)
! );
! insert into a_snap (code) values ('p');
! insert into a_snap (code) values ('q');
! insert into b_snap (a, num) values ('p', 1);
! insert into b_snap (a, num) values ('p', 2);
! insert into c_snap (name, a) values ('A', 'p');
! insert into c_snap (name, a) values ('B', 'q');
! insert into c_snap (name, a) values ('C', null);
! select c_snap.name, ss.code, ss.b_cnt, ss.const
! from c_snap left join
!   (select a_snap.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const
!    from a_snap left join
!      (select count(1) as cnt, b_snap.a from b_snap group by b_snap.a) as b_grp
!      on a_snap.code = b_grp.a
!   ) as ss
!   on (c_snap.a = ss.code)
! order by c_snap.name;
!  name | code | b_cnt | const 
! ------+------+-------+-------
!  A    | p    |     2 |    -1
!  B    | q    |     0 |    -1
!  C    |      |       |      
! (3 rows)
! 
! rollback;
! -- test case for problems with dropping an open relation during abort
! BEGIN;
! 	savepoint x;
! 		CREATE TABLE koju (a INT UNIQUE);
! 		INSERT INTO koju VALUES (1);
! 		INSERT INTO koju VALUES (1);
! ERROR:  duplicate key value violates unique constraint "koju_a_key"
! DETAIL:  Key (a)=(1) already exists.
! 	rollback to x;
! 	CREATE TABLE koju (a INT UNIQUE);
! 	INSERT INTO koju VALUES (1);
! 	INSERT INTO koju VALUES (1);
! ERROR:  duplicate key value violates unique constraint "koju_a_key"
! DETAIL:  Key (a)=(1) already exists.
! ROLLBACK;
! DROP TABLE foo;
! DROP TABLE baz;
! DROP TABLE barbaz;
! -- test case for problems with revalidating an open relation during abort
! create function inverse(int) returns float8 as
! $$
! begin
!   analyze revalidate_bug;
!   return 1::float8/$1;
! exception
!   when division_by_zero then return 0;
! end$$ language plpgsql volatile;
! create table revalidate_bug (c float8 unique);
! insert into revalidate_bug values (1);
! insert into revalidate_bug values (inverse(0));
! drop table revalidate_bug;
! drop function inverse(int);
! -- verify that cursors created during an aborted subtransaction are
! -- closed, but that we do not rollback the effect of any FETCHs
! -- performed in the aborted subtransaction
! begin;
! savepoint x;
! create table abc (a int);
! insert into abc values (5);
! insert into abc values (10);
! declare foo cursor for select * from abc order by a;
! fetch from foo;
!  a 
! ---
!  5
! (1 row)
! 
! rollback to x;
! -- should fail
! fetch from foo;
! ERROR:  cursor "foo" does not exist
! commit;
! begin;
! create table abc (a int);
! insert into abc values (5);
! insert into abc values (10);
! insert into abc values (15);
! declare foo cursor for select * from abc order by a;
! fetch from foo;
!  a 
! ---
!  5
! (1 row)
! 
! savepoint x;
! fetch from foo;
!  a  
! ----
!  10
! (1 row)
! 
! rollback to x;
! fetch from foo;
!  a  
! ----
!  15
! (1 row)
! 
! abort;
! -- Test for proper cleanup after a failure in a cursor portal
! -- that was created in an outer subtransaction
! CREATE FUNCTION invert(x float8) RETURNS float8 LANGUAGE plpgsql AS
! $$ begin return 1/x; end $$;
! CREATE FUNCTION create_temp_tab() RETURNS text
! LANGUAGE plpgsql AS $$
! BEGIN
!   CREATE TEMP TABLE new_table (f1 float8);
!   -- case of interest is that we fail while holding an open
!   -- relcache reference to new_table
!   INSERT INTO new_table SELECT invert(0.0);
!   RETURN 'foo';
! END $$;
! BEGIN;
! DECLARE ok CURSOR FOR SELECT * FROM int8_tbl order by 1;
! DECLARE ctt CURSOR FOR SELECT create_temp_tab();
! FETCH ok;
!  q1  | q2  
! -----+-----
!  123 | 456
! (1 row)
! 
! SAVEPOINT s1;
! FETCH ok;  -- should work
!  q1  |        q2        
! -----+------------------
!  123 | 4567890123456789
! (1 row)
! 
! FETCH ctt; -- error occurs here
! ERROR:  division by zero
! CONTEXT:  SQL statement "INSERT INTO new_table SELECT invert(0.0)"
! PL/pgSQL function create_temp_tab() line 6 at SQL statement
! ROLLBACK TO s1;
! FETCH ok;  -- should work
!         q1        | q2  
! ------------------+-----
!  4567890123456789 | 123
! (1 row)
! 
! FETCH ctt; -- must be rejected
! ERROR:  portal "ctt" cannot be run
! COMMIT;
! DROP FUNCTION create_temp_tab();
! DROP FUNCTION invert(x float8);
! -- Test for successful cleanup of an aborted transaction at session exit.
! -- THIS MUST BE THE LAST TEST IN THIS FILE.
! begin;
! select 1/0;
! ERROR:  division by zero
! rollback to X;
! ERROR:  no such savepoint
! -- DO NOT ADD ANYTHING HERE.
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/random.out"	2025-07-31 16:07:14.997067946 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/random.out"	2025-07-31 16:39:29.775072988 +0800
***************
*** 1,52 ****
! --
! -- RANDOM
! -- Test the random function
! --
! -- count the number of tuples originally, should be 1000
! SELECT count(*) FROM onek;
!  count 
! -------
!   1000
! (1 row)
! 
! -- pick three random rows, they shouldn't match
! (SELECT unique1 AS random
!   FROM onek ORDER BY random() LIMIT 1)
! INTERSECT
! (SELECT unique1 AS random
!   FROM onek ORDER BY random() LIMIT 1)
! INTERSECT
! (SELECT unique1 AS random
!   FROM onek ORDER BY random() LIMIT 1);
!  random 
! --------
! (0 rows)
! 
! -- count roughly 1/10 of the tuples
! SELECT count(*) AS random INTO RANDOM_TBL
!   FROM onek WHERE random() < 1.0/10;
! -- select again, the count should be different
! INSERT INTO RANDOM_TBL (random)
!   SELECT count(*)
!   FROM onek WHERE random() < 1.0/10;
! -- select again, the count should be different
! INSERT INTO RANDOM_TBL (random)
!   SELECT count(*)
!   FROM onek WHERE random() < 1.0/10;
! -- select again, the count should be different
! INSERT INTO RANDOM_TBL (random)
!   SELECT count(*)
!   FROM onek WHERE random() < 1.0/10;
! -- now test that they are different counts
! SELECT random, count(random) FROM RANDOM_TBL
!   GROUP BY random HAVING count(random) > 3;
!  random | count 
! --------+-------
! (0 rows)
! 
! SELECT AVG(random) FROM RANDOM_TBL
!   HAVING AVG(random) NOT BETWEEN 80 AND 120;
!  avg 
! -----
! (0 rows)
! 
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/portals_1.out"	2025-07-31 16:07:14.997067946 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/portals.out"	2025-07-31 16:39:29.779072903 +0800
***************
*** 1,1284 ****
! --
! -- Cursor regression tests
! --
! BEGIN;
! DECLARE foo1 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo2 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DECLARE foo3 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo4 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DECLARE foo5 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo6 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DECLARE foo7 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo8 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DECLARE foo9 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo10 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DECLARE foo11 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo12 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DECLARE foo13 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo14 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DECLARE foo15 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo16 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DECLARE foo17 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo18 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DECLARE foo19 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo20 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DECLARE foo21 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! DECLARE foo22 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DECLARE foo23 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! FETCH 1 in foo1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH 2 in foo2;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (2 rows)
! 
! FETCH 3 in foo3;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
! (3 rows)
! 
! FETCH 4 in foo4;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
! (4 rows)
! 
! FETCH 5 in foo5;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
! (5 rows)
! 
! FETCH 6 in foo6;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
! (6 rows)
! 
! FETCH 7 in foo7;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
! (7 rows)
! 
! FETCH 8 in foo8;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
! (8 rows)
! 
! FETCH 9 in foo9;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
! (9 rows)
! 
! FETCH 10 in foo10;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
! (10 rows)
! 
! FETCH 11 in foo11;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
! (11 rows)
! 
! FETCH 12 in foo12;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
! (12 rows)
! 
! FETCH 13 in foo13;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
! (13 rows)
! 
! FETCH 14 in foo14;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
! (14 rows)
! 
! FETCH 15 in foo15;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
! (15 rows)
! 
! FETCH 16 in foo16;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
! (16 rows)
! 
! FETCH 17 in foo17;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
! (17 rows)
! 
! FETCH 18 in foo18;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
! (18 rows)
! 
! FETCH 19 in foo19;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
! (19 rows)
! 
! FETCH 20 in foo20;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
! (20 rows)
! 
! FETCH 21 in foo21;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
! (21 rows)
! 
! FETCH 22 in foo22;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
!       59 |      21 |   1 |    3 |   9 |     19 |      59 |       59 |          59 |        59 |       59 | 118 |  119 | HCAAAA   | VAAAAA   | HHHHxx
! (22 rows)
! 
! FETCH 23 in foo23;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
!       59 |      21 |   1 |    3 |   9 |     19 |      59 |       59 |          59 |        59 |       59 | 118 |  119 | HCAAAA   | VAAAAA   | HHHHxx
!     8020 |      22 |   0 |    0 |   0 |      0 |      20 |       20 |          20 |      3020 |     8020 |  40 |   41 | MWAAAA   | WAAAAA   | OOOOxx
! (23 rows)
! 
! FETCH backward 1 in foo23;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!       59 |      21 |   1 |    3 |   9 |     19 |      59 |       59 |          59 |        59 |       59 | 118 |  119 | HCAAAA   | VAAAAA   | HHHHxx
! (1 row)
! 
! FETCH backward 2 in foo22;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     9460 |      20 |   0 |    0 |   0 |      0 |      60 |      460 |        1460 |      4460 |     9460 | 120 |  121 | WZAAAA   | UAAAAA   | AAAAxx
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
! (2 rows)
! 
! FETCH backward 3 in foo21;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6969 |      19 |   1 |    1 |   9 |      9 |      69 |      969 |         969 |      1969 |     6969 | 138 |  139 | BIAAAA   | TAAAAA   | VVVVxx
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
! (3 rows)
! 
! FETCH backward 4 in foo20;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6621 |      18 |   1 |    1 |   1 |      1 |      21 |      621 |         621 |      1621 |     6621 |  42 |   43 | RUAAAA   | SAAAAA   | OOOOxx
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
! (4 rows)
! 
! FETCH backward 5 in foo19;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5785 |      17 |   1 |    1 |   5 |      5 |      85 |      785 |        1785 |       785 |     5785 | 170 |  171 | NOAAAA   | RAAAAA   | HHHHxx
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
! (5 rows)
! 
! FETCH backward 6 in foo18;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5387 |      16 |   1 |    3 |   7 |      7 |      87 |      387 |        1387 |       387 |     5387 | 174 |  175 | FZAAAA   | QAAAAA   | AAAAxx
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
! (6 rows)
! 
! FETCH backward 7 in foo17;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5006 |      15 |   0 |    2 |   6 |      6 |       6 |        6 |        1006 |         6 |     5006 |  12 |   13 | OKAAAA   | PAAAAA   | VVVVxx
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
! (7 rows)
! 
! FETCH backward 8 in foo16;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5471 |      14 |   1 |    3 |   1 |     11 |      71 |      471 |        1471 |       471 |     5471 | 142 |  143 | LCAAAA   | OAAAAA   | OOOOxx
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
! (8 rows)
! 
! FETCH backward 9 in foo15;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6243 |      13 |   1 |    3 |   3 |      3 |      43 |      243 |         243 |      1243 |     6243 |  86 |   87 | DGAAAA   | NAAAAA   | HHHHxx
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
! (9 rows)
! 
! FETCH backward 10 in foo14;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5222 |      12 |   0 |    2 |   2 |      2 |      22 |      222 |        1222 |       222 |     5222 |  44 |   45 | WSAAAA   | MAAAAA   | AAAAxx
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
! (10 rows)
! 
! FETCH backward 11 in foo13;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1504 |      11 |   0 |    0 |   4 |      4 |       4 |      504 |        1504 |      1504 |     1504 |   8 |    9 | WFAAAA   | LAAAAA   | VVVVxx
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (11 rows)
! 
! FETCH backward 12 in foo12;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1314 |      10 |   0 |    2 |   4 |     14 |      14 |      314 |        1314 |      1314 |     1314 |  28 |   29 | OYAAAA   | KAAAAA   | OOOOxx
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (11 rows)
! 
! FETCH backward 13 in foo11;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     3043 |       9 |   1 |    3 |   3 |      3 |      43 |       43 |        1043 |      3043 |     3043 |  86 |   87 | BNAAAA   | JAAAAA   | HHHHxx
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (10 rows)
! 
! FETCH backward 14 in foo10;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     4321 |       8 |   1 |    1 |   1 |      1 |      21 |      321 |         321 |      4321 |     4321 |  42 |   43 | FKAAAA   | IAAAAA   | AAAAxx
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (9 rows)
! 
! FETCH backward 15 in foo9;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     6701 |       7 |   1 |    1 |   1 |      1 |       1 |      701 |         701 |      1701 |     6701 |   2 |    3 | TXAAAA   | HAAAAA   | VVVVxx
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (8 rows)
! 
! FETCH backward 16 in foo8;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     5057 |       6 |   1 |    1 |   7 |     17 |      57 |       57 |        1057 |        57 |     5057 | 114 |  115 | NMAAAA   | GAAAAA   | OOOOxx
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (7 rows)
! 
! FETCH backward 17 in foo7;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8009 |       5 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |      3009 |     8009 |  18 |   19 | BWAAAA   | FAAAAA   | HHHHxx
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (6 rows)
! 
! FETCH backward 18 in foo6;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     7164 |       4 |   0 |    0 |   4 |      4 |      64 |      164 |        1164 |      2164 |     7164 | 128 |  129 | OPAAAA   | EAAAAA   | AAAAxx
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (5 rows)
! 
! FETCH backward 19 in foo5;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     9850 |       3 |   0 |    2 |   0 |     10 |      50 |      850 |        1850 |      4850 |     9850 | 100 |  101 | WOAAAA   | DAAAAA   | VVVVxx
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (4 rows)
! 
! FETCH backward 20 in foo4;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (3 rows)
! 
! FETCH backward 21 in foo3;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (2 rows)
! 
! FETCH backward 22 in foo2;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH backward 23 in foo1;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
! (0 rows)
! 
! CLOSE foo1;
! CLOSE foo2;
! CLOSE foo3;
! CLOSE foo4;
! CLOSE foo5;
! CLOSE foo6;
! CLOSE foo7;
! CLOSE foo8;
! CLOSE foo9;
! CLOSE foo10;
! CLOSE foo11;
! CLOSE foo12;
! -- leave some cursors open, to test that auto-close works.
! -- record this in the system view as well (don't query the time field there
! -- however)
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors ORDER BY 1;
!  name  |                               statement                               | is_holdable | is_binary | is_scrollable 
! -------+-----------------------------------------------------------------------+-------------+-----------+---------------
!  foo13 | DECLARE foo13 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo14 | DECLARE foo14 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2; | f           | f         | t
!  foo15 | DECLARE foo15 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo16 | DECLARE foo16 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2; | f           | f         | t
!  foo17 | DECLARE foo17 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo18 | DECLARE foo18 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2; | f           | f         | t
!  foo19 | DECLARE foo19 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo20 | DECLARE foo20 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2; | f           | f         | t
!  foo21 | DECLARE foo21 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
!  foo22 | DECLARE foo22 SCROLL CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2; | f           | f         | t
!  foo23 | DECLARE foo23 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2; | f           | f         | t
! (11 rows)
! 
! END;
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name | statement | is_holdable | is_binary | is_scrollable 
! ------+-----------+-------------+-----------+---------------
! (0 rows)
! 
! --
! -- NO SCROLL disallows backward fetching
! --
! BEGIN;
! DECLARE foo24 NO SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
! FETCH 1 FROM foo24;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH BACKWARD 1 FROM foo24; -- should fail
! ERROR:  cursor can only scan forward
! HINT:  Declare it with SCROLL option to enable backward scan.
! END;
! --
! -- Cursors outside transaction blocks
! --
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name | statement | is_holdable | is_binary | is_scrollable 
! ------+-----------+-------------+-----------+---------------
! (0 rows)
! 
! BEGIN;
! DECLARE foo25 SCROLL CURSOR WITH HOLD FOR SELECT * FROM tenk2 ORDER BY unique2;
! FETCH FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
! (1 row)
! 
! FETCH FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (1 row)
! 
! COMMIT;
! FETCH FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     3420 |       2 |   0 |    0 |   0 |      0 |      20 |      420 |        1420 |      3420 |     3420 |  40 |   41 | OBAAAA   | CAAAAA   | OOOOxx
! (1 row)
! 
! FETCH BACKWARD FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     1891 |       1 |   1 |    3 |   1 |     11 |      91 |      891 |        1891 |      1891 |     1891 | 182 |  183 | TUAAAA   | BAAAAA   | HHHHxx
! (1 row)
! 
! FETCH ABSOLUTE -1 FROM foo25;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!     2968 |    9999 |   0 |    0 |   8 |      8 |      68 |      968 |         968 |      2968 |     2968 | 136 |  137 | EKAAAA   | PUOAAA   | VVVVxx
! (1 row)
! 
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name  |                                    statement                                    | is_holdable | is_binary | is_scrollable 
! -------+---------------------------------------------------------------------------------+-------------+-----------+---------------
!  foo25 | DECLARE foo25 SCROLL CURSOR WITH HOLD FOR SELECT * FROM tenk2 ORDER BY unique2; | t           | f         | t
! (1 row)
! 
! CLOSE foo25;
! --
! -- ROLLBACK should close holdable cursors
! --
! BEGIN;
! DECLARE foo26 CURSOR WITH HOLD FOR SELECT * FROM tenk1 ORDER BY unique2;
! ROLLBACK;
! -- should fail
! FETCH FROM foo26;
! ERROR:  cursor "foo26" does not exist
! --
! -- Parameterized DECLARE needs to insert param values into the cursor portal
! --
! BEGIN;
! CREATE FUNCTION declares_cursor(text)
!    RETURNS void
!    AS 'DECLARE c CURSOR FOR SELECT stringu1 FROM tenk1 WHERE stringu1 LIKE $1 ORDER BY stringu1;'
!    LANGUAGE SQL;
! SELECT declares_cursor('AB%');
!  declares_cursor 
! -----------------
!  
! (1 row)
! 
! FETCH ALL FROM c;
!  stringu1 
! ----------
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
!  ABAAAA
! (15 rows)
! 
! ROLLBACK;
! --
! -- Test behavior of both volatile and stable functions inside a cursor;
! -- in particular we want to see what happens during commit of a holdable
! -- cursor
! --
! create table tt1(f1 int);
! create function count_tt1_v() returns int8 as
! 'select count(*) from tt1' language sql volatile;
! create function count_tt1_s() returns int8 as
! 'select count(*) from tt1' language sql stable;
! begin;
! insert into tt1 values(1);
! declare c1 cursor for select count_tt1_v(), count_tt1_s();
! insert into tt1 values(2);
! fetch all from c1;
!  count_tt1_v | count_tt1_s 
! -------------+-------------
!            2 |           1
! (1 row)
! 
! rollback;
! begin;
! insert into tt1 values(1);
! declare c2 cursor with hold for select count_tt1_v(), count_tt1_s();
! insert into tt1 values(2);
! commit;
! delete from tt1;
! fetch all from c2;
!  count_tt1_v | count_tt1_s 
! -------------+-------------
!            2 |           2
! (1 row)
! 
! drop function count_tt1_v();
! drop function count_tt1_s();
! drop table tt1;
! -- Create a cursor with the BINARY option and check the pg_cursors view
! BEGIN;
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
!  name |                              statement                               | is_holdable | is_binary | is_scrollable 
! ------+----------------------------------------------------------------------+-------------+-----------+---------------
!  c2   | declare c2 cursor with hold for select count_tt1_v(), count_tt1_s(); | t           | f         | f
! (1 row)
! 
! DECLARE bc BINARY CURSOR FOR SELECT * FROM tenk1;
! SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors ORDER BY 1;
!  name |                              statement                               | is_holdable | is_binary | is_scrollable 
! ------+----------------------------------------------------------------------+-------------+-----------+---------------
!  bc   | DECLARE bc BINARY CURSOR FOR SELECT * FROM tenk1;                    | f           | t         | f
!  c2   | declare c2 cursor with hold for select count_tt1_v(), count_tt1_s(); | t           | f         | f
! (2 rows)
! 
! ROLLBACK;
! -- We should not see the portal that is created internally to
! -- implement EXECUTE in pg_cursors
! PREPARE cprep AS
!   SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
! EXECUTE cprep;
!  name |                              statement                               | is_holdable | is_binary | is_scrollable 
! ------+----------------------------------------------------------------------+-------------+-----------+---------------
!  c2   | declare c2 cursor with hold for select count_tt1_v(), count_tt1_s(); | t           | f         | f
! (1 row)
! 
! -- test CLOSE ALL;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
!  c2
! (1 row)
! 
! CLOSE ALL;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
! (0 rows)
! 
! BEGIN;
! DECLARE foo1 CURSOR WITH HOLD FOR SELECT 1;
! DECLARE foo2 CURSOR WITHOUT HOLD FOR SELECT 1;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
!  foo1
!  foo2
! (2 rows)
! 
! CLOSE ALL;
! SELECT name FROM pg_cursors ORDER BY 1;
!  name 
! ------
! (0 rows)
! 
! COMMIT;
! --
! -- Tests for updatable cursors
! --
! CREATE TABLE uctest(f1 int, f2 text);
! INSERT INTO uctest VALUES (1, 'one'), (2, 'two'), (3, 'three');
! SELECT * FROM uctest ORDER BY f1;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
! (3 rows)
! 
! -- Check DELETE WHERE CURRENT
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest ORDER BY f1;
! FETCH 2 FROM c1;
!  f1 | f2  
! ----+-----
!   1 | one
!   2 | two
! (2 rows)
! 
! DELETE FROM uctest WHERE CURRENT OF c1;
! ERROR:  WHERE CURRENT OF clause not yet supported
! -- should show deletion
! SELECT * FROM uctest ORDER BY f1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! -- cursor did not move
! FETCH ALL FROM c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! -- cursor is insensitive
! MOVE BACKWARD ALL IN c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! FETCH ALL FROM c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! COMMIT;
! -- should still see deletion
! SELECT * FROM uctest ORDER BY f1;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
! (3 rows)
! 
! -- Check UPDATE WHERE CURRENT; this time use FOR UPDATE
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest ORDER BY 1 FOR UPDATE;
! FETCH c1;
!  f1 | f2  
! ----+-----
!   1 | one
! (1 row)
! 
! UPDATE uctest SET f1 = 8 WHERE CURRENT OF c1;
! ERROR:  WHERE CURRENT OF clause not yet supported
! SELECT * FROM uctest ORDER BY f1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! COMMIT;
! SELECT * FROM uctest ORDER BY f1;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
! (3 rows)
! 
! -- Check repeated-update and update-then-delete cases
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest ORDER BY 1;
! FETCH c1;
!  f1 | f2  
! ----+-----
!   1 | one
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! ERROR:  WHERE CURRENT OF clause not yet supported
! SELECT * FROM uctest ORDER BY 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! SELECT * FROM uctest ORDER BY 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! -- insensitive cursor should not show effects of updates or deletes
! FETCH RELATIVE 0 FROM c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! DELETE FROM uctest WHERE CURRENT OF c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! SELECT * FROM uctest ORDER BY f1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! DELETE FROM uctest WHERE CURRENT OF c1; -- no-op
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! SELECT * FROM uctest ORDER BY f1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1; -- no-op
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! SELECT * FROM uctest ORDER BY f1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! FETCH RELATIVE 0 FROM c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! SELECT * FROM uctest ORDER BY f1;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
! (3 rows)
! 
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest ORDER BY 1 FOR UPDATE;
! FETCH c1;
!  f1 | f2  
! ----+-----
!   1 | one
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! ERROR:  WHERE CURRENT OF clause not yet supported
! SELECT * FROM uctest ORDER BY f1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! SELECT * FROM uctest ORDER BY f1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! DELETE FROM uctest WHERE CURRENT OF c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! SELECT * FROM uctest ORDER BY f1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! DELETE FROM uctest WHERE CURRENT OF c1; -- no-op
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! SELECT * FROM uctest ORDER BY f1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1; -- no-op
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! SELECT * FROM uctest ORDER BY f1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! --- sensitive cursors can't currently scroll back, so this is an error:
! FETCH RELATIVE 0 FROM c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! SELECT * FROM uctest ORDER BY f1;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
! (3 rows)
! 
! -- Check inheritance cases
! CREATE TABLE ucchild () inherits (uctest);
! INSERT INTO ucchild values(100, 'hundred');
! SELECT * FROM uctest ORDER BY f1;
!  f1  |   f2    
! -----+---------
!    1 | one
!    2 | two
!    3 | three
!  100 | hundred
! (4 rows)
! 
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest ORDER BY 1 FOR UPDATE;
! FETCH 1 FROM c1;
!  f1 | f2  
! ----+-----
!   1 | one
! (1 row)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! ERROR:  WHERE CURRENT OF clause not yet supported
! FETCH 1 FROM c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! FETCH 1 FROM c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! FETCH 1 FROM c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! COMMIT;
! SELECT * FROM uctest ORDER BY f1;
!  f1  |   f2    
! -----+---------
!    1 | one
!    2 | two
!    3 | three
!  100 | hundred
! (4 rows)
! 
! -- Can update from a self-join, but only if FOR UPDATE says which to use
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 ORDER BY 1;
! FETCH 1 FROM c1;
!  f1 | f2 | f1 | f2 
! ----+----+----+----
! (0 rows)
! 
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;  -- fail
! ERROR:  WHERE CURRENT OF clause not yet supported
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 ORDER BY 1 FOR UPDATE;
! ERROR:  FOR UPDATE is not allowed with joins
! FETCH 1 FROM c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;  -- fail
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 ORDER BY 1 FOR SHARE OF a;
! ERROR:  FOR SHARE is not allowed with joins
! FETCH 1 FROM c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! SELECT * FROM uctest ORDER BY f1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! ROLLBACK;
! -- Check various error cases
! DELETE FROM uctest WHERE CURRENT OF c1;  -- fail, no such cursor
! ERROR:  WHERE CURRENT OF clause not yet supported
! DECLARE cx CURSOR WITH HOLD FOR SELECT * FROM uctest;
! DELETE FROM uctest WHERE CURRENT OF cx;  -- fail, can't use held cursor
! ERROR:  WHERE CURRENT OF clause not yet supported
! BEGIN;
! DECLARE c CURSOR FOR SELECT * FROM tenk2 ORDER BY unique2;
! DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor on wrong table
! ERROR:  WHERE CURRENT OF clause not yet supported
! ROLLBACK;
! BEGIN;
! DECLARE c CURSOR FOR SELECT * FROM tenk2 FOR SHARE;
! DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor on wrong table
! ERROR:  WHERE CURRENT OF clause not yet supported
! ROLLBACK;
! BEGIN;
! DECLARE c CURSOR FOR SELECT * FROM tenk1 JOIN tenk2 USING (unique1);
! DELETE FROM tenk1 WHERE CURRENT OF c;  -- fail, cursor is on a join
! ERROR:  WHERE CURRENT OF clause not yet supported
! ROLLBACK;
! BEGIN;
! DECLARE c CURSOR FOR SELECT f1,count(*) FROM uctest GROUP BY f1;
! DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor is on aggregation
! ERROR:  WHERE CURRENT OF clause not yet supported
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM uctest;
! DELETE FROM uctest WHERE CURRENT OF c1; -- fail, no current row
! ERROR:  WHERE CURRENT OF clause not yet supported
! ROLLBACK;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT MIN(f1) FROM uctest FOR UPDATE;
! ERROR:  FOR UPDATE is not allowed with aggregate functions
! ROLLBACK;
! -- WHERE CURRENT OF may someday work with views, but today is not that day.
! -- For now, just make sure it errors out cleanly.
! CREATE VIEW ucview AS SELECT * FROM uctest ORDER BY 1;
! CREATE RULE ucrule AS ON DELETE TO ucview DO INSTEAD
!   DELETE FROM uctest WHERE f1 = OLD.f1;
! BEGIN;
! DECLARE c1 CURSOR FOR SELECT * FROM ucview;
! FETCH FROM c1;
!  f1 | f2  
! ----+-----
!   1 | one
! (1 row)
! 
! DELETE FROM ucview WHERE CURRENT OF c1; -- fail, views not supported
! ERROR:  WHERE CURRENT OF clause not yet supported
! ROLLBACK;
! -- Make sure snapshot management works okay, per bug report in
! -- 235395b90909301035v7228ce63q392931f15aa74b31@mail.gmail.com
! BEGIN;
! SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
! CREATE TABLE cursor (a int, b int) distribute by hash(b);
! INSERT INTO cursor VALUES (1);
! DECLARE c1 NO SCROLL CURSOR FOR SELECT * FROM cursor FOR UPDATE;
! UPDATE cursor SET a = 2;
! FETCH ALL FROM c1;
!  a | b 
! ---+---
! (0 rows)
! 
! COMMIT;
! DROP TABLE cursor;
! DROP VIEW ucview;
! DROP TABLE ucchild;
! DROP TABLE uctest;
! -- Check rewinding a cursor containing a stable function in LIMIT,
! -- per bug report in 8336843.9833.1399385291498.JavaMail.root@quick
! begin;
! create function nochange(int) returns int
!   as 'select $1 limit 1' language sql stable;
! declare c cursor for select * from int8_tbl order by 1,2 limit nochange(3);
! fetch all from c;
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (3 rows)
! 
! move backward all in c;
! fetch all from c;
!         q1        |        q2         
! ------------------+-------------------
!               123 |               456
!               123 |  4567890123456789
!  4567890123456789 | -4567890123456789
! (3 rows)
! 
! rollback;
! -- Check handling of non-backwards-scan-capable plans with scroll cursors
! begin;
! explain (costs off) declare c1 cursor for select (select 42) as x;
!         QUERY PLAN         
! ---------------------------
!  Result
!    InitPlan 1 (returns $0)
!      ->  Result
! (3 rows)
! 
! explain (costs off) declare c1 scroll cursor for select (select 42) as x;
!         QUERY PLAN         
! ---------------------------
!  Materialize
!    InitPlan 1 (returns $0)
!      ->  Result
!    ->  Result
! (4 rows)
! 
! declare c1 scroll cursor for select (select 42) as x;
! fetch all in c1;
!  x  
! ----
!  42
! (1 row)
! 
! fetch backward all in c1;
!  x  
! ----
!  42
! (1 row)
! 
! rollback;
! begin;
! explain (costs off) declare c2 cursor for select generate_series(1,3) as g;
!   QUERY PLAN  
! --------------
!  ProjectSet
!    ->  Result
! (2 rows)
! 
! explain (costs off) declare c2 scroll cursor for select generate_series(1,3) as g;
!      QUERY PLAN     
! --------------------
!  Materialize
!    ->  ProjectSet
!          ->  Result
! (3 rows)
! 
! declare c2 scroll cursor for select generate_series(1,3) as g;
! fetch all in c2;
!  g 
! ---
!  1
!  2
!  3
! (3 rows)
! 
! fetch backward all in c2;
!  g 
! ---
!  3
!  2
!  1
! (3 rows)
! 
! rollback;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/arrays.out"	2025-07-31 16:07:14.979068232 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/arrays.out"	2025-07-31 16:39:29.778072924 +0800
***************
*** 1,2277 ****
! --
! -- ARRAYS
! --
! CREATE TABLE arrtest (
! 	a 			int2[],
! 	b 			int4[][][],
! 	c 			name[],
! 	d			text[][],
! 	e 			float8[],
! 	f			char(5)[],
! 	g			varchar(5)[]
! );
! --
! -- only the 'e' array is 0-based, the others are 1-based.
! --
! INSERT INTO arrtest (a[1:5], b[1:1][1:2][1:2], c, d, f, g)
!    VALUES ('{1,2,3,4,5}', '{{{0,0},{1,2}}}', '{}', '{}', '{}', '{}');
! UPDATE arrtest SET e[0] = '1.1';
! UPDATE arrtest SET e[1] = '2.2';
! INSERT INTO arrtest (f)
!    VALUES ('{"too long"}');
! ERROR:  value too long for type character(5)
! INSERT INTO arrtest (a, b[1:2][1:2], c, d, e, f, g)
!    VALUES ('{11,12,23}', '{{3,4},{4,5}}', '{"foobar"}',
!            '{{"elt1", "elt2"}}', '{"3.4", "6.7"}',
!            '{"abc","abcde"}', '{"abc","abcde"}');
! INSERT INTO arrtest (a, b[1:2], c, d[1:2])
!    VALUES ('{}', '{3,4}', '{foo,bar}', '{bar,foo}');
! SELECT * FROM arrtest ORDER BY a, b, c;
!       a      |        b        |     c     |       d       |        e        |        f        |      g      
! -------------+-----------------+-----------+---------------+-----------------+-----------------+-------------
!  {}          | {3,4}           | {foo,bar} | {bar,foo}     |                 |                 | 
!  {1,2,3,4,5} | {{{0,0},{1,2}}} | {}        | {}            | [0:1]={1.1,2.2} | {}              | {}
!  {11,12,23}  | {{3,4},{4,5}}   | {foobar}  | {{elt1,elt2}} | {3.4,6.7}       | {"abc  ",abcde} | {abc,abcde}
! (3 rows)
! 
! SELECT arrtest.a[1],
!           arrtest.b[1][1][1],
!           arrtest.c[1],
!           arrtest.d[1][1],
!           arrtest.e[0]
!    FROM arrtest 
!    ORDER BY a, b, c;
!  a  | b |   c    |  d   |  e  
! ----+---+--------+------+-----
!   1 | 0 |        |      | 1.1
!  11 |   | foobar | elt1 |    
!     |   | foo    |      |    
! (3 rows)
! 
! SELECT a[1], b[1][1][1], c[1], d[1][1], e[0]
!    FROM arrtest
!    ORDER BY a, b, c;
!  a  | b |   c    |  d   |  e  
! ----+---+--------+------+-----
!   1 | 0 |        |      | 1.1
!  11 |   | foobar | elt1 |    
!     |   | foo    |      |    
! (3 rows)
! 
! SELECT a[1:3],
!           b[1:1][1:2][1:2],
!           c[1:2],
!           d[1:1][1:2]
!    FROM arrtest
!    ORDER BY a, b, c;
!      a      |        b        |     c     |       d       
! ------------+-----------------+-----------+---------------
!  {}         | {}              | {foo,bar} | {}
!  {1,2,3}    | {{{0,0},{1,2}}} | {}        | {}
!  {11,12,23} | {}              | {foobar}  | {{elt1,elt2}}
! (3 rows)
! 
! SELECT array_ndims(a) AS a,array_ndims(b) AS b,array_ndims(c) AS c
!    FROM arrtest 
!    ORDER BY b;
!  a | b | c 
! ---+---+---
!    | 1 | 1
!  1 | 2 | 1
!  1 | 3 |  
! (3 rows)
! 
! SELECT array_dims(a) AS a,array_dims(b) AS b,array_dims(c) AS c
!    FROM arrtest 
!    ORDER BY b;
!    a   |        b        |   c   
! -------+-----------------+-------
!  [1:5] | [1:1][1:2][1:2] | 
!        | [1:2]           | [1:2]
!  [1:3] | [1:2][1:2]      | [1:1]
! (3 rows)
! 
! -- returns nothing
! SELECT *
!    FROM arrtest
!    WHERE a[1] < 5 and
!          c = '{"foobar"}'::_name;
!  a | b | c | d | e | f | g 
! ---+---+---+---+---+---+---
! (0 rows)
! 
! UPDATE arrtest
!   SET a[1:2] = '{16,25}'
!   WHERE NOT a = '{}'::_int2;
! UPDATE arrtest
!   SET b[1:1][1:1][1:2] = '{113, 117}',
!       b[1:1][1:2][2:2] = '{142, 147}'
!   WHERE array_dims(b) = '[1:1][1:2][1:2]';
! UPDATE arrtest
!   SET c[2:2] = '{"new_word"}'
!   WHERE array_dims(c) is not null;
! SELECT a,b,c FROM arrtest ORDER BY a, b, c;
!        a       |           b           |         c         
! ---------------+-----------------------+-------------------
!  {}            | {3,4}                 | {foo,new_word}
!  {16,25,3,4,5} | {{{113,142},{1,147}}} | {}
!  {16,25,23}    | {{3,4},{4,5}}         | {foobar,new_word}
! (3 rows)
! 
! SELECT a[1:3],
!           b[1:1][1:2][1:2],
!           c[1:2],
!           d[1:1][2:2]
!    FROM arrtest 
!    ORDER BY a, b, c;
!      a      |           b           |         c         |    d     
! ------------+-----------------------+-------------------+----------
!  {}         | {}                    | {foo,new_word}    | {}
!  {16,25,3}  | {{{113,142},{1,147}}} | {}                | {}
!  {16,25,23} | {}                    | {foobar,new_word} | {{elt2}}
! (3 rows)
! 
! SELECT b[1:1][2][2],
!        d[1:1][2]
!    FROM arrtest ORDER BY 1, 2;
!            b           |       d       
! -----------------------+---------------
!  {}                    | {}
!  {}                    | {{elt1,elt2}}
!  {{{113,142},{1,147}}} | {}
! (3 rows)
! 
! INSERT INTO arrtest(a) VALUES('{1,null,3}');
! SELECT a FROM arrtest ORDER BY 1;
!        a       
! ---------------
!  {}
!  {1,NULL,3}
!  {16,25,3,4,5}
!  {16,25,23}
! (4 rows)
! 
! UPDATE arrtest SET a[4] = NULL WHERE a[2] IS NULL;
! SELECT a FROM arrtest WHERE a[2] IS NULL ORDER BY 1;
!         a        
! -----------------
!  {1,NULL,3,NULL}
!  [4:4]={NULL}
! (2 rows)
! 
! DELETE FROM arrtest WHERE a[2] IS NULL AND b IS NULL;
! SELECT a,b,c FROM arrtest ORDER BY a, b, c;
!        a       |           b           |         c         
! ---------------+-----------------------+-------------------
!  {16,25,3,4,5} | {{{113,142},{1,147}}} | {}
!  {16,25,23}    | {{3,4},{4,5}}         | {foobar,new_word}
!  [4:4]={NULL}  | {3,4}                 | {foo,new_word}
! (3 rows)
! 
! -- test mixed slice/scalar subscripting
! select '{{1,2,3},{4,5,6},{7,8,9}}'::int[];
!            int4            
! ---------------------------
!  {{1,2,3},{4,5,6},{7,8,9}}
! (1 row)
! 
! select ('{{1,2,3},{4,5,6},{7,8,9}}'::int[])[1:2][2];
!      int4      
! ---------------
!  {{1,2},{4,5}}
! (1 row)
! 
! select '[0:2][0:2]={{1,2,3},{4,5,6},{7,8,9}}'::int[];
!                  int4                 
! --------------------------------------
!  [0:2][0:2]={{1,2,3},{4,5,6},{7,8,9}}
! (1 row)
! 
! select ('[0:2][0:2]={{1,2,3},{4,5,6},{7,8,9}}'::int[])[1:2][2];
!      int4      
! ---------------
!  {{5,6},{8,9}}
! (1 row)
! 
! --
! -- check subscription corner cases
! --
! -- More subscripts than MAXDIMS(6)
! SELECT ('{}'::int[])[1][2][3][4][5][6][7];
! ERROR:  number of array dimensions (7) exceeds the maximum allowed (6)
! -- NULL index yields NULL when selecting
! SELECT ('{{{1},{2},{3}},{{4},{5},{6}}}'::int[])[1][NULL][1];
!  int4 
! ------
!      
! (1 row)
! 
! SELECT ('{{{1},{2},{3}},{{4},{5},{6}}}'::int[])[1][NULL:1][1];
!  int4 
! ------
!  
! (1 row)
! 
! SELECT ('{{{1},{2},{3}},{{4},{5},{6}}}'::int[])[1][1:NULL][1];
!  int4 
! ------
!  
! (1 row)
! 
! -- NULL index in assignment is an error
! UPDATE arrtest
!   SET c[NULL] = '{"can''t assign"}'
!   WHERE array_dims(c) is not null;
! ERROR:  array subscript in assignment must not be null
! UPDATE arrtest
!   SET c[NULL:1] = '{"can''t assign"}'
!   WHERE array_dims(c) is not null;
! ERROR:  array subscript in assignment must not be null
! UPDATE arrtest
!   SET c[1:NULL] = '{"can''t assign"}'
!   WHERE array_dims(c) is not null;
! ERROR:  array subscript in assignment must not be null
! -- test slices with empty lower and/or upper index
! CREATE TEMP TABLE arrtest_s (
!   a       int2[],
!   b       int2[][]
! );
! INSERT INTO arrtest_s VALUES ('{1,2,3,4,5}', '{{1,2,3}, {4,5,6}, {7,8,9}}');
! INSERT INTO arrtest_s VALUES ('[0:4]={1,2,3,4,5}', '[0:2][0:2]={{1,2,3}, {4,5,6}, {7,8,9}}');
! SELECT * FROM arrtest_s ORDER BY a, b;
!          a         |                  b                   
! -------------------+--------------------------------------
!  [0:4]={1,2,3,4,5} | [0:2][0:2]={{1,2,3},{4,5,6},{7,8,9}}
!  {1,2,3,4,5}       | {{1,2,3},{4,5,6},{7,8,9}}
! (2 rows)
! 
! SELECT a[:3], b[:2][:2] FROM arrtest_s ORDER BY a, b;
!      a     |             b             
! -----------+---------------------------
!  {1,2,3}   | {{1,2},{4,5}}
!  {1,2,3,4} | {{1,2,3},{4,5,6},{7,8,9}}
! (2 rows)
! 
! SELECT a[2:], b[2:][2:] FROM arrtest_s ORDER BY a, b;
!      a     |       b       
! -----------+---------------
!  {2,3,4,5} | {{5,6},{8,9}}
!  {3,4,5}   | {{9}}
! (2 rows)
! 
! SELECT a[:], b[:] FROM arrtest_s;
!       a      |             b             
! -------------+---------------------------
!  {1,2,3,4,5} | {{1,2,3},{4,5,6},{7,8,9}}
!  {1,2,3,4,5} | {{1,2,3},{4,5,6},{7,8,9}}
! (2 rows)
! 
! -- updates
! UPDATE arrtest_s SET a[:3] = '{11, 12, 13}', b[:2][:2] = '{{11,12}, {14,15}}'
!   WHERE array_lower(a,1) = 1;
! SELECT * FROM arrtest_s ORDER BY a, b;
!          a         |                  b                   
! -------------------+--------------------------------------
!  [0:4]={1,2,3,4,5} | [0:2][0:2]={{1,2,3},{4,5,6},{7,8,9}}
!  {11,12,13,4,5}    | {{11,12,3},{14,15,6},{7,8,9}}
! (2 rows)
! 
! UPDATE arrtest_s SET a[3:] = '{23, 24, 25}', b[2:][2:] = '{{25,26}, {28,29}}';
! SELECT * FROM arrtest_s ORDER BY a, b;
!           a          |                   b                   
! ---------------------+---------------------------------------
!  [0:4]={1,2,3,23,24} | [0:2][0:2]={{1,2,3},{4,5,6},{7,8,25}}
!  {11,12,23,24,25}    | {{11,12,3},{14,25,26},{7,28,29}}
! (2 rows)
! 
! UPDATE arrtest_s SET a[:] = '{11, 12, 13, 14, 15}';
! SELECT * FROM arrtest_s ORDER BY a, b;
!            a            |                   b                   
! ------------------------+---------------------------------------
!  [0:4]={11,12,13,14,15} | [0:2][0:2]={{1,2,3},{4,5,6},{7,8,25}}
!  {11,12,13,14,15}       | {{11,12,3},{14,25,26},{7,28,29}}
! (2 rows)
! 
! UPDATE arrtest_s SET a[:] = '{23, 24, 25}';  -- fail, too small
! ERROR:  source array too small
! INSERT INTO arrtest_s VALUES(NULL, NULL);
! UPDATE arrtest_s SET a[:] = '{11, 12, 13, 14, 15}';  -- fail, no good with null
! ERROR:  array slice subscript must provide both boundaries
! DETAIL:  When assigning to a slice of an empty array value, slice boundaries must be fully specified.
! -- check with fixed-length-array type, such as point
! SELECT f1[0:1] FROM POINT_TBL;
! ERROR:  slices of fixed-length arrays not implemented
! SELECT f1[0:] FROM POINT_TBL;
! ERROR:  slices of fixed-length arrays not implemented
! SELECT f1[:1] FROM POINT_TBL;
! ERROR:  slices of fixed-length arrays not implemented
! SELECT f1[:] FROM POINT_TBL;
! ERROR:  slices of fixed-length arrays not implemented
! -- subscript assignments to fixed-width result in NULL if previous value is NULL
! UPDATE point_tbl SET f1[0] = 10 WHERE f1 IS NULL RETURNING *;
!  f1 
! ----
!  
! (1 row)
! 
! INSERT INTO point_tbl(f1[0]) VALUES(0) RETURNING *;
!  f1 
! ----
!  
! (1 row)
! 
! -- NULL assignments get ignored
! UPDATE point_tbl SET f1[0] = NULL WHERE f1::text = '(10,10)'::point::text RETURNING *;
!    f1    
! ---------
!  (10,10)
! (1 row)
! 
! -- but non-NULL subscript assignments work
! UPDATE point_tbl SET f1[0] = -10, f1[1] = -10 WHERE f1::text = '(10,10)'::point::text RETURNING *;
!     f1     
! -----------
!  (-10,-10)
! (1 row)
! 
! -- but not to expand the range
! UPDATE point_tbl SET f1[3] = 10 WHERE f1::text = '(-10,-10)'::point::text RETURNING *;
! ERROR:  array subscript out of range
! --
! -- test array extension
! --
! CREATE TEMP TABLE arrtest1 (i int[], t text[]);
! insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
! select * from arrtest1;
!       i       |          t          
! --------------+---------------------
!  {1,2,NULL,4} | {one,two,NULL,four}
! (1 row)
! 
! update arrtest1 set i[2] = 22, t[2] = 'twenty-two';
! select * from arrtest1;
!        i       |             t              
! ---------------+----------------------------
!  {1,22,NULL,4} | {one,twenty-two,NULL,four}
! (1 row)
! 
! update arrtest1 set i[5] = 5, t[5] = 'five';
! select * from arrtest1;
!         i        |                t                
! -----------------+---------------------------------
!  {1,22,NULL,4,5} | {one,twenty-two,NULL,four,five}
! (1 row)
! 
! update arrtest1 set i[8] = 8, t[8] = 'eight';
! select * from arrtest1;
!               i              |                        t                        
! -----------------------------+-------------------------------------------------
!  {1,22,NULL,4,5,NULL,NULL,8} | {one,twenty-two,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[0] = 0, t[0] = 'zero';
! select * from arrtest1;
!                   i                  |                             t                              
! -------------------------------------+------------------------------------------------------------
!  [0:8]={0,1,22,NULL,4,5,NULL,NULL,8} | [0:8]={zero,one,twenty-two,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[-3] = -3, t[-3] = 'minus-three';
! select * from arrtest1;
!                          i                         |                                         t                                         
! ---------------------------------------------------+-----------------------------------------------------------------------------------
!  [-3:8]={-3,NULL,NULL,0,1,22,NULL,4,5,NULL,NULL,8} | [-3:8]={minus-three,NULL,NULL,zero,one,twenty-two,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[0:2] = array[10,11,12], t[0:2] = array['ten','eleven','twelve'];
! select * from arrtest1;
!                           i                          |                                        t                                        
! -----------------------------------------------------+---------------------------------------------------------------------------------
!  [-3:8]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,8} | [-3:8]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,eight}
! (1 row)
! 
! update arrtest1 set i[8:10] = array[18,null,20], t[8:10] = array['p18',null,'p20'];
! select * from arrtest1;
!                                i                               |                                            t                                            
! ---------------------------------------------------------------+-----------------------------------------------------------------------------------------
!  [-3:10]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20} | [-3:10]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20}
! (1 row)
! 
! update arrtest1 set i[11:12] = array[null,22], t[11:12] = array[null,'p22'];
! select * from arrtest1;
!                                    i                                   |                                                t                                                 
! -----------------------------------------------------------------------+--------------------------------------------------------------------------------------------------
!  [-3:12]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22} | [-3:12]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22}
! (1 row)
! 
! update arrtest1 set i[15:16] = array[null,26], t[15:16] = array[null,'p26'];
! select * from arrtest1;
!                                             i                                            |                                                          t                                                          
! -----------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------
!  [-3:16]={-3,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-3:16]={minus-three,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! update arrtest1 set i[-5:-3] = array[-15,-14,-13], t[-5:-3] = array['m15','m14','m13'];
! select * from arrtest1;
!                                                 i                                                 |                                                          t                                                          
! --------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------
!  [-5:16]={-15,-14,-13,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-5:16]={m15,m14,m13,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! update arrtest1 set i[-7:-6] = array[-17,null], t[-7:-6] = array['m17',null];
! select * from arrtest1;
!                                                      i                                                     |                                                              t                                                               
! -----------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------
!  [-7:16]={-17,NULL,-15,-14,-13,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-7:16]={m17,NULL,m15,m14,m13,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! update arrtest1 set i[-12:-10] = array[-22,null,-20], t[-12:-10] = array['m22',null,'m20'];
! select * from arrtest1;
!                                                                  i                                                                 |                                                                          t                                                                           
! -----------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------
!  [-12:16]={-22,NULL,-20,NULL,NULL,-17,NULL,-15,-14,-13,NULL,NULL,10,11,12,NULL,4,5,NULL,NULL,18,NULL,20,NULL,22,NULL,NULL,NULL,26} | [-12:16]={m22,NULL,m20,NULL,NULL,m17,NULL,m15,m14,m13,NULL,NULL,ten,eleven,twelve,NULL,four,five,NULL,NULL,p18,NULL,p20,NULL,p22,NULL,NULL,NULL,p26}
! (1 row)
! 
! delete from arrtest1;
! insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
! select * from arrtest1;
!       i       |          t          
! --------------+---------------------
!  {1,2,NULL,4} | {one,two,NULL,four}
! (1 row)
! 
! update arrtest1 set i[0:5] = array[0,1,2,null,4,5], t[0:5] = array['z','p1','p2',null,'p4','p5'];
! select * from arrtest1;
!            i            |             t              
! ------------------------+----------------------------
!  [0:5]={0,1,2,NULL,4,5} | [0:5]={z,p1,p2,NULL,p4,p5}
! (1 row)
! 
! --
! -- array expressions and operators
! --
! -- table creation and INSERTs
! CREATE TEMP TABLE arrtest2 (i integer ARRAY[4], f float8[], n numeric[], t text[], d timestamp[]);
! INSERT INTO arrtest2 VALUES(
!   ARRAY[[[113,142],[1,147]]],
!   ARRAY[1.1,1.2,1.3]::float8[],
!   ARRAY[1.1,1.2,1.3],
!   ARRAY[[['aaa','aab'],['aba','abb'],['aca','acb']],[['baa','bab'],['bba','bbb'],['bca','bcb']]],
!   ARRAY['19620326','19931223','19970117']::timestamp[]
! );
! -- some more test data
! CREATE TEMP TABLE arrtest_f (f0 int, f1 text, f2 float8);
! insert into arrtest_f values(1,'cat1',1.21);
! insert into arrtest_f values(2,'cat1',1.24);
! insert into arrtest_f values(3,'cat1',1.18);
! insert into arrtest_f values(4,'cat1',1.26);
! insert into arrtest_f values(5,'cat1',1.15);
! insert into arrtest_f values(6,'cat2',1.15);
! insert into arrtest_f values(7,'cat2',1.26);
! insert into arrtest_f values(8,'cat2',1.32);
! insert into arrtest_f values(9,'cat2',1.30);
! CREATE TEMP TABLE arrtest_i (f0 int, f1 text, f2 int);
! insert into arrtest_i values(1,'cat1',21);
! insert into arrtest_i values(2,'cat1',24);
! insert into arrtest_i values(3,'cat1',18);
! insert into arrtest_i values(4,'cat1',26);
! insert into arrtest_i values(5,'cat1',15);
! insert into arrtest_i values(6,'cat2',15);
! insert into arrtest_i values(7,'cat2',26);
! insert into arrtest_i values(8,'cat2',32);
! insert into arrtest_i values(9,'cat2',30);
! -- expressions
! SELECT t.f[1][3][1] AS "131", t.f[2][2][1] AS "221" FROM (
!   SELECT ARRAY[[[111,112],[121,122],[131,132]],[[211,212],[221,122],[231,232]]] AS f
! ) AS t;
!  131 | 221 
! -----+-----
!  131 | 221
! (1 row)
! 
! SELECT ARRAY[[[[[['hello'],['world']]]]]];
!            array           
! ---------------------------
!  {{{{{{hello},{world}}}}}}
! (1 row)
! 
! SELECT ARRAY[ARRAY['hello'],ARRAY['world']];
!        array       
! -------------------
!  {{hello},{world}}
! (1 row)
! 
! SELECT ARRAY(select f2 from arrtest_f order by f2) AS "ARRAY";
!                      ARRAY                     
! -----------------------------------------------
!  {1.15,1.15,1.18,1.21,1.24,1.26,1.26,1.3,1.32}
! (1 row)
! 
! -- with nulls
! SELECT '{1,null,3}'::int[];
!     int4    
! ------------
!  {1,NULL,3}
! (1 row)
! 
! SELECT ARRAY[1,NULL,3];
!    array    
! ------------
!  {1,NULL,3}
! (1 row)
! 
! -- functions
! SELECT array_append(array[42], 6) AS "{42,6}";
!  {42,6} 
! --------
!  {42,6}
! (1 row)
! 
! SELECT array_prepend(6, array[42]) AS "{6,42}";
!  {6,42} 
! --------
!  {6,42}
! (1 row)
! 
! SELECT array_cat(ARRAY[1,2], ARRAY[3,4]) AS "{1,2,3,4}";
!  {1,2,3,4} 
! -----------
!  {1,2,3,4}
! (1 row)
! 
! SELECT array_cat(ARRAY[1,2], ARRAY[[3,4],[5,6]]) AS "{{1,2},{3,4},{5,6}}";
!  {{1,2},{3,4},{5,6}} 
! ---------------------
!  {{1,2},{3,4},{5,6}}
! (1 row)
! 
! SELECT array_cat(ARRAY[[3,4],[5,6]], ARRAY[1,2]) AS "{{3,4},{5,6},{1,2}}";
!  {{3,4},{5,6},{1,2}} 
! ---------------------
!  {{3,4},{5,6},{1,2}}
! (1 row)
! 
! SELECT array_position(ARRAY[1,2,3,4,5], 4);
!  array_position 
! ----------------
!               4
! (1 row)
! 
! SELECT array_position(ARRAY[5,3,4,2,1], 4);
!  array_position 
! ----------------
!               3
! (1 row)
! 
! SELECT array_position(ARRAY[[1,2],[3,4]], 3);
! ERROR:  searching for elements in multidimensional arrays is not supported
! SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
!  array_position 
! ----------------
!               2
! (1 row)
! 
! SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'sat');
!  array_position 
! ----------------
!               7
! (1 row)
! 
! SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], NULL);
!  array_position 
! ----------------
!                
! (1 row)
! 
! SELECT array_position(ARRAY['sun','mon','tue','wed','thu',NULL,'fri','sat'], NULL);
!  array_position 
! ----------------
!               6
! (1 row)
! 
! SELECT array_position(ARRAY['sun','mon','tue','wed','thu',NULL,'fri','sat'], 'sat');
!  array_position 
! ----------------
!               8
! (1 row)
! 
! SELECT array_positions(NULL, 10);
!  array_positions 
! -----------------
!  
! (1 row)
! 
! SELECT array_positions(NULL, NULL::int);
!  array_positions 
! -----------------
!  
! (1 row)
! 
! SELECT array_positions(ARRAY[1,2,3,4,5,6,1,2,3,4,5,6], 4);
!  array_positions 
! -----------------
!  {4,10}
! (1 row)
! 
! SELECT array_positions(ARRAY[[1,2],[3,4]], 4);
! ERROR:  searching for elements in multidimensional arrays is not supported
! SELECT array_positions(ARRAY[1,2,3,4,5,6,1,2,3,4,5,6], NULL);
!  array_positions 
! -----------------
!  {}
! (1 row)
! 
! SELECT array_positions(ARRAY[1,2,3,NULL,5,6,1,2,3,NULL,5,6], NULL);
!  array_positions 
! -----------------
!  {4,10}
! (1 row)
! 
! SELECT array_length(array_positions(ARRAY(SELECT 'AAAAAAAAAAAAAAAAAAAAAAAAA'::text || i % 10
!                                           FROM generate_series(1,100) g(i)),
!                                   'AAAAAAAAAAAAAAAAAAAAAAAAA5'), 1);
!  array_length 
! --------------
!            10
! (1 row)
! 
! DO $$
! DECLARE
!   o int;
!   a int[] := ARRAY[1,2,3,2,3,1,2];
! BEGIN
!   o := array_position(a, 2);
!   WHILE o IS NOT NULL
!   LOOP
!     RAISE NOTICE '%', o;
!     o := array_position(a, 2, o + 1);
!   END LOOP;
! END
! $$ LANGUAGE plpgsql;
! NOTICE:  2
! NOTICE:  4
! NOTICE:  7
! SELECT array_position('[2:4]={1,2,3}'::int[], 1);
!  array_position 
! ----------------
!               2
! (1 row)
! 
! SELECT array_positions('[2:4]={1,2,3}'::int[], 1);
!  array_positions 
! -----------------
!  {2}
! (1 row)
! 
! SELECT
!     array_position(ids, (1, 1)),
!     array_positions(ids, (1, 1))
!         FROM
! (VALUES
!     (ARRAY[(0, 0), (1, 1)]),
!     (ARRAY[(1, 1)])
! ) AS f (ids);
!  array_position | array_positions 
! ----------------+-----------------
!               2 | {2}
!               1 | {1}
! (2 rows)
! 
! -- operators
! SELECT a FROM arrtest WHERE b = ARRAY[[[113,142],[1,147]]];
!        a       
! ---------------
!  {16,25,3,4,5}
! (1 row)
! 
! SELECT NOT ARRAY[1.1,1.2,1.3] = ARRAY[1.1,1.2,1.3] AS "FALSE";
!  FALSE 
! -------
!  f
! (1 row)
! 
! SELECT ARRAY[1,2] || 3 AS "{1,2,3}";
!  {1,2,3} 
! ---------
!  {1,2,3}
! (1 row)
! 
! SELECT 0 || ARRAY[1,2] AS "{0,1,2}";
!  {0,1,2} 
! ---------
!  {0,1,2}
! (1 row)
! 
! SELECT ARRAY[1,2] || ARRAY[3,4] AS "{1,2,3,4}";
!  {1,2,3,4} 
! -----------
!  {1,2,3,4}
! (1 row)
! 
! SELECT ARRAY[[['hello','world']]] || ARRAY[[['happy','birthday']]] AS "ARRAY";
!                 ARRAY                 
! --------------------------------------
!  {{{hello,world}},{{happy,birthday}}}
! (1 row)
! 
! SELECT ARRAY[[1,2],[3,4]] || ARRAY[5,6] AS "{{1,2},{3,4},{5,6}}";
!  {{1,2},{3,4},{5,6}} 
! ---------------------
!  {{1,2},{3,4},{5,6}}
! (1 row)
! 
! SELECT ARRAY[0,0] || ARRAY[1,1] || ARRAY[2,2] AS "{0,0,1,1,2,2}";
!  {0,0,1,1,2,2} 
! ---------------
!  {0,0,1,1,2,2}
! (1 row)
! 
! SELECT 0 || ARRAY[1,2] || 3 AS "{0,1,2,3}";
!  {0,1,2,3} 
! -----------
!  {0,1,2,3}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i @> '{32}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{32}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (6 rows)
! 
! SELECT * FROM array_op_test WHERE i @> '{17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (8 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (8 rows)
! 
! SELECT * FROM array_op_test WHERE i @> '{32,17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{32,17}' ORDER BY seqno;
!  seqno |                i                |                                                                 t                                                                  
! -------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
! (11 rows)
! 
! SELECT * FROM array_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
!  seqno |       i       |                                                             t                                                              
! -------+---------------+----------------------------------------------------------------------------------------------------------------------------
!     40 | {34}          | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     74 | {32}          | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     98 | {38,34,32,89} | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!    101 | {}            | {}
! (4 rows)
! 
! SELECT * FROM array_op_test WHERE i = '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i @> '{}' ORDER BY seqno;
!  seqno |                i                |                                                                                                       t                                                                                                        
! -------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!      1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
!      2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
!      3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
!      4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
!      5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!      7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
!      8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
!      9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
!     10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
!     11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
!     14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     16 | {14,63,85,11}                   | {AAAAAA66777}
!     17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
!     18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
!     21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
!     22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
!     23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
!     24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
!     25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
!     26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
!     27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
!     28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
!     29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
!     30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
!     32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
!     33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
!     34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
!     35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
!     36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
!     37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
!     38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
!     39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
!     40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
!     42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
!     43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
!     44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
!     45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
!     47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
!     48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
!     49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
!     50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
!     51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
!     52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
!     55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
!     56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
!     57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
!     58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
!     59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
!     60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
!     61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
!     62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
!     63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
!     64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
!     67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
!     68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
!     69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
!     70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
!     71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
!     72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
!     76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
!     79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
!     81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
!     82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
!     84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
!     85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
!     86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
!     87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
!     88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
!     91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
!     92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
!     93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
!     94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
!     95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
!     96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
!     97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!     99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
!    101 | {}                              | {}
!    102 | {NULL}                          | {NULL}
! (102 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i <@ '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
!  seqno |   i    |   t    
! -------+--------+--------
!    102 | {NULL} | {NULL}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE i @> '{NULL}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (4 rows)
! 
! SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (4 rows)
! 
! SELECT * FROM array_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |        i         |                                 t                                  
! -------+------------------+--------------------------------------------------------------------
!     15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |        i         |                                 t                                  
! -------+------------------+--------------------------------------------------------------------
!     15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |  i   |                                 t                                  
! -------+------+--------------------------------------------------------------------
!     79 | {45} | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
!  seqno |           i           |                                                                     t                                                                      
! -------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
!     15 | {17,14,16,63,67}      | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
!     45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     96 | {23,97,43}            | {AAAAAAAAAA646,A87088}
! (6 rows)
! 
! SELECT * FROM array_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
!  seqno |         i          |                                                     t                                                     
! -------+--------------------+-----------------------------------------------------------------------------------------------------------
!     22 | {11,6,56,62,53,30} | {AAAAAAAA72908}
!     45 | {99,45}            | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!    101 | {}                 | {}
! (3 rows)
! 
! SELECT * FROM array_op_test WHERE t = '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! SELECT * FROM array_op_test WHERE t @> '{}' ORDER BY seqno;
!  seqno |                i                |                                                                                                       t                                                                                                        
! -------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!      1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
!      2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
!      3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
!      4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
!      5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
!      6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
!      7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
!      8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
!      9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
!     10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
!     11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
!     12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
!     13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
!     14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
!     15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
!     16 | {14,63,85,11}                   | {AAAAAA66777}
!     17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
!     18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
!     19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
!     20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
!     21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
!     22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
!     23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
!     24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
!     25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
!     26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
!     27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
!     28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
!     29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
!     30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
!     31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
!     32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
!     33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
!     34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
!     35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
!     36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
!     37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
!     38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
!     39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
!     40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
!     41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
!     42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
!     43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
!     44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
!     45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
!     46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
!     47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
!     48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
!     49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
!     50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
!     51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
!     52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
!     53 | {38,17}                         | {AAAAAAAAAAA21658}
!     54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
!     55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
!     56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
!     57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
!     58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
!     59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
!     60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
!     61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
!     62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
!     63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
!     64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
!     65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
!     66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
!     67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
!     68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
!     69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
!     70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
!     71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
!     72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
!     73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
!     74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
!     75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
!     76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
!     77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
!     78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
!     79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
!     80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
!     81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
!     82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
!     83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
!     84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
!     85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
!     86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
!     87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
!     88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
!     89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
!     90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
!     91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
!     92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
!     93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
!     94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
!     95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
!     96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
!     97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
!     98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
!     99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
!    100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
!    101 | {}                              | {}
!    102 | {NULL}                          | {NULL}
! (102 rows)
! 
! SELECT * FROM array_op_test WHERE t && '{}' ORDER BY seqno;
!  seqno | i | t 
! -------+---+---
! (0 rows)
! 
! SELECT * FROM array_op_test WHERE t <@ '{}' ORDER BY seqno;
!  seqno | i  | t  
! -------+----+----
!    101 | {} | {}
! (1 row)
! 
! -- array casts
! SELECT ARRAY[1,2,3]::text[]::int[]::float8[] AS "{1,2,3}";
!  {1,2,3} 
! ---------
!  {1,2,3}
! (1 row)
! 
! SELECT ARRAY[1,2,3]::text[]::int[]::float8[] is of (float8[]) as "TRUE";
!  TRUE 
! ------
!  t
! (1 row)
! 
! SELECT ARRAY[['a','bc'],['def','hijk']]::text[]::varchar[] AS "{{a,bc},{def,hijk}}";
!  {{a,bc},{def,hijk}} 
! ---------------------
!  {{a,bc},{def,hijk}}
! (1 row)
! 
! SELECT ARRAY[['a','bc'],['def','hijk']]::text[]::varchar[] is of (varchar[]) as "TRUE";
!  TRUE 
! ------
!  t
! (1 row)
! 
! SELECT CAST(ARRAY[[[[[['a','bb','ccc']]]]]] as text[]) as "{{{{{{a,bb,ccc}}}}}}";
!  {{{{{{a,bb,ccc}}}}}} 
! ----------------------
!  {{{{{{a,bb,ccc}}}}}}
! (1 row)
! 
! SELECT NULL::text[]::int[] AS "NULL";
!  NULL 
! ------
!  
! (1 row)
! 
! -- scalar op any/all (array)
! select 33 = any ('{1,2,3}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33 = any ('{1,2,33}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 33 = all ('{1,2,33}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33 >= all ('{1,2,33}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- boundary cases
! select null::int >= all ('{1,2,33}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select null::int >= all ('{}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select null::int >= any ('{}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! -- cross-datatype
! select 33.4 = any (array[1,2,3]);
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33.4 > all (array[1,2,3]);
!  ?column? 
! ----------
!  t
! (1 row)
! 
! -- errors
! select 33 * any ('{1,2,3}');
! ERROR:  op ANY/ALL (array) requires operator to yield boolean
! LINE 1: select 33 * any ('{1,2,3}');
!                   ^
! select 33 * any (44);
! ERROR:  op ANY/ALL (array) requires array on right side
! LINE 1: select 33 * any (44);
!                   ^
! -- nulls
! select 33 = any (null::int[]);
!  ?column? 
! ----------
!  
! (1 row)
! 
! select null::int = any ('{1,2,3}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select 33 = any ('{1,null,3}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select 33 = any ('{1,null,33}');
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 33 = all (null::int[]);
!  ?column? 
! ----------
!  
! (1 row)
! 
! select null::int = all ('{1,2,3}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! select 33 = all ('{1,null,3}');
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 33 = all ('{33,null,33}');
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- nulls later in the bitmap
! SELECT -1 != ALL(ARRAY(SELECT NULLIF(g.i, 900) FROM generate_series(1,1000) g(i)));
!  ?column? 
! ----------
!  
! (1 row)
! 
! -- test indexes on arrays
! -- PGXCTODO: related to feature request 3520520, this distribution type is changed
! -- to replication. As integer arrays are no available distribution types, this table
! -- should use roundrobin distribution if nothing is specified but roundrobin
! -- distribution cannot be safely used to check constraints on remote nodes.
! -- When global constraints are supported, this replication distribution should be removed.
! create temp table arr_tbl (f1 int[] unique) distribute by replication;
! insert into arr_tbl values ('{1,2,3}');
! insert into arr_tbl values ('{1,2}');
! -- failure expected:
! insert into arr_tbl values ('{1,2,3}');
! ERROR:  duplicate key value violates unique constraint "arr_tbl_f1_key"
! DETAIL:  Key (f1)=((pg_catalog.int4){1,2,3}) already exists.
! insert into arr_tbl values ('{2,3,4}');
! insert into arr_tbl values ('{1,5,3}');
! insert into arr_tbl values ('{1,2,10}');
! set enable_seqscan to off;
! set enable_bitmapscan to off;
! select * from arr_tbl where f1 > '{1,2,3}' and f1 <= '{1,5,3}';
!     f1    
! ----------
!  {1,2,10}
!  {1,5,3}
! (2 rows)
! 
! select * from arr_tbl where f1 >= '{1,2,3}' and f1 < '{1,5,3}';
!     f1    
! ----------
!  {1,2,3}
!  {1,2,10}
! (2 rows)
! 
! -- test ON CONFLICT DO UPDATE with arrays
! create temp table arr_pk_tbl (pk int4 primary key, f1 int[]);
! insert into arr_pk_tbl values (1, '{1,2,3}');
! insert into arr_pk_tbl values (1, '{3,4,5}') on conflict (pk)
!   do update set f1[1] = excluded.f1[1], f1[3] = excluded.f1[3]
!   returning pk, f1;
!  pk |   f1    
! ----+---------
!   1 | {3,2,5}
! (1 row)
! 
! insert into arr_pk_tbl(pk, f1[1:2]) values (1, '{6,7,8}') on conflict (pk)
!   do update set f1[1] = excluded.f1[1],
!     f1[2] = excluded.f1[2],
!     f1[3] = excluded.f1[3]
!   returning pk, f1;
!  pk |     f1     
! ----+------------
!   1 | {6,7,NULL}
! (1 row)
! 
! -- note: if above selects don't produce the expected tuple order,
! -- then you didn't get an indexscan plan, and something is busted.
! reset enable_seqscan;
! reset enable_bitmapscan;
! -- test [not] (like|ilike) (any|all) (...)
! select 'foo' like any (array['%a', '%o']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' like any (array['%a', '%b']); -- f
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 'foo' like all (array['f%', '%o']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' like all (array['f%', '%b']); -- f
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 'foo' not like any (array['%a', '%b']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' not like all (array['%a', '%o']); -- f
!  ?column? 
! ----------
!  f
! (1 row)
! 
! select 'foo' ilike any (array['%A', '%O']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select 'foo' ilike all (array['F%', '%O']); -- t
!  ?column? 
! ----------
!  t
! (1 row)
! 
! --
! -- General array parser tests
! --
! -- none of the following should be accepted
! select '{{1,{2}},{2,3}}'::text[];
! ERROR:  malformed array literal: "{{1,{2}},{2,3}}"
! LINE 1: select '{{1,{2}},{2,3}}'::text[];
!                ^
! DETAIL:  Unexpected "{" character.
! select '{{},{}}'::text[];
! ERROR:  malformed array literal: "{{},{}}"
! LINE 1: select '{{},{}}'::text[];
!                ^
! DETAIL:  Unexpected "}" character.
! select E'{{1,2},\\{2,3}}'::text[];
! ERROR:  malformed array literal: "{{1,2},\{2,3}}"
! LINE 1: select E'{{1,2},\\{2,3}}'::text[];
!                ^
! DETAIL:  Unexpected "\" character.
! select '{{"1 2" x},{3}}'::text[];
! ERROR:  malformed array literal: "{{"1 2" x},{3}}"
! LINE 1: select '{{"1 2" x},{3}}'::text[];
!                ^
! DETAIL:  Unexpected array element.
! select '{}}'::text[];
! ERROR:  malformed array literal: "{}}"
! LINE 1: select '{}}'::text[];
!                ^
! DETAIL:  Junk after closing right brace.
! select '{ }}'::text[];
! ERROR:  malformed array literal: "{ }}"
! LINE 1: select '{ }}'::text[];
!                ^
! DETAIL:  Junk after closing right brace.
! select array[];
! ERROR:  cannot determine type of empty array
! LINE 1: select array[];
!                ^
! HINT:  Explicitly cast to the desired type, for example ARRAY[]::integer[].
! -- none of the above should be accepted
! -- all of the following should be accepted
! select '{}'::text[];
!  text 
! ------
!  {}
! (1 row)
! 
! select '{{{1,2,3,4},{2,3,4,5}},{{3,4,5,6},{4,5,6,7}}}'::text[];
!                      text                      
! -----------------------------------------------
!  {{{1,2,3,4},{2,3,4,5}},{{3,4,5,6},{4,5,6,7}}}
! (1 row)
! 
! select '{0 second  ,0 second}'::interval[];
!    interval    
! ---------------
!  {"@ 0","@ 0"}
! (1 row)
! 
! select '{ { "," } , { 3 } }'::text[];
!     text     
! -------------
!  {{","},{3}}
! (1 row)
! 
! select '  {   {  "  0 second  "   ,  0 second  }   }'::text[];
!              text              
! -------------------------------
!  {{"  0 second  ","0 second"}}
! (1 row)
! 
! select '{
!            0 second,
!            @ 1 hour @ 42 minutes @ 20 seconds
!          }'::interval[];
!               interval              
! ------------------------------------
!  {"@ 0","@ 1 hour 42 mins 20 secs"}
! (1 row)
! 
! select array[]::text[];
!  array 
! -------
!  {}
! (1 row)
! 
! select '[0:1]={1.1,2.2}'::float8[];
!      float8      
! -----------------
!  [0:1]={1.1,2.2}
! (1 row)
! 
! -- all of the above should be accepted
! -- tests for array aggregates
! CREATE TEMP TABLE arraggtest ( f1 INT[], f2 TEXT[][], f3 FLOAT[]);
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{1,2,3,4}','{{grey,red},{blue,blue}}','{1.6, 0.0}');
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{1,2,3}','{{grey,red},{grey,blue}}','{1.6}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!     max    |   min   |           max            |           min            |   max   |  min  
! -----------+---------+--------------------------+--------------------------+---------+-------
!  {1,2,3,4} | {1,2,3} | {{grey,red},{grey,blue}} | {{grey,red},{blue,blue}} | {1.6,0} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{3,3,2,4,5,6}','{{white,yellow},{pink,orange}}','{2.1,3.3,1.8,1.7,1.6}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      |   min   |              max               |           min            |          max          |  min  
! ---------------+---------+--------------------------------+--------------------------+-----------------------+-------
!  {3,3,2,4,5,6} | {1,2,3} | {{white,yellow},{pink,orange}} | {{grey,red},{blue,blue}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{2}','{{black,red},{green,orange}}','{1.6,2.2,2.6,0.4}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      |   min   |              max               |             min              |          max          |  min  
! ---------------+---------+--------------------------------+------------------------------+-----------------------+-------
!  {3,3,2,4,5,6} | {1,2,3} | {{white,yellow},{pink,orange}} | {{black,red},{green,orange}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{4,2,6,7,8,1}','{{red},{black},{purple},{blue},{blue}}',NULL);
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      |   min   |              max               |             min              |          max          |  min  
! ---------------+---------+--------------------------------+------------------------------+-----------------------+-------
!  {4,2,6,7,8,1} | {1,2,3} | {{white,yellow},{pink,orange}} | {{black,red},{green,orange}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! INSERT INTO arraggtest (f1, f2, f3) VALUES
! ('{}','{{pink,white,blue,red,grey,orange}}','{2.1,1.87,1.4,2.2}');
! SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest;
!       max      | min |              max               |             min              |          max          |  min  
! ---------------+-----+--------------------------------+------------------------------+-----------------------+-------
!  {4,2,6,7,8,1} | {}  | {{white,yellow},{pink,orange}} | {{black,red},{green,orange}} | {2.1,3.3,1.8,1.7,1.6} | {1.6}
! (1 row)
! 
! -- A few simple tests for arrays of composite types
! create type comptype as (f1 int, f2 text);
! create table comptable (c1 comptype, c2 comptype[]);
! -- XXX would like to not have to specify row() construct types here ...
! insert into comptable
!   values (row(1,'foo'), array[row(2,'bar')::comptype, row(3,'baz')::comptype]);
! -- check that implicitly named array type _comptype isn't a problem
! create type _comptype as enum('fooey');
! select * from comptable;
!    c1    |          c2           
! ---------+-----------------------
!  (1,foo) | {"(2,bar)","(3,baz)"}
! (1 row)
! 
! select c2[2].f2 from comptable;
!  f2  
! -----
!  baz
! (1 row)
! 
! drop type _comptype;
! drop table comptable;
! drop type comptype;
! create or replace function unnest1(anyarray)
! returns setof anyelement as $$
! select $1[s] from generate_subscripts($1,1) g(s);
! $$ language sql immutable;
! create or replace function unnest2(anyarray)
! returns setof anyelement as $$
! select $1[s1][s2] from generate_subscripts($1,1) g1(s1),
!                    generate_subscripts($1,2) g2(s2);
! $$ language sql immutable;
! select * from unnest1(array[1,2,3]);
!  unnest1 
! ---------
!        1
!        2
!        3
! (3 rows)
! 
! select * from unnest2(array[[1,2,3],[4,5,6]]);
!  unnest2 
! ---------
!        1
!        2
!        3
!        4
!        5
!        6
! (6 rows)
! 
! drop function unnest1(anyarray);
! drop function unnest2(anyarray);
! select array_fill(null::integer, array[3,3],array[2,2]);
!                            array_fill                            
! -----------------------------------------------------------------
!  [2:4][2:4]={{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(null::integer, array[3,3]);
!                       array_fill                      
! ------------------------------------------------------
!  {{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(null::text, array[3,3],array[2,2]);
!                            array_fill                            
! -----------------------------------------------------------------
!  [2:4][2:4]={{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(null::text, array[3,3]);
!                       array_fill                      
! ------------------------------------------------------
!  {{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}}
! (1 row)
! 
! select array_fill(7, array[3,3],array[2,2]);
!               array_fill              
! --------------------------------------
!  [2:4][2:4]={{7,7,7},{7,7,7},{7,7,7}}
! (1 row)
! 
! select array_fill(7, array[3,3]);
!         array_fill         
! ---------------------------
!  {{7,7,7},{7,7,7},{7,7,7}}
! (1 row)
! 
! select array_fill('juhu'::text, array[3,3],array[2,2]);
!                            array_fill                            
! -----------------------------------------------------------------
!  [2:4][2:4]={{juhu,juhu,juhu},{juhu,juhu,juhu},{juhu,juhu,juhu}}
! (1 row)
! 
! select array_fill('juhu'::text, array[3,3]);
!                       array_fill                      
! ------------------------------------------------------
!  {{juhu,juhu,juhu},{juhu,juhu,juhu},{juhu,juhu,juhu}}
! (1 row)
! 
! select a, a = '{}' as is_eq, array_dims(a)
!   from (select array_fill(42, array[0]) as a) ss;
!  a  | is_eq | array_dims 
! ----+-------+------------
!  {} | t     | 
! (1 row)
! 
! select a, a = '{}' as is_eq, array_dims(a)
!   from (select array_fill(42, '{}') as a) ss;
!  a  | is_eq | array_dims 
! ----+-------+------------
!  {} | t     | 
! (1 row)
! 
! select a, a = '{}' as is_eq, array_dims(a)
!   from (select array_fill(42, '{}', '{}') as a) ss;
!  a  | is_eq | array_dims 
! ----+-------+------------
!  {} | t     | 
! (1 row)
! 
! -- raise exception
! select array_fill(1, null, array[2,2]);
! ERROR:  dimension array or low bound array cannot be null
! select array_fill(1, array[2,2], null);
! ERROR:  dimension array or low bound array cannot be null
! select array_fill(1, array[2,2], '{}');
! ERROR:  wrong number of array subscripts
! DETAIL:  Low bound array has different size than dimensions array.
! select array_fill(1, array[3,3], array[1,1,1]);
! ERROR:  wrong number of array subscripts
! DETAIL:  Low bound array has different size than dimensions array.
! select array_fill(1, array[1,2,null]);
! ERROR:  dimension values cannot be null
! select array_fill(1, array[[1,2],[3,4]]);
! ERROR:  wrong number of array subscripts
! DETAIL:  Dimension array must be one dimensional.
! select string_to_array('1|2|3', '|');
!  string_to_array 
! -----------------
!  {1,2,3}
! (1 row)
! 
! select string_to_array('1|2|3|', '|');
!  string_to_array 
! -----------------
!  {1,2,3,""}
! (1 row)
! 
! select string_to_array('1||2|3||', '||');
!  string_to_array 
! -----------------
!  {1,2|3,""}
! (1 row)
! 
! select string_to_array('1|2|3', '');
!  string_to_array 
! -----------------
!  {1|2|3}
! (1 row)
! 
! select string_to_array('', '|');
!  string_to_array 
! -----------------
!  {}
! (1 row)
! 
! select string_to_array('1|2|3', NULL);
!  string_to_array 
! -----------------
!  {1,|,2,|,3}
! (1 row)
! 
! select string_to_array(NULL, '|') IS NULL;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select string_to_array('abc', '');
!  string_to_array 
! -----------------
!  {abc}
! (1 row)
! 
! select string_to_array('abc', '', 'abc');
!  string_to_array 
! -----------------
!  {NULL}
! (1 row)
! 
! select string_to_array('abc', ',');
!  string_to_array 
! -----------------
!  {abc}
! (1 row)
! 
! select string_to_array('abc', ',', 'abc');
!  string_to_array 
! -----------------
!  {NULL}
! (1 row)
! 
! select string_to_array('1,2,3,4,,6', ',');
!  string_to_array 
! -----------------
!  {1,2,3,4,"",6}
! (1 row)
! 
! select string_to_array('1,2,3,4,,6', ',', '');
!  string_to_array  
! ------------------
!  {1,2,3,4,NULL,6}
! (1 row)
! 
! select string_to_array('1,2,3,4,*,6', ',', '*');
!  string_to_array  
! ------------------
!  {1,2,3,4,NULL,6}
! (1 row)
! 
! select array_to_string(NULL::int4[], ',') IS NULL;
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select array_to_string('{}'::int4[], ',');
!  array_to_string 
! -----------------
!  
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], ',');
!  array_to_string 
! -----------------
!  1,2,3,4,6
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], ',', '*');
!  array_to_string 
! -----------------
!  1,2,3,4,*,6
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], NULL);
!  array_to_string 
! -----------------
!  
! (1 row)
! 
! select array_to_string(array[1,2,3,4,NULL,6], ',', NULL);
!  array_to_string 
! -----------------
!  1,2,3,4,6
! (1 row)
! 
! select array_to_string(string_to_array('1|2|3', '|'), '|');
!  array_to_string 
! -----------------
!  1|2|3
! (1 row)
! 
! select array_length(array[1,2,3], 1);
!  array_length 
! --------------
!             3
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 0);
!  array_length 
! --------------
!              
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 1);
!  array_length 
! --------------
!             2
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 2);
!  array_length 
! --------------
!             3
! (1 row)
! 
! select array_length(array[[1,2,3], [4,5,6]], 3);
!  array_length 
! --------------
!              
! (1 row)
! 
! select cardinality(NULL::int[]);
!  cardinality 
! -------------
!             
! (1 row)
! 
! select cardinality('{}'::int[]);
!  cardinality 
! -------------
!            0
! (1 row)
! 
! select cardinality(array[1,2,3]);
!  cardinality 
! -------------
!            3
! (1 row)
! 
! select cardinality('[2:4]={5,6,7}'::int[]);
!  cardinality 
! -------------
!            3
! (1 row)
! 
! select cardinality('{{1,2}}'::int[]);
!  cardinality 
! -------------
!            2
! (1 row)
! 
! select cardinality('{{1,2},{3,4},{5,6}}'::int[]);
!  cardinality 
! -------------
!            6
! (1 row)
! 
! select cardinality('{{{1,9},{5,6}},{{2,3},{3,4}}}'::int[]);
!  cardinality 
! -------------
!            8
! (1 row)
! 
! -- array_agg(anynonarray)
! select array_agg(unique1) from (select unique1 from tenk1 where unique1 < 15 order by unique1) ss;
!               array_agg               
! --------------------------------------
!  {1,2,5,6,8,9,12,13,0,3,4,7,10,11,14}
! (1 row)
! 
! select array_agg(ten) from (select ten from tenk1 where unique1 < 15 order by unique1) ss;
!             array_agg            
! ---------------------------------
!  {1,2,5,6,8,9,2,3,0,3,4,7,0,1,4}
! (1 row)
! 
! select array_agg(nullif(ten, 4)) from (select ten from tenk1 where unique1 < 15 order by unique1) ss;
!                array_agg               
! ---------------------------------------
!  {1,2,5,6,8,9,2,3,0,3,NULL,7,0,1,NULL}
! (1 row)
! 
! select array_agg(unique1) from tenk1 where unique1 < -15;
!  array_agg 
! -----------
!  
! (1 row)
! 
! -- array_agg(anyarray)
! select array_agg(ar)
!   from (values ('{1,2}'::int[]), ('{3,4}'::int[])) v(ar);
!    array_agg   
! ---------------
!  {{1,2},{3,4}}
! (1 row)
! 
! select array_agg(distinct ar order by ar desc)
!   from (select array[i / 2] from generate_series(1,10) a(i)) b(ar);
!          array_agg         
! ---------------------------
!  {{5},{4},{3},{2},{1},{0}}
! (1 row)
! 
! select array_agg(ar)
!   from (select array_agg(array[i, i+1, i-1])
!         from generate_series(1,2) a(i)) b(ar);
!       array_agg      
! ---------------------
!  {{{1,2,0},{2,3,1}}}
! (1 row)
! 
! select array_agg(array[i+1.2, i+1.3, i+1.4]) from generate_series(1,3) g(i);
!                   array_agg                  
! ---------------------------------------------
!  {{2.2,2.3,2.4},{3.2,3.3,3.4},{4.2,4.3,4.4}}
! (1 row)
! 
! select array_agg(array['Hello', i::text]) from generate_series(9,11) g(i);
!              array_agg             
! -----------------------------------
!  {{Hello,9},{Hello,10},{Hello,11}}
! (1 row)
! 
! select array_agg(array[i, nullif(i, 3), i+1]) from generate_series(1,4) g(i);
!               array_agg               
! --------------------------------------
!  {{1,1,2},{2,2,3},{3,NULL,4},{4,4,5}}
! (1 row)
! 
! -- errors
! select array_agg('{}'::int[]) from generate_series(1,2);
! ERROR:  cannot accumulate empty arrays
! select array_agg(null::int[]) from generate_series(1,2);
! ERROR:  cannot accumulate null arrays
! select array_agg(ar)
!   from (values ('{1,2}'::int[]), ('{3}'::int[])) v(ar);
! ERROR:  cannot accumulate arrays of different dimensionality
! select unnest(array[1,2,3]);
!  unnest 
! --------
!       1
!       2
!       3
! (3 rows)
! 
! select * from unnest(array[1,2,3]);
!  unnest 
! --------
!       1
!       2
!       3
! (3 rows)
! 
! select unnest(array[1,2,3,4.5]::float8[]);
!  unnest 
! --------
!       1
!       2
!       3
!     4.5
! (4 rows)
! 
! select unnest(array[1,2,3,4.5]::numeric[]);
!  unnest 
! --------
!       1
!       2
!       3
!     4.5
! (4 rows)
! 
! select unnest(array[1,2,3,null,4,null,null,5,6]);
!  unnest 
! --------
!       1
!       2
!       3
!        
!       4
!        
!        
!       5
!       6
! (9 rows)
! 
! select unnest(array[1,2,3,null,4,null,null,5,6]::text[]);
!  unnest 
! --------
!  1
!  2
!  3
!  
!  4
!  
!  
!  5
!  6
! (9 rows)
! 
! select abs(unnest(array[1,2,null,-3]));
!  abs 
! -----
!    1
!    2
!     
!    3
! (4 rows)
! 
! select array_remove(array[1,2,2,3], 2);
!  array_remove 
! --------------
!  {1,3}
! (1 row)
! 
! select array_remove(array[1,2,2,3], 5);
!  array_remove 
! --------------
!  {1,2,2,3}
! (1 row)
! 
! select array_remove(array[1,NULL,NULL,3], NULL);
!  array_remove 
! --------------
!  {1,3}
! (1 row)
! 
! select array_remove(array['A','CC','D','C','RR'], 'RR');
!  array_remove 
! --------------
!  {A,CC,D,C}
! (1 row)
! 
! select array_remove('{{1,2,2},{1,4,3}}', 2); -- not allowed
! ERROR:  removing elements from multidimensional arrays is not supported
! select array_remove(array['X','X','X'], 'X') = '{}';
!  ?column? 
! ----------
!  t
! (1 row)
! 
! select array_replace(array[1,2,5,4],5,3);
!  array_replace 
! ---------------
!  {1,2,3,4}
! (1 row)
! 
! select array_replace(array[1,2,5,4],5,NULL);
!  array_replace 
! ---------------
!  {1,2,NULL,4}
! (1 row)
! 
! select array_replace(array[1,2,NULL,4,NULL],NULL,5);
!  array_replace 
! ---------------
!  {1,2,5,4,5}
! (1 row)
! 
! select array_replace(array['A','B','DD','B'],'B','CC');
!  array_replace 
! ---------------
!  {A,CC,DD,CC}
! (1 row)
! 
! select array_replace(array[1,NULL,3],NULL,NULL);
!  array_replace 
! ---------------
!  {1,NULL,3}
! (1 row)
! 
! select array_replace(array['AB',NULL,'CDE'],NULL,'12');
!  array_replace 
! ---------------
!  {AB,12,CDE}
! (1 row)
! 
! -- array(select array-value ...)
! select array(select array[i,i/2] from generate_series(1,5) i);
!               array              
! ---------------------------------
!  {{1,0},{2,1},{3,1},{4,2},{5,2}}
! (1 row)
! 
! select array(select array['Hello', i::text] from generate_series(9,11) i);
!                array               
! -----------------------------------
!  {{Hello,9},{Hello,10},{Hello,11}}
! (1 row)
! 
! -- Insert/update on a column that is array of composite
! create temp table t1 (f1 int8_tbl[]);
! insert into t1 (f1[5].q1) values(42);
! select * from t1;
!        f1        
! -----------------
!  [5:5]={"(42,)"}
! (1 row)
! 
! update t1 set f1[5].q2 = 43;
! select * from t1;
!         f1         
! -------------------
!  [5:5]={"(42,43)"}
! (1 row)
! 
! -- Check that arrays of composites are safely detoasted when needed
! create temp table src (f1 text);
! insert into src
!   select string_agg(random()::text,'') from generate_series(1,10000);
! create type textandtext as (c1 text, c2 text);
! create temp table dest (f1 textandtext[]);
! insert into dest select array[row(f1,f1)::textandtext] from src;
! select length(md5((f1[1]).c2)) from dest;
!  length 
! --------
!      32
! (1 row)
! 
! delete from src;
! select length(md5((f1[1]).c2)) from dest;
!  length 
! --------
!      32
! (1 row)
! 
! truncate table src;
! drop table src;
! select length(md5((f1[1]).c2)) from dest;
!  length 
! --------
!      32
! (1 row)
! 
! drop table dest;
! drop type textandtext;
! -- Tests for polymorphic-array form of width_bucket()
! -- this exercises the varwidth and float8 code paths
! SELECT
!     op,
!     width_bucket(op::numeric, ARRAY[1, 3, 5, 10.0]::numeric[]) AS wb_n1,
!     width_bucket(op::numeric, ARRAY[0, 5.5, 9.99]::numeric[]) AS wb_n2,
!     width_bucket(op::numeric, ARRAY[-6, -5, 2.0]::numeric[]) AS wb_n3,
!     width_bucket(op::float8, ARRAY[1, 3, 5, 10.0]::float8[]) AS wb_f1,
!     width_bucket(op::float8, ARRAY[0, 5.5, 9.99]::float8[]) AS wb_f2,
!     width_bucket(op::float8, ARRAY[-6, -5, 2.0]::float8[]) AS wb_f3
! FROM (VALUES
!   (-5.2),
!   (-0.0000000001),
!   (0.000000000001),
!   (1),
!   (1.99999999999999),
!   (2),
!   (2.00000000000001),
!   (3),
!   (4),
!   (4.5),
!   (5),
!   (5.5),
!   (6),
!   (7),
!   (8),
!   (9),
!   (9.99999999999999),
!   (10),
!   (10.0000000000001)
! ) v(op);
!         op        | wb_n1 | wb_n2 | wb_n3 | wb_f1 | wb_f2 | wb_f3 
! ------------------+-------+-------+-------+-------+-------+-------
!              -5.2 |     0 |     0 |     1 |     0 |     0 |     1
!     -0.0000000001 |     0 |     0 |     2 |     0 |     0 |     2
!    0.000000000001 |     0 |     1 |     2 |     0 |     1 |     2
!                 1 |     1 |     1 |     2 |     1 |     1 |     2
!  1.99999999999999 |     1 |     1 |     2 |     1 |     1 |     2
!                 2 |     1 |     1 |     3 |     1 |     1 |     3
!  2.00000000000001 |     1 |     1 |     3 |     1 |     1 |     3
!                 3 |     2 |     1 |     3 |     2 |     1 |     3
!                 4 |     2 |     1 |     3 |     2 |     1 |     3
!               4.5 |     2 |     1 |     3 |     2 |     1 |     3
!                 5 |     3 |     1 |     3 |     3 |     1 |     3
!               5.5 |     3 |     2 |     3 |     3 |     2 |     3
!                 6 |     3 |     2 |     3 |     3 |     2 |     3
!                 7 |     3 |     2 |     3 |     3 |     2 |     3
!                 8 |     3 |     2 |     3 |     3 |     2 |     3
!                 9 |     3 |     2 |     3 |     3 |     2 |     3
!  9.99999999999999 |     3 |     3 |     3 |     3 |     3 |     3
!                10 |     4 |     3 |     3 |     4 |     3 |     3
!  10.0000000000001 |     4 |     3 |     3 |     4 |     3 |     3
! (19 rows)
! 
! -- ensure float8 path handles NaN properly
! SELECT
!     op,
!     width_bucket(op, ARRAY[1, 3, 9, 'NaN', 'NaN']::float8[]) AS wb
! FROM (VALUES
!   (-5.2::float8),
!   (4::float8),
!   (77::float8),
!   ('NaN'::float8)
! ) v(op);
!   op  | wb 
! ------+----
!  -5.2 |  0
!     4 |  2
!    77 |  3
!   NaN |  5
! (4 rows)
! 
! -- these exercise the generic fixed-width code path
! SELECT
!     op,
!     width_bucket(op, ARRAY[1, 3, 5, 10]) AS wb_1
! FROM generate_series(0,11) as op;
!  op | wb_1 
! ----+------
!   0 |    0
!   1 |    1
!   2 |    1
!   3 |    2
!   4 |    2
!   5 |    3
!   6 |    3
!   7 |    3
!   8 |    3
!   9 |    3
!  10 |    4
!  11 |    4
! (12 rows)
! 
! SELECT width_bucket(now(),
!                     array['yesterday', 'today', 'tomorrow']::timestamptz[]);
!  width_bucket 
! --------------
!             2
! (1 row)
! 
! -- corner cases
! SELECT width_bucket(5, ARRAY[3]);
!  width_bucket 
! --------------
!             1
! (1 row)
! 
! SELECT width_bucket(5, '{}');
!  width_bucket 
! --------------
!             0
! (1 row)
! 
! -- error cases
! SELECT width_bucket('5'::text, ARRAY[3, 4]::integer[]);
! ERROR:  function width_bucket(text, integer[]) does not exist
! LINE 1: SELECT width_bucket('5'::text, ARRAY[3, 4]::integer[]);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! SELECT width_bucket(5, ARRAY[3, 4, NULL]);
! ERROR:  thresholds array must not contain NULLs
! SELECT width_bucket(5, ARRAY[ARRAY[1, 2], ARRAY[3, 4]]);
! ERROR:  thresholds must be one-dimensional array
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/btree_index.out"	2025-07-31 16:07:14.980068216 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/btree_index.out"	2025-07-31 16:39:29.775072988 +0800
***************
*** 1,152 ****
! --
! -- BTREE_INDEX
! -- test retrieval of min/max keys for each index
! --
! SELECT b.*
!    FROM bt_i4_heap b
!    WHERE b.seqno < 1;
!  seqno |   random   
! -------+------------
!      0 | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_i4_heap b
!    WHERE b.seqno >= 9999;
!  seqno |   random   
! -------+------------
!   9999 | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_i4_heap b
!    WHERE b.seqno = 4500;
!  seqno |   random   
! -------+------------
!   4500 | 2080851358
! (1 row)
! 
! SELECT b.*
!    FROM bt_name_heap b
!    WHERE b.seqno < '1'::name;
!  seqno |   random   
! -------+------------
!  0     | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_name_heap b
!    WHERE b.seqno >= '9999'::name;
!  seqno |   random   
! -------+------------
!  9999  | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_name_heap b
!    WHERE b.seqno = '4500'::name;
!  seqno |   random   
! -------+------------
!  4500  | 2080851358
! (1 row)
! 
! SELECT b.*
!    FROM bt_txt_heap b
!    WHERE b.seqno < '1'::text;
!  seqno |   random   
! -------+------------
!  0     | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_txt_heap b
!    WHERE b.seqno >= '9999'::text;
!  seqno |   random   
! -------+------------
!  9999  | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_txt_heap b
!    WHERE b.seqno = '4500'::text;
!  seqno |   random   
! -------+------------
!  4500  | 2080851358
! (1 row)
! 
! SELECT b.*
!    FROM bt_f8_heap b
!    WHERE b.seqno < '1'::float8;
!  seqno |   random   
! -------+------------
!      0 | 1935401906
! (1 row)
! 
! SELECT b.*
!    FROM bt_f8_heap b
!    WHERE b.seqno >= '9999'::float8;
!  seqno |   random   
! -------+------------
!   9999 | 1227676208
! (1 row)
! 
! SELECT b.*
!    FROM bt_f8_heap b
!    WHERE b.seqno = '4500'::float8;
!  seqno |   random   
! -------+------------
!   4500 | 2080851358
! (1 row)
! 
! --
! -- Check correct optimization of LIKE (special index operator support)
! -- for both indexscan and bitmapscan cases
! --
! set enable_seqscan to false;
! set enable_indexscan to true;
! set enable_bitmapscan to false;
! select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
!         proname         
! ------------------------
!  RI_FKey_cascade_del
!  RI_FKey_noaction_del
!  RI_FKey_restrict_del
!  RI_FKey_setdefault_del
!  RI_FKey_setnull_del
! (5 rows)
! 
! set enable_indexscan to false;
! set enable_bitmapscan to true;
! select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
!         proname         
! ------------------------
!  RI_FKey_cascade_del
!  RI_FKey_noaction_del
!  RI_FKey_restrict_del
!  RI_FKey_setdefault_del
!  RI_FKey_setnull_del
! (5 rows)
! 
! --
! -- Test B-tree page deletion. In particular, deleting a non-leaf page.
! --
! -- First create a tree that's at least four levels deep. The text inserted
! -- is long and poorly compressible. That way only a few index tuples fit on
! -- each page, allowing us to get a tall tree with fewer pages.
! create table btree_tall_tbl(id int4, t text);
! create index btree_tall_idx on btree_tall_tbl (id, t) with (fillfactor = 10);
! insert into btree_tall_tbl
!   select g, g::text || '_' ||
!           (select string_agg(md5(i::text), '_') from generate_series(1, 50) i)
! from generate_series(1, 100) g;
! -- Delete most entries, and vacuum. This causes page deletions.
! delete from btree_tall_tbl where id < 950;
! vacuum btree_tall_tbl;
! --
! -- Test B-tree insertion with a metapage update (XLOG_BTREE_INSERT_META
! -- WAL record type). This happens when a "fast root" page is split.
! --
! -- The vacuum above should've turned the leaf page into a fast root. We just
! -- need to insert some rows to cause the fast root page to split.
! insert into btree_tall_tbl (id, t)
!   select g, repeat('x', 100) from generate_series(1, 500) g;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/hash_index.out"	2025-07-31 16:07:14.984068152 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/hash_index.out"	2025-07-31 16:39:29.793072604 +0800
***************
*** 1,237 ****
! --
! -- HASH_INDEX
! -- grep 843938989 hash.data
! --
! SELECT * FROM hash_i4_heap
!    WHERE hash_i4_heap.random = 843938989;
!  seqno |  random   
! -------+-----------
!     15 | 843938989
! (1 row)
! 
! --
! -- hash index
! -- grep 66766766 hash.data
! --
! SELECT * FROM hash_i4_heap
!    WHERE hash_i4_heap.random = 66766766;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep 1505703298 hash.data
! --
! SELECT * FROM hash_name_heap
!    WHERE hash_name_heap.random = '1505703298'::name;
!  seqno |   random   
! -------+------------
!   9838 | 1505703298
! (1 row)
! 
! --
! -- hash index
! -- grep 7777777 hash.data
! --
! SELECT * FROM hash_name_heap
!    WHERE hash_name_heap.random = '7777777'::name;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep 1351610853 hash.data
! --
! SELECT * FROM hash_txt_heap
!    WHERE hash_txt_heap.random = '1351610853'::text;
!  seqno |   random   
! -------+------------
!   5677 | 1351610853
! (1 row)
! 
! --
! -- hash index
! -- grep 111111112222222233333333 hash.data
! --
! SELECT * FROM hash_txt_heap
!    WHERE hash_txt_heap.random = '111111112222222233333333'::text;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep 444705537 hash.data
! --
! SELECT * FROM hash_f8_heap
!    WHERE hash_f8_heap.random = '444705537'::float8;
!  seqno |  random   
! -------+-----------
!   7853 | 444705537
! (1 row)
! 
! --
! -- hash index
! -- grep 88888888 hash.data
! --
! SELECT * FROM hash_f8_heap
!    WHERE hash_f8_heap.random = '88888888'::float8;
!  seqno | random 
! -------+--------
! (0 rows)
! 
! --
! -- hash index
! -- grep '^90[^0-9]' hashovfl.data
! --
! -- SELECT count(*) AS i988 FROM hash_ovfl_heap
! --    WHERE x = 90;
! --
! -- hash index
! -- grep '^1000[^0-9]' hashovfl.data
! --
! -- SELECT count(*) AS i0 FROM hash_ovfl_heap
! --    WHERE x = 1000;
! --
! -- HASH
! --
! UPDATE hash_i4_heap
!    SET random = 1
!    WHERE hash_i4_heap.seqno = 1492;
! SELECT h.seqno AS i1492, h.random AS i1
!    FROM hash_i4_heap h
!    WHERE h.random = 1;
!  i1492 | i1 
! -------+----
!   1492 |  1
! (1 row)
! 
! UPDATE hash_i4_heap
!    SET seqno = 20000
!    WHERE hash_i4_heap.random = 1492795354;
! SELECT h.seqno AS i20000
!    FROM hash_i4_heap h
!    WHERE h.random = 1492795354;
!  i20000 
! --------
!   20000
! (1 row)
! 
! UPDATE hash_name_heap
!    SET random = '0123456789abcdef'::name
!    WHERE hash_name_heap.seqno = 6543;
! SELECT h.seqno AS i6543, h.random AS c0_to_f
!    FROM hash_name_heap h
!    WHERE h.random = '0123456789abcdef'::name;
!  i6543 |     c0_to_f      
! -------+------------------
!   6543 | 0123456789abcdef
! (1 row)
! 
! UPDATE hash_name_heap
!    SET seqno = 20000
!    WHERE hash_name_heap.random = '76652222'::name;
! --
! -- this is the row we just replaced; index scan should return zero rows
! --
! SELECT h.seqno AS emptyset
!    FROM hash_name_heap h
!    WHERE h.random = '76652222'::name;
!  emptyset 
! ----------
! (0 rows)
! 
! UPDATE hash_txt_heap
!    SET random = '0123456789abcdefghijklmnop'::text
!    WHERE hash_txt_heap.seqno = 4002;
! SELECT h.seqno AS i4002, h.random AS c0_to_p
!    FROM hash_txt_heap h
!    WHERE h.random = '0123456789abcdefghijklmnop'::text;
!  i4002 |          c0_to_p           
! -------+----------------------------
!   4002 | 0123456789abcdefghijklmnop
! (1 row)
! 
! UPDATE hash_txt_heap
!    SET seqno = 20000
!    WHERE hash_txt_heap.random = '959363399'::text;
! SELECT h.seqno AS t20000
!    FROM hash_txt_heap h
!    WHERE h.random = '959363399'::text;
!  t20000 
! --------
!   20000
! (1 row)
! 
! UPDATE hash_f8_heap
!    SET random = '-1234.1234'::float8
!    WHERE hash_f8_heap.seqno = 8906;
! SELECT h.seqno AS i8096, h.random AS f1234_1234
!    FROM hash_f8_heap h
!    WHERE h.random = '-1234.1234'::float8;
!  i8096 | f1234_1234 
! -------+------------
!   8906 | -1234.1234
! (1 row)
! 
! UPDATE hash_f8_heap
!    SET seqno = 20000
!    WHERE hash_f8_heap.random = '488912369'::float8;
! SELECT h.seqno AS f20000
!    FROM hash_f8_heap h
!    WHERE h.random = '488912369'::float8;
!  f20000 
! --------
!   20000
! (1 row)
! 
! -- UPDATE hash_ovfl_heap
! --    SET x = 1000
! --   WHERE x = 90;
! -- this vacuums the index as well
! -- VACUUM hash_ovfl_heap;
! -- SELECT count(*) AS i0 FROM hash_ovfl_heap
! --   WHERE x = 90;
! -- SELECT count(*) AS i988 FROM hash_ovfl_heap
! --  WHERE x = 1000;
! --
! -- Cause some overflow insert and splits.
! --
! CREATE TABLE hash_split_heap (keycol INT);
! INSERT INTO hash_split_heap SELECT 1 FROM generate_series(1, 500) a;
! CREATE INDEX hash_split_index on hash_split_heap USING HASH (keycol);
! INSERT INTO hash_split_heap SELECT 1 FROM generate_series(1, 5000) a;
! -- Let's do a backward scan.
! BEGIN;
! SET enable_seqscan = OFF;
! SET enable_bitmapscan = OFF;
! DECLARE c CURSOR FOR SELECT * from hash_split_heap WHERE keycol = 1;
! MOVE FORWARD ALL FROM c;
! -- XL does not support backward scan of RemoteSubplan/RemoteSubquery and hence
! -- the next statement will fail
! MOVE BACKWARD 10000 FROM c;
! ERROR:  cursor can only scan forward
! HINT:  Declare it with SCROLL option to enable backward scan.
! MOVE BACKWARD ALL FROM c;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! CLOSE c;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! END;
! -- DELETE, INSERT, VACUUM.
! DELETE FROM hash_split_heap WHERE keycol = 1;
! INSERT INTO hash_split_heap SELECT a/2 FROM generate_series(1, 25000) a;
! VACUUM hash_split_heap;
! -- Clean up.
! DROP TABLE hash_split_heap;
! -- Index on temp table.
! CREATE TEMP TABLE hash_temp_heap (x int, y int);
! INSERT INTO hash_temp_heap VALUES (1,1);
! CREATE INDEX hash_idx ON hash_temp_heap USING hash (x);
! DROP TABLE hash_temp_heap CASCADE;
! -- Float4 type.
! CREATE TABLE hash_heap_float4 (x float4, y int);
! INSERT INTO hash_heap_float4 VALUES (1.1,1);
! CREATE INDEX hash_idx ON hash_heap_float4 USING hash (x);
! DROP TABLE hash_heap_float4 CASCADE;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/update_1.out"	2025-07-31 16:07:15.006067803 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/update.out"	2025-07-31 16:39:29.786072754 +0800
***************
*** 1,221 ****
! --
! -- UPDATE syntax tests
! --
! CREATE TABLE update_test (
!     a   INT DEFAULT 10,
!     b   INT,
!     c   TEXT
! ) DISTRIBUTE BY REPLICATION;
! CREATE TABLE upsert_test (
!     a   INT PRIMARY KEY,
!     b   TEXT
! ) DISTRIBUTE BY REPLICATION;
! INSERT INTO update_test VALUES (5, 10, 'foo');
! INSERT INTO update_test(b, a) VALUES (15, 10);
! SELECT * FROM update_test ORDER BY a, b, c;
!  a  | b  |  c  
! ----+----+-----
!   5 | 10 | foo
!  10 | 15 | 
! (2 rows)
! 
! UPDATE update_test SET a = DEFAULT, b = DEFAULT;
! SELECT * FROM update_test  ORDER BY a, b, c;
!  a  | b |  c  
! ----+---+-----
!  10 |   | foo
!  10 |   | 
! (2 rows)
! 
! -- aliases for the UPDATE target table
! UPDATE update_test AS t SET b = 10 WHERE t.a = 10;
! SELECT * FROM update_test  ORDER BY a, b, c;
!  a  | b  |  c  
! ----+----+-----
!  10 | 10 | foo
!  10 | 10 | 
! (2 rows)
! 
! UPDATE update_test t SET b = t.b + 10 WHERE t.a = 10;
! SELECT * FROM update_test  ORDER BY a, b, c;
!  a  | b  |  c  
! ----+----+-----
!  10 | 20 | foo
!  10 | 20 | 
! (2 rows)
! 
! --
! -- Test VALUES in FROM
! --
! UPDATE update_test SET a=v.i FROM (VALUES(100, 20)) AS v(i, j)
!   WHERE update_test.b = v.j;
! SELECT * FROM update_test  ORDER BY a, b, c;
!   a  | b  |  c  
! -----+----+-----
!  100 | 20 | foo
!  100 | 20 | 
! (2 rows)
! 
! -- fail, wrong data type:
! UPDATE update_test SET a = v.* FROM (VALUES(100, 20)) AS v(i, j)
!   WHERE update_test.b = v.j;
! ERROR:  column "a" is of type integer but expression is of type record
! LINE 1: UPDATE update_test SET a = v.* FROM (VALUES(100, 20)) AS v(i...
!                                    ^
! HINT:  You will need to rewrite or cast the expression.
! --
! -- Test multiple-set-clause syntax
! --
! INSERT INTO update_test SELECT a,b+1,c FROM update_test;
! SELECT * FROM update_test;
!   a  | b  |  c  
! -----+----+-----
!  100 | 20 | foo
!  100 | 20 | 
!  100 | 21 | foo
!  100 | 21 | 
! (4 rows)
! 
! UPDATE update_test SET (c,b,a) = ('bugle', b+11, DEFAULT) WHERE c = 'foo';
! SELECT * FROM update_test  ORDER BY a, b, c;
!   a  | b  |   c   
! -----+----+-------
!   10 | 31 | bugle
!   10 | 32 | bugle
!  100 | 20 | 
!  100 | 21 | 
! (4 rows)
! 
! UPDATE update_test SET (c,b) = ('car', a+b), a = a + 1 WHERE a = 10;
! SELECT * FROM update_test  ORDER BY a, b, c;
!   a  | b  |  c  
! -----+----+-----
!   11 | 41 | car
!   11 | 42 | car
!  100 | 20 | 
!  100 | 21 | 
! (4 rows)
! 
! -- fail, multi assignment to same column:
! UPDATE update_test SET (c,b) = ('car', a+b), b = a + 1 WHERE a = 10;
! ERROR:  multiple assignments to same column "b"
! -- uncorrelated sub-select:
! UPDATE update_test
!   SET (b,a) = (select a,b from update_test where b = 41 and c = 'car')
!   WHERE a = 100 AND b = 20;
! SELECT * FROM update_test order by 1;
!   a  | b  |  c  
! -----+----+-----
!   11 | 41 | car
!   11 | 42 | car
!   41 | 11 | 
!  100 | 21 | 
! (4 rows)
! 
! -- correlated sub-select:
! UPDATE update_test o
!   SET (b,a) = (select a+1,b from update_test i
!                where i.a=o.a and i.b=o.b and i.c is not distinct from o.c);
! SELECT * FROM update_test order by 1;
!  a  |  b  |  c  
! ----+-----+-----
!  11 |  42 | 
!  21 | 101 | 
!  41 |  12 | car
!  42 |  12 | car
! (4 rows)
! 
! -- fail, multiple rows supplied:
! UPDATE update_test SET (b,a) = (select a+1,b from update_test);
! ERROR:  more than one row returned by a subquery used as an expression
! -- set to null if no rows supplied:
! UPDATE update_test SET (b,a) = (select a+1,b from update_test where a = 1000)
!   WHERE a = 11;
! SELECT * FROM update_test order by 1;
!  a  |  b  |  c  
! ----+-----+-----
!  21 | 101 | 
!  41 |  12 | car
!  42 |  12 | car
!     |     | 
! (4 rows)
! 
! -- *-expansion should work in this context:
! UPDATE update_test SET (a,b) = ROW(v.*) FROM (VALUES(21, 100)) AS v(i, j)
!   WHERE update_test.a = v.i;
! -- you might expect this to work, but syntactically it's not a RowExpr:
! UPDATE update_test SET (a,b) = (v.*) FROM (VALUES(21, 101)) AS v(i, j)
!   WHERE update_test.a = v.i;
! ERROR:  source for a multiple-column UPDATE item must be a sub-SELECT or ROW() expression
! LINE 1: UPDATE update_test SET (a,b) = (v.*) FROM (VALUES(21, 101)) ...
!                                         ^
! -- if an alias for the target table is specified, don't allow references
! -- to the original table name
! UPDATE update_test AS t SET b = update_test.b + 10 WHERE t.a = 10;
! ERROR:  invalid reference to FROM-clause entry for table "update_test"
! LINE 1: UPDATE update_test AS t SET b = update_test.b + 10 WHERE t.a...
!                                         ^
! HINT:  Perhaps you meant to reference the table alias "t".
! -- Make sure that we can update to a TOASTed value.
! UPDATE update_test SET c = repeat('x', 10000) WHERE c = 'car';
! SELECT a, b, char_length(c) FROM update_test ORDER BY a;
!  a  |  b  | char_length 
! ----+-----+-------------
!  21 | 100 |            
!  41 |  12 |       10000
!  42 |  12 |       10000
!     |     |            
! (4 rows)
! 
! -- Test ON CONFLICT DO UPDATE
! INSERT INTO upsert_test VALUES(1, 'Boo');
! -- uncorrelated  sub-select:
! WITH aaa AS (SELECT 1 AS a, 'Foo' AS b) INSERT INTO upsert_test
!   VALUES (1, 'Bar') ON CONFLICT(a)
!   DO UPDATE SET (b, a) = (SELECT b, a FROM aaa) RETURNING *;
!  a |  b  
! ---+-----
!  1 | Foo
! (1 row)
! 
! -- correlated sub-select:
! INSERT INTO upsert_test VALUES (1, 'Baz') ON CONFLICT(a)
!   DO UPDATE SET (b, a) = (SELECT b || ', Correlated', a from upsert_test i WHERE i.a = upsert_test.a)
!   RETURNING *;
!  a |        b        
! ---+-----------------
!  1 | Foo, Correlated
! (1 row)
! 
! -- correlated sub-select (EXCLUDED.* alias):
! INSERT INTO upsert_test VALUES (1, 'Bat') ON CONFLICT(a)
!   DO UPDATE SET (b, a) = (SELECT b || ', Excluded', a from upsert_test i WHERE i.a = excluded.a)
!   RETURNING *;
!  a |             b             
! ---+---------------------------
!  1 | Foo, Correlated, Excluded
! (1 row)
! 
! DROP TABLE update_test;
! DROP TABLE upsert_test;
! -- update to a partition should check partition bound constraint for the new tuple
! create table range_parted (
! 	a text,
! 	b int
! ) partition by range (a, b);
! create table part_a_1_a_10 partition of range_parted for values from ('a', 1) to ('a', 10);
! create table part_a_10_a_20 partition of range_parted for values from ('a', 10) to ('a', 20);
! create table part_b_1_b_10 partition of range_parted for values from ('b', 1) to ('b', 10);
! create table part_b_10_b_20 partition of range_parted for values from ('b', 10) to ('b', 20);
! insert into part_a_1_a_10 values ('a', 1);
! insert into part_b_10_b_20 values ('b', 10);
! -- fail
! update part_a_1_a_10 set a = 'b' where a = 'a';
! ERROR:  Distributed column or partition column "a" can't be updated in current version
! update range_parted set b = b - 1 where b = 10;
! ERROR:  new row for relation "part_b_10_b_20" violates partition constraint
! DETAIL:  Failing row contains (b, 9).
! -- ok
! update range_parted set b = b + 1 where b = 10;
! -- cleanup
! drop table range_parted;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/namespace.out"	2025-07-31 16:07:14.991068041 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/namespace.out"	2025-07-31 16:39:29.781072860 +0800
***************
*** 1,113 ****
! --
! -- Regression tests for schemas (namespaces)
! --
! CREATE SCHEMA test_schema_1
!        CREATE UNIQUE INDEX abc_a_idx ON abc (a)
!        CREATE VIEW abc_view AS
!               SELECT a+1 AS a, b+1 AS b FROM abc
!        CREATE TABLE abc (
!               a serial,
!               b int UNIQUE
!        );
! -- verify that the objects were created
! SELECT COUNT(*) FROM pg_class WHERE relnamespace =
!     (SELECT oid FROM pg_namespace WHERE nspname = 'test_schema_1');
!  count 
! -------
!      5
! (1 row)
! 
! INSERT INTO test_schema_1.abc DEFAULT VALUES;
! INSERT INTO test_schema_1.abc DEFAULT VALUES;
! INSERT INTO test_schema_1.abc DEFAULT VALUES;
! SELECT * FROM test_schema_1.abc ORDER BY a;
!  a | b 
! ---+---
!  1 |  
!  2 |  
!  3 |  
! (3 rows)
! 
! SELECT * FROM test_schema_1.abc_view ORDER BY a;
!  a | b 
! ---+---
!  2 |  
!  3 |  
!  4 |  
! (3 rows)
! 
! ALTER SCHEMA test_schema_1 RENAME TO test_schema_renamed;
! SELECT COUNT(*) FROM pg_class WHERE relnamespace =
!     (SELECT oid FROM pg_namespace WHERE nspname = 'test_schema_1');
!  count 
! -------
!      0
! (1 row)
! 
! -- test IF NOT EXISTS cases
! CREATE SCHEMA test_schema_renamed; -- fail, already exists
! ERROR:  schema "test_schema_renamed" already exists
! CREATE SCHEMA IF NOT EXISTS test_schema_renamed; -- ok with notice
! NOTICE:  schema "test_schema_renamed" already exists, skipping
! CREATE SCHEMA IF NOT EXISTS test_schema_renamed -- fail, disallowed
!        CREATE TABLE abc (
!               a serial,
!               b int UNIQUE
!        );
! ERROR:  CREATE SCHEMA IF NOT EXISTS cannot include schema elements
! LINE 2:        CREATE TABLE abc (
!                ^
! DROP SCHEMA test_schema_renamed CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table test_schema_renamed.abc
! drop cascades to view test_schema_renamed.abc_view
! -- verify that the objects were dropped
! SELECT COUNT(*) FROM pg_class WHERE relnamespace =
!     (SELECT oid FROM pg_namespace WHERE nspname = 'test_schema_renamed');
!  count 
! -------
!      0
! (1 row)
! 
! CREATE SCHEMA test_schema_2
!        CREATE TABLE ab (
!               a serial,
!               b int UNIQUE
!        );
! CREATE SCHEMA test_schema_3;
! CREATE SCHEMA test_schema_4
!        CREATE TABLE ab (
!               a serial,
!               b int UNIQUE
!        );
! INSERT INTO test_schema_2.ab(b) VALUES(1);
! INSERT INTO test_schema_2.ab(b) VALUES(2);
! SELECT * FROM test_schema_2.ab ORDER BY a, b;
!  a | b 
! ---+---
!  1 | 1
!  2 | 2
! (2 rows)
! 
! INSERT INTO test_schema_3.ab(b) VALUES(3);
! ERROR:  relation "test_schema_3.ab" does not exist
! LINE 1: INSERT INTO test_schema_3.ab(b) VALUES(3);
!                     ^
! SELECT * FROM test_schema_3.ab ORDER BY a, b;
! ERROR:  relation "test_schema_3.ab" does not exist
! LINE 1: SELECT * FROM test_schema_3.ab ORDER BY a, b;
!                       ^
! INSERT INTO test_schema_4.ab(b) VALUES(4);
! INSERT INTO test_schema_4.ab(b) VALUES(5);
! SELECT * FROM test_schema_4.ab ORDER BY a, b;
!  a | b 
! ---+---
!  1 | 4
!  2 | 5
! (2 rows)
! 
! DROP SCHEMA test_schema_2 CASCADE;
! NOTICE:  drop cascades to table test_schema_2.ab
! DROP SCHEMA test_schema_3 CASCADE;
! DROP SCHEMA test_schema_4 CASCADE;
! NOTICE:  drop cascades to table test_schema_4.ab
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/delete.out"	2025-07-31 16:07:14.982068184 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/delete.out"	2025-07-31 16:39:29.785072775 +0800
***************
*** 1,33 ****
! CREATE TABLE delete_test (
!     id SERIAL PRIMARY KEY,
!     a INT,
!     b text
! );
! INSERT INTO delete_test (a) VALUES (10);
! INSERT INTO delete_test (a, b) VALUES (50, repeat('x', 10000));
! INSERT INTO delete_test (a) VALUES (100);
! -- allow an alias to be specified for DELETE's target table
! DELETE FROM delete_test AS dt WHERE dt.a > 75;
! -- if an alias is specified, don't allow the original table name
! -- to be referenced
! DELETE FROM delete_test dt WHERE delete_test.a > 25;
! ERROR:  invalid reference to FROM-clause entry for table "delete_test"
! LINE 1: DELETE FROM delete_test dt WHERE delete_test.a > 25;
!                                          ^
! HINT:  Perhaps you meant to reference the table alias "dt".
! SELECT id, a, char_length(b) FROM delete_test ORDER BY id;
!  id | a  | char_length 
! ----+----+-------------
!   1 | 10 |            
!   2 | 50 |       10000
! (2 rows)
! 
! -- delete a row with a TOASTed value
! DELETE FROM delete_test WHERE a > 25;
! SELECT id, a, char_length(b) FROM delete_test ORDER BY id;
!  id | a  | char_length 
! ----+----+-------------
!   1 | 10 |            
! (1 row)
! 
! DROP TABLE delete_test;
--- 1 ----
! psql: FATAL:  the database system is in recovery mode

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/prepared_xacts.out"	2025-07-31 16:07:14.997067946 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/prepared_xacts.out"	2025-07-31 16:39:30.744052328 +0800
***************
*** 112,118 ****
  INSERT INTO pxtest1 VALUES ('fff');
  -- This should fail, because the gid foo3 is already in use
  PREPARE TRANSACTION 'foo3';
! ERROR:  transaction identifier "foo3" is already in use
  SELECT * FROM pxtest1  ORDER BY foobar;
   foobar 
  --------
--- 112,118 ----
  INSERT INTO pxtest1 VALUES ('fff');
  -- This should fail, because the gid foo3 is already in use
  PREPARE TRANSACTION 'foo3';
! ERROR:  node:datanode_1, backend_pid:383266, nodename:datanode_2,backend_pid:383267,message:transaction identifier "foo3" is already in use
  SELECT * FROM pxtest1  ORDER BY foobar;
   foobar 
  --------
***************
*** 259,265 ****
                Table "public.pxtest2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
  
  SELECT * FROM pxtest2;
   a 
--- 259,265 ----
                Table "public.pxtest2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
  
  SELECT * FROM pxtest2;
   a 

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/brin_1.out"	2025-07-31 16:07:14.980068216 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/brin.out"	2025-07-31 16:39:38.023897227 +0800
***************
*** 67,72 ****
--- 67,74 ----
  	thousand,
  	tenthous
  FROM tenk1;
+ ERROR:  node:datanode_1, backend_pid:383376, nodename:datanode_2,backend_pid:383377,message:null value in column "byteacol" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, null, null, null, null, null, null, null, null, null, null, fe80::6e40:8ff:fea9:aea6, fe80::6e40:8ff:fea9:aea6/128, null, null, null, null, null, null, null, null, null, null, null, empty, null, null, 800, 8800).
  CREATE INDEX brintest2_idx ON brintest2 (thousand, tenthous);
  CLUSTER brintest2 USING brintest2_idx;
  INSERT INTO brintest (inetcol, cidrcol, int4rangecol) SELECT inetcol, cidrcol, int4rangecol FROM brintest2 LIMIT 25;
***************
*** 372,377 ****
--- 374,395 ----
  	END LOOP;
  END;
  $x$;
+ WARNING:  unexpected number of results 47 for (int4rangecol,<@,int4range,"[3,4)",72)
+ WARNING:  unexpected number of results 49 for (int4rangecol,<,int4range,"[36,44)",74)
+ WARNING:  unexpected number of results 50 for (int4rangecol,<=,int4range,"[43,1043)",75)
+ WARNING:  unexpected number of results 100 for (int4rangecol,@>,int4range,empty,125)
+ WARNING:  unexpected number of results 47 for (int4rangecol,<@,int4range,empty,72)
+ WARNING:  unexpected number of results 47 for (int4rangecol,=,int4range,empty,72)
+ WARNING:  unexpected number of results 47 for (int4rangecol,<=,int4range,empty,72)
+ WARNING:  unexpected number of results 100 for (int4rangecol,>=,int4range,empty,125)
+ WARNING:  unexpected number of results 100 for (inetcol,>,inet,0.0.0.0,125)
+ WARNING:  unexpected number of results 100 for (inetcol,>=,inet,0.0.0.0,125)
+ WARNING:  unexpected number of results 100 for (inetcol,>,cidr,0.0.0.0,125)
+ WARNING:  unexpected number of results 100 for (inetcol,>=,cidr,0.0.0.0,125)
+ WARNING:  unexpected number of results 100 for (cidrcol,>,inet,0.0.0.0,125)
+ WARNING:  unexpected number of results 100 for (cidrcol,>=,inet,0.0.0.0,125)
+ WARNING:  unexpected number of results 100 for (cidrcol,>,cidr,0.0.0.0,125)
+ WARNING:  unexpected number of results 100 for (cidrcol,>=,cidr,0.0.0.0,125)
  RESET enable_seqscan;
  RESET enable_bitmapscan;
  INSERT INTO brintest SELECT

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/privileges.out"	2025-07-31 16:07:14.997067946 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/privileges.out"	2025-07-31 16:39:38.566885667 +0800
***************
*** 208,214 ****
   Remote Subquery Scan on all (datanode_1,datanode_2)
     ->  Nested Loop
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Seq Scan on atest12 atest12_1
                       Filter: (b <<< 5)
           ->  Bitmap Heap Scan on atest12
--- 208,214 ----
   Remote Subquery Scan on all (datanode_1,datanode_2)
     ->  Nested Loop
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Seq Scan on atest12 atest12_1
                       Filter: (b <<< 5)
           ->  Bitmap Heap Scan on atest12
***************
*** 226,232 ****
   Remote Subquery Scan on all (datanode_1,datanode_2)
     ->  Nested Loop
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Seq Scan on atest12 y
                       Filter: (abs(a) <<< 5)
           ->  Index Scan using atest12_a_idx on atest12 x
--- 226,232 ----
   Remote Subquery Scan on all (datanode_1,datanode_2)
     ->  Nested Loop
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Seq Scan on atest12 y
                       Filter: (abs(a) <<< 5)
           ->  Index Scan using atest12_a_idx on atest12 x
***************
*** 251,257 ****
   Remote Subquery Scan on all (datanode_1,datanode_2)
     ->  Nested Loop
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Seq Scan on atest12 atest12_1
                       Filter: (b <<< 5)
           ->  Index Scan using atest12_a_idx on atest12
--- 251,257 ----
   Remote Subquery Scan on all (datanode_1,datanode_2)
     ->  Nested Loop
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Seq Scan on atest12 atest12_1
                       Filter: (b <<< 5)
           ->  Index Scan using atest12_a_idx on atest12
***************
*** 271,277 ****
   Remote Subquery Scan on all (datanode_1,datanode_2)
     ->  Nested Loop
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Seq Scan on atest12 atest12_1
                       Filter: (b <<< 5)
           ->  Bitmap Heap Scan on atest12
--- 271,277 ----
   Remote Subquery Scan on all (datanode_1,datanode_2)
     ->  Nested Loop
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Seq Scan on atest12 atest12_1
                       Filter: (b <<< 5)
           ->  Bitmap Heap Scan on atest12
***************
*** 293,299 ****
           ->  Seq Scan on atest12 x
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: b
                       ->  Seq Scan on atest12 y
                             Filter: (abs(a) <<< 5)
  (9 rows)
--- 293,299 ----
           ->  Seq Scan on atest12 x
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: b
                       ->  Seq Scan on atest12 y
                             Filter: (abs(a) <<< 5)
  (9 rows)
***************
*** 539,558 ****
  INSERT INTO t1 VALUES (3, 1, 3);
  SET SESSION AUTHORIZATION regress_user2;
  INSERT INTO t1 (c1, c2) VALUES (1, 1); -- fail, but row not shown
! ERROR:  duplicate key value violates unique constraint "t1_pkey"
  UPDATE t1 SET c2 = 1; -- fail, but row not shown
! ERROR:  duplicate key value violates unique constraint "t1_pkey"
  INSERT INTO t1 (c1, c2) VALUES (null, null); -- fail, but see columns being inserted
! ERROR:  null value in column "c1" violates not-null constraint
  DETAIL:  Failing row contains (c1, c2) = (null, null).
  INSERT INTO t1 (c3) VALUES (null); -- fail, but see columns being inserted or have SELECT
! ERROR:  null value in column "c1" violates not-null constraint
  DETAIL:  Failing row contains (c1, c3) = (null, null).
  INSERT INTO t1 (c1) VALUES (5); -- fail, but see columns being inserted or have SELECT
! ERROR:  null value in column "c2" violates not-null constraint
  DETAIL:  Failing row contains (c1) = (5).
  UPDATE t1 SET c3 = 10; -- fail, but see columns with SELECT rights, or being modified
! ERROR:  new row for relation "t1" violates check constraint "t1_c3_check"
  DETAIL:  Failing row contains (c1, c3) = (1, 10).
  SET SESSION AUTHORIZATION regress_user1;
  DROP TABLE t1;
--- 539,558 ----
  INSERT INTO t1 VALUES (3, 1, 3);
  SET SESSION AUTHORIZATION regress_user2;
  INSERT INTO t1 (c1, c2) VALUES (1, 1); -- fail, but row not shown
! ERROR:  node:datanode_1, backend_pid:383366, nodename:datanode_1,backend_pid:383366,message:duplicate key value violates unique constraint "t1_pkey"
  UPDATE t1 SET c2 = 1; -- fail, but row not shown
! ERROR:  node:datanode_1, backend_pid:383287, nodename:datanode_1,backend_pid:383287,message:duplicate key value violates unique constraint "t1_pkey"
  INSERT INTO t1 (c1, c2) VALUES (null, null); -- fail, but see columns being inserted
! ERROR:  node:datanode_1, backend_pid:383287, nodename:datanode_1,backend_pid:383287,message:null value in column "c1" violates not-null constraint
  DETAIL:  Failing row contains (c1, c2) = (null, null).
  INSERT INTO t1 (c3) VALUES (null); -- fail, but see columns being inserted or have SELECT
! ERROR:  node:datanode_1, backend_pid:383289, nodename:datanode_1,backend_pid:383289,message:null value in column "c1" violates not-null constraint
  DETAIL:  Failing row contains (c1, c3) = (null, null).
  INSERT INTO t1 (c1) VALUES (5); -- fail, but see columns being inserted or have SELECT
! ERROR:  node:datanode_1, backend_pid:383289, nodename:datanode_1,backend_pid:383289,message:null value in column "c2" violates not-null constraint
  DETAIL:  Failing row contains (c1) = (5).
  UPDATE t1 SET c3 = 10; -- fail, but see columns with SELECT rights, or being modified
! ERROR:  node:datanode_2, backend_pid:383284, nodename:datanode_1,backend_pid:383289,message:new row for relation "t1" violates check constraint "t1_c3_check"
  DETAIL:  Failing row contains (c1, c3) = (1, 10).
  SET SESSION AUTHORIZATION regress_user1;
  DROP TABLE t1;
***************
*** 596,651 ****
  -- check inheritance cases
  SET SESSION AUTHORIZATION regress_user1;
  CREATE TABLE atestp1 (f1 int, f2 int) WITH OIDS DISTRIBUTE BY ROUNDROBIN;
  CREATE TABLE atestp2 (fx int, fy int) WITH OIDS DISTRIBUTE BY ROUNDROBIN;
  CREATE TABLE atestc (fz int) INHERITS (atestp1, atestp2);
  GRANT SELECT(fx,fy,oid) ON atestp2 TO regress_user2;
  GRANT SELECT(fx) ON atestc TO regress_user2;
  SET SESSION AUTHORIZATION regress_user2;
  SELECT fx FROM atestp2; -- ok
!  fx 
! ----
! (0 rows)
! 
  SELECT fy FROM atestp2; -- ok
!  fy 
! ----
! (0 rows)
! 
  SELECT atestp2 FROM atestp2; -- ok
!  atestp2 
! ---------
! (0 rows)
! 
  SELECT oid FROM atestp2; -- ok
!  oid 
! -----
! (0 rows)
! 
  SELECT fy FROM atestc; -- fail
! ERROR:  permission denied for relation atestc
  SET SESSION AUTHORIZATION regress_user1;
  GRANT SELECT(fy,oid) ON atestc TO regress_user2;
  SET SESSION AUTHORIZATION regress_user2;
  SELECT fx FROM atestp2; -- still ok
!  fx 
! ----
! (0 rows)
! 
  SELECT fy FROM atestp2; -- ok
!  fy 
! ----
! (0 rows)
! 
  SELECT atestp2 FROM atestp2; -- ok
!  atestp2 
! ---------
! (0 rows)
! 
  SELECT oid FROM atestp2; -- ok
!  oid 
! -----
! (0 rows)
! 
  -- privileges on functions, languages
  -- switch to superuser
  \c -
--- 596,651 ----
  -- check inheritance cases
  SET SESSION AUTHORIZATION regress_user1;
  CREATE TABLE atestp1 (f1 int, f2 int) WITH OIDS DISTRIBUTE BY ROUNDROBIN;
+ ERROR:  Cannot support distribute type: RoundRobin
  CREATE TABLE atestp2 (fx int, fy int) WITH OIDS DISTRIBUTE BY ROUNDROBIN;
+ ERROR:  Cannot support distribute type: RoundRobin
  CREATE TABLE atestc (fz int) INHERITS (atestp1, atestp2);
+ ERROR:  relation "atestp1" does not exist
  GRANT SELECT(fx,fy,oid) ON atestp2 TO regress_user2;
+ ERROR:  relation "atestp2" does not exist
  GRANT SELECT(fx) ON atestc TO regress_user2;
+ ERROR:  relation "atestc" does not exist
  SET SESSION AUTHORIZATION regress_user2;
  SELECT fx FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT fx FROM atestp2;
!                        ^
  SELECT fy FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT fy FROM atestp2;
!                        ^
  SELECT atestp2 FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT atestp2 FROM atestp2;
!                             ^
  SELECT oid FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT oid FROM atestp2;
!                         ^
  SELECT fy FROM atestc; -- fail
! ERROR:  relation "atestc" does not exist
! LINE 1: SELECT fy FROM atestc;
!                        ^
  SET SESSION AUTHORIZATION regress_user1;
  GRANT SELECT(fy,oid) ON atestc TO regress_user2;
+ ERROR:  relation "atestc" does not exist
  SET SESSION AUTHORIZATION regress_user2;
  SELECT fx FROM atestp2; -- still ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT fx FROM atestp2;
!                        ^
  SELECT fy FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT fy FROM atestp2;
!                        ^
  SELECT atestp2 FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT atestp2 FROM atestp2;
!                             ^
  SELECT oid FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT oid FROM atestp2;
!                         ^
  -- privileges on functions, languages
  -- switch to superuser
  \c -
***************
*** 1704,1711 ****
--- 1704,1714 ----
  DROP TABLE atest5;
  DROP TABLE atest6;
  DROP TABLE atestc;
+ ERROR:  table "atestc" does not exist
  DROP TABLE atestp1;
+ ERROR:  table "atestp1" does not exist
  DROP TABLE atestp2;
+ ERROR:  table "atestp2" does not exist
  SELECT lo_unlink(oid) FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
   lo_unlink 
  -----------

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/collate_1.out"	2025-07-31 16:07:14.981068200 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/collate.out"	2025-07-31 16:39:35.060900320 +0800
***************
*** 19,25 ****
          Table "collate_tests.collate_test1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | text    | C         | not null | 
  
  CREATE TABLE collate_test_fail (
--- 19,25 ----
          Table "collate_tests.collate_test1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | text    | C         | not null | 
  
  CREATE TABLE collate_test_fail (
***************
*** 36,42 ****
        Table "collate_tests.collate_test_like"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | text    | C         | not null | 
  
  CREATE TABLE collate_test2 (
--- 36,42 ----
        Table "collate_tests.collate_test_like"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | text    | C         | not null | 
  
  CREATE TABLE collate_test2 (
***************
*** 464,470 ****
  CREATE TABLE test_u AS SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2; -- fail
  -- ideally this would be a parse-time error, but for now it must be run-time:
  select x < y from collate_test10; -- fail
! ERROR:  could not determine which collation to use for string comparison
  HINT:  Use the COLLATE clause to set the collation explicitly.
  select x || y from collate_test10; -- ok, because || is not collation aware
   ?column? 
--- 464,470 ----
  CREATE TABLE test_u AS SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2; -- fail
  -- ideally this would be a parse-time error, but for now it must be run-time:
  select x < y from collate_test10; -- fail
! ERROR:  node:datanode_1, backend_pid:383356, nodename:datanode_1,backend_pid:383356,message:could not determine which collation to use for string comparison
  HINT:  Use the COLLATE clause to set the collation explicitly.
  select x || y from collate_test10; -- ok, because || is not collation aware
   ?column? 
***************
*** 587,596 ****
  CREATE TABLE collate_test20 (f1 text COLLATE "C" PRIMARY KEY);
  INSERT INTO collate_test20 VALUES ('foo'), ('bar');
  CREATE TABLE collate_test21 (f2 text COLLATE "POSIX" REFERENCES collate_test20);
  INSERT INTO collate_test21 VALUES ('foo'), ('bar');
  INSERT INTO collate_test21 VALUES ('baz'); -- fail
! ERROR:  insert or update on table "collate_test21" violates foreign key constraint "collate_test21_f2_fkey"
! DETAIL:  Key (f2)=(baz) is not present in table "collate_test20".
  CREATE TABLE collate_test22 (f2 text COLLATE "POSIX");
  INSERT INTO collate_test22 VALUES ('foo'), ('bar'), ('baz');
  ALTER TABLE collate_test22 ADD FOREIGN KEY (f2) REFERENCES collate_test20; -- fail
--- 587,601 ----
  CREATE TABLE collate_test20 (f1 text COLLATE "C" PRIMARY KEY);
  INSERT INTO collate_test20 VALUES ('foo'), ('bar');
  CREATE TABLE collate_test21 (f2 text COLLATE "POSIX" REFERENCES collate_test20);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  INSERT INTO collate_test21 VALUES ('foo'), ('bar');
+ ERROR:  relation "collate_test21" does not exist
+ LINE 1: INSERT INTO collate_test21 VALUES ('foo'), ('bar');
+                     ^
  INSERT INTO collate_test21 VALUES ('baz'); -- fail
! ERROR:  relation "collate_test21" does not exist
! LINE 1: INSERT INTO collate_test21 VALUES ('baz');
!                     ^
  CREATE TABLE collate_test22 (f2 text COLLATE "POSIX");
  INSERT INTO collate_test22 VALUES ('foo'), ('bar'), ('baz');
  ALTER TABLE collate_test22 ADD FOREIGN KEY (f2) REFERENCES collate_test20; -- fail
***************
*** 663,666 ****
  --
  \set VERBOSITY terse
  DROP SCHEMA collate_tests CASCADE;
! NOTICE:  drop cascades to 18 other objects
--- 668,671 ----
  --
  \set VERBOSITY terse
  DROP SCHEMA collate_tests CASCADE;
! NOTICE:  drop cascades to 17 other objects

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/matview_1.out"	2025-07-31 16:07:14.991068041 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/matview.out"	2025-07-31 16:39:36.959919882 +0800
***************
*** 25,31 ****
     ->  Finalize HashAggregate
           Group Key: type
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: type
                 ->  Partial HashAggregate
                       Group Key: type
                       ->  Seq Scan on mvtest_t
--- 25,31 ----
     ->  Finalize HashAggregate
           Group Key: type
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: type
                 ->  Partial HashAggregate
                       Group Key: type
                       ->  Seq Scan on mvtest_t
***************
*** 68,74 ****
           ->  Finalize HashAggregate
                 Group Key: mvtest_t.type
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: type
                       ->  Partial HashAggregate
                             Group Key: mvtest_t.type
                             ->  Seq Scan on mvtest_t
--- 68,74 ----
           ->  Finalize HashAggregate
                 Group Key: mvtest_t.type
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: type
                       ->  Partial HashAggregate
                             Group Key: mvtest_t.type
                             ->  Seq Scan on mvtest_t
***************
*** 98,104 ****
                 ->  Finalize HashAggregate
                       Group Key: mvtest_t.type
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: type
                             ->  Partial HashAggregate
                                   Group Key: mvtest_t.type
                                   ->  Seq Scan on mvtest_t
--- 98,104 ----
                 ->  Finalize HashAggregate
                       Group Key: mvtest_t.type
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: type
                             ->  Partial HashAggregate
                                   Group Key: mvtest_t.type
                                   ->  Seq Scan on mvtest_t
***************
*** 262,268 ****
  
  REFRESH MATERIALIZED VIEW mvtest_tmm;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm;
! ERROR:  cannot refresh materialized view "public.mvtest_tvmm" concurrently
  HINT:  Create a unique index with no WHERE clause on one or more columns of the materialized view.
  REFRESH MATERIALIZED VIEW mvtest_tvmm;
  REFRESH MATERIALIZED VIEW mvtest_tvvm;
--- 262,268 ----
  
  REFRESH MATERIALIZED VIEW mvtest_tmm;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm;
! ERROR:  node:coord2, backend_pid:383274, nodename:coord2,backend_pid:383274,message:cannot refresh materialized view "public.mvtest_tvmm" concurrently
  HINT:  Create a unique index with no WHERE clause on one or more columns of the materialized view.
  REFRESH MATERIALIZED VIEW mvtest_tvmm;
  REFRESH MATERIALIZED VIEW mvtest_tvvm;
***************
*** 310,316 ****
  NOTICE:  materialized view "no_such_mv" does not exist, skipping
  -- make sure invalid combination of options is prohibited
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm WITH NO DATA;
! ERROR:  CONCURRENTLY and WITH NO DATA options cannot be used together
  -- no tuple locks on materialized views
  SELECT * FROM mvtest_tvvm FOR SHARE;
  ERROR:  cannot lock rows in materialized view "mvtest_tvvm"
--- 310,316 ----
  NOTICE:  materialized view "no_such_mv" does not exist, skipping
  -- make sure invalid combination of options is prohibited
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm WITH NO DATA;
! ERROR:  node:coord2, backend_pid:383265, nodename:coord2,backend_pid:383265,message:CONCURRENTLY and WITH NO DATA options cannot be used together
  -- no tuple locks on materialized views
  SELECT * FROM mvtest_tvvm FOR SHARE;
  ERROR:  cannot lock rows in materialized view "mvtest_tvvm"
***************
*** 404,413 ****
  CREATE UNIQUE INDEX ON mvtest_mv(a);
  INSERT INTO mvtest_foo SELECT * FROM mvtest_foo;
  REFRESH MATERIALIZED VIEW mvtest_mv;
! ERROR:  could not create unique index "mvtest_mv_a_idx"
  DETAIL:  Key (a)=(1) is duplicated.
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
! ERROR:  new data for materialized view "mvtest_mv" contains duplicate rows without any null columns
  DETAIL:  Row: (1,10)
  DROP TABLE mvtest_foo CASCADE;
  NOTICE:  drop cascades to materialized view mvtest_mv
--- 404,413 ----
  CREATE UNIQUE INDEX ON mvtest_mv(a);
  INSERT INTO mvtest_foo SELECT * FROM mvtest_foo;
  REFRESH MATERIALIZED VIEW mvtest_mv;
! ERROR:  node:coord2, backend_pid:383265, nodename:coord2,backend_pid:383265,message:could not create unique index "mvtest_mv_a_idx"
  DETAIL:  Key (a)=(1) is duplicated.
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
! ERROR:  node:coord2, backend_pid:383265, nodename:coord2,backend_pid:383265,message:new data for materialized view "mvtest_mv" contains duplicate rows without any null columns
  DETAIL:  Row: (1,10)
  DROP TABLE mvtest_foo CASCADE;
  NOTICE:  drop cascades to materialized view mvtest_mv
***************
*** 536,548 ****
  ERROR:  division by zero
  create materialized view mvtest_error as select 1/0 as x with no data;
  refresh materialized view mvtest_error;  -- fail here
! ERROR:  division by zero
  drop materialized view mvtest_error;
  -- make sure that matview rows can be referenced as source rows (bug #9398)
  CREATE TABLE mvtest_v AS SELECT generate_series(1,10) AS a;
  CREATE MATERIALIZED VIEW mvtest_mv_v AS SELECT a FROM mvtest_v WHERE a <= 5;
  DELETE FROM mvtest_v WHERE EXISTS ( SELECT * FROM mvtest_mv_v WHERE mvtest_mv_v.a = mvtest_v.a );
! ERROR:  materialized view "mvtest_mv_v" has not been populated
  HINT:  Use the REFRESH MATERIALIZED VIEW command.
  SELECT * FROM mvtest_v order by 1;
   a  
--- 536,548 ----
  ERROR:  division by zero
  create materialized view mvtest_error as select 1/0 as x with no data;
  refresh materialized view mvtest_error;  -- fail here
! ERROR:  node:coord2, backend_pid:383274, nodename:coord2,backend_pid:383274,message:division by zero
  drop materialized view mvtest_error;
  -- make sure that matview rows can be referenced as source rows (bug #9398)
  CREATE TABLE mvtest_v AS SELECT generate_series(1,10) AS a;
  CREATE MATERIALIZED VIEW mvtest_mv_v AS SELECT a FROM mvtest_v WHERE a <= 5;
  DELETE FROM mvtest_v WHERE EXISTS ( SELECT * FROM mvtest_mv_v WHERE mvtest_mv_v.a = mvtest_v.a );
! ERROR:  node:datanode_2, backend_pid:383292, nodename:datanode_1,backend_pid:383366,message:materialized view "mvtest_mv_v" has not been populated
  HINT:  Use the REFRESH MATERIALIZED VIEW command.
  SELECT * FROM mvtest_v order by 1;
   a  

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/rowsecurity_1.out"	2025-07-31 16:07:14.999067914 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/rowsecurity.out"	2025-07-31 16:39:38.962877236 +0800
***************
*** 64,70 ****
--- 64,72 ----
      dauthor     name,
      dtitle      text
  );
+ ERROR:  corrupted catalog, no shard group of 0 found
  GRANT ALL ON document TO public;
+ ERROR:  relation "document" does not exist
  INSERT INTO document VALUES
      ( 1, 11, 1, 'regress_rls_bob', 'my first novel'),
      ( 2, 11, 2, 'regress_rls_bob', 'my second novel'),
***************
*** 76,85 ****
--- 78,92 ----
      ( 8, 44, 1, 'regress_rls_carol', 'great manga'),
      ( 9, 22, 1, 'regress_rls_dave', 'awesome science fiction'),
      (10, 33, 2, 'regress_rls_dave', 'awesome technology book');
+ ERROR:  relation "document" does not exist
+ LINE 1: INSERT INTO document VALUES
+                     ^
  ALTER TABLE document ENABLE ROW LEVEL SECURITY;
+ ERROR:  relation "document" does not exist
  -- user's security level must be higher than or equal to document's
  CREATE POLICY p1 ON document AS PERMISSIVE
      USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
+ ERROR:  relation "document" does not exist
  -- try to create a policy of bogus type
  CREATE POLICY p1 ON document AS UGLY
      USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
***************
*** 93,387 ****
  -- to p1r first
  CREATE POLICY p2r ON document AS RESTRICTIVE TO regress_rls_dave
      USING (cid <> 44 AND cid < 50);
  -- and Dave isn't allowed to see manga documents
  CREATE POLICY p1r ON document AS RESTRICTIVE TO regress_rls_dave
      USING (cid <> 44);
  \dp
!                                                                   Access privileges
!        Schema       |   Name   | Type  |              Access privileges              | Column privileges |                  Policies                  
! --------------------+----------+-------+---------------------------------------------+-------------------+--------------------------------------------
   regress_rls_schema | category | table | regress_rls_alice=arwdDxt/regress_rls_alice+|                   | 
                      |          |       | =arwdDxt/regress_rls_alice                  |                   | 
-  regress_rls_schema | document | table | regress_rls_alice=arwdDxt/regress_rls_alice+|                   | p1:                                       +
-                     |          |       | =arwdDxt/regress_rls_alice                  |                   |   (u): (dlevel <= ( SELECT uaccount.seclv +
-                     |          |       |                                             |                   |    FROM uaccount                          +
-                     |          |       |                                             |                   |   WHERE (uaccount.pguser = CURRENT_USER)))+
-                     |          |       |                                             |                   | p2r (RESTRICTIVE):                        +
-                     |          |       |                                             |                   |   (u): ((cid <> 44) AND (cid < 50))       +
-                     |          |       |                                             |                   |   to: regress_rls_dave                    +
-                     |          |       |                                             |                   | p1r (RESTRICTIVE):                        +
-                     |          |       |                                             |                   |   (u): (cid <> 44)                        +
-                     |          |       |                                             |                   |   to: regress_rls_dave
   regress_rls_schema | uaccount | table | regress_rls_alice=arwdDxt/regress_rls_alice+|                   | 
                      |          |       | =r/regress_rls_alice                        |                   | 
! (3 rows)
  
  \d document
-         Table "regress_rls_schema.document"
-  Column  |  Type   | Collation | Nullable | Default 
- ---------+---------+-----------+----------+---------
-  did     | integer |           | not null | 
-  cid     | integer |           |          | 
-  dlevel  | integer |           | not null | 
-  dauthor | name    |           |          | 
-  dtitle  | text    |           |          | 
- Indexes:
-     "document_pkey" PRIMARY KEY, btree (did)
- Foreign-key constraints:
-     "document_cid_fkey" FOREIGN KEY (cid) REFERENCES category(cid)
- Policies:
-     POLICY "p1"
-       USING ((dlevel <= ( SELECT uaccount.seclv
-    FROM uaccount
-   WHERE (uaccount.pguser = CURRENT_USER))))
-     POLICY "p1r" AS RESTRICTIVE
-       TO regress_rls_dave
-       USING ((cid <> 44))
-     POLICY "p2r" AS RESTRICTIVE
-       TO regress_rls_dave
-       USING (((cid <> 44) AND (cid < 50)))
- 
  SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename = 'document' ORDER BY policyname;
!      schemaname     | tablename | policyname | permissive  |       roles        | cmd |                    qual                    | with_check 
! --------------------+-----------+------------+-------------+--------------------+-----+--------------------------------------------+------------
!  regress_rls_schema | document  | p1         | PERMISSIVE  | {public}           | ALL | (dlevel <= ( SELECT uaccount.seclv        +| 
!                     |           |            |             |                    |     |    FROM uaccount                          +| 
!                     |           |            |             |                    |     |   WHERE (uaccount.pguser = CURRENT_USER))) | 
!  regress_rls_schema | document  | p1r        | RESTRICTIVE | {regress_rls_dave} | ALL | (cid <> 44)                                | 
!  regress_rls_schema | document  | p2r        | RESTRICTIVE | {regress_rls_dave} | ALL | ((cid <> 44) AND (cid < 50))               | 
! (3 rows)
  
  -- viewpoint from regress_rls_bob
  SET SESSION AUTHORIZATION regress_rls_bob;
  SET row_security TO ON;
  SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
!  did | cid | dlevel |      dauthor      |         dtitle          
! -----+-----+--------+-------------------+-------------------------
!    1 |  11 |      1 | regress_rls_bob   | my first novel
!    4 |  44 |      1 | regress_rls_bob   | my first manga
!    6 |  22 |      1 | regress_rls_carol | great science fiction
!    8 |  44 |      1 | regress_rls_carol | great manga
!    9 |  22 |      1 | regress_rls_dave  | awesome science fiction
! (5 rows)
! 
  SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
!  cid | did | dlevel |      dauthor      |         dtitle          |      cname      
! -----+-----+--------+-------------------+-------------------------+-----------------
!   11 |   1 |      1 | regress_rls_bob   | my first novel          | novel
!   44 |   4 |      1 | regress_rls_bob   | my first manga          | manga
!   22 |   6 |      1 | regress_rls_carol | great science fiction   | science fiction
!   44 |   8 |      1 | regress_rls_carol | great manga             | manga
!   22 |   9 |      1 | regress_rls_dave  | awesome science fiction | science fiction
! (5 rows)
! 
  -- try a sampled version
  SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)
    WHERE f_leak(dtitle) ORDER BY did;
!  did | cid | dlevel |      dauthor      |         dtitle          
! -----+-----+--------+-------------------+-------------------------
!    6 |  22 |      1 | regress_rls_carol | great science fiction
!    8 |  44 |      1 | regress_rls_carol | great manga
!    9 |  22 |      1 | regress_rls_dave  | awesome science fiction
! (3 rows)
! 
  -- viewpoint from regress_rls_carol
  SET SESSION AUTHORIZATION regress_rls_carol;
  SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
!  did | cid | dlevel |      dauthor      |         dtitle          
! -----+-----+--------+-------------------+-------------------------
!    1 |  11 |      1 | regress_rls_bob   | my first novel
!    2 |  11 |      2 | regress_rls_bob   | my second novel
!    3 |  22 |      2 | regress_rls_bob   | my science fiction
!    4 |  44 |      1 | regress_rls_bob   | my first manga
!    5 |  44 |      2 | regress_rls_bob   | my second manga
!    6 |  22 |      1 | regress_rls_carol | great science fiction
!    7 |  33 |      2 | regress_rls_carol | great technology book
!    8 |  44 |      1 | regress_rls_carol | great manga
!    9 |  22 |      1 | regress_rls_dave  | awesome science fiction
!   10 |  33 |      2 | regress_rls_dave  | awesome technology book
! (10 rows)
! 
  SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
!  cid | did | dlevel |      dauthor      |         dtitle          |      cname      
! -----+-----+--------+-------------------+-------------------------+-----------------
!   11 |   1 |      1 | regress_rls_bob   | my first novel          | novel
!   11 |   2 |      2 | regress_rls_bob   | my second novel         | novel
!   22 |   3 |      2 | regress_rls_bob   | my science fiction      | science fiction
!   44 |   4 |      1 | regress_rls_bob   | my first manga          | manga
!   44 |   5 |      2 | regress_rls_bob   | my second manga         | manga
!   22 |   6 |      1 | regress_rls_carol | great science fiction   | science fiction
!   33 |   7 |      2 | regress_rls_carol | great technology book   | technology
!   44 |   8 |      1 | regress_rls_carol | great manga             | manga
!   22 |   9 |      1 | regress_rls_dave  | awesome science fiction | science fiction
!   33 |  10 |      2 | regress_rls_dave  | awesome technology book | technology
! (10 rows)
! 
  -- try a sampled version
  SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)
    WHERE f_leak(dtitle) ORDER BY did;
!  did | cid | dlevel |      dauthor      |         dtitle          
! -----+-----+--------+-------------------+-------------------------
!    6 |  22 |      1 | regress_rls_carol | great science fiction
!    8 |  44 |      1 | regress_rls_carol | great manga
!    9 |  22 |      1 | regress_rls_dave  | awesome science fiction
!   10 |  33 |      2 | regress_rls_dave  | awesome technology book
! (4 rows)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Seq Scan on document
!          Filter: ((dlevel <= $0) AND f_leak(dtitle))
!          InitPlan 1 (returns $0)
!            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                  ->  Index Scan using uaccount_pkey on uaccount
!                        Index Cond: (pguser = CURRENT_USER)
! (7 rows)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Hash Join
!          Hash Cond: (category.cid = document.cid)
!          InitPlan 1 (returns $0)
!            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                  ->  Index Scan using uaccount_pkey on uaccount
!                        Index Cond: (pguser = CURRENT_USER)
!          ->  Seq Scan on category
!          ->  Hash
!                ->  Seq Scan on document
!                      Filter: ((dlevel <= $0) AND f_leak(dtitle))
! (11 rows)
! 
  -- viewpoint from regress_rls_dave
  SET SESSION AUTHORIZATION regress_rls_dave;
  SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
!  did | cid | dlevel |      dauthor      |         dtitle          
! -----+-----+--------+-------------------+-------------------------
!    1 |  11 |      1 | regress_rls_bob   | my first novel
!    2 |  11 |      2 | regress_rls_bob   | my second novel
!    3 |  22 |      2 | regress_rls_bob   | my science fiction
!    6 |  22 |      1 | regress_rls_carol | great science fiction
!    7 |  33 |      2 | regress_rls_carol | great technology book
!    9 |  22 |      1 | regress_rls_dave  | awesome science fiction
!   10 |  33 |      2 | regress_rls_dave  | awesome technology book
! (7 rows)
! 
  SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
!  cid | did | dlevel |      dauthor      |         dtitle          |      cname      
! -----+-----+--------+-------------------+-------------------------+-----------------
!   11 |   1 |      1 | regress_rls_bob   | my first novel          | novel
!   11 |   2 |      2 | regress_rls_bob   | my second novel         | novel
!   22 |   3 |      2 | regress_rls_bob   | my science fiction      | science fiction
!   22 |   6 |      1 | regress_rls_carol | great science fiction   | science fiction
!   33 |   7 |      2 | regress_rls_carol | great technology book   | technology
!   22 |   9 |      1 | regress_rls_dave  | awesome science fiction | science fiction
!   33 |  10 |      2 | regress_rls_dave  | awesome technology book | technology
! (7 rows)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
!                                              QUERY PLAN                                             
! ----------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Seq Scan on document
!          Filter: ((cid <> 44) AND (cid <> 44) AND (cid < 50) AND (dlevel <= $0) AND f_leak(dtitle))
!          InitPlan 1 (returns $0)
!            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                  ->  Index Scan using uaccount_pkey on uaccount
!                        Index Cond: (pguser = CURRENT_USER)
! (7 rows)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
!                                                    QUERY PLAN                                                   
! ----------------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Hash Join
!          Hash Cond: (category.cid = document.cid)
!          InitPlan 1 (returns $0)
!            ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                  ->  Index Scan using uaccount_pkey on uaccount
!                        Index Cond: (pguser = CURRENT_USER)
!          ->  Seq Scan on category
!          ->  Hash
!                ->  Seq Scan on document
!                      Filter: ((cid <> 44) AND (cid <> 44) AND (cid < 50) AND (dlevel <= $0) AND f_leak(dtitle))
! (11 rows)
! 
  -- 44 would technically fail for both p2r and p1r, but we should get an error
  -- back from p1r for this because it sorts first
  INSERT INTO document VALUES (100, 44, 1, 'regress_rls_dave', 'testing sorting of policies'); -- fail
! ERROR:  new row violates row-level security policy "p1r" for table "document"
  -- Just to see a p2r error
  INSERT INTO document VALUES (100, 55, 1, 'regress_rls_dave', 'testing sorting of policies'); -- fail
! ERROR:  new row violates row-level security policy "p2r" for table "document"
  -- only owner can change policies
  ALTER POLICY p1 ON document USING (true);    --fail
! ERROR:  must be owner of relation document
  DROP POLICY p1 ON document;                  --fail
! ERROR:  must be owner of relation document
  SET SESSION AUTHORIZATION regress_rls_alice;
  ALTER POLICY p1 ON document USING (dauthor = current_user);
  -- viewpoint from regress_rls_bob again
  SET SESSION AUTHORIZATION regress_rls_bob;
  SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
!  did | cid | dlevel |     dauthor     |       dtitle       
! -----+-----+--------+-----------------+--------------------
!    1 |  11 |      1 | regress_rls_bob | my first novel
!    2 |  11 |      2 | regress_rls_bob | my second novel
!    3 |  22 |      2 | regress_rls_bob | my science fiction
!    4 |  44 |      1 | regress_rls_bob | my first manga
!    5 |  44 |      2 | regress_rls_bob | my second manga
! (5 rows)
! 
  SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
!  cid | did | dlevel |     dauthor     |       dtitle       |      cname      
! -----+-----+--------+-----------------+--------------------+-----------------
!   11 |   1 |      1 | regress_rls_bob | my first novel     | novel
!   11 |   2 |      2 | regress_rls_bob | my second novel    | novel
!   22 |   3 |      2 | regress_rls_bob | my science fiction | science fiction
!   44 |   4 |      1 | regress_rls_bob | my first manga     | manga
!   44 |   5 |      2 | regress_rls_bob | my second manga    | manga
! (5 rows)
! 
  -- viewpoint from rls_regres_carol again
  SET SESSION AUTHORIZATION regress_rls_carol;
  SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
!  did | cid | dlevel |      dauthor      |        dtitle         
! -----+-----+--------+-------------------+-----------------------
!    6 |  22 |      1 | regress_rls_carol | great science fiction
!    7 |  33 |      2 | regress_rls_carol | great technology book
!    8 |  44 |      1 | regress_rls_carol | great manga
! (3 rows)
! 
  SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
!  cid | did | dlevel |      dauthor      |        dtitle         |      cname      
! -----+-----+--------+-------------------+-----------------------+-----------------
!   22 |   6 |      1 | regress_rls_carol | great science fiction | science fiction
!   33 |   7 |      2 | regress_rls_carol | great technology book | technology
!   44 |   8 |      1 | regress_rls_carol | great manga           | manga
! (3 rows)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Seq Scan on document
!          Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))
! (3 rows)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Nested Loop
!          ->  Seq Scan on document
!                Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))
!          ->  Index Scan using category_pkey on category
!                Index Cond: (cid = document.cid)
! (6 rows)
! 
  -- interaction of FK/PK constraints
  SET SESSION AUTHORIZATION regress_rls_alice;
  CREATE POLICY p2 ON category
--- 100,232 ----
  -- to p1r first
  CREATE POLICY p2r ON document AS RESTRICTIVE TO regress_rls_dave
      USING (cid <> 44 AND cid < 50);
+ ERROR:  relation "document" does not exist
  -- and Dave isn't allowed to see manga documents
  CREATE POLICY p1r ON document AS RESTRICTIVE TO regress_rls_dave
      USING (cid <> 44);
+ ERROR:  relation "document" does not exist
  \dp
!                                                  Access privileges
!        Schema       |   Name   | Type  |              Access privileges              | Column privileges | Policies 
! --------------------+----------+-------+---------------------------------------------+-------------------+----------
   regress_rls_schema | category | table | regress_rls_alice=arwdDxt/regress_rls_alice+|                   | 
                      |          |       | =arwdDxt/regress_rls_alice                  |                   | 
   regress_rls_schema | uaccount | table | regress_rls_alice=arwdDxt/regress_rls_alice+|                   | 
                      |          |       | =r/regress_rls_alice                        |                   | 
! (2 rows)
  
  \d document
  SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename = 'document' ORDER BY policyname;
!  schemaname | tablename | policyname | permissive | roles | cmd | qual | with_check 
! ------------+-----------+------------+------------+-------+-----+------+------------
! (0 rows)
  
  -- viewpoint from regress_rls_bob
  SET SESSION AUTHORIZATION regress_rls_bob;
  SET row_security TO ON;
  SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
!                       ^
  SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document NATURAL JOIN category WHERE f_leak(dt...
!                       ^
  -- try a sampled version
  SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)
    WHERE f_leak(dtitle) ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(...
!                       ^
  -- viewpoint from regress_rls_carol
  SET SESSION AUTHORIZATION regress_rls_carol;
  SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
!                       ^
  SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document NATURAL JOIN category WHERE f_leak(dt...
!                       ^
  -- try a sampled version
  SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)
    WHERE f_leak(dtitle) ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(...
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
! ERROR:  relation "document" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtit...
!                                           ^
  EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
! ERROR:  relation "document" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN cate...
!                                           ^
  -- viewpoint from regress_rls_dave
  SET SESSION AUTHORIZATION regress_rls_dave;
  SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
!                       ^
  SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document NATURAL JOIN category WHERE f_leak(dt...
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
! ERROR:  relation "document" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtit...
!                                           ^
  EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
! ERROR:  relation "document" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN cate...
!                                           ^
  -- 44 would technically fail for both p2r and p1r, but we should get an error
  -- back from p1r for this because it sorts first
  INSERT INTO document VALUES (100, 44, 1, 'regress_rls_dave', 'testing sorting of policies'); -- fail
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (100, 44, 1, 'regress_rls_dave',...
!                     ^
  -- Just to see a p2r error
  INSERT INTO document VALUES (100, 55, 1, 'regress_rls_dave', 'testing sorting of policies'); -- fail
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (100, 55, 1, 'regress_rls_dave',...
!                     ^
  -- only owner can change policies
  ALTER POLICY p1 ON document USING (true);    --fail
! ERROR:  relation "document" does not exist
  DROP POLICY p1 ON document;                  --fail
! ERROR:  relation "document" does not exist
  SET SESSION AUTHORIZATION regress_rls_alice;
  ALTER POLICY p1 ON document USING (dauthor = current_user);
+ ERROR:  relation "document" does not exist
  -- viewpoint from regress_rls_bob again
  SET SESSION AUTHORIZATION regress_rls_bob;
  SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
!                       ^
  SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document NATURAL JOIN category WHERE f_leak(dt...
!                       ^
  -- viewpoint from rls_regres_carol again
  SET SESSION AUTHORIZATION regress_rls_carol;
  SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
!                       ^
  SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document NATURAL JOIN category WHERE f_leak(dt...
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
! ERROR:  relation "document" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtit...
!                                           ^
  EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
! ERROR:  relation "document" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN cate...
!                                           ^
  -- interaction of FK/PK constraints
  SET SESSION AUTHORIZATION regress_rls_alice;
  CREATE POLICY p2 ON category
***************
*** 392,574 ****
  -- cannot delete PK referenced by invisible FK
  SET SESSION AUTHORIZATION regress_rls_bob;
  SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid;
!  did | cid | dlevel |     dauthor     |       dtitle       | cid |   cname    
! -----+-----+--------+-----------------+--------------------+-----+------------
!    1 |  11 |      1 | regress_rls_bob | my first novel     |  11 | novel
!    2 |  11 |      2 | regress_rls_bob | my second novel    |  11 | novel
!    3 |  22 |      2 | regress_rls_bob | my science fiction |     | 
!    4 |  44 |      1 | regress_rls_bob | my first manga     |     | 
!    5 |  44 |      2 | regress_rls_bob | my second manga    |     | 
!      |     |        |                 |                    |  33 | technology
! (6 rows)
! 
  DELETE FROM category WHERE cid = 33;    -- fails with FK violation
- ERROR:  update or delete on table "category" violates foreign key constraint "document_cid_fkey" on table "document"
- DETAIL:  Key is still referenced from table "document".
  -- can insert FK referencing invisible PK
  SET SESSION AUTHORIZATION regress_rls_carol;
  SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid;
!  did | cid | dlevel |      dauthor      |        dtitle         | cid |      cname      
! -----+-----+--------+-------------------+-----------------------+-----+-----------------
!    6 |  22 |      1 | regress_rls_carol | great science fiction |  22 | science fiction
!    7 |  33 |      2 | regress_rls_carol | great technology book |     | 
!    8 |  44 |      1 | regress_rls_carol | great manga           |  44 | manga
! (3 rows)
! 
  INSERT INTO document VALUES (11, 33, 1, current_user, 'hoge');
  -- UNIQUE or PRIMARY KEY constraint violation DOES reveal presence of row
  SET SESSION AUTHORIZATION regress_rls_bob;
  INSERT INTO document VALUES (8, 44, 1, 'regress_rls_bob', 'my third manga'); -- Must fail with unique violation, revealing presence of did we can't see
! ERROR:  duplicate key value violates unique constraint "document_pkey"
  SELECT * FROM document WHERE did = 8; -- and confirm we can't see it
!  did | cid | dlevel | dauthor | dtitle 
! -----+-----+--------+---------+--------
! (0 rows)
! 
  -- RLS policies are checked before constraints
  INSERT INTO document VALUES (8, 44, 1, 'regress_rls_carol', 'my third manga'); -- Should fail with RLS check violation, not duplicate key violation
! ERROR:  new row violates row-level security policy for table "document"
  UPDATE document SET did = 8, dauthor = 'regress_rls_carol' WHERE did = 5; -- Should fail with RLS check violation, not duplicate key violation
! ERROR:  Distributed column or partition column "did" can't be updated in current version
  -- database superuser does bypass RLS policy when enabled
  RESET SESSION AUTHORIZATION;
  SET row_security TO ON;
  SELECT * FROM document ORDER BY did;
!  did | cid | dlevel |      dauthor      |         dtitle          
! -----+-----+--------+-------------------+-------------------------
!    1 |  11 |      1 | regress_rls_bob   | my first novel
!    2 |  11 |      2 | regress_rls_bob   | my second novel
!    3 |  22 |      2 | regress_rls_bob   | my science fiction
!    4 |  44 |      1 | regress_rls_bob   | my first manga
!    5 |  44 |      2 | regress_rls_bob   | my second manga
!    6 |  22 |      1 | regress_rls_carol | great science fiction
!    7 |  33 |      2 | regress_rls_carol | great technology book
!    8 |  44 |      1 | regress_rls_carol | great manga
!    9 |  22 |      1 | regress_rls_dave  | awesome science fiction
!   10 |  33 |      2 | regress_rls_dave  | awesome technology book
!   11 |  33 |      1 | regress_rls_carol | hoge
! (11 rows)
! 
  SELECT * FROM category ORDER BY cid;
   cid |      cname      
  -----+-----------------
    11 | novel
    22 | science fiction
-   33 | technology
    44 | manga
! (4 rows)
  
  -- database superuser does bypass RLS policy when disabled
  RESET SESSION AUTHORIZATION;
  SET row_security TO OFF;
  SELECT * FROM document ORDER BY did;
!  did | cid | dlevel |      dauthor      |         dtitle          
! -----+-----+--------+-------------------+-------------------------
!    1 |  11 |      1 | regress_rls_bob   | my first novel
!    2 |  11 |      2 | regress_rls_bob   | my second novel
!    3 |  22 |      2 | regress_rls_bob   | my science fiction
!    4 |  44 |      1 | regress_rls_bob   | my first manga
!    5 |  44 |      2 | regress_rls_bob   | my second manga
!    6 |  22 |      1 | regress_rls_carol | great science fiction
!    7 |  33 |      2 | regress_rls_carol | great technology book
!    8 |  44 |      1 | regress_rls_carol | great manga
!    9 |  22 |      1 | regress_rls_dave  | awesome science fiction
!   10 |  33 |      2 | regress_rls_dave  | awesome technology book
!   11 |  33 |      1 | regress_rls_carol | hoge
! (11 rows)
! 
  SELECT * FROM category ORDER BY cid;
   cid |      cname      
  -----+-----------------
    11 | novel
    22 | science fiction
-   33 | technology
    44 | manga
! (4 rows)
  
  -- database non-superuser with bypass privilege can bypass RLS policy when disabled
  SET SESSION AUTHORIZATION regress_rls_exempt_user;
  SET row_security TO OFF;
  SELECT * FROM document ORDER BY did;
!  did | cid | dlevel |      dauthor      |         dtitle          
! -----+-----+--------+-------------------+-------------------------
!    1 |  11 |      1 | regress_rls_bob   | my first novel
!    2 |  11 |      2 | regress_rls_bob   | my second novel
!    3 |  22 |      2 | regress_rls_bob   | my science fiction
!    4 |  44 |      1 | regress_rls_bob   | my first manga
!    5 |  44 |      2 | regress_rls_bob   | my second manga
!    6 |  22 |      1 | regress_rls_carol | great science fiction
!    7 |  33 |      2 | regress_rls_carol | great technology book
!    8 |  44 |      1 | regress_rls_carol | great manga
!    9 |  22 |      1 | regress_rls_dave  | awesome science fiction
!   10 |  33 |      2 | regress_rls_dave  | awesome technology book
!   11 |  33 |      1 | regress_rls_carol | hoge
! (11 rows)
! 
  SELECT * FROM category ORDER BY cid;
   cid |      cname      
  -----+-----------------
    11 | novel
    22 | science fiction
-   33 | technology
    44 | manga
! (4 rows)
  
  -- RLS policy does not apply to table owner when RLS enabled.
  SET SESSION AUTHORIZATION regress_rls_alice;
  SET row_security TO ON;
  SELECT * FROM document ORDER BY did;
!  did | cid | dlevel |      dauthor      |         dtitle          
! -----+-----+--------+-------------------+-------------------------
!    1 |  11 |      1 | regress_rls_bob   | my first novel
!    2 |  11 |      2 | regress_rls_bob   | my second novel
!    3 |  22 |      2 | regress_rls_bob   | my science fiction
!    4 |  44 |      1 | regress_rls_bob   | my first manga
!    5 |  44 |      2 | regress_rls_bob   | my second manga
!    6 |  22 |      1 | regress_rls_carol | great science fiction
!    7 |  33 |      2 | regress_rls_carol | great technology book
!    8 |  44 |      1 | regress_rls_carol | great manga
!    9 |  22 |      1 | regress_rls_dave  | awesome science fiction
!   10 |  33 |      2 | regress_rls_dave  | awesome technology book
!   11 |  33 |      1 | regress_rls_carol | hoge
! (11 rows)
! 
  SELECT * FROM category ORDER BY cid;
   cid |      cname      
  -----+-----------------
    11 | novel
    22 | science fiction
-   33 | technology
    44 | manga
! (4 rows)
  
  -- RLS policy does not apply to table owner when RLS disabled.
  SET SESSION AUTHORIZATION regress_rls_alice;
  SET row_security TO OFF;
  SELECT * FROM document ORDER BY did;
!  did | cid | dlevel |      dauthor      |         dtitle          
! -----+-----+--------+-------------------+-------------------------
!    1 |  11 |      1 | regress_rls_bob   | my first novel
!    2 |  11 |      2 | regress_rls_bob   | my second novel
!    3 |  22 |      2 | regress_rls_bob   | my science fiction
!    4 |  44 |      1 | regress_rls_bob   | my first manga
!    5 |  44 |      2 | regress_rls_bob   | my second manga
!    6 |  22 |      1 | regress_rls_carol | great science fiction
!    7 |  33 |      2 | regress_rls_carol | great technology book
!    8 |  44 |      1 | regress_rls_carol | great manga
!    9 |  22 |      1 | regress_rls_dave  | awesome science fiction
!   10 |  33 |      2 | regress_rls_dave  | awesome technology book
!   11 |  33 |      1 | regress_rls_carol | hoge
! (11 rows)
! 
  SELECT * FROM category ORDER BY cid;
   cid |      cname      
  -----+-----------------
    11 | novel
    22 | science fiction
-   33 | technology
    44 | manga
! (4 rows)
  
  --
  -- Table inheritance and RLS policy
--- 237,349 ----
  -- cannot delete PK referenced by invisible FK
  SET SESSION AUTHORIZATION regress_rls_bob;
  SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document d FULL OUTER JOIN category c on d.cid...
!                       ^
  DELETE FROM category WHERE cid = 33;    -- fails with FK violation
  -- can insert FK referencing invisible PK
  SET SESSION AUTHORIZATION regress_rls_carol;
  SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document d FULL OUTER JOIN category c on d.cid...
!                       ^
  INSERT INTO document VALUES (11, 33, 1, current_user, 'hoge');
+ ERROR:  relation "document" does not exist
+ LINE 1: INSERT INTO document VALUES (11, 33, 1, current_user, 'hoge'...
+                     ^
  -- UNIQUE or PRIMARY KEY constraint violation DOES reveal presence of row
  SET SESSION AUTHORIZATION regress_rls_bob;
  INSERT INTO document VALUES (8, 44, 1, 'regress_rls_bob', 'my third manga'); -- Must fail with unique violation, revealing presence of did we can't see
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (8, 44, 1, 'regress_rls_bob', 'm...
!                     ^
  SELECT * FROM document WHERE did = 8; -- and confirm we can't see it
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document WHERE did = 8;
!                       ^
  -- RLS policies are checked before constraints
  INSERT INTO document VALUES (8, 44, 1, 'regress_rls_carol', 'my third manga'); -- Should fail with RLS check violation, not duplicate key violation
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (8, 44, 1, 'regress_rls_carol', ...
!                     ^
  UPDATE document SET did = 8, dauthor = 'regress_rls_carol' WHERE did = 5; -- Should fail with RLS check violation, not duplicate key violation
! ERROR:  relation "document" does not exist
! LINE 1: UPDATE document SET did = 8, dauthor = 'regress_rls_carol' W...
!                ^
  -- database superuser does bypass RLS policy when enabled
  RESET SESSION AUTHORIZATION;
  SET row_security TO ON;
  SELECT * FROM document ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document ORDER BY did;
!                       ^
  SELECT * FROM category ORDER BY cid;
   cid |      cname      
  -----+-----------------
    11 | novel
    22 | science fiction
    44 | manga
! (3 rows)
  
  -- database superuser does bypass RLS policy when disabled
  RESET SESSION AUTHORIZATION;
  SET row_security TO OFF;
  SELECT * FROM document ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document ORDER BY did;
!                       ^
  SELECT * FROM category ORDER BY cid;
   cid |      cname      
  -----+-----------------
    11 | novel
    22 | science fiction
    44 | manga
! (3 rows)
  
  -- database non-superuser with bypass privilege can bypass RLS policy when disabled
  SET SESSION AUTHORIZATION regress_rls_exempt_user;
  SET row_security TO OFF;
  SELECT * FROM document ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document ORDER BY did;
!                       ^
  SELECT * FROM category ORDER BY cid;
   cid |      cname      
  -----+-----------------
    11 | novel
    22 | science fiction
    44 | manga
! (3 rows)
  
  -- RLS policy does not apply to table owner when RLS enabled.
  SET SESSION AUTHORIZATION regress_rls_alice;
  SET row_security TO ON;
  SELECT * FROM document ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document ORDER BY did;
!                       ^
  SELECT * FROM category ORDER BY cid;
   cid |      cname      
  -----+-----------------
    11 | novel
    22 | science fiction
    44 | manga
! (3 rows)
  
  -- RLS policy does not apply to table owner when RLS disabled.
  SET SESSION AUTHORIZATION regress_rls_alice;
  SET row_security TO OFF;
  SELECT * FROM document ORDER BY did;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document ORDER BY did;
!                       ^
  SELECT * FROM category ORDER BY cid;
   cid |      cname      
  -----+-----------------
    11 | novel
    22 | science fiction
    44 | manga
! (3 rows)
  
  --
  -- Table inheritance and RLS policy
***************
*** 863,869 ****
                            Table "regress_rls_schema.part_document"
   Column  |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  ---------+---------+-----------+----------+---------+----------+--------------+-------------
!  did     | integer |           |          |         | plain    |              | 
   cid     | integer |           |          |         | plain    |              | 
   dlevel  | integer |           | not null |         | plain    |              | 
   dauthor | name    |           |          |         | plain    |              | 
--- 638,644 ----
                            Table "regress_rls_schema.part_document"
   Column  |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
  ---------+---------+-----------+----------+---------+----------+--------------+-------------
!  did     | integer |           | not null |         | plain    |              | 
   cid     | integer |           |          |         | plain    |              | 
   dlevel  | integer |           | not null |         | plain    |              | 
   dauthor | name    |           |          |         | plain    |              | 
***************
*** 880,886 ****
  Partitions: part_document_fiction FOR VALUES FROM (11) TO (12),
              part_document_nonfiction FOR VALUES FROM (99) TO (100),
              part_document_satire FOR VALUES FROM (55) TO (56)
! Distribute By: HASH(did)
  Location Nodes: ALL DATANODES
  
  SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename like '%part_document%' ORDER BY policyname;
--- 655,661 ----
  Partitions: part_document_fiction FOR VALUES FROM (11) TO (12),
              part_document_nonfiction FOR VALUES FROM (99) TO (100),
              part_document_satire FOR VALUES FROM (55) TO (56)
! Distribute By: SHARD(did)
  Location Nodes: ALL DATANODES
  
  SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename like '%part_document%' ORDER BY policyname;
***************
*** 981,994 ****
  
  -- pp1 ERROR
  INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_dave', 'testing pp1'); -- fail
! ERROR:  new row violates row-level security policy for table "part_document"
  -- pp1r ERROR
  INSERT INTO part_document VALUES (100, 99, 1, 'regress_rls_dave', 'testing pp1r'); -- fail
! ERROR:  new row violates row-level security policy "pp1r" for table "part_document"
  -- Show that RLS policy does not apply for direct inserts to children
  -- This should fail with RLS POLICY pp1r violation.
  INSERT INTO part_document VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- fail
! ERROR:  new row violates row-level security policy "pp1r" for table "part_document"
  -- But this should succeed.
  INSERT INTO part_document_satire VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- success
  -- We still cannot see the row using the parent
--- 756,769 ----
  
  -- pp1 ERROR
  INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_dave', 'testing pp1'); -- fail
! ERROR:  node:datanode_2, backend_pid:383292, nodename:datanode_2,backend_pid:383292,message:new row violates row-level security policy for table "part_document"
  -- pp1r ERROR
  INSERT INTO part_document VALUES (100, 99, 1, 'regress_rls_dave', 'testing pp1r'); -- fail
! ERROR:  node:datanode_2, backend_pid:383292, nodename:datanode_2,backend_pid:383292,message:new row violates row-level security policy "pp1r" for table "part_document"
  -- Show that RLS policy does not apply for direct inserts to children
  -- This should fail with RLS POLICY pp1r violation.
  INSERT INTO part_document VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- fail
! ERROR:  node:datanode_2, backend_pid:383292, nodename:datanode_2,backend_pid:383292,message:new row violates row-level security policy "pp1r" for table "part_document"
  -- But this should succeed.
  INSERT INTO part_document_satire VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- success
  -- We still cannot see the row using the parent
***************
*** 1018,1024 ****
  -- This should fail with RLS violation now.
  SET SESSION AUTHORIZATION regress_rls_dave;
  INSERT INTO part_document_satire VALUES (101, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- fail
! ERROR:  new row violates row-level security policy for table "part_document_satire"
  -- And now we cannot see directly into the partition either, due to RLS
  SELECT * FROM part_document_satire WHERE f_leak(dtitle) ORDER BY did;
   did | cid | dlevel | dauthor | dtitle 
--- 793,799 ----
  -- This should fail with RLS violation now.
  SET SESSION AUTHORIZATION regress_rls_dave;
  INSERT INTO part_document_satire VALUES (101, 55, 1, 'regress_rls_dave', 'testing RLS with partitions'); -- fail
! ERROR:  node:datanode_1, backend_pid:383366, nodename:datanode_1,backend_pid:383366,message:new row violates row-level security policy for table "part_document_satire"
  -- And now we cannot see directly into the partition either, due to RLS
  SELECT * FROM part_document_satire WHERE f_leak(dtitle) ORDER BY did;
   did | cid | dlevel | dauthor | dtitle 
***************
*** 1221,1227 ****
      USING ((SELECT dlevel <= seclv FROM uaccount WHERE pguser = current_user));
  SET SESSION AUTHORIZATION regress_rls_carol;
  INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_carol', 'testing pp3'); -- fail
! ERROR:  new row violates row-level security policy "pp3" for table "part_document"
  ----- Dependencies -----
  SET SESSION AUTHORIZATION regress_rls_alice;
  SET row_security TO ON;
--- 996,1002 ----
      USING ((SELECT dlevel <= seclv FROM uaccount WHERE pguser = current_user));
  SET SESSION AUTHORIZATION regress_rls_carol;
  INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_carol', 'testing pp3'); -- fail
! ERROR:  node:datanode_2, backend_pid:383377, nodename:datanode_2,backend_pid:383377,message:new row violates row-level security policy "pp3" for table "part_document"
  ----- Dependencies -----
  SET SESSION AUTHORIZATION regress_rls_alice;
  SET row_security TO ON;
***************
*** 1589,1596 ****
  WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b);
  EXPLAIN (COSTS OFF) UPDATE t1 SET b=t1.b FROM t2
  WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
!                                     QUERY PLAN                                     
! -----------------------------------------------------------------------------------
   Remote Subquery Scan on all (datanode_2)
     ->  Update on t1
           Update on t1
--- 1364,1371 ----
  WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b);
  EXPLAIN (COSTS OFF) UPDATE t1 SET b=t1.b FROM t2
  WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
   Remote Subquery Scan on all (datanode_2)
     ->  Update on t1
           Update on t1
***************
*** 1599,1645 ****
           ->  Nested Loop
                 ->  Seq Scan on t1
                       Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Materialize
!                      ->  Remote Subquery Scan on all (datanode_2)
!                            ->  Seq Scan on t2
!                                  Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
           ->  Nested Loop
                 ->  Seq Scan on t2 t2_1
                       Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Materialize
!                      ->  Remote Subquery Scan on all (datanode_2)
!                            ->  Seq Scan on t2
!                                  Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
           ->  Nested Loop
                 ->  Seq Scan on t3
                       Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Materialize
!                      ->  Remote Subquery Scan on all (datanode_2)
!                            ->  Seq Scan on t2
!                                  Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
! (26 rows)
  
  UPDATE t1 SET b=t1.b FROM t2
  WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
  EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t1
  WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
!                                        QUERY PLAN                                        
! -----------------------------------------------------------------------------------------
   Remote Subquery Scan on all (datanode_2)
     ->  Update on t2
           ->  Nested Loop
                 ->  Seq Scan on t2
                       Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
!                ->  Materialize
!                      ->  Remote Subquery Scan on all (datanode_2)
!                            ->  Append
!                                  ->  Seq Scan on t1
!                                        Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
!                                  ->  Seq Scan on t2 t2_1
!                                        Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
!                                  ->  Seq Scan on t3
!                                        Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
! (14 rows)
  
  UPDATE t2 SET b=t2.b FROM t1
  WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
--- 1374,1412 ----
           ->  Nested Loop
                 ->  Seq Scan on t1
                       Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Seq Scan on t2
!                      Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
           ->  Nested Loop
                 ->  Seq Scan on t2 t2_1
                       Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Seq Scan on t2
!                      Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
           ->  Nested Loop
                 ->  Seq Scan on t3
                       Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Seq Scan on t2
!                      Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
! (20 rows)
  
  UPDATE t1 SET b=t1.b FROM t2
  WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
  EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t1
  WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
!                                  QUERY PLAN                                  
! -----------------------------------------------------------------------------
   Remote Subquery Scan on all (datanode_2)
     ->  Update on t2
           ->  Nested Loop
                 ->  Seq Scan on t2
                       Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
!                ->  Append
!                      ->  Seq Scan on t1
!                            Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
!                      ->  Seq Scan on t2 t2_1
!                            Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
!                      ->  Seq Scan on t3
!                            Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
! (12 rows)
  
  UPDATE t2 SET b=t2.b FROM t1
  WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
***************
*** 1647,1665 ****
  EXPLAIN (COSTS OFF) UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
  WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
  AND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2;
!                                     QUERY PLAN                                     
! -----------------------------------------------------------------------------------
   Remote Subquery Scan on all (datanode_2)
     ->  Update on t2 t2_1
           ->  Nested Loop
                 Join Filter: (t2_1.b = t2_2.b)
                 ->  Seq Scan on t2 t2_1
                       Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
!                ->  Materialize
!                      ->  Remote Subquery Scan on all (datanode_2)
!                            ->  Seq Scan on t2 t2_2
!                                  Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
! (10 rows)
  
  UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
  WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
--- 1414,1430 ----
  EXPLAIN (COSTS OFF) UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
  WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
  AND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2;
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
   Remote Subquery Scan on all (datanode_2)
     ->  Update on t2 t2_1
           ->  Nested Loop
                 Join Filter: (t2_1.b = t2_2.b)
                 ->  Seq Scan on t2 t2_1
                       Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
!                ->  Seq Scan on t2 t2_2
!                      Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
! (8 rows)
  
  UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
  WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
***************
*** 1672,1724 ****
  EXPLAIN (COSTS OFF) UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2
  WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.b
  AND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_2;
!                                        QUERY PLAN                                        
! -----------------------------------------------------------------------------------------
   Remote Subquery Scan on all (datanode_2)
     ->  Update on t1 t1_1
           Update on t1 t1_1
           Update on t2 t1_1_1
           Update on t3 t1_1_2
!          ->  Hash Join
!                Hash Cond: (b = t1_1.b)
!                ->  Remote Subquery Scan on all (datanode_2)
!                      ->  Append
!                            ->  Seq Scan on t1 t1_2
!                                  Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                            ->  Seq Scan on t2 t1_2_1
!                                  Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                            ->  Seq Scan on t3 t1_2_2
!                                  Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Hash
!                      ->  Seq Scan on t1 t1_1
                             Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
           ->  Nested Loop
!                Join Filter: (t1_1_1.b = b)
                 ->  Seq Scan on t2 t1_1_1
                       Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Materialize
!                      ->  Remote Subquery Scan on all (datanode_2)
!                            ->  Append
!                                  ->  Seq Scan on t1 t1_2
!                                        Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                                  ->  Seq Scan on t2 t1_2_1
!                                        Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                                  ->  Seq Scan on t3 t1_2_2
!                                        Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
           ->  Nested Loop
!                Join Filter: (t1_1_2.b = b)
                 ->  Seq Scan on t3 t1_1_2
                       Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Materialize
!                      ->  Remote Subquery Scan on all (datanode_2)
!                            ->  Append
!                                  ->  Seq Scan on t1 t1_2
!                                        Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                                  ->  Seq Scan on t2 t1_2_1
!                                        Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                                  ->  Seq Scan on t3 t1_2_2
!                                        Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
! (44 rows)
  
  UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2
  WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.b
--- 1437,1483 ----
  EXPLAIN (COSTS OFF) UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2
  WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.b
  AND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_2;
!                                  QUERY PLAN                                  
! -----------------------------------------------------------------------------
   Remote Subquery Scan on all (datanode_2)
     ->  Update on t1 t1_1
           Update on t1 t1_1
           Update on t2 t1_1_1
           Update on t3 t1_1_2
!          ->  Nested Loop
!                Join Filter: (t1_1.b = t1_2.b)
!                ->  Seq Scan on t1 t1_1
!                      Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Append
!                      ->  Seq Scan on t1 t1_2
!                            Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                      ->  Seq Scan on t2 t1_2_1
!                            Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                      ->  Seq Scan on t3 t1_2_2
                             Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
           ->  Nested Loop
!                Join Filter: (t1_1_1.b = t1_2.b)
                 ->  Seq Scan on t2 t1_1_1
                       Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Append
!                      ->  Seq Scan on t1 t1_2
!                            Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                      ->  Seq Scan on t2 t1_2_1
!                            Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                      ->  Seq Scan on t3 t1_2_2
!                            Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
           ->  Nested Loop
!                Join Filter: (t1_1_2.b = t1_2.b)
                 ->  Seq Scan on t3 t1_1_2
                       Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                ->  Append
!                      ->  Seq Scan on t1 t1_2
!                            Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                      ->  Seq Scan on t2 t1_2_1
!                            Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
!                      ->  Seq Scan on t3 t1_2_2
!                            Filter: ((a = 4) AND ((a % 2) = 0) AND f_leak(b))
! (38 rows)
  
  UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2
  WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.b
***************
*** 1823,1831 ****
  (5 rows)
  
  INSERT INTO bv1 VALUES (-1, 'xxx'); -- should fail view WCO
! ERROR:  new row violates row-level security policy for table "b1"
  INSERT INTO bv1 VALUES (11, 'xxx'); -- should fail RLS check
! ERROR:  new row violates row-level security policy for table "b1"
  INSERT INTO bv1 VALUES (12, 'xxx'); -- ok
  EXPLAIN (COSTS OFF) UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b);
                                   QUERY PLAN                                  
--- 1582,1590 ----
  (5 rows)
  
  INSERT INTO bv1 VALUES (-1, 'xxx'); -- should fail view WCO
! ERROR:  node:datanode_1, backend_pid:383289, nodename:datanode_1,backend_pid:383289,message:new row violates row-level security policy for table "b1"
  INSERT INTO bv1 VALUES (11, 'xxx'); -- should fail RLS check
! ERROR:  node:datanode_2, backend_pid:383284, nodename:datanode_2,backend_pid:383284,message:new row violates row-level security policy for table "b1"
  INSERT INTO bv1 VALUES (12, 'xxx'); -- ok
  EXPLAIN (COSTS OFF) UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b);
                                   QUERY PLAN                                  
***************
*** 1879,1967 ****
  --
  SET SESSION AUTHORIZATION regress_rls_alice;
  DROP POLICY p1 ON document;
  DROP POLICY p1r ON document;
  CREATE POLICY p1 ON document FOR SELECT USING (true);
  CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user);
  CREATE POLICY p3 ON document FOR UPDATE
    USING (cid = (SELECT cid from category WHERE cname = 'novel'))
    WITH CHECK (dauthor = current_user);
  SET SESSION AUTHORIZATION regress_rls_bob;
  -- Exists...
  SELECT * FROM document WHERE did = 2 order by 1;
!  did | cid | dlevel |     dauthor     |     dtitle      
! -----+-----+--------+-----------------+-----------------
!    2 |  11 |      2 | regress_rls_bob | my second novel
! (1 row)
! 
  -- ...so violates actual WITH CHECK OPTION within UPDATE (not INSERT, since
  -- alternative UPDATE path happens to be taken):
  INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, dauthor = EXCLUDED.dauthor;
! ERROR:  new row violates row-level security policy for table "document"
  -- Violates USING qual for UPDATE policy p3.
  --
  -- UPDATE path is taken, but UPDATE fails purely because *existing* row to be
  -- updated is not a "novel"/cid 11 (row is not leaked, even though we have
  -- SELECT privileges sufficient to see the row in this instance):
  INSERT INTO document VALUES (33, 22, 1, 'regress_rls_bob', 'okay science fiction'); -- preparation for next statement
  INSERT INTO document VALUES (33, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'Some novel, replaces sci-fi') -- takes UPDATE path
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
! ERROR:  new row violates row-level security policy (USING expression) for table "document"
  -- Fine (we UPDATE, since INSERT WCOs and UPDATE security barrier quals + WCOs
  -- not violated):
  INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
!  did | cid | dlevel |     dauthor     |     dtitle     
! -----+-----+--------+-----------------+----------------
!    2 |  11 |      2 | regress_rls_bob | my first novel
! (1 row)
! 
  -- Fine (we INSERT, so "cid = 33" ("technology") isn't evaluated):
  INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
!  did | cid | dlevel |     dauthor     |        dtitle         
! -----+-----+--------+-----------------+-----------------------
!   78 |  11 |      1 | regress_rls_bob | some technology novel
! (1 row)
! 
  -- Fine (same query, but we UPDATE, so "cid = 33", ("technology") is not the
  -- case in respect of *existing* tuple):
  INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
!  did | cid | dlevel |     dauthor     |        dtitle         
! -----+-----+--------+-----------------+-----------------------
!   78 |  33 |      1 | regress_rls_bob | some technology novel
! (1 row)
! 
  -- Same query a third time, but now fails due to existing tuple finally not
  -- passing quals:
  INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
! ERROR:  new row violates row-level security policy (USING expression) for table "document"
  -- Don't fail just because INSERT doesn't satisfy WITH CHECK option that
  -- originated as a barrier/USING() qual from the UPDATE.  Note that the UPDATE
  -- path *isn't* taken, and so UPDATE-related policy does not apply:
  INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
!  did | cid | dlevel |     dauthor     |              dtitle              
! -----+-----+--------+-----------------+----------------------------------
!   79 |  33 |      1 | regress_rls_bob | technology book, can only insert
! (1 row)
! 
  -- But this time, the same statement fails, because the UPDATE path is taken,
  -- and updating the row just inserted falls afoul of security barrier qual
  -- (enforced as WCO) -- what we might have updated target tuple to is
  -- irrelevant, in fact.
  INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
! ERROR:  new row violates row-level security policy (USING expression) for table "document"
  -- Test default USING qual enforced as WCO
  SET SESSION AUTHORIZATION regress_rls_alice;
  DROP POLICY p1 ON document;
  DROP POLICY p2 ON document;
  DROP POLICY p3 ON document;
  CREATE POLICY p3_with_default ON document FOR UPDATE
    USING (cid = (SELECT cid from category WHERE cname = 'novel'));
  SET SESSION AUTHORIZATION regress_rls_bob;
  -- Just because WCO-style enforcement of USING quals occurs with
  -- existing/target tuple does not mean that the implementation can be allowed
--- 1638,1736 ----
  --
  SET SESSION AUTHORIZATION regress_rls_alice;
  DROP POLICY p1 ON document;
+ ERROR:  relation "document" does not exist
  DROP POLICY p1r ON document;
+ ERROR:  relation "document" does not exist
  CREATE POLICY p1 ON document FOR SELECT USING (true);
+ ERROR:  relation "document" does not exist
  CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user);
+ ERROR:  relation "document" does not exist
  CREATE POLICY p3 ON document FOR UPDATE
    USING (cid = (SELECT cid from category WHERE cname = 'novel'))
    WITH CHECK (dauthor = current_user);
+ ERROR:  relation "document" does not exist
  SET SESSION AUTHORIZATION regress_rls_bob;
  -- Exists...
  SELECT * FROM document WHERE did = 2 order by 1;
! ERROR:  relation "document" does not exist
! LINE 1: SELECT * FROM document WHERE did = 2 order by 1;
!                       ^
  -- ...so violates actual WITH CHECK OPTION within UPDATE (not INSERT, since
  -- alternative UPDATE path happens to be taken):
  INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, dauthor = EXCLUDED.dauthor;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (2, (SELECT cid from category WH...
!                     ^
  -- Violates USING qual for UPDATE policy p3.
  --
  -- UPDATE path is taken, but UPDATE fails purely because *existing* row to be
  -- updated is not a "novel"/cid 11 (row is not leaked, even though we have
  -- SELECT privileges sufficient to see the row in this instance):
  INSERT INTO document VALUES (33, 22, 1, 'regress_rls_bob', 'okay science fiction'); -- preparation for next statement
+ ERROR:  relation "document" does not exist
+ LINE 1: INSERT INTO document VALUES (33, 22, 1, 'regress_rls_bob', '...
+                     ^
  INSERT INTO document VALUES (33, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'Some novel, replaces sci-fi') -- takes UPDATE path
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (33, (SELECT cid from category W...
!                     ^
  -- Fine (we UPDATE, since INSERT WCOs and UPDATE security barrier quals + WCOs
  -- not violated):
  INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (2, (SELECT cid from category WH...
!                     ^
  -- Fine (we INSERT, so "cid = 33" ("technology") isn't evaluated):
  INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (78, (SELECT cid from category W...
!                     ^
  -- Fine (same query, but we UPDATE, so "cid = 33", ("technology") is not the
  -- case in respect of *existing* tuple):
  INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (78, (SELECT cid from category W...
!                     ^
  -- Same query a third time, but now fails due to existing tuple finally not
  -- passing quals:
  INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (78, (SELECT cid from category W...
!                     ^
  -- Don't fail just because INSERT doesn't satisfy WITH CHECK option that
  -- originated as a barrier/USING() qual from the UPDATE.  Note that the UPDATE
  -- path *isn't* taken, and so UPDATE-related policy does not apply:
  INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (79, (SELECT cid from category W...
!                     ^
  -- But this time, the same statement fails, because the UPDATE path is taken,
  -- and updating the row just inserted falls afoul of security barrier qual
  -- (enforced as WCO) -- what we might have updated target tuple to is
  -- irrelevant, in fact.
  INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (79, (SELECT cid from category W...
!                     ^
  -- Test default USING qual enforced as WCO
  SET SESSION AUTHORIZATION regress_rls_alice;
  DROP POLICY p1 ON document;
+ ERROR:  relation "document" does not exist
  DROP POLICY p2 ON document;
+ ERROR:  relation "document" does not exist
  DROP POLICY p3 ON document;
+ ERROR:  relation "document" does not exist
  CREATE POLICY p3_with_default ON document FOR UPDATE
    USING (cid = (SELECT cid from category WHERE cname = 'novel'));
+ ERROR:  relation "document" does not exist
  SET SESSION AUTHORIZATION regress_rls_bob;
  -- Just because WCO-style enforcement of USING quals occurs with
  -- existing/target tuple does not mean that the implementation can be allowed
***************
*** 1976,1991 ****
  -- UPDATE to make this fail:
  INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
! ERROR:  new row violates row-level security policy for table "document"
  -- UPDATE path is taken here.  Existing tuple passes, since it's cid
  -- corresponds to "novel", but default USING qual is enforced against
  -- post-UPDATE tuple too (as always when updating with a policy that lacks an
  -- explicit WCO), and so this fails:
  INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET cid = EXCLUDED.cid, dtitle = EXCLUDED.dtitle RETURNING *;
! ERROR:  new row violates row-level security policy for table "document"
  SET SESSION AUTHORIZATION regress_rls_alice;
  DROP POLICY p3_with_default ON document;
  --
  -- Test ALL policies with ON CONFLICT DO UPDATE (much the same as existing UPDATE
  -- tests)
--- 1745,1765 ----
  -- UPDATE to make this fail:
  INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (79, (SELECT cid from category W...
!                     ^
  -- UPDATE path is taken here.  Existing tuple passes, since it's cid
  -- corresponds to "novel", but default USING qual is enforced against
  -- post-UPDATE tuple too (as always when updating with a policy that lacks an
  -- explicit WCO), and so this fails:
  INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET cid = EXCLUDED.cid, dtitle = EXCLUDED.dtitle RETURNING *;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (2, (SELECT cid from category WH...
!                     ^
  SET SESSION AUTHORIZATION regress_rls_alice;
  DROP POLICY p3_with_default ON document;
+ ERROR:  relation "document" does not exist
  --
  -- Test ALL policies with ON CONFLICT DO UPDATE (much the same as existing UPDATE
  -- tests)
***************
*** 1993,2012 ****
  CREATE POLICY p3_with_all ON document FOR ALL
    USING (cid = (SELECT cid from category WHERE cname = 'novel'))
    WITH CHECK (dauthor = current_user);
  SET SESSION AUTHORIZATION regress_rls_bob;
  -- Fails, since ALL WCO is enforced in insert path:
  INSERT INTO document VALUES (80, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33;
! ERROR:  new row violates row-level security policy for table "document"
  -- Fails, since ALL policy USING qual is enforced (existing, target tuple is in
  -- violation, since it has the "manga" cid):
  INSERT INTO document VALUES (4, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
! ERROR:  new row violates row-level security policy (USING expression) for table "document"
  -- Fails, since ALL WCO are enforced:
  INSERT INTO document VALUES (1, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET dauthor = 'regress_rls_carol';
! ERROR:  new row violates row-level security policy for table "document"
  --
  -- ROLE/GROUP
  --
--- 1767,1793 ----
  CREATE POLICY p3_with_all ON document FOR ALL
    USING (cid = (SELECT cid from category WHERE cname = 'novel'))
    WITH CHECK (dauthor = current_user);
+ ERROR:  relation "document" does not exist
  SET SESSION AUTHORIZATION regress_rls_bob;
  -- Fails, since ALL WCO is enforced in insert path:
  INSERT INTO document VALUES (80, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (80, (SELECT cid from category W...
!                     ^
  -- Fails, since ALL policy USING qual is enforced (existing, target tuple is in
  -- violation, since it has the "manga" cid):
  INSERT INTO document VALUES (4, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (4, (SELECT cid from category WH...
!                     ^
  -- Fails, since ALL WCO are enforced:
  INSERT INTO document VALUES (1, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
      ON CONFLICT (did) DO UPDATE SET dauthor = 'regress_rls_carol';
! ERROR:  relation "document" does not exist
! LINE 1: INSERT INTO document VALUES (1, (SELECT cid from category WH...
!                     ^
  --
  -- ROLE/GROUP
  --
***************
*** 2557,2563 ****
                 Filter: f_leak(abc)
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: b
                       ->  Seq Scan on y2
                             Filter: (((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0))
  (10 rows)
--- 2338,2344 ----
                 Filter: f_leak(abc)
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: b
                       ->  Seq Scan on y2
                             Filter: (((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0))
  (10 rows)
***************
*** 2576,2582 ****
           ->  Seq Scan on test_qual_pushdown
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: b
                       ->  Seq Scan on y2
                             Filter: ((((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0)) AND f_leak(b))
  (9 rows)
--- 2357,2363 ----
           ->  Seq Scan on test_qual_pushdown
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: b
                       ->  Seq Scan on y2
                             Filter: ((((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0)) AND f_leak(b))
  (9 rows)
***************
*** 2683,2689 ****
  --
  RESET SESSION AUTHORIZATION;
  ALTER POLICY p1 ON t1 RENAME TO p1; --fail
! ERROR:  policy "p1" for table "t1" already exists
  SELECT polname, relname
      FROM pg_policy pol
      JOIN pg_class pc ON (pc.oid = pol.polrelid)
--- 2464,2470 ----
  --
  RESET SESSION AUTHORIZATION;
  ALTER POLICY p1 ON t1 RENAME TO p1; --fail
! ERROR:  node:datanode_2, backend_pid:383284, nodename:coord2,backend_pid:383274,message:policy "p1" for table "t1" already exists
  SELECT polname, relname
      FROM pg_policy pol
      JOIN pg_class pc ON (pc.oid = pol.polrelid)
***************
*** 3448,3454 ****
  
  -- r2 is read-only
  INSERT INTO r2 VALUES (2); -- Not allowed
! ERROR:  new row violates row-level security policy for table "r2"
  UPDATE r2 SET a = 2 RETURNING *; -- Updates nothing
   a 
  ---
--- 3229,3235 ----
  
  -- r2 is read-only
  INSERT INTO r2 VALUES (2); -- Not allowed
! ERROR:  node:datanode_2, backend_pid:383284, nodename:datanode_1,backend_pid:383283,message:new row violates row-level security policy for table "r2"
  UPDATE r2 SET a = 2 RETURNING *; -- Updates nothing
   a 
  ---
***************
*** 3516,3522 ****
  
  -- RLS error
  INSERT INTO r1 VALUES (1);
! ERROR:  new row violates row-level security policy for table "r1"
  -- No error (unable to see any rows to update)
  UPDATE r1 SET a = 1;
  TABLE r1;
--- 3297,3303 ----
  
  -- RLS error
  INSERT INTO r1 VALUES (1);
! ERROR:  node:datanode_2, backend_pid:383284, nodename:datanode_1,backend_pid:383283,message:new row violates row-level security policy for table "r1"
  -- No error (unable to see any rows to update)
  UPDATE r1 SET a = 1;
  TABLE r1;
***************
*** 3550,3573 ****
  SET row_security = on;
  CREATE TABLE r1 (a int PRIMARY KEY);
  CREATE TABLE r2 (a int REFERENCES r1);
  INSERT INTO r1 VALUES (10), (20);
  INSERT INTO r2 VALUES (10), (20);
  -- Create policies on r2 which prevent the
  -- owner from seeing any rows, but RI should
  -- still see them.
  CREATE POLICY p1 ON r2 USING (false);
  ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
  ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
  -- Errors due to rows in r2
  DELETE FROM r1;
- ERROR:  update or delete on table "r1" violates foreign key constraint "r2_a_fkey" on table "r2"
- DETAIL:  Key (a)=(10) is still referenced from table "r2".
  -- Reset r2 to no-RLS
  DROP POLICY p1 ON r2;
  ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
  ALTER TABLE r2 DISABLE ROW LEVEL SECURITY;
  -- clean out r2 for INSERT test below
  DELETE FROM r2;
  -- Change r1 to not allow rows to be seen
  CREATE POLICY p1 ON r1 USING (false);
  ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
--- 3331,3365 ----
  SET row_security = on;
  CREATE TABLE r1 (a int PRIMARY KEY);
  CREATE TABLE r2 (a int REFERENCES r1);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  INSERT INTO r1 VALUES (10), (20);
  INSERT INTO r2 VALUES (10), (20);
+ ERROR:  relation "r2" does not exist
+ LINE 1: INSERT INTO r2 VALUES (10), (20);
+                     ^
  -- Create policies on r2 which prevent the
  -- owner from seeing any rows, but RI should
  -- still see them.
  CREATE POLICY p1 ON r2 USING (false);
+ ERROR:  relation "r2" does not exist
  ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
+ ERROR:  relation "r2" does not exist
  ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
+ ERROR:  relation "r2" does not exist
  -- Errors due to rows in r2
  DELETE FROM r1;
  -- Reset r2 to no-RLS
  DROP POLICY p1 ON r2;
+ ERROR:  relation "r2" does not exist
  ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
+ ERROR:  relation "r2" does not exist
  ALTER TABLE r2 DISABLE ROW LEVEL SECURITY;
+ ERROR:  relation "r2" does not exist
  -- clean out r2 for INSERT test below
  DELETE FROM r2;
+ ERROR:  relation "r2" does not exist
+ LINE 1: DELETE FROM r2;
+                     ^
  -- Change r1 to not allow rows to be seen
  CREATE POLICY p1 ON r1 USING (false);
  ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
***************
*** 3580,3636 ****
  
  -- No error, RI still sees that row exists in r1
  INSERT INTO r2 VALUES (10);
  DROP TABLE r2;
  DROP TABLE r1;
  -- Ensure cascaded DELETE works
  CREATE TABLE r1 (a int PRIMARY KEY);
  CREATE TABLE r2 (a int REFERENCES r1 ON DELETE CASCADE);
  INSERT INTO r1 VALUES (10), (20);
  INSERT INTO r2 VALUES (10), (20);
  -- Create policies on r2 which prevent the
  -- owner from seeing any rows, but RI should
  -- still see them.
  CREATE POLICY p1 ON r2 USING (false);
  ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
  ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
  -- Deletes all records from both
  DELETE FROM r1;
  -- Remove FORCE from r2
  ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
  -- As owner, we now bypass RLS
  -- verify no rows in r2 now
  TABLE r2;
!  a 
! ---
! (0 rows)
! 
  DROP TABLE r2;
  DROP TABLE r1;
  -- Ensure cascaded UPDATE works
  CREATE TABLE r1 (a int PRIMARY KEY) DISTRIBUTE BY REPLICATION;
  CREATE TABLE r2 (a int REFERENCES r1 ON UPDATE CASCADE);
  INSERT INTO r1 VALUES (10), (20);
  INSERT INTO r2 VALUES (10), (20);
  -- Create policies on r2 which prevent the
  -- owner from seeing any rows, but RI should
  -- still see them.
  CREATE POLICY p1 ON r2 USING (false);
  ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
  ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
  -- Updates records in both
  UPDATE r1 SET a = a+5;
  -- Remove FORCE from r2
  ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
  -- As owner, we now bypass RLS
  -- verify records in r2 updated
  TABLE r2;
!  a  
! ----
!  15
!  25
! (2 rows)
! 
  DROP TABLE r2;
  DROP TABLE r1;
  --
  -- Test INSERT+RETURNING applies SELECT policies as
--- 3372,3446 ----
  
  -- No error, RI still sees that row exists in r1
  INSERT INTO r2 VALUES (10);
+ ERROR:  relation "r2" does not exist
+ LINE 1: INSERT INTO r2 VALUES (10);
+                     ^
  DROP TABLE r2;
+ ERROR:  table "r2" does not exist
  DROP TABLE r1;
  -- Ensure cascaded DELETE works
  CREATE TABLE r1 (a int PRIMARY KEY);
  CREATE TABLE r2 (a int REFERENCES r1 ON DELETE CASCADE);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  INSERT INTO r1 VALUES (10), (20);
  INSERT INTO r2 VALUES (10), (20);
+ ERROR:  relation "r2" does not exist
+ LINE 1: INSERT INTO r2 VALUES (10), (20);
+                     ^
  -- Create policies on r2 which prevent the
  -- owner from seeing any rows, but RI should
  -- still see them.
  CREATE POLICY p1 ON r2 USING (false);
+ ERROR:  relation "r2" does not exist
  ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
+ ERROR:  relation "r2" does not exist
  ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
+ ERROR:  relation "r2" does not exist
  -- Deletes all records from both
  DELETE FROM r1;
  -- Remove FORCE from r2
  ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
+ ERROR:  relation "r2" does not exist
  -- As owner, we now bypass RLS
  -- verify no rows in r2 now
  TABLE r2;
! ERROR:  relation "r2" does not exist
! LINE 1: TABLE r2;
!               ^
  DROP TABLE r2;
+ ERROR:  table "r2" does not exist
  DROP TABLE r1;
  -- Ensure cascaded UPDATE works
  CREATE TABLE r1 (a int PRIMARY KEY) DISTRIBUTE BY REPLICATION;
  CREATE TABLE r2 (a int REFERENCES r1 ON UPDATE CASCADE);
+ ERROR:  corrupted catalog, no shard group of 0 found
  INSERT INTO r1 VALUES (10), (20);
  INSERT INTO r2 VALUES (10), (20);
+ ERROR:  relation "r2" does not exist
+ LINE 1: INSERT INTO r2 VALUES (10), (20);
+                     ^
  -- Create policies on r2 which prevent the
  -- owner from seeing any rows, but RI should
  -- still see them.
  CREATE POLICY p1 ON r2 USING (false);
+ ERROR:  relation "r2" does not exist
  ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
+ ERROR:  relation "r2" does not exist
  ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
+ ERROR:  relation "r2" does not exist
  -- Updates records in both
  UPDATE r1 SET a = a+5;
  -- Remove FORCE from r2
  ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
+ ERROR:  relation "r2" does not exist
  -- As owner, we now bypass RLS
  -- verify records in r2 updated
  TABLE r2;
! ERROR:  relation "r2" does not exist
! LINE 1: TABLE r2;
!               ^
  DROP TABLE r2;
+ ERROR:  table "r2" does not exist
  DROP TABLE r1;
  --
  -- Test INSERT+RETURNING applies SELECT policies as
***************
*** 3645,3650 ****
--- 3455,3462 ----
  ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
  -- Works fine
  INSERT INTO r1 VALUES (10), (20);
+ ERROR:  COPY FROM not supported with row-level security
+ HINT:  Use INSERT statements instead.
  -- No error, but no rows
  TABLE r1;
   a 
***************
*** 3659,3665 ****
  SET row_security = on;
  -- Error
  INSERT INTO r1 VALUES (10), (20) RETURNING *;
! ERROR:  new row violates row-level security policy for table "r1"
  DROP TABLE r1;
  --
  -- Test UPDATE+RETURNING applies SELECT policies as
--- 3471,3477 ----
  SET row_security = on;
  -- Error
  INSERT INTO r1 VALUES (10), (20) RETURNING *;
! ERROR:  node:datanode_2, backend_pid:383286, nodename:datanode_2,backend_pid:383286,message:new row violates row-level security policy for table "r1"
  DROP TABLE r1;
  --
  -- Test UPDATE+RETURNING applies SELECT policies as
***************
*** 3695,3701 ****
  ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
  -- Error
  UPDATE r1 SET a = 30 RETURNING *;
! ERROR:  new row violates row-level security policy for table "r1"
  DROP TABLE r1;
  -- Check dependency handling
  RESET SESSION AUTHORIZATION;
--- 3507,3513 ----
  ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
  -- Error
  UPDATE r1 SET a = 30 RETURNING *;
! ERROR:  node:datanode_2, backend_pid:383286, nodename:datanode_1,backend_pid:383287,message:new row violates row-level security policy for table "r1"
  DROP TABLE r1;
  -- Check dependency handling
  RESET SESSION AUTHORIZATION;
***************
*** 3764,3770 ****
  RESET SESSION AUTHORIZATION;
  \set VERBOSITY terse \\ -- suppress cascade details
  DROP SCHEMA regress_rls_schema CASCADE;
! NOTICE:  drop cascades to 29 other objects
  \set VERBOSITY default
  DROP USER regress_rls_alice;
  DROP USER regress_rls_bob;
--- 3576,3582 ----
  RESET SESSION AUTHORIZATION;
  \set VERBOSITY terse \\ -- suppress cascade details
  DROP SCHEMA regress_rls_schema CASCADE;
! NOTICE:  drop cascades to 28 other objects
  \set VERBOSITY default
  DROP USER regress_rls_alice;
  DROP USER regress_rls_bob;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/object_address.out"	2025-07-31 16:07:14.993068009 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/object_address.out"	2025-07-31 16:39:35.411952852 +0800
***************
*** 28,35 ****
  CREATE DOMAIN addr_nsp.gendomain AS int4 CONSTRAINT domconstr CHECK (value > 0);
  CREATE FUNCTION addr_nsp.trig() RETURNS TRIGGER LANGUAGE plpgsql AS $$ BEGIN END; $$;
  CREATE TRIGGER t BEFORE INSERT ON addr_nsp.gentable FOR EACH ROW EXECUTE PROCEDURE addr_nsp.trig();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  CREATE POLICY genpol ON addr_nsp.gentable;
  CREATE SERVER "integer" FOREIGN DATA WRAPPER addr_fdw;
  CREATE USER MAPPING FOR regress_addr_user SERVER "integer";
--- 28,33 ----

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/tablesample_1.out"	2025-07-31 16:07:15.004067834 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/tablesample.out"	2025-07-31 16:39:32.702010592 +0800
***************
*** 250,256 ****
           ->  Sort
                 Sort Key: "*VALUES*".column1
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: column1
                       ->  Partial HashAggregate
                             Group Key: "*VALUES*".column1
                             ->  Nested Loop
--- 250,256 ----
           ->  Sort
                 Sort Key: "*VALUES*".column1
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: column1
                       ->  Partial HashAggregate
                             Group Key: "*VALUES*".column1
                             ->  Nested Loop
***************
*** 283,299 ****
  LINE 1: SELECT id FROM test_tablesample TABLESAMPLE FOOBAR (1);
                                                      ^
  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (NULL);
! ERROR:  TABLESAMPLE parameter cannot be null
  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (NULL);
! ERROR:  TABLESAMPLE REPEATABLE parameter cannot be null
  SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (-1);
! ERROR:  sample percentage must be between 0 and 100
  SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (200);
! ERROR:  sample percentage must be between 0 and 100
  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (-1);
! ERROR:  sample percentage must be between 0 and 100
  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (200);
! ERROR:  sample percentage must be between 0 and 100
  SELECT id FROM test_tablesample_v1 TABLESAMPLE BERNOULLI (1);
  ERROR:  TABLESAMPLE clause can only be applied to tables and materialized views
  LINE 1: SELECT id FROM test_tablesample_v1 TABLESAMPLE BERNOULLI (1)...
--- 283,299 ----
  LINE 1: SELECT id FROM test_tablesample TABLESAMPLE FOOBAR (1);
                                                      ^
  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (NULL);
! ERROR:  node:datanode_2, backend_pid:383284, nodename:datanode_1,backend_pid:383266,message:TABLESAMPLE parameter cannot be null
  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (NULL);
! ERROR:  node:datanode_2, backend_pid:383284, nodename:datanode_1,backend_pid:383266,message:TABLESAMPLE REPEATABLE parameter cannot be null
  SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (-1);
! ERROR:  node:datanode_2, backend_pid:383267, nodename:datanode_1,backend_pid:383366,message:sample percentage must be between 0 and 100
  SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (200);
! ERROR:  node:datanode_2, backend_pid:383267, nodename:datanode_2,backend_pid:383267,message:sample percentage must be between 0 and 100
  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (-1);
! ERROR:  node:datanode_2, backend_pid:383284, nodename:datanode_1,backend_pid:383266,message:sample percentage must be between 0 and 100
  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (200);
! ERROR:  node:datanode_2, backend_pid:383284, nodename:datanode_1,backend_pid:383266,message:sample percentage must be between 0 and 100
  SELECT id FROM test_tablesample_v1 TABLESAMPLE BERNOULLI (1);
  ERROR:  TABLESAMPLE clause can only be applied to tables and materialized views
  LINE 1: SELECT id FROM test_tablesample_v1 TABLESAMPLE BERNOULLI (1)...

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/alter_generic.out"	2025-07-31 16:07:14.977847998 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/alter_generic.out"	2025-07-31 16:39:41.451824266 +0800
***************
*** 29,35 ****
    sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = 0
  );
  ALTER AGGREGATE alt_func1(int) RENAME TO alt_func3;  -- failed (not aggregate)
! ERROR:  function alt_func1(integer) is not an aggregate
  ALTER AGGREGATE alt_func1(int) OWNER TO regress_alter_user3;  -- failed (not aggregate)
  ERROR:  function alt_func1(integer) is not an aggregate
  ALTER AGGREGATE alt_func1(int) SET SCHEMA alt_nsp2;  -- failed (not aggregate)
--- 29,35 ----
    sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = 0
  );
  ALTER AGGREGATE alt_func1(int) RENAME TO alt_func3;  -- failed (not aggregate)
! ERROR:  node:datanode_2, backend_pid:383292, nodename:coord2,backend_pid:383264,message:function alt_func1(integer) is not an aggregate
  ALTER AGGREGATE alt_func1(int) OWNER TO regress_alter_user3;  -- failed (not aggregate)
  ERROR:  function alt_func1(integer) is not an aggregate
  ALTER AGGREGATE alt_func1(int) SET SCHEMA alt_nsp2;  -- failed (not aggregate)
***************
*** 43,49 ****
  ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp1;  -- OK, already there
  ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;  -- OK
  ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg2;   -- failed (name conflict)
! ERROR:  function alt_agg2(integer) already exists in schema "alt_nsp1"
  ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg3;   -- OK
  ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
--- 43,49 ----
  ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp1;  -- OK, already there
  ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;  -- OK
  ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg2;   -- failed (name conflict)
! ERROR:  node:datanode_2, backend_pid:383286, nodename:coord2,backend_pid:383262,message:function alt_agg2(integer) already exists in schema "alt_nsp1"
  ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg3;   -- OK
  ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
***************
*** 72,78 ****
  ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;	-- failed (name conflicts)
  ERROR:  function alt_func2(integer) already exists in schema "alt_nsp2"
  ALTER AGGREGATE alt_agg3(int) RENAME TO alt_agg4;   -- failed (not owner)
! ERROR:  must be owner of function alt_agg3
  ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg4;   -- OK
  ALTER AGGREGATE alt_agg3(int) OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of function alt_agg3
--- 72,78 ----
  ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;	-- failed (name conflicts)
  ERROR:  function alt_func2(integer) already exists in schema "alt_nsp2"
  ALTER AGGREGATE alt_agg3(int) RENAME TO alt_agg4;   -- failed (not owner)
! ERROR:  node:datanode_1, backend_pid:383271, nodename:coord2,backend_pid:383342,message:must be owner of function alt_agg3
  ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg4;   -- OK
  ALTER AGGREGATE alt_agg3(int) OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of function alt_agg3
***************
*** 111,117 ****
  CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
  CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
  ALTER CONVERSION alt_conv1 RENAME TO alt_conv2;  -- failed (name conflict)
! ERROR:  conversion "alt_conv2" already exists in schema "alt_nsp1"
  ALTER CONVERSION alt_conv1 RENAME TO alt_conv3;  -- OK
  ALTER CONVERSION alt_conv2 OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
--- 111,117 ----
  CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
  CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
  ALTER CONVERSION alt_conv1 RENAME TO alt_conv2;  -- failed (name conflict)
! ERROR:  node:datanode_1, backend_pid:383271, nodename:coord2,backend_pid:383262,message:conversion "alt_conv2" already exists in schema "alt_nsp1"
  ALTER CONVERSION alt_conv1 RENAME TO alt_conv3;  -- OK
  ALTER CONVERSION alt_conv2 OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
***************
*** 121,127 ****
  CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
  CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
  ALTER CONVERSION alt_conv3 RENAME TO alt_conv4;  -- failed (not owner)
! ERROR:  must be owner of conversion alt_conv3
  ALTER CONVERSION alt_conv1 RENAME TO alt_conv4;  -- OK
  ALTER CONVERSION alt_conv3 OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of conversion alt_conv3
--- 121,127 ----
  CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
  CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
  ALTER CONVERSION alt_conv3 RENAME TO alt_conv4;  -- failed (not owner)
! ERROR:  node:datanode_2, backend_pid:383284, nodename:coord2,backend_pid:383262,message:must be owner of conversion alt_conv3
  ALTER CONVERSION alt_conv1 RENAME TO alt_conv4;  -- OK
  ALTER CONVERSION alt_conv3 OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of conversion alt_conv3
***************
*** 153,162 ****
  CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1;
  CREATE SERVER alt_fserv2 FOREIGN DATA WRAPPER alt_fdw2;
  ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;  -- failed (name conflict)
! ERROR:  foreign-data wrapper "alt_fdw2" already exists
  ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw3;  -- OK
  ALTER SERVER alt_fserv1 RENAME TO alt_fserv2;   -- failed (name conflict)
! ERROR:  server "alt_fserv2" already exists
  ALTER SERVER alt_fserv1 RENAME TO alt_fserv3;   -- OK
  SELECT fdwname FROM pg_foreign_data_wrapper WHERE fdwname like 'alt_fdw%';
   fdwname  
--- 153,162 ----
  CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1;
  CREATE SERVER alt_fserv2 FOREIGN DATA WRAPPER alt_fdw2;
  ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;  -- failed (name conflict)
! ERROR:  node:datanode_2, backend_pid:383286, nodename:coord2,backend_pid:383341,message:foreign-data wrapper "alt_fdw2" already exists
  ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw3;  -- OK
  ALTER SERVER alt_fserv1 RENAME TO alt_fserv2;   -- failed (name conflict)
! ERROR:  node:datanode_2, backend_pid:383292, nodename:coord2,backend_pid:383341,message:server "alt_fserv2" already exists
  ALTER SERVER alt_fserv1 RENAME TO alt_fserv3;   -- OK
  SELECT fdwname FROM pg_foreign_data_wrapper WHERE fdwname like 'alt_fdw%';
   fdwname  
***************
*** 181,189 ****
  ALTER LANGUAGE alt_lang2 OWNER TO regress_alter_user2;  -- OK
  SET SESSION AUTHORIZATION regress_alter_user1;
  ALTER LANGUAGE alt_lang1 RENAME TO alt_lang2;   -- failed (name conflict)
! ERROR:  language "alt_lang2" already exists
  ALTER LANGUAGE alt_lang2 RENAME TO alt_lang3;   -- failed (not owner)
! ERROR:  must be owner of language alt_lang2
  ALTER LANGUAGE alt_lang1 RENAME TO alt_lang3;   -- OK
  ALTER LANGUAGE alt_lang2 OWNER TO regress_alter_user3;  -- failed (not owner)
  ERROR:  must be owner of language alt_lang2
--- 181,189 ----
  ALTER LANGUAGE alt_lang2 OWNER TO regress_alter_user2;  -- OK
  SET SESSION AUTHORIZATION regress_alter_user1;
  ALTER LANGUAGE alt_lang1 RENAME TO alt_lang2;   -- failed (name conflict)
! ERROR:  node:datanode_1, backend_pid:383343, nodename:coord2,backend_pid:383265,message:language "alt_lang2" already exists
  ALTER LANGUAGE alt_lang2 RENAME TO alt_lang3;   -- failed (not owner)
! ERROR:  node:datanode_2, backend_pid:383284, nodename:coord2,backend_pid:383265,message:must be owner of language alt_lang2
  ALTER LANGUAGE alt_lang1 RENAME TO alt_lang3;   -- OK
  ALTER LANGUAGE alt_lang2 OWNER TO regress_alter_user3;  -- failed (not owner)
  ERROR:  must be owner of language alt_lang2
***************
*** 248,261 ****
  ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_user1;
  SET SESSION AUTHORIZATION regress_alter_user1;
  ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf2;  -- failed (name conflict)
! ERROR:  operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp1"
  ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf3;  -- OK
  ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
  ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_user3;  -- OK
  ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- OK
  ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc2;  -- failed (name conflict)
! ERROR:  operator class "alt_opc2" for access method "hash" already exists in schema "alt_nsp1"
  ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc3;  -- OK
  ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
--- 248,261 ----
  ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_user1;
  SET SESSION AUTHORIZATION regress_alter_user1;
  ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf2;  -- failed (name conflict)
! ERROR:  node:datanode_2, backend_pid:383286, nodename:coord2,backend_pid:383265,message:operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp1"
  ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf3;  -- OK
  ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
  ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_user3;  -- OK
  ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- OK
  ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc2;  -- failed (name conflict)
! ERROR:  node:datanode_2, backend_pid:383284, nodename:coord2,backend_pid:383265,message:operator class "alt_opc2" for access method "hash" already exists in schema "alt_nsp1"
  ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc3;  -- OK
  ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
***************
*** 272,278 ****
  ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_user2;
  SET SESSION AUTHORIZATION regress_alter_user2;
  ALTER OPERATOR FAMILY alt_opf3 USING hash RENAME TO alt_opf4;	-- failed (not owner)
! ERROR:  must be owner of operator family alt_opf3
  ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf4;  -- OK
  ALTER OPERATOR FAMILY alt_opf3 USING hash OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of operator family alt_opf3
--- 272,278 ----
  ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_user2;
  SET SESSION AUTHORIZATION regress_alter_user2;
  ALTER OPERATOR FAMILY alt_opf3 USING hash RENAME TO alt_opf4;	-- failed (not owner)
! ERROR:  node:datanode_2, backend_pid:383284, nodename:coord2,backend_pid:383265,message:must be owner of operator family alt_opf3
  ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf4;  -- OK
  ALTER OPERATOR FAMILY alt_opf3 USING hash OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of operator family alt_opf3
***************
*** 283,289 ****
  ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- failed (name conflict)
  ERROR:  operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp2"
  ALTER OPERATOR CLASS alt_opc3 USING hash RENAME TO alt_opc4;	-- failed (not owner)
! ERROR:  must be owner of operator class alt_opc3
  ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc4;  -- OK
  ALTER OPERATOR CLASS alt_opc3 USING hash OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of operator class alt_opc3
--- 283,289 ----
  ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- failed (name conflict)
  ERROR:  operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp2"
  ALTER OPERATOR CLASS alt_opc3 USING hash RENAME TO alt_opc4;	-- failed (not owner)
! ERROR:  node:datanode_2, backend_pid:383292, nodename:coord2,backend_pid:383265,message:must be owner of operator class alt_opc3
  ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc4;  -- OK
  ALTER OPERATOR CLASS alt_opc3 USING hash OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of operator class alt_opc3
***************
*** 504,510 ****
  CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_1;
  CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_1;
  ALTER STATISTICS alt_stat1 RENAME TO alt_stat2;   -- failed (name conflict)
! ERROR:  statistics object "alt_stat2" already exists in schema "alt_nsp1"
  ALTER STATISTICS alt_stat1 RENAME TO alt_stat3;   -- failed (name conflict)
  ALTER STATISTICS alt_stat2 OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
--- 504,510 ----
  CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_1;
  CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_1;
  ALTER STATISTICS alt_stat1 RENAME TO alt_stat2;   -- failed (name conflict)
! ERROR:  node:datanode_2, backend_pid:383292, nodename:coord2,backend_pid:383341,message:statistics object "alt_stat2" already exists in schema "alt_nsp1"
  ALTER STATISTICS alt_stat1 RENAME TO alt_stat3;   -- failed (name conflict)
  ALTER STATISTICS alt_stat2 OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
***************
*** 515,521 ****
  CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_2;
  CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_2;
  ALTER STATISTICS alt_stat3 RENAME TO alt_stat4;    -- failed (not owner)
! ERROR:  must be owner of statistics object alt_stat3
  ALTER STATISTICS alt_stat1 RENAME TO alt_stat4;    -- OK
  ALTER STATISTICS alt_stat3 OWNER TO regress_alter_user2; -- failed (not owner)
  ERROR:  must be owner of statistics object alt_stat3
--- 515,521 ----
  CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_2;
  CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_2;
  ALTER STATISTICS alt_stat3 RENAME TO alt_stat4;    -- failed (not owner)
! ERROR:  node:datanode_2, backend_pid:383284, nodename:coord2,backend_pid:383265,message:must be owner of statistics object alt_stat3
  ALTER STATISTICS alt_stat1 RENAME TO alt_stat4;    -- OK
  ALTER STATISTICS alt_stat3 OWNER TO regress_alter_user2; -- failed (not owner)
  ERROR:  must be owner of statistics object alt_stat3
***************
*** 546,552 ****
  CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
  CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict2;  -- failed (name conflict)
! ERROR:  text search dictionary "alt_ts_dict2" already exists in schema "alt_nsp1"
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict3;  -- OK
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
--- 546,552 ----
  CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
  CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict2;  -- failed (name conflict)
! ERROR:  node:datanode_2, backend_pid:383292, nodename:coord2,backend_pid:383262,message:text search dictionary "alt_ts_dict2" already exists in schema "alt_nsp1"
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict3;  -- OK
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
***************
*** 556,562 ****
  CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
  CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 RENAME TO alt_ts_dict4;  -- failed (not owner)
! ERROR:  must be owner of text search dictionary alt_ts_dict3
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict4;  -- OK
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of text search dictionary alt_ts_dict3
--- 556,562 ----
  CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
  CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 RENAME TO alt_ts_dict4;  -- failed (not owner)
! ERROR:  node:datanode_2, backend_pid:383284, nodename:coord2,backend_pid:383262,message:must be owner of text search dictionary alt_ts_dict3
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict4;  -- OK
  ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of text search dictionary alt_ts_dict3
***************
*** 587,593 ****
  CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
  CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf2;  -- failed (name conflict)
! ERROR:  text search configuration "alt_ts_conf2" already exists in schema "alt_nsp1"
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf3;  -- OK
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
--- 587,593 ----
  CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
  CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf2;  -- failed (name conflict)
! ERROR:  node:datanode_2, backend_pid:383292, nodename:coord2,backend_pid:383262,message:text search configuration "alt_ts_conf2" already exists in schema "alt_nsp1"
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf3;  -- OK
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_user2;  -- failed (no role membership)
  ERROR:  must be member of role "regress_alter_user2"
***************
*** 597,603 ****
  CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
  CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 RENAME TO alt_ts_conf4;  -- failed (not owner)
! ERROR:  must be owner of text search configuration alt_ts_conf3
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf4;  -- OK
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of text search configuration alt_ts_conf3
--- 597,603 ----
  CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
  CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 RENAME TO alt_ts_conf4;  -- failed (not owner)
! ERROR:  node:datanode_1, backend_pid:383343, nodename:coord2,backend_pid:383262,message:must be owner of text search configuration alt_ts_conf3
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf4;  -- OK
  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 OWNER TO regress_alter_user2;  -- failed (not owner)
  ERROR:  must be owner of text search configuration alt_ts_conf3
***************
*** 627,633 ****
  CREATE TEXT SEARCH TEMPLATE alt_ts_temp1 (lexize=dsimple_lexize);
  CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
  ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp2; -- failed (name conflict)
! ERROR:  text search template "alt_ts_temp2" already exists in schema "alt_nsp1"
  ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp3; -- OK
  ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;    -- OK
  CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
--- 627,633 ----
  CREATE TEXT SEARCH TEMPLATE alt_ts_temp1 (lexize=dsimple_lexize);
  CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
  ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp2; -- failed (name conflict)
! ERROR:  node:datanode_2, backend_pid:383292, nodename:coord2,backend_pid:383262,message:text search template "alt_ts_temp2" already exists in schema "alt_nsp1"
  ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp3; -- OK
  ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;    -- OK
  CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
***************
*** 652,658 ****
  CREATE TEXT SEARCH PARSER alt_ts_prs2
      (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
  ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs2; -- failed (name conflict)
! ERROR:  text search parser "alt_ts_prs2" already exists in schema "alt_nsp1"
  ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs3; -- OK
  ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;   -- OK
  CREATE TEXT SEARCH PARSER alt_ts_prs2
--- 652,658 ----
  CREATE TEXT SEARCH PARSER alt_ts_prs2
      (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
  ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs2; -- failed (name conflict)
! ERROR:  node:datanode_2, backend_pid:383292, nodename:coord2,backend_pid:383262,message:text search parser "alt_ts_prs2" already exists in schema "alt_nsp1"
  ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs3; -- OK
  ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;   -- OK
  CREATE TEXT SEARCH PARSER alt_ts_prs2

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/misc.out"	2025-07-31 16:37:23.180862898 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/misc.out"	2025-07-31 16:39:39.901857250 +0800
***************
*** 29,40 ****
--- 29,47 ----
     FROM onek
     WHERE onek.stringu1 = 'JBAAAA' and
  	  onek.stringu1 = tmp.stringu1;
+ ERROR:  relation "tmp" does not exist
+ LINE 1: UPDATE tmp
+                ^
  UPDATE tmp
     SET stringu1 = reverse_name(onek2.stringu1)
     FROM onek2
     WHERE onek2.stringu1 = 'JCAAAA' and
  	  onek2.stringu1 = tmp.stringu1;
+ ERROR:  relation "tmp" does not exist
+ LINE 1: UPDATE tmp
+                ^
  DROP TABLE tmp;
+ ERROR:  table "tmp" does not exist
  --UPDATE person*
  --   SET age = age + 1;
  --UPDATE person*

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/sysviews.out"	2025-07-31 16:07:15.004067834 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/sysviews.out"	2025-07-31 16:39:39.459866658 +0800
***************
*** 82,110 ****
   enable_audit_warning              | off
   enable_auditlogger_warning        | off
   enable_bitmapscan                 | on
!  enable_buffer_mprotect            | on
   enable_check_password             | off
   enable_clean_2pc_launcher         | on
!  enable_clog_mprotect              | on
!  enable_cls                        | on
   enable_cold_hot_router_print      | off
   enable_cold_hot_visible           | off
   enable_cold_seperation            | off
   enable_committs_print             | off
!  enable_concurrently_index         | off
   enable_copy_silence               | off
   enable_crypt_check                | off
!  enable_crypt_debug                | on
   enable_crypt_parellel_debug       | off
   enable_data_mask                  | on
   enable_datanode_row_triggers      | off
!  enable_distinct_optimizer         | on
   enable_distri_debug               | off
   enable_distri_debug_print         | off
   enable_distri_visibility_print    | off
   enable_distributed_unique_plan    | on
   enable_fast_query_shipping        | on
!  enable_fga                        | on
   enable_gathermerge                | on
   enable_gtm_debug_print            | off
   enable_gtm_proxy                  | off
--- 82,110 ----
   enable_audit_warning              | off
   enable_auditlogger_warning        | off
   enable_bitmapscan                 | on
!  enable_buffer_mprotect            | off
   enable_check_password             | off
   enable_clean_2pc_launcher         | on
!  enable_clog_mprotect              | off
!  enable_cls                        | off
   enable_cold_hot_router_print      | off
   enable_cold_hot_visible           | off
   enable_cold_seperation            | off
   enable_committs_print             | off
!  enable_concurrently_index         | on
   enable_copy_silence               | off
   enable_crypt_check                | off
!  enable_crypt_debug                | off
   enable_crypt_parellel_debug       | off
   enable_data_mask                  | on
   enable_datanode_row_triggers      | off
!  enable_distinct_optimizer         | off
   enable_distri_debug               | off
   enable_distri_debug_print         | off
   enable_distri_visibility_print    | off
   enable_distributed_unique_plan    | on
   enable_fast_query_shipping        | on
!  enable_fga                        | off
   enable_gathermerge                | on
   enable_gtm_debug_print            | off
   enable_gtm_proxy                  | off
***************
*** 115,121 ****
   enable_key_value                  | off
   enable_lock_account               | off
   enable_material                   | on
!  enable_memory_optimization        | on
   enable_mergejoin                  | on
   enable_multi_cluster              | on
   enable_multi_cluster_print        | off
--- 115,121 ----
   enable_key_value                  | off
   enable_lock_account               | off
   enable_material                   | on
!  enable_memory_optimization        | off
   enable_mergejoin                  | on
   enable_multi_cluster              | on
   enable_multi_cluster_print        | off
***************
*** 130,136 ****
   enable_pooler_debug_print         | on
   enable_pooler_stuck_exit          | off
   enable_pooler_thread_log_print    | on
!  enable_pullup_subquery            | on
   enable_replication_slot_debug     | off
   enable_sampling_analyze           | on
   enable_seqscan                    | on
--- 130,136 ----
   enable_pooler_debug_print         | on
   enable_pooler_stuck_exit          | off
   enable_pooler_thread_log_print    | on
!  enable_pullup_subquery            | off
   enable_replication_slot_debug     | off
   enable_sampling_analyze           | on
   enable_seqscan                    | on
***************
*** 139,148 ****
   enable_statistic                  | on
   enable_subquery_shipping          | on
   enable_tidscan                    | on
!  enable_tlog_mprotect              | on
   enable_transparent_crypt          | on
   enable_user_authority_force_check | off
!  enable_xlog_mprotect              | on
  (71 rows)
  
  -- Test that the pg_timezone_names and pg_timezone_abbrevs views are
--- 139,148 ----
   enable_statistic                  | on
   enable_subquery_shipping          | on
   enable_tidscan                    | on
!  enable_tlog_mprotect              | off
   enable_transparent_crypt          | on
   enable_user_authority_force_check | off
!  enable_xlog_mprotect              | off
  (71 rows)
  
  -- Test that the pg_timezone_names and pg_timezone_abbrevs views are

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/stats_ext_2.out"	2025-07-31 16:07:15.003067850 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/stats_ext.out"	2025-07-31 16:39:41.997812648 +0800
***************
*** 32,73 ****
  ERROR:  unrecognized statistic type "unrecognized"
  -- Ensure stats are dropped sanely, and test IF NOT EXISTS while at it
  CREATE TABLE ab1 (a INTEGER, b INTEGER, c INTEGER) DISTRIBUTE BY HASH(c);
  CREATE STATISTICS IF NOT EXISTS ab1_a_b_stats ON a, b FROM ab1;
  CREATE STATISTICS IF NOT EXISTS ab1_a_b_stats ON a, b FROM ab1;
! NOTICE:  statistics object "ab1_a_b_stats" already exists, skipping
  DROP STATISTICS ab1_a_b_stats;
  CREATE SCHEMA regress_schema_2;
  CREATE STATISTICS regress_schema_2.ab1_a_b_stats ON a, b FROM ab1;
  -- Let's also verify the pg_get_statisticsobjdef output looks sane.
  SELECT pg_get_statisticsobjdef(oid) FROM pg_statistic_ext WHERE stxname = 'ab1_a_b_stats';
!                       pg_get_statisticsobjdef                      
! -------------------------------------------------------------------
!  CREATE STATISTICS regress_schema_2.ab1_a_b_stats ON a, b FROM ab1
! (1 row)
  
  DROP STATISTICS regress_schema_2.ab1_a_b_stats;
  -- Ensure statistics are dropped when columns are
  CREATE STATISTICS ab1_b_c_stats ON b, c FROM ab1;
  CREATE STATISTICS ab1_a_b_c_stats ON a, b, c FROM ab1;
  CREATE STATISTICS ab1_b_a_stats ON b, a FROM ab1;
  ALTER TABLE ab1 DROP COLUMN a;
  \d ab1
-                 Table "public.ab1"
-  Column |  Type   | Collation | Nullable | Default 
- --------+---------+-----------+----------+---------
-  b      | integer |           |          | 
-  c      | integer |           |          | 
- Statistics objects:
-     "public"."ab1_b_c_stats" (ndistinct, dependencies) ON b, c FROM ab1
- 
  -- Ensure statistics are dropped when table is
  SELECT stxname FROM pg_statistic_ext WHERE stxname LIKE 'ab1%';
!     stxname    
! ---------------
!  ab1_b_c_stats
! (1 row)
  
  DROP TABLE ab1;
  SELECT stxname FROM pg_statistic_ext WHERE stxname LIKE 'ab1%';
   stxname 
  ---------
--- 32,73 ----
  ERROR:  unrecognized statistic type "unrecognized"
  -- Ensure stats are dropped sanely, and test IF NOT EXISTS while at it
  CREATE TABLE ab1 (a INTEGER, b INTEGER, c INTEGER) DISTRIBUTE BY HASH(c);
+ ERROR:  Cannot support distribute type: Hash
  CREATE STATISTICS IF NOT EXISTS ab1_a_b_stats ON a, b FROM ab1;
+ ERROR:  relation "ab1" does not exist
  CREATE STATISTICS IF NOT EXISTS ab1_a_b_stats ON a, b FROM ab1;
! ERROR:  relation "ab1" does not exist
  DROP STATISTICS ab1_a_b_stats;
+ ERROR:  statistics object "ab1_a_b_stats" does not exist
  CREATE SCHEMA regress_schema_2;
  CREATE STATISTICS regress_schema_2.ab1_a_b_stats ON a, b FROM ab1;
+ ERROR:  relation "ab1" does not exist
  -- Let's also verify the pg_get_statisticsobjdef output looks sane.
  SELECT pg_get_statisticsobjdef(oid) FROM pg_statistic_ext WHERE stxname = 'ab1_a_b_stats';
!  pg_get_statisticsobjdef 
! -------------------------
! (0 rows)
  
  DROP STATISTICS regress_schema_2.ab1_a_b_stats;
+ ERROR:  statistics object "regress_schema_2.ab1_a_b_stats" does not exist
  -- Ensure statistics are dropped when columns are
  CREATE STATISTICS ab1_b_c_stats ON b, c FROM ab1;
+ ERROR:  relation "ab1" does not exist
  CREATE STATISTICS ab1_a_b_c_stats ON a, b, c FROM ab1;
+ ERROR:  relation "ab1" does not exist
  CREATE STATISTICS ab1_b_a_stats ON b, a FROM ab1;
+ ERROR:  relation "ab1" does not exist
  ALTER TABLE ab1 DROP COLUMN a;
+ ERROR:  relation "ab1" does not exist
  \d ab1
  -- Ensure statistics are dropped when table is
  SELECT stxname FROM pg_statistic_ext WHERE stxname LIKE 'ab1%';
!  stxname 
! ---------
! (0 rows)
  
  DROP TABLE ab1;
+ ERROR:  table "ab1" does not exist
  SELECT stxname FROM pg_statistic_ext WHERE stxname LIKE 'ab1%';
   stxname 
  ---------
***************
*** 180,186 ****
     ->  Finalize HashAggregate
           Group Key: a, b
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: a
                 ->  Partial HashAggregate
                       Group Key: a, b
                       ->  Seq Scan on ndistinct
--- 180,186 ----
     ->  Finalize HashAggregate
           Group Key: a, b
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: a
                 ->  Partial HashAggregate
                       Group Key: a, b
                       ->  Seq Scan on ndistinct
***************
*** 194,200 ****
     ->  Finalize HashAggregate
           Group Key: b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Group Key: b, c
                       ->  Seq Scan on ndistinct
--- 194,200 ----
     ->  Finalize HashAggregate
           Group Key: b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Group Key: b, c
                       ->  Seq Scan on ndistinct
***************
*** 208,214 ****
     ->  Finalize HashAggregate
           Group Key: a, b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: a
                 ->  Partial HashAggregate
                       Group Key: a, b, c
                       ->  Seq Scan on ndistinct
--- 208,214 ----
     ->  Finalize HashAggregate
           Group Key: a, b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: a
                 ->  Partial HashAggregate
                       Group Key: a, b, c
                       ->  Seq Scan on ndistinct
***************
*** 222,228 ****
     ->  Finalize HashAggregate
           Group Key: a, b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: a
                 ->  Partial HashAggregate
                       Group Key: a, b, c, d
                       ->  Seq Scan on ndistinct
--- 222,228 ----
     ->  Finalize HashAggregate
           Group Key: a, b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: a
                 ->  Partial HashAggregate
                       Group Key: a, b, c, d
                       ->  Seq Scan on ndistinct
***************
*** 236,242 ****
     ->  Finalize HashAggregate
           Group Key: b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Group Key: b, c, d
                       ->  Seq Scan on ndistinct
--- 236,242 ----
     ->  Finalize HashAggregate
           Group Key: b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Group Key: b, c, d
                       ->  Seq Scan on ndistinct
***************
*** 261,267 ****
     ->  Finalize HashAggregate
           Group Key: a, b
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: a
                 ->  Partial HashAggregate
                       Group Key: a, b
                       ->  Seq Scan on ndistinct
--- 261,267 ----
     ->  Finalize HashAggregate
           Group Key: a, b
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: a
                 ->  Partial HashAggregate
                       Group Key: a, b
                       ->  Seq Scan on ndistinct
***************
*** 275,281 ****
     ->  Finalize HashAggregate
           Group Key: b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Group Key: b, c
                       ->  Seq Scan on ndistinct
--- 275,281 ----
     ->  Finalize HashAggregate
           Group Key: b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Group Key: b, c
                       ->  Seq Scan on ndistinct
***************
*** 289,295 ****
     ->  Finalize HashAggregate
           Group Key: a, b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: a
                 ->  Partial HashAggregate
                       Group Key: a, b, c
                       ->  Seq Scan on ndistinct
--- 289,295 ----
     ->  Finalize HashAggregate
           Group Key: a, b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: a
                 ->  Partial HashAggregate
                       Group Key: a, b, c
                       ->  Seq Scan on ndistinct
***************
*** 305,311 ****
     ->  Finalize HashAggregate
           Group Key: a, b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: a
                 ->  Partial HashAggregate
                       Group Key: a, b, c, d
                       ->  Seq Scan on ndistinct
--- 305,311 ----
     ->  Finalize HashAggregate
           Group Key: a, b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: a
                 ->  Partial HashAggregate
                       Group Key: a, b, c, d
                       ->  Seq Scan on ndistinct
***************
*** 319,325 ****
     ->  Finalize HashAggregate
           Group Key: b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Group Key: b, c, d
                       ->  Seq Scan on ndistinct
--- 319,325 ----
     ->  Finalize HashAggregate
           Group Key: b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Group Key: b, c, d
                       ->  Seq Scan on ndistinct
***************
*** 348,354 ****
     ->  Finalize HashAggregate
           Group Key: a, b
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Group Key: a, b
                       ->  Seq Scan on ndistinct
--- 348,354 ----
     ->  Finalize HashAggregate
           Group Key: a, b
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Group Key: a, b
                       ->  Seq Scan on ndistinct
***************
*** 362,368 ****
     ->  Finalize HashAggregate
           Group Key: a, b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Partial GroupAggregate
                       Group Key: a, b, c
                       ->  Sort
--- 362,368 ----
     ->  Finalize HashAggregate
           Group Key: a, b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Partial GroupAggregate
                       Group Key: a, b, c
                       ->  Sort
***************
*** 378,384 ****
     ->  Finalize HashAggregate
           Group Key: a, b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: d
                 ->  Partial GroupAggregate
                       Group Key: a, b, c, d
                       ->  Sort
--- 378,384 ----
     ->  Finalize HashAggregate
           Group Key: a, b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: d
                 ->  Partial GroupAggregate
                       Group Key: a, b, c, d
                       ->  Sort
***************
*** 394,400 ****
     ->  Finalize HashAggregate
           Group Key: b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: d
                 ->  Partial HashAggregate
                       Group Key: b, c, d
                       ->  Seq Scan on ndistinct
--- 394,400 ----
     ->  Finalize HashAggregate
           Group Key: b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: d
                 ->  Partial HashAggregate
                       Group Key: b, c, d
                       ->  Seq Scan on ndistinct
***************
*** 408,414 ****
     ->  Finalize HashAggregate
           Group Key: a, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: d
                 ->  Partial HashAggregate
                       Group Key: a, d
                       ->  Seq Scan on ndistinct
--- 408,414 ----
     ->  Finalize HashAggregate
           Group Key: a, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: d
                 ->  Partial HashAggregate
                       Group Key: a, d
                       ->  Seq Scan on ndistinct
***************
*** 431,437 ****
     ->  Finalize HashAggregate
           Group Key: a, b
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Group Key: a, b
                       ->  Seq Scan on ndistinct
--- 431,437 ----
     ->  Finalize HashAggregate
           Group Key: a, b
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Group Key: a, b
                       ->  Seq Scan on ndistinct
***************
*** 445,451 ****
     ->  Finalize HashAggregate
           Group Key: a, b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Group Key: a, b, c
                       ->  Seq Scan on ndistinct
--- 445,451 ----
     ->  Finalize HashAggregate
           Group Key: a, b, c
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Group Key: a, b, c
                       ->  Seq Scan on ndistinct
***************
*** 459,465 ****
     ->  Finalize HashAggregate
           Group Key: a, b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: d
                 ->  Partial HashAggregate
                       Group Key: a, b, c, d
                       ->  Seq Scan on ndistinct
--- 459,465 ----
     ->  Finalize HashAggregate
           Group Key: a, b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: d
                 ->  Partial HashAggregate
                       Group Key: a, b, c, d
                       ->  Seq Scan on ndistinct
***************
*** 473,479 ****
     ->  Finalize HashAggregate
           Group Key: b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: d
                 ->  Partial HashAggregate
                       Group Key: b, c, d
                       ->  Seq Scan on ndistinct
--- 473,479 ----
     ->  Finalize HashAggregate
           Group Key: b, c, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: d
                 ->  Partial HashAggregate
                       Group Key: b, c, d
                       ->  Seq Scan on ndistinct
***************
*** 487,493 ****
     ->  Finalize HashAggregate
           Group Key: a, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: d
                 ->  Partial HashAggregate
                       Group Key: a, d
                       ->  Seq Scan on ndistinct
--- 487,493 ----
     ->  Finalize HashAggregate
           Group Key: a, d
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: d
                 ->  Partial HashAggregate
                       Group Key: a, d
                       ->  Seq Scan on ndistinct

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/fast_default.out"	2025-07-31 16:07:14.982068184 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/fast_default.out"	2025-07-31 16:39:41.146830755 +0800
***************
*** 5,10 ****
--- 5,12 ----
  CREATE SCHEMA fast_default;
  CREATE TABLE m(id OID);
  INSERT INTO m VALUES (NULL::OID);
+ ERROR:  node:datanode_1, backend_pid:383283, nodename:datanode_1,backend_pid:383283,message:null value in column "id" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  CREATE FUNCTION set(tabname name) RETURNS VOID
  AS $$
  BEGIN
***************
*** 162,170 ****
  (28 rows)
  
  SELECT comp();
!    comp    
! -----------
!  Rewritten
  (1 row)
  
  DROP TABLE T;
--- 164,172 ----
  (28 rows)
  
  SELECT comp();
!  comp 
! ------
!  
  (1 row)
  
  DROP TABLE T;
***************
*** 245,253 ****
  (16 rows)
  
  SELECT comp();
!    comp    
! -----------
!  Rewritten
  (1 row)
  
  DROP TABLE T;
--- 247,255 ----
  (16 rows)
  
  SELECT comp();
!  comp 
! ------
!  
  (1 row)
  
  DROP TABLE T;
***************
*** 267,283 ****
  -- now() is stable, because it returns the transaction timestamp
  ALTER TABLE T ADD COLUMN c1 TIMESTAMP DEFAULT now();
  SELECT comp();
!    comp    
! -----------
!  Rewritten
  (1 row)
  
  -- clock_timestamp() is volatile
  ALTER TABLE T ADD COLUMN c2 TIMESTAMP DEFAULT clock_timestamp();
  SELECT comp();
!    comp    
! -----------
!  Rewritten
  (1 row)
  
  DROP TABLE T;
--- 269,285 ----
  -- now() is stable, because it returns the transaction timestamp
  ALTER TABLE T ADD COLUMN c1 TIMESTAMP DEFAULT now();
  SELECT comp();
!  comp 
! ------
!  
  (1 row)
  
  -- clock_timestamp() is volatile
  ALTER TABLE T ADD COLUMN c2 TIMESTAMP DEFAULT clock_timestamp();
  SELECT comp();
!  comp 
! ------
!  
  (1 row)
  
  DROP TABLE T;
***************
*** 484,492 ****
  (9 rows)
  
  SELECT comp();
!    comp    
! -----------
!  Rewritten
  (1 row)
  
  DROP TABLE T;
--- 486,494 ----
  (9 rows)
  
  SELECT comp();
!  comp 
! ------
!  
  (1 row)
  
  DROP TABLE T;
***************
*** 536,544 ****
  (6 rows)
  
  SELECT comp();
!    comp    
! -----------
!  Rewritten
  (1 row)
  
  -- query to exercise expand_tuple function
--- 538,546 ----
  (6 rows)
  
  SELECT comp();
!  comp 
! ------
!  
  (1 row)
  
  -- query to exercise expand_tuple function

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/rules.out"	2025-07-31 16:07:15.000067898 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/rules.out"	2025-07-31 16:39:43.682776806 +0800
***************
*** 32,69 ****
--- 32,83 ----
  --  can but must not have a semicolon at the end).
  --
  create table rtest_system (sysname text, sysdesc text) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table rtest_interface (sysname text, ifname text) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table rtest_person (pname text, pdesc text) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table rtest_admin (pname text, sysname text) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create rule rtest_sys_upd as on update to rtest_system do also (
  	update rtest_interface set sysname = new.sysname
  		where sysname = old.sysname;
  	update rtest_admin set sysname = new.sysname
  		where sysname = old.sysname
  	);
+ ERROR:  relation "rtest_system" does not exist
  create rule rtest_sys_del as on delete to rtest_system do also (
  	delete from rtest_interface where sysname = old.sysname;
  	delete from rtest_admin where sysname = old.sysname;
  	);
+ ERROR:  relation "rtest_system" does not exist
  create rule rtest_pers_upd as on update to rtest_person do also
  	update rtest_admin set pname = new.pname where pname = old.pname;
+ ERROR:  relation "rtest_person" does not exist
  create rule rtest_pers_del as on delete to rtest_person do also
  	delete from rtest_admin where pname = old.pname;
+ ERROR:  relation "rtest_person" does not exist
  --
  -- Tables and rules for the logging test
  --
  create table rtest_emp (ename char(20), salary money) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table rtest_emplog (ename char(20), who name, action char(10), newsal money, oldsal money) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table rtest_empmass (ename char(20), salary money) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create rule rtest_emp_ins as on insert to rtest_emp do
  	insert into rtest_emplog values (new.ename, current_user,
  			'hired', new.salary, '0.00');
+ ERROR:  relation "rtest_emp" does not exist
  create rule rtest_emp_upd as on update to rtest_emp where new.salary != old.salary do
  	insert into rtest_emplog values (new.ename, current_user,
  			'honored', new.salary, old.salary);
+ ERROR:  relation "rtest_emp" does not exist
  create rule rtest_emp_del as on delete to rtest_emp do
  	insert into rtest_emplog values (old.ename, current_user,
  			'fired', '0.00', old.salary);
+ ERROR:  relation "rtest_emp" does not exist
  --
  -- Tables and rules for the multiple cascaded qualified instead
  -- rule test
***************
*** 292,298 ****
  -- updates in a mergejoin
  update rtest_v1 set b = rtest_t2.b from rtest_t2 where rtest_v1.a = rtest_t2.a;
  ERROR:  could not plan this distributed UPDATE/DELETE
! DETAIL:  correlated or complex UPDATE/DELETE is currently not supported in Postgres-XL.
  select * from rtest_v1 order by a, b;
   a | b  
  ---+----
--- 306,312 ----
  -- updates in a mergejoin
  update rtest_v1 set b = rtest_t2.b from rtest_t2 where rtest_v1.a = rtest_t2.a;
  ERROR:  could not plan this distributed UPDATE/DELETE
! DETAIL:  correlated or complex UPDATE/DELETE is currently not supported in OpenTenBase.
  select * from rtest_v1 order by a, b;
   a | b  
  ---+----
***************
*** 331,337 ****
  
  update rtest_v1 set a = rtest_t3.a + 20 from rtest_t3 where rtest_v1.b = rtest_t3.b;
  ERROR:  could not plan this distributed UPDATE/DELETE
! DETAIL:  correlated or complex UPDATE/DELETE is currently not supported in Postgres-XL.
  select * from rtest_v1 order by a, b;
   a  | b  
  ----+----
--- 345,351 ----
  
  update rtest_v1 set a = rtest_t3.a + 20 from rtest_t3 where rtest_v1.b = rtest_t3.b;
  ERROR:  could not plan this distributed UPDATE/DELETE
! DETAIL:  correlated or complex UPDATE/DELETE is currently not supported in OpenTenBase.
  select * from rtest_v1 order by a, b;
   a  | b  
  ----+----
***************
*** 349,484 ****
  -- Test for constraint updates/deletes
  --
  insert into rtest_system values ('orion', 'Linux Jan Wieck');
  insert into rtest_system values ('notjw', 'WinNT Jan Wieck (notebook)');
  insert into rtest_system values ('neptun', 'Fileserver');
  insert into rtest_interface values ('orion', 'eth0');
  insert into rtest_interface values ('orion', 'eth1');
  insert into rtest_interface values ('notjw', 'eth0');
  insert into rtest_interface values ('neptun', 'eth0');
  insert into rtest_person values ('jw', 'Jan Wieck');
  insert into rtest_person values ('bm', 'Bruce Momjian');
  insert into rtest_admin values ('jw', 'orion');
  insert into rtest_admin values ('jw', 'notjw');
  insert into rtest_admin values ('bm', 'neptun');
  update rtest_system set sysname = 'pluto' where sysname = 'neptun';
  select * from rtest_interface order by sysname, ifname;
!  sysname | ifname 
! ---------+--------
!  notjw   | eth0
!  orion   | eth0
!  orion   | eth1
!  pluto   | eth0
! (4 rows)
! 
  select * from rtest_admin order by pname, sysname;
!  pname | sysname 
! -------+---------
!  bm    | pluto
!  jw    | notjw
!  jw    | orion
! (3 rows)
! 
  update rtest_person set pname = 'jwieck' where pdesc = 'Jan Wieck';
  -- Note: use ORDER BY here to ensure consistent output across all systems.
  -- The above UPDATE affects two rows with equal keys, so they could be
  -- updated in either order depending on the whim of the local qsort().
  select * from rtest_admin order by pname, sysname;
!  pname  | sysname 
! --------+---------
!  bm     | pluto
!  jwieck | notjw
!  jwieck | orion
! (3 rows)
! 
  delete from rtest_system where sysname = 'orion';
  select * from rtest_interface order by sysname, ifname;
!  sysname | ifname 
! ---------+--------
!  notjw   | eth0
!  pluto   | eth0
! (2 rows)
! 
  select * from rtest_admin order by pname, sysname;
!  pname  | sysname 
! --------+---------
!  bm     | pluto
!  jwieck | notjw
! (2 rows)
! 
  --
  -- Rule qualification test
  --
  insert into rtest_emp values ('wiecc', '5000.00');
  insert into rtest_emp values ('gates', '80000.00');
  update rtest_emp set ename = 'wiecx' where ename = 'wiecc';
  update rtest_emp set ename = 'wieck', salary = '6000.00' where ename = 'wiecx';
  update rtest_emp set salary = '7000.00' where ename = 'wieck';
  delete from rtest_emp where ename = 'gates';
  select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (5 rows)
! 
  insert into rtest_empmass values ('meyer', '4000.00');
  insert into rtest_empmass values ('maier', '5000.00');
  insert into rtest_empmass values ('mayr', '6000.00');
  insert into rtest_emp select * from rtest_empmass;
  select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  maier                | t            | hired      |  $5,000.00 |      $0.00
!  mayr                 | t            | hired      |  $6,000.00 |      $0.00
!  meyer                | t            | hired      |  $4,000.00 |      $0.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (8 rows)
! 
  update rtest_empmass set salary = salary + '1000.00';
  update rtest_emp set salary = rtest_empmass.salary from rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
  select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  maier                | t            | hired      |  $5,000.00 |      $0.00
!  maier                | t            | honored    |  $6,000.00 |  $5,000.00
!  mayr                 | t            | hired      |  $6,000.00 |      $0.00
!  mayr                 | t            | honored    |  $7,000.00 |  $6,000.00
!  meyer                | t            | hired      |  $4,000.00 |      $0.00
!  meyer                | t            | honored    |  $5,000.00 |  $4,000.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (11 rows)
! 
  delete from rtest_emp using rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
  select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
!         ename         | matches user |   action   |   newsal   |   oldsal   
! ----------------------+--------------+------------+------------+------------
!  gates                | t            | fired      |      $0.00 | $80,000.00
!  gates                | t            | hired      | $80,000.00 |      $0.00
!  maier                | t            | fired      |      $0.00 |  $6,000.00
!  maier                | t            | hired      |  $5,000.00 |      $0.00
!  maier                | t            | honored    |  $6,000.00 |  $5,000.00
!  mayr                 | t            | fired      |      $0.00 |  $7,000.00
!  mayr                 | t            | hired      |  $6,000.00 |      $0.00
!  mayr                 | t            | honored    |  $7,000.00 |  $6,000.00
!  meyer                | t            | fired      |      $0.00 |  $5,000.00
!  meyer                | t            | hired      |  $4,000.00 |      $0.00
!  meyer                | t            | honored    |  $5,000.00 |  $4,000.00
!  wiecc                | t            | hired      |  $5,000.00 |      $0.00
!  wieck                | t            | honored    |  $6,000.00 |  $5,000.00
!  wieck                | t            | honored    |  $7,000.00 |  $6,000.00
! (14 rows)
! 
  --
  -- Multiple cascaded qualified instead rule test
  --
--- 363,521 ----
  -- Test for constraint updates/deletes
  --
  insert into rtest_system values ('orion', 'Linux Jan Wieck');
+ ERROR:  relation "rtest_system" does not exist
+ LINE 1: insert into rtest_system values ('orion', 'Linux Jan Wieck')...
+                     ^
  insert into rtest_system values ('notjw', 'WinNT Jan Wieck (notebook)');
+ ERROR:  relation "rtest_system" does not exist
+ LINE 1: insert into rtest_system values ('notjw', 'WinNT Jan Wieck (...
+                     ^
  insert into rtest_system values ('neptun', 'Fileserver');
+ ERROR:  relation "rtest_system" does not exist
+ LINE 1: insert into rtest_system values ('neptun', 'Fileserver');
+                     ^
  insert into rtest_interface values ('orion', 'eth0');
+ ERROR:  relation "rtest_interface" does not exist
+ LINE 1: insert into rtest_interface values ('orion', 'eth0');
+                     ^
  insert into rtest_interface values ('orion', 'eth1');
+ ERROR:  relation "rtest_interface" does not exist
+ LINE 1: insert into rtest_interface values ('orion', 'eth1');
+                     ^
  insert into rtest_interface values ('notjw', 'eth0');
+ ERROR:  relation "rtest_interface" does not exist
+ LINE 1: insert into rtest_interface values ('notjw', 'eth0');
+                     ^
  insert into rtest_interface values ('neptun', 'eth0');
+ ERROR:  relation "rtest_interface" does not exist
+ LINE 1: insert into rtest_interface values ('neptun', 'eth0');
+                     ^
  insert into rtest_person values ('jw', 'Jan Wieck');
+ ERROR:  relation "rtest_person" does not exist
+ LINE 1: insert into rtest_person values ('jw', 'Jan Wieck');
+                     ^
  insert into rtest_person values ('bm', 'Bruce Momjian');
+ ERROR:  relation "rtest_person" does not exist
+ LINE 1: insert into rtest_person values ('bm', 'Bruce Momjian');
+                     ^
  insert into rtest_admin values ('jw', 'orion');
+ ERROR:  relation "rtest_admin" does not exist
+ LINE 1: insert into rtest_admin values ('jw', 'orion');
+                     ^
  insert into rtest_admin values ('jw', 'notjw');
+ ERROR:  relation "rtest_admin" does not exist
+ LINE 1: insert into rtest_admin values ('jw', 'notjw');
+                     ^
  insert into rtest_admin values ('bm', 'neptun');
+ ERROR:  relation "rtest_admin" does not exist
+ LINE 1: insert into rtest_admin values ('bm', 'neptun');
+                     ^
  update rtest_system set sysname = 'pluto' where sysname = 'neptun';
+ ERROR:  relation "rtest_system" does not exist
+ LINE 1: update rtest_system set sysname = 'pluto' where sysname = 'n...
+                ^
  select * from rtest_interface order by sysname, ifname;
! ERROR:  relation "rtest_interface" does not exist
! LINE 1: select * from rtest_interface order by sysname, ifname;
!                       ^
  select * from rtest_admin order by pname, sysname;
! ERROR:  relation "rtest_admin" does not exist
! LINE 1: select * from rtest_admin order by pname, sysname;
!                       ^
  update rtest_person set pname = 'jwieck' where pdesc = 'Jan Wieck';
+ ERROR:  relation "rtest_person" does not exist
+ LINE 1: update rtest_person set pname = 'jwieck' where pdesc = 'Jan ...
+                ^
  -- Note: use ORDER BY here to ensure consistent output across all systems.
  -- The above UPDATE affects two rows with equal keys, so they could be
  -- updated in either order depending on the whim of the local qsort().
  select * from rtest_admin order by pname, sysname;
! ERROR:  relation "rtest_admin" does not exist
! LINE 1: select * from rtest_admin order by pname, sysname;
!                       ^
  delete from rtest_system where sysname = 'orion';
+ ERROR:  relation "rtest_system" does not exist
+ LINE 1: delete from rtest_system where sysname = 'orion';
+                     ^
  select * from rtest_interface order by sysname, ifname;
! ERROR:  relation "rtest_interface" does not exist
! LINE 1: select * from rtest_interface order by sysname, ifname;
!                       ^
  select * from rtest_admin order by pname, sysname;
! ERROR:  relation "rtest_admin" does not exist
! LINE 1: select * from rtest_admin order by pname, sysname;
!                       ^
  --
  -- Rule qualification test
  --
  insert into rtest_emp values ('wiecc', '5000.00');
+ ERROR:  relation "rtest_emp" does not exist
+ LINE 1: insert into rtest_emp values ('wiecc', '5000.00');
+                     ^
  insert into rtest_emp values ('gates', '80000.00');
+ ERROR:  relation "rtest_emp" does not exist
+ LINE 1: insert into rtest_emp values ('gates', '80000.00');
+                     ^
  update rtest_emp set ename = 'wiecx' where ename = 'wiecc';
+ ERROR:  relation "rtest_emp" does not exist
+ LINE 1: update rtest_emp set ename = 'wiecx' where ename = 'wiecc';
+                ^
  update rtest_emp set ename = 'wieck', salary = '6000.00' where ename = 'wiecx';
+ ERROR:  relation "rtest_emp" does not exist
+ LINE 1: update rtest_emp set ename = 'wieck', salary = '6000.00' whe...
+                ^
  update rtest_emp set salary = '7000.00' where ename = 'wieck';
+ ERROR:  relation "rtest_emp" does not exist
+ LINE 1: update rtest_emp set salary = '7000.00' where ename = 'wieck...
+                ^
  delete from rtest_emp where ename = 'gates';
+ ERROR:  relation "rtest_emp" does not exist
+ LINE 1: delete from rtest_emp where ename = 'gates';
+                     ^
  select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
! ERROR:  relation "rtest_emplog" does not exist
! LINE 1: ...er as "matches user", action, newsal, oldsal from rtest_empl...
!                                                              ^
  insert into rtest_empmass values ('meyer', '4000.00');
+ ERROR:  relation "rtest_empmass" does not exist
+ LINE 1: insert into rtest_empmass values ('meyer', '4000.00');
+                     ^
  insert into rtest_empmass values ('maier', '5000.00');
+ ERROR:  relation "rtest_empmass" does not exist
+ LINE 1: insert into rtest_empmass values ('maier', '5000.00');
+                     ^
  insert into rtest_empmass values ('mayr', '6000.00');
+ ERROR:  relation "rtest_empmass" does not exist
+ LINE 1: insert into rtest_empmass values ('mayr', '6000.00');
+                     ^
  insert into rtest_emp select * from rtest_empmass;
+ ERROR:  relation "rtest_emp" does not exist
+ LINE 1: insert into rtest_emp select * from rtest_empmass;
+                     ^
  select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
! ERROR:  relation "rtest_emplog" does not exist
! LINE 1: ...er as "matches user", action, newsal, oldsal from rtest_empl...
!                                                              ^
  update rtest_empmass set salary = salary + '1000.00';
+ ERROR:  relation "rtest_empmass" does not exist
+ LINE 1: update rtest_empmass set salary = salary + '1000.00';
+                ^
  update rtest_emp set salary = rtest_empmass.salary from rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
+ ERROR:  relation "rtest_emp" does not exist
+ LINE 1: update rtest_emp set salary = rtest_empmass.salary from rtes...
+                ^
  select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
! ERROR:  relation "rtest_emplog" does not exist
! LINE 1: ...er as "matches user", action, newsal, oldsal from rtest_empl...
!                                                              ^
  delete from rtest_emp using rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
+ ERROR:  relation "rtest_emp" does not exist
+ LINE 1: delete from rtest_emp using rtest_empmass where rtest_emp.en...
+                     ^
  select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
! ERROR:  relation "rtest_emplog" does not exist
! LINE 1: ...er as "matches user", action, newsal, oldsal from rtest_empl...
!                                                              ^
  --
  -- Multiple cascaded qualified instead rule test
  --
***************
*** 947,952 ****
--- 984,990 ----
  	slmaxlen   float,         -- maximum shoelace length
  	slunit     char(8)        -- length unit
  ) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  CREATE TABLE shoelace_data (
  	sl_name    char(10),      -- primary key
  	sl_avail   integer,       -- available # of pairs
***************
*** 954,963 ****
--- 992,1003 ----
  	sl_len     float,         -- shoelace length
  	sl_unit    char(8)        -- length unit
  ) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  CREATE TABLE unit (
  	un_name    char(8),       -- the primary key
  	un_fact    float          -- factor to transform to cm
  ) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  CREATE VIEW shoe AS
  	SELECT sh.shoename,
  		   sh.sh_avail,
***************
*** 969,974 ****
--- 1009,1017 ----
  		   sh.slunit
  	  FROM shoe_data sh, unit un
  	 WHERE sh.slunit = un.un_name;
+ ERROR:  relation "shoe_data" does not exist
+ LINE 10:    FROM shoe_data sh, unit un
+                  ^
  CREATE VIEW shoelace AS
  	SELECT s.sl_name,
  		   s.sl_avail,
***************
*** 978,983 ****
--- 1021,1029 ----
  		   s.sl_len * u.un_fact AS sl_len_cm
  	  FROM shoelace_data s, unit u
  	 WHERE s.sl_unit = u.un_name;
+ ERROR:  relation "shoelace_data" does not exist
+ LINE 8:    FROM shoelace_data s, unit u
+                 ^
  CREATE VIEW shoe_ready AS
  	SELECT rsh.shoename,
  		   rsh.sh_avail,
***************
*** 988,1029 ****
  	 WHERE rsl.sl_color = rsh.slcolor
  	   AND rsl.sl_len_cm >= rsh.slminlen_cm
  	   AND rsl.sl_len_cm <= rsh.slmaxlen_cm;
  INSERT INTO unit VALUES ('cm', 1.0);
  INSERT INTO unit VALUES ('m', 100.0);
  INSERT INTO unit VALUES ('inch', 2.54);
  INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
  INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
  INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
  INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');
  INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
  INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
  INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
  INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
  INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
  INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
  INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
  INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');
  -- SELECTs in doc
  SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |        0 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |        0 | brown      |    0.9 | m        |        90
!  sl7        |        7 | brown      |     60 | cm       |        60
!  sl8        |        1 | brown      |     40 | inch     |     101.6
! (8 rows)
! 
  SELECT * FROM shoe_ready WHERE total_avail >= 2 ORDER BY 1;
!   shoename  | sh_avail |  sl_name   | sl_avail | total_avail 
! ------------+----------+------------+----------+-------------
!  sh1        |        2 | sl1        |        5 |           2
!  sh3        |        4 | sl7        |        7 |           4
! (2 rows)
! 
      CREATE TABLE shoelace_log (
          sl_name    char(10),      -- shoelace changed
          sl_avail   integer,       -- new available value
--- 1034,1111 ----
  	 WHERE rsl.sl_color = rsh.slcolor
  	   AND rsl.sl_len_cm >= rsh.slminlen_cm
  	   AND rsl.sl_len_cm <= rsh.slmaxlen_cm;
+ ERROR:  relation "shoe" does not exist
+ LINE 7:    FROM shoe rsh, shoelace rsl
+                 ^
  INSERT INTO unit VALUES ('cm', 1.0);
+ ERROR:  relation "unit" does not exist
+ LINE 1: INSERT INTO unit VALUES ('cm', 1.0);
+                     ^
  INSERT INTO unit VALUES ('m', 100.0);
+ ERROR:  relation "unit" does not exist
+ LINE 1: INSERT INTO unit VALUES ('m', 100.0);
+                     ^
  INSERT INTO unit VALUES ('inch', 2.54);
+ ERROR:  relation "unit" does not exist
+ LINE 1: INSERT INTO unit VALUES ('inch', 2.54);
+                     ^
  INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
+ ERROR:  relation "shoe_data" does not exist
+ LINE 1: INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0,...
+                     ^
  INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
+ ERROR:  relation "shoe_data" does not exist
+ LINE 1: INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0,...
+                     ^
  INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
+ ERROR:  relation "shoe_data" does not exist
+ LINE 1: INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0,...
+                     ^
  INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');
+ ERROR:  relation "shoe_data" does not exist
+ LINE 1: INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0,...
+                     ^
  INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
+ ERROR:  relation "shoelace_data" does not exist
+ LINE 1: INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, '...
+                     ^
  INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
+ ERROR:  relation "shoelace_data" does not exist
+ LINE 1: INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, ...
+                     ^
  INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
+ ERROR:  relation "shoelace_data" does not exist
+ LINE 1: INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , ...
+                     ^
  INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
+ ERROR:  relation "shoelace_data" does not exist
+ LINE 1: INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , ...
+                     ^
  INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
+ ERROR:  relation "shoelace_data" does not exist
+ LINE 1: INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , '...
+                     ^
  INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
+ ERROR:  relation "shoelace_data" does not exist
+ LINE 1: INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , '...
+                     ^
  INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
+ ERROR:  relation "shoelace_data" does not exist
+ LINE 1: INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'c...
+                     ^
  INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');
+ ERROR:  relation "shoelace_data" does not exist
+ LINE 1: INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'i...
+                     ^
  -- SELECTs in doc
  SELECT * FROM shoelace ORDER BY sl_name;
! ERROR:  relation "shoelace" does not exist
! LINE 1: SELECT * FROM shoelace ORDER BY sl_name;
!                       ^
  SELECT * FROM shoe_ready WHERE total_avail >= 2 ORDER BY 1;
! ERROR:  relation "shoe_ready" does not exist
! LINE 1: SELECT * FROM shoe_ready WHERE total_avail >= 2 ORDER BY 1;
!                       ^
      CREATE TABLE shoelace_log (
          sl_name    char(10),      -- shoelace changed
          sl_avail   integer,       -- new available value
***************
*** 1041,1052 ****
                                          'Al Bundy',
                                          'epoch'
                                      );
  UPDATE shoelace_data SET sl_avail = 6 WHERE  sl_name = 'sl7';
  SELECT * FROM shoelace_log;
!   sl_name   | sl_avail | log_who  |         log_when         
! ------------+----------+----------+--------------------------
!  sl7        |        6 | Al Bundy | Thu Jan 01 00:00:00 1970
! (1 row)
  
      CREATE RULE shoelace_ins AS ON INSERT TO shoelace
          DO INSTEAD
--- 1123,1137 ----
                                          'Al Bundy',
                                          'epoch'
                                      );
+ ERROR:  relation "shoelace_data" does not exist
  UPDATE shoelace_data SET sl_avail = 6 WHERE  sl_name = 'sl7';
+ ERROR:  relation "shoelace_data" does not exist
+ LINE 1: UPDATE shoelace_data SET sl_avail = 6 WHERE  sl_name = 'sl7'...
+                ^
  SELECT * FROM shoelace_log;
!  sl_name | sl_avail | log_who | log_when 
! ---------+----------+---------+----------
! (0 rows)
  
      CREATE RULE shoelace_ins AS ON INSERT TO shoelace
          DO INSTEAD
***************
*** 1056,1061 ****
--- 1141,1147 ----
                 NEW.sl_color,
                 NEW.sl_len,
                 NEW.sl_unit);
+ ERROR:  relation "shoelace" does not exist
      CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
          DO INSTEAD
          UPDATE shoelace_data SET
***************
*** 1065,1074 ****
--- 1151,1162 ----
                 sl_len = NEW.sl_len,
                 sl_unit = NEW.sl_unit
           WHERE sl_name = OLD.sl_name;
+ ERROR:  relation "shoelace" does not exist
      CREATE RULE shoelace_del AS ON DELETE TO shoelace
          DO INSTEAD
          DELETE FROM shoelace_data
           WHERE sl_name = OLD.sl_name;
+ ERROR:  relation "shoelace" does not exist
      CREATE TABLE shoelace_arrive (
          arr_name    char(10),
          arr_quant   integer
***************
*** 1082,1182 ****
          UPDATE shoelace SET
                 sl_avail = sl_avail + NEW.ok_quant
           WHERE sl_name = NEW.ok_name;
  INSERT INTO shoelace_arrive VALUES ('sl3', 10);
  INSERT INTO shoelace_arrive VALUES ('sl6', 20);
  INSERT INTO shoelace_arrive VALUES ('sl8', 20);
  SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |        0 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |        0 | brown      |    0.9 | m        |        90
!  sl7        |        6 | brown      |     60 | cm       |        60
!  sl8        |        1 | brown      |     40 | inch     |     101.6
! (8 rows)
! 
  insert into shoelace_ok select * from shoelace_arrive;
  SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |       10 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |       20 | brown      |    0.9 | m        |        90
!  sl7        |        6 | brown      |     60 | cm       |        60
!  sl8        |       21 | brown      |     40 | inch     |     101.6
! (8 rows)
! 
  SELECT * FROM shoelace_log ORDER BY sl_name;
!   sl_name   | sl_avail | log_who  |         log_when         
! ------------+----------+----------+--------------------------
!  sl3        |       10 | Al Bundy | Thu Jan 01 00:00:00 1970
!  sl6        |       20 | Al Bundy | Thu Jan 01 00:00:00 1970
!  sl7        |        6 | Al Bundy | Thu Jan 01 00:00:00 1970
!  sl8        |       21 | Al Bundy | Thu Jan 01 00:00:00 1970
! (4 rows)
  
      CREATE VIEW shoelace_obsolete AS
  	SELECT * FROM shoelace WHERE NOT EXISTS
  	    (SELECT shoename FROM shoe WHERE slcolor = sl_color);
      CREATE VIEW shoelace_candelete AS
  	SELECT * FROM shoelace_obsolete WHERE sl_avail = 0;
  insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
  insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
  -- Unsupported (even though a similar updatable view construct is)
  insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0)
    on conflict do nothing;
! ERROR:  INSERT with ON CONFLICT clause cannot be used with table that has INSERT or UPDATE rules
  SELECT * FROM shoelace_obsolete ORDER BY sl_len_cm;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl9        |        0 | pink       |     35 | inch     |      88.9
!  sl10       |     1000 | magenta    |     40 | inch     |     101.6
! (2 rows)
! 
  SELECT * FROM shoelace_candelete;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl9        |        0 | pink       |     35 | inch     |      88.9
! (1 row)
! 
  DELETE FROM shoelace WHERE EXISTS
      (SELECT * FROM shoelace_candelete
               WHERE sl_name = shoelace.sl_name);
  SELECT * FROM shoelace ORDER BY sl_name;
!   sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
! ------------+----------+------------+--------+----------+-----------
!  sl1        |        5 | black      |     80 | cm       |        80
!  sl10       |     1000 | magenta    |     40 | inch     |     101.6
!  sl2        |        6 | black      |    100 | cm       |       100
!  sl3        |       10 | black      |     35 | inch     |      88.9
!  sl4        |        8 | black      |     40 | inch     |     101.6
!  sl5        |        4 | brown      |      1 | m        |       100
!  sl6        |       20 | brown      |    0.9 | m        |        90
!  sl7        |        6 | brown      |     60 | cm       |        60
!  sl8        |       21 | brown      |     40 | inch     |     101.6
! (9 rows)
! 
  SELECT * FROM shoe ORDER BY shoename;
!   shoename  | sh_avail |  slcolor   | slminlen | slminlen_cm | slmaxlen | slmaxlen_cm |  slunit  
! ------------+----------+------------+----------+-------------+----------+-------------+----------
!  sh1        |        2 | black      |       70 |          70 |       90 |          90 | cm      
!  sh2        |        0 | black      |       30 |        76.2 |       40 |       101.6 | inch    
!  sh3        |        4 | brown      |       50 |          50 |       65 |          65 | cm      
!  sh4        |        3 | brown      |       40 |       101.6 |       50 |         127 | inch    
! (4 rows)
! 
  SELECT count(*) FROM shoe;
!  count 
! -------
!      4
! (1 row)
! 
  --
  -- Simple test of qualified ON INSERT ... this did not work in 7.0 ...
  --
--- 1170,1246 ----
          UPDATE shoelace SET
                 sl_avail = sl_avail + NEW.ok_quant
           WHERE sl_name = NEW.ok_name;
+ ERROR:  relation "shoelace" does not exist
+ LINE 3:         UPDATE shoelace SET
+                        ^
  INSERT INTO shoelace_arrive VALUES ('sl3', 10);
  INSERT INTO shoelace_arrive VALUES ('sl6', 20);
  INSERT INTO shoelace_arrive VALUES ('sl8', 20);
  SELECT * FROM shoelace ORDER BY sl_name;
! ERROR:  relation "shoelace" does not exist
! LINE 1: SELECT * FROM shoelace ORDER BY sl_name;
!                       ^
  insert into shoelace_ok select * from shoelace_arrive;
  SELECT * FROM shoelace ORDER BY sl_name;
! ERROR:  relation "shoelace" does not exist
! LINE 1: SELECT * FROM shoelace ORDER BY sl_name;
!                       ^
  SELECT * FROM shoelace_log ORDER BY sl_name;
!  sl_name | sl_avail | log_who | log_when 
! ---------+----------+---------+----------
! (0 rows)
  
      CREATE VIEW shoelace_obsolete AS
  	SELECT * FROM shoelace WHERE NOT EXISTS
  	    (SELECT shoename FROM shoe WHERE slcolor = sl_color);
+ ERROR:  relation "shoelace" does not exist
+ LINE 2:  SELECT * FROM shoelace WHERE NOT EXISTS
+                        ^
      CREATE VIEW shoelace_candelete AS
  	SELECT * FROM shoelace_obsolete WHERE sl_avail = 0;
+ ERROR:  relation "shoelace_obsolete" does not exist
+ LINE 2:  SELECT * FROM shoelace_obsolete WHERE sl_avail = 0;
+                        ^
  insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
+ ERROR:  relation "shoelace" does not exist
+ LINE 1: insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch',...
+                     ^
  insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
+ ERROR:  relation "shoelace" does not exist
+ LINE 1: insert into shoelace values ('sl10', 1000, 'magenta', 40.0, ...
+                     ^
  -- Unsupported (even though a similar updatable view construct is)
  insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0)
    on conflict do nothing;
! ERROR:  relation "shoelace" does not exist
! LINE 1: insert into shoelace values ('sl10', 1000, 'magenta', 40.0, ...
!                     ^
  SELECT * FROM shoelace_obsolete ORDER BY sl_len_cm;
! ERROR:  relation "shoelace_obsolete" does not exist
! LINE 1: SELECT * FROM shoelace_obsolete ORDER BY sl_len_cm;
!                       ^
  SELECT * FROM shoelace_candelete;
! ERROR:  relation "shoelace_candelete" does not exist
! LINE 1: SELECT * FROM shoelace_candelete;
!                       ^
  DELETE FROM shoelace WHERE EXISTS
      (SELECT * FROM shoelace_candelete
               WHERE sl_name = shoelace.sl_name);
+ ERROR:  relation "shoelace" does not exist
+ LINE 1: DELETE FROM shoelace WHERE EXISTS
+                     ^
  SELECT * FROM shoelace ORDER BY sl_name;
! ERROR:  relation "shoelace" does not exist
! LINE 1: SELECT * FROM shoelace ORDER BY sl_name;
!                       ^
  SELECT * FROM shoe ORDER BY shoename;
! ERROR:  relation "shoe" does not exist
! LINE 1: SELECT * FROM shoe ORDER BY shoename;
!                       ^
  SELECT count(*) FROM shoe;
! ERROR:  relation "shoe" does not exist
! LINE 1: SELECT count(*) FROM shoe;
!                              ^
  --
  -- Simple test of qualified ON INSERT ... this did not work in 7.0 ...
  --
***************
*** 2336,2387 ****
      rtest_view1.b,
      rtest_viewfunc1(rtest_view1.a) AS refcount
     FROM rtest_view1;
- shoe| SELECT sh.shoename,
-     sh.sh_avail,
-     sh.slcolor,
-     sh.slminlen,
-     (sh.slminlen * un.un_fact) AS slminlen_cm,
-     sh.slmaxlen,
-     (sh.slmaxlen * un.un_fact) AS slmaxlen_cm,
-     sh.slunit
-    FROM shoe_data sh,
-     unit un
-   WHERE (sh.slunit = un.un_name);
- shoe_ready| SELECT rsh.shoename,
-     rsh.sh_avail,
-     rsl.sl_name,
-     rsl.sl_avail,
-     int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail
-    FROM shoe rsh,
-     shoelace rsl
-   WHERE ((rsl.sl_color = rsh.slcolor) AND (rsl.sl_len_cm >= rsh.slminlen_cm) AND (rsl.sl_len_cm <= rsh.slmaxlen_cm));
- shoelace| SELECT s.sl_name,
-     s.sl_avail,
-     s.sl_color,
-     s.sl_len,
-     s.sl_unit,
-     (s.sl_len * u.un_fact) AS sl_len_cm
-    FROM shoelace_data s,
-     unit u
-   WHERE (s.sl_unit = u.un_name);
- shoelace_candelete| SELECT shoelace_obsolete.sl_name,
-     shoelace_obsolete.sl_avail,
-     shoelace_obsolete.sl_color,
-     shoelace_obsolete.sl_len,
-     shoelace_obsolete.sl_unit,
-     shoelace_obsolete.sl_len_cm
-    FROM shoelace_obsolete
-   WHERE (shoelace_obsolete.sl_avail = 0);
- shoelace_obsolete| SELECT shoelace.sl_name,
-     shoelace.sl_avail,
-     shoelace.sl_color,
-     shoelace.sl_len,
-     shoelace.sl_unit,
-     shoelace.sl_len_cm
-    FROM shoelace
-   WHERE (NOT (EXISTS ( SELECT shoe.shoename
-            FROM shoe
-           WHERE (shoe.slcolor = shoelace.sl_color))));
  street| SELECT r.name,
      r.thepath,
      c.cname
--- 2400,2405 ----
***************
*** 2397,2405 ****
      emp.location,
      (12 * emp.salary) AS annualsal
     FROM emp;
- zv1| SELECT zt1.f1,
-     'dummy'::text AS junk
-    FROM pg_temp_31.zt1;
  SELECT tablename, rulename, definition FROM pg_rules
  	ORDER BY tablename, rulename;
  pg_settings|pg_settings_n|CREATE RULE pg_settings_n AS
--- 2415,2420 ----
***************
*** 2407,2422 ****
  pg_settings|pg_settings_u|CREATE RULE pg_settings_u AS
      ON UPDATE TO pg_settings
     WHERE (new.name = old.name) DO  SELECT set_config(old.name, new.setting, false) AS set_config;
- rtest_emp|rtest_emp_del|CREATE RULE rtest_emp_del AS
-     ON DELETE TO rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
-   VALUES (old.ename, CURRENT_USER, 'fired'::bpchar, '$0.00'::money, old.salary);
- rtest_emp|rtest_emp_ins|CREATE RULE rtest_emp_ins AS
-     ON INSERT TO rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
-   VALUES (new.ename, CURRENT_USER, 'hired'::bpchar, new.salary, '$0.00'::money);
- rtest_emp|rtest_emp_upd|CREATE RULE rtest_emp_upd AS
-     ON UPDATE TO rtest_emp
-    WHERE (new.salary <> old.salary) DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
-   VALUES (new.ename, CURRENT_USER, 'honored'::bpchar, new.salary, old.salary);
  rtest_nothn1|rtest_nothn_r1|CREATE RULE rtest_nothn_r1 AS
      ON INSERT TO rtest_nothn1
     WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD NOTHING;
--- 2422,2427 ----
***************
*** 2442,2465 ****
      ON INSERT TO rtest_order1
     WHERE (new.a < 100) DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
    VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 4 - this should run 4th'::text);
- rtest_person|rtest_pers_del|CREATE RULE rtest_pers_del AS
-     ON DELETE TO rtest_person DO  DELETE FROM rtest_admin
-   WHERE (rtest_admin.pname = old.pname);
- rtest_person|rtest_pers_upd|CREATE RULE rtest_pers_upd AS
-     ON UPDATE TO rtest_person DO  UPDATE rtest_admin SET pname = new.pname
-   WHERE (rtest_admin.pname = old.pname);
- rtest_system|rtest_sys_del|CREATE RULE rtest_sys_del AS
-     ON DELETE TO rtest_system DO ( DELETE FROM rtest_interface
-   WHERE (rtest_interface.sysname = old.sysname);
-  DELETE FROM rtest_admin
-   WHERE (rtest_admin.sysname = old.sysname);
- );
- rtest_system|rtest_sys_upd|CREATE RULE rtest_sys_upd AS
-     ON UPDATE TO rtest_system DO ( UPDATE rtest_interface SET sysname = new.sysname
-   WHERE (rtest_interface.sysname = old.sysname);
-  UPDATE rtest_admin SET sysname = new.sysname
-   WHERE (rtest_admin.sysname = old.sysname);
- );
  rtest_t4|rtest_t4_ins1|CREATE RULE rtest_t4_ins1 AS
      ON INSERT TO rtest_t4
     WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD  INSERT INTO rtest_t5 (a, b)
--- 2447,2452 ----
***************
*** 2485,2506 ****
  rtest_v1|rtest_v1_upd|CREATE RULE rtest_v1_upd AS
      ON UPDATE TO rtest_v1 DO INSTEAD  UPDATE rtest_t1 SET a = new.a, b = new.b
    WHERE (rtest_t1.a = old.a);
- shoelace|shoelace_del|CREATE RULE shoelace_del AS
-     ON DELETE TO shoelace DO INSTEAD  DELETE FROM shoelace_data
-   WHERE (shoelace_data.sl_name = old.sl_name);
- shoelace|shoelace_ins|CREATE RULE shoelace_ins AS
-     ON INSERT TO shoelace DO INSTEAD  INSERT INTO shoelace_data (sl_name, sl_avail, sl_color, sl_len, sl_unit)
-   VALUES (new.sl_name, new.sl_avail, new.sl_color, new.sl_len, new.sl_unit);
- shoelace|shoelace_upd|CREATE RULE shoelace_upd AS
-     ON UPDATE TO shoelace DO INSTEAD  UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit
-   WHERE (shoelace_data.sl_name = old.sl_name);
- shoelace_data|log_shoelace|CREATE RULE log_shoelace AS
-     ON UPDATE TO shoelace_data
-    WHERE (new.sl_avail <> old.sl_avail) DO  INSERT INTO shoelace_log (sl_name, sl_avail, log_who, log_when)
-   VALUES (new.sl_name, new.sl_avail, 'Al Bundy'::name, 'Thu Jan 01 00:00:00 1970'::timestamp without time zone);
- shoelace_ok|shoelace_ok_ins|CREATE RULE shoelace_ok_ins AS
-     ON INSERT TO shoelace_ok DO INSTEAD  UPDATE shoelace SET sl_avail = (shoelace.sl_avail + new.ok_quant)
-   WHERE (shoelace.sl_name = new.ok_name);
  -- restore normal output mode
  \a\t
  --
--- 2472,2477 ----
***************
*** 2542,2547 ****
--- 2513,2519 ----
  	foreign key (id3a, id3b) references rule_and_refint_t1 (id1a, id1b),
  	foreign key (id3a, id3c) references rule_and_refint_t2 (id2a, id2c)
  );
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  insert into rule_and_refint_t1 values (1, 11);
  insert into rule_and_refint_t1 values (1, 12);
  insert into rule_and_refint_t1 values (2, 21);
***************
*** 2551,2581 ****
  insert into rule_and_refint_t2 values (2, 21);
  insert into rule_and_refint_t2 values (2, 22);
  insert into rule_and_refint_t3 values (1, 11, 11, 'row1');
  insert into rule_and_refint_t3 values (1, 11, 12, 'row2');
  insert into rule_and_refint_t3 values (1, 12, 11, 'row3');
  insert into rule_and_refint_t3 values (1, 12, 12, 'row4');
  insert into rule_and_refint_t3 values (1, 11, 13, 'row5');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey1"
! DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".
  insert into rule_and_refint_t3 values (1, 13, 11, 'row6');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey"
! DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
  -- Ordinary table
  insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
    on conflict do nothing;
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey"
! DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
  -- rule not fired, so fk violation
  insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
    on conflict (id3a, id3b, id3c) do update
    set id3b = excluded.id3b;
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey"
! DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
  -- rule fired, so unsupported
  insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0)
    on conflict (sl_name) do update
    set sl_avail = excluded.sl_avail;
! ERROR:  INSERT with ON CONFLICT clause cannot be used with table that has INSERT or UPDATE rules
  create rule rule_and_refint_t3_ins as on insert to rule_and_refint_t3
  	where (exists (select 1 from rule_and_refint_t3
  			where (((rule_and_refint_t3.id3a = new.id3a)
--- 2523,2571 ----
  insert into rule_and_refint_t2 values (2, 21);
  insert into rule_and_refint_t2 values (2, 22);
  insert into rule_and_refint_t3 values (1, 11, 11, 'row1');
+ ERROR:  relation "rule_and_refint_t3" does not exist
+ LINE 1: insert into rule_and_refint_t3 values (1, 11, 11, 'row1');
+                     ^
  insert into rule_and_refint_t3 values (1, 11, 12, 'row2');
+ ERROR:  relation "rule_and_refint_t3" does not exist
+ LINE 1: insert into rule_and_refint_t3 values (1, 11, 12, 'row2');
+                     ^
  insert into rule_and_refint_t3 values (1, 12, 11, 'row3');
+ ERROR:  relation "rule_and_refint_t3" does not exist
+ LINE 1: insert into rule_and_refint_t3 values (1, 12, 11, 'row3');
+                     ^
  insert into rule_and_refint_t3 values (1, 12, 12, 'row4');
+ ERROR:  relation "rule_and_refint_t3" does not exist
+ LINE 1: insert into rule_and_refint_t3 values (1, 12, 12, 'row4');
+                     ^
  insert into rule_and_refint_t3 values (1, 11, 13, 'row5');
! ERROR:  relation "rule_and_refint_t3" does not exist
! LINE 1: insert into rule_and_refint_t3 values (1, 11, 13, 'row5');
!                     ^
  insert into rule_and_refint_t3 values (1, 13, 11, 'row6');
! ERROR:  relation "rule_and_refint_t3" does not exist
! LINE 1: insert into rule_and_refint_t3 values (1, 13, 11, 'row6');
!                     ^
  -- Ordinary table
  insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
    on conflict do nothing;
! ERROR:  relation "rule_and_refint_t3" does not exist
! LINE 1: insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
!                     ^
  -- rule not fired, so fk violation
  insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
    on conflict (id3a, id3b, id3c) do update
    set id3b = excluded.id3b;
! ERROR:  relation "rule_and_refint_t3" does not exist
! LINE 1: insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
!                     ^
  -- rule fired, so unsupported
  insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0)
    on conflict (sl_name) do update
    set sl_avail = excluded.sl_avail;
! ERROR:  relation "shoelace" does not exist
! LINE 1: insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch',...
!                     ^
  create rule rule_and_refint_t3_ins as on insert to rule_and_refint_t3
  	where (exists (select 1 from rule_and_refint_t3
  			where (((rule_and_refint_t3.id3a = new.id3a)
***************
*** 2585,2596 ****
  	where (((rule_and_refint_t3.id3a = new.id3a)
  	and (rule_and_refint_t3.id3b = new.id3b))
  	and (rule_and_refint_t3.id3c = new.id3c));
  insert into rule_and_refint_t3 values (1, 11, 13, 'row7');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey1"
! DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".
  insert into rule_and_refint_t3 values (1, 13, 11, 'row8');
! ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey"
! DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
  --
  -- disallow dropping a view's rule (bug #5072)
  --
--- 2575,2589 ----
  	where (((rule_and_refint_t3.id3a = new.id3a)
  	and (rule_and_refint_t3.id3b = new.id3b))
  	and (rule_and_refint_t3.id3c = new.id3c));
+ ERROR:  relation "rule_and_refint_t3" does not exist
  insert into rule_and_refint_t3 values (1, 11, 13, 'row7');
! ERROR:  relation "rule_and_refint_t3" does not exist
! LINE 1: insert into rule_and_refint_t3 values (1, 11, 13, 'row7');
!                     ^
  insert into rule_and_refint_t3 values (1, 13, 11, 'row8');
! ERROR:  relation "rule_and_refint_t3" does not exist
! LINE 1: insert into rule_and_refint_t3 values (1, 13, 11, 'row8');
!                     ^
  --
  -- disallow dropping a view's rule (bug #5072)
  --
***************
*** 2750,2802 ****
  reset constraint_exclusion;
  -- test various flavors of pg_get_viewdef()
  select pg_get_viewdef('shoe'::regclass) as unpretty;
!                     unpretty                    
! ------------------------------------------------
!   SELECT sh.shoename,                          +
!      sh.sh_avail,                              +
!      sh.slcolor,                               +
!      sh.slminlen,                              +
!      (sh.slminlen * un.un_fact) AS slminlen_cm,+
!      sh.slmaxlen,                              +
!      (sh.slmaxlen * un.un_fact) AS slmaxlen_cm,+
!      sh.slunit                                 +
!     FROM shoe_data sh,                         +
!      unit un                                   +
!    WHERE (sh.slunit = un.un_name);
! (1 row)
! 
  select pg_get_viewdef('shoe'::regclass,true) as pretty;
!                     pretty                    
! ----------------------------------------------
!   SELECT sh.shoename,                        +
!      sh.sh_avail,                            +
!      sh.slcolor,                             +
!      sh.slminlen,                            +
!      sh.slminlen * un.un_fact AS slminlen_cm,+
!      sh.slmaxlen,                            +
!      sh.slmaxlen * un.un_fact AS slmaxlen_cm,+
!      sh.slunit                               +
!     FROM shoe_data sh,                       +
!      unit un                                 +
!    WHERE sh.slunit = un.un_name;
! (1 row)
! 
  select pg_get_viewdef('shoe'::regclass,0) as prettier;
!                    prettier                   
! ----------------------------------------------
!   SELECT sh.shoename,                        +
!      sh.sh_avail,                            +
!      sh.slcolor,                             +
!      sh.slminlen,                            +
!      sh.slminlen * un.un_fact AS slminlen_cm,+
!      sh.slmaxlen,                            +
!      sh.slmaxlen * un.un_fact AS slmaxlen_cm,+
!      sh.slunit                               +
!     FROM shoe_data sh,                       +
!      unit un                                 +
!    WHERE sh.slunit = un.un_name;
! (1 row)
! 
  --
  -- check multi-row VALUES in rules
  --
--- 2743,2759 ----
  reset constraint_exclusion;
  -- test various flavors of pg_get_viewdef()
  select pg_get_viewdef('shoe'::regclass) as unpretty;
! ERROR:  relation "shoe" does not exist
! LINE 1: select pg_get_viewdef('shoe'::regclass) as unpretty;
!                               ^
  select pg_get_viewdef('shoe'::regclass,true) as pretty;
! ERROR:  relation "shoe" does not exist
! LINE 1: select pg_get_viewdef('shoe'::regclass,true) as pretty;
!                               ^
  select pg_get_viewdef('shoe'::regclass,0) as prettier;
! ERROR:  relation "shoe" does not exist
! LINE 1: select pg_get_viewdef('shoe'::regclass,0) as prettier;
!                               ^
  --
  -- check multi-row VALUES in rules
  --
***************
*** 2868,2881 ****
                                   Table "public.rules_src"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  f1     | integer |           |          |         | plain   |              | 
   f2     | integer |           |          |         | plain   |              | 
  Rules:
      r1 AS
      ON UPDATE TO rules_src DO  INSERT INTO rules_log (f1, f2, tag) VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
      r2 AS
      ON UPDATE TO rules_src DO  VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
! Distribute By: HASH(f1)
  Location Nodes: ALL DATANODES
  
  --
--- 2825,2838 ----
                                   Table "public.rules_src"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  f1     | integer |           | not null |         | plain   |              | 
   f2     | integer |           |          |         | plain   |              | 
  Rules:
      r1 AS
      ON UPDATE TO rules_src DO  INSERT INTO rules_log (f1, f2, tag) VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
      r2 AS
      ON UPDATE TO rules_src DO  VALUES (old.f1,old.f2,'old'::text), (new.f1,new.f2,'new'::text)
! Distribute By: SHARD(f1)
  Location Nodes: ALL DATANODES
  
  --
***************
*** 2887,2893 ****
                                   Table "public.rules_src"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  f1     | integer |           |          |         | plain   |              | 
   f2     | integer |           |          |         | plain   |              | 
  Rules:
      r1 AS
--- 2844,2850 ----
                                   Table "public.rules_src"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  f1     | integer |           | not null |         | plain   |              | 
   f2     | integer |           |          |         | plain   |              | 
  Rules:
      r1 AS
***************
*** 2902,2908 ****
      r5 AS
      ON UPDATE TO rules_src DO INSTEAD  UPDATE rules_log trgt SET tag = 'updated'::text
    WHERE trgt.f1 = new.f1
! Distribute By: HASH(f1)
  Location Nodes: ALL DATANODES
  
  --
--- 2859,2865 ----
      r5 AS
      ON UPDATE TO rules_src DO INSTEAD  UPDATE rules_log trgt SET tag = 'updated'::text
    WHERE trgt.f1 = new.f1
! Distribute By: SHARD(f1)
  Location Nodes: ALL DATANODES
  
  --
***************
*** 2939,2949 ****
  -- error conditions for alter rename rule
  --
  ALTER RULE InsertRule ON rule_v1 RENAME TO NewInsertRule; -- doesn't exist
! ERROR:  rule "insertrule" for relation "rule_v1" does not exist
  ALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN"; -- already exists
! ERROR:  rule "_RETURN" for relation "rule_v1" already exists
  ALTER RULE "_RETURN" ON rule_v1 RENAME TO abc; -- ON SELECT rule cannot be renamed
! ERROR:  renaming an ON SELECT rule is not allowed
  DROP VIEW rule_v1;
  DROP TABLE rule_t1;
  --
--- 2896,2906 ----
  -- error conditions for alter rename rule
  --
  ALTER RULE InsertRule ON rule_v1 RENAME TO NewInsertRule; -- doesn't exist
! ERROR:  node:datanode_2, backend_pid:383286, nodename:coord2,backend_pid:383265,message:rule "insertrule" for relation "rule_v1" does not exist
  ALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN"; -- already exists
! ERROR:  node:datanode_2, backend_pid:383286, nodename:coord2,backend_pid:383265,message:rule "_RETURN" for relation "rule_v1" already exists
  ALTER RULE "_RETURN" ON rule_v1 RENAME TO abc; -- ON SELECT rule cannot be renamed
! ERROR:  node:datanode_1, backend_pid:383283, nodename:coord2,backend_pid:383265,message:renaming an ON SELECT rule is not allowed
  DROP VIEW rule_v1;
  DROP TABLE rule_t1;
  --
***************
*** 3203,3209 ****
             ->  Remote Subquery Scan on all
                   ->  Values Scan on "*VALUES*"
           ->  Remote Subquery Scan on all
!                Distribute results by H: hat_name
                 ->  CTE Scan on data
  (11 rows)
  
--- 3160,3166 ----
             ->  Remote Subquery Scan on all
                   ->  Values Scan on "*VALUES*"
           ->  Remote Subquery Scan on all
!                Distribute results by S: hat_name
                 ->  CTE Scan on data
  (11 rows)
  

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/psql_crosstab.out"	2025-07-31 16:07:14.997067946 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/psql_crosstab.out"	2025-07-31 16:39:42.143809542 +0800
***************
*** 10,50 ****
     ('v0','h4','dbl', -3, '2014-12-15'),
     ('v0',NULL,'qux', 5, '2014-07-15'),
     ('v1','h2','quux',7, '2015-04-04');
  -- make plans more stable
  ANALYZE ctv_data;
  -- running \crosstabview after query uses query in buffer
  SELECT v, EXTRACT(year FROM d), count(*)
   FROM ctv_data
   GROUP BY 1, 2
   ORDER BY 1, 2;
!  v  | date_part | count 
! ----+-----------+-------
!  v0 |      2014 |     2
!  v0 |      2015 |     1
!  v1 |      2015 |     3
!  v2 |      2015 |     1
! (4 rows)
! 
  -- basic usage with 3 columns
   \crosstabview
!  v  | 2014 | 2015 
! ----+------+------
!  v0 |    2 |    1
!  v1 |      |    3
!  v2 |      |    1
! (3 rows)
! 
  -- ordered months in horizontal header, quoted column name
  SELECT v, to_char(d, 'Mon') AS "month name", EXTRACT(month FROM d) AS num,
   count(*) FROM ctv_data  GROUP BY 1,2,3 ORDER BY 1
   \crosstabview v "month name" 4 num
!  v  | Jan | Apr | Jul | Dec 
! ----+-----+-----+-----+-----
!  v0 |     |     |   2 |   1
!  v1 |     |   2 |   1 |    
!  v2 |   1 |     |     |    
! (3 rows)
! 
  -- ordered months in vertical header, ordered years in horizontal header
  SELECT EXTRACT(year FROM d) AS year, to_char(d,'Mon') AS """month"" name",
    EXTRACT(month FROM d) AS month,
--- 10,40 ----
     ('v0','h4','dbl', -3, '2014-12-15'),
     ('v0',NULL,'qux', 5, '2014-07-15'),
     ('v1','h2','quux',7, '2015-04-04');
+ ERROR:  node:datanode_1, backend_pid:383271, nodename:datanode_1,backend_pid:383271,message:null value in column "v" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, null, null, null).
  -- make plans more stable
  ANALYZE ctv_data;
+ ERROR:  node:datanode_2, backend_pid:383284, nodename:datanode_1,backend_pid:383271,message:relation "ctv_data" does not exist
  -- running \crosstabview after query uses query in buffer
  SELECT v, EXTRACT(year FROM d), count(*)
   FROM ctv_data
   GROUP BY 1, 2
   ORDER BY 1, 2;
! ERROR:  relation "ctv_data" does not exist
! LINE 2:  FROM ctv_data
!               ^
  -- basic usage with 3 columns
   \crosstabview
! ERROR:  relation "ctv_data" does not exist
! LINE 2:  FROM ctv_data
!               ^
  -- ordered months in horizontal header, quoted column name
  SELECT v, to_char(d, 'Mon') AS "month name", EXTRACT(month FROM d) AS num,
   count(*) FROM ctv_data  GROUP BY 1,2,3 ORDER BY 1
   \crosstabview v "month name" 4 num
! ERROR:  relation "ctv_data" does not exist
! LINE 2:  count(*) FROM ctv_data  GROUP BY 1,2,3 ORDER BY 1
!                        ^
  -- ordered months in vertical header, ordered years in horizontal header
  SELECT EXTRACT(year FROM d) AS year, to_char(d,'Mon') AS """month"" name",
    EXTRACT(month FROM d) AS month,
***************
*** 53,117 ****
    GROUP BY EXTRACT(year FROM d), to_char(d,'Mon'), EXTRACT(month FROM d)
  ORDER BY month
  \crosstabview """month"" name" year format year
!  "month" name |      2014       |      2015      
! --------------+-----------------+----------------
!  Jan          |                 | sum=3 avg=3.0
!  Apr          |                 | sum=10 avg=5.0
!  Jul          | sum=5 avg=5.0   | sum=4 avg=4.0
!  Dec          | sum=-3 avg=-3.0 | 
! (4 rows)
! 
  -- combine contents vertically into the same cell (V/H duplicates)
  SELECT v, h, string_agg(c, E'\n') FROM ctv_data GROUP BY v, h ORDER BY 1,2,3
   \crosstabview 1 2 3
!  v  | h4  |     | h0  |  h2  | h1  
! ----+-----+-----+-----+------+-----
!  v0 | qux+| qux |     |      | 
!     | dbl |     |     |      | 
!  v1 |     |     | baz | foo +| 
!     |     |     |     | quux | 
!  v2 |     |     |     |      | bar
! (3 rows)
! 
  -- horizontal ASC order from window function
  SELECT v,h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h) AS r
  FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
   \crosstabview v h c r
!  v  | h0  | h1  |  h2  | h4  |     
! ----+-----+-----+------+-----+-----
!  v0 |     |     |      | qux+| qux
!     |     |     |      | dbl | 
!  v1 | baz |     | foo +|     | 
!     |     |     | quux |     | 
!  v2 |     | bar |      |     | 
! (3 rows)
! 
  -- horizontal DESC order from window function
  SELECT v, h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h DESC) AS r
  FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
   \crosstabview v h c r
!  v  |     | h4  |  h2  | h1  | h0  
! ----+-----+-----+------+-----+-----
!  v0 | qux | qux+|      |     | 
!     |     | dbl |      |     | 
!  v1 |     |     | foo +|     | baz
!     |     |     | quux |     | 
!  v2 |     |     |      | bar | 
! (3 rows)
! 
  -- horizontal ASC order from window function, NULLs pushed rightmost
  SELECT v,h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h NULLS LAST) AS r
  FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
   \crosstabview v h c r
!  v  | h0  | h1  |  h2  | h4  |     
! ----+-----+-----+------+-----+-----
!  v0 |     |     |      | qux+| qux
!     |     |     |      | dbl | 
!  v1 | baz |     | foo +|     | 
!     |     |     | quux |     | 
!  v2 |     | bar |      |     | 
! (3 rows)
! 
  -- only null, no column name, 2 columns: error
  SELECT null,null \crosstabview
  \crosstabview: query must return at least three columns
--- 43,78 ----
    GROUP BY EXTRACT(year FROM d), to_char(d,'Mon'), EXTRACT(month FROM d)
  ORDER BY month
  \crosstabview """month"" name" year format year
! ERROR:  relation "ctv_data" does not exist
! LINE 4:   FROM ctv_data
!                ^
  -- combine contents vertically into the same cell (V/H duplicates)
  SELECT v, h, string_agg(c, E'\n') FROM ctv_data GROUP BY v, h ORDER BY 1,2,3
   \crosstabview 1 2 3
! ERROR:  relation "ctv_data" does not exist
! LINE 1: SELECT v, h, string_agg(c, E'\n') FROM ctv_data GROUP BY v, ...
!                                                ^
  -- horizontal ASC order from window function
  SELECT v,h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h) AS r
  FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
   \crosstabview v h c r
! ERROR:  relation "ctv_data" does not exist
! LINE 2: FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
!              ^
  -- horizontal DESC order from window function
  SELECT v, h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h DESC) AS r
  FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
   \crosstabview v h c r
! ERROR:  relation "ctv_data" does not exist
! LINE 2: FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
!              ^
  -- horizontal ASC order from window function, NULLs pushed rightmost
  SELECT v,h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h NULLS LAST) AS r
  FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
   \crosstabview v h c r
! ERROR:  relation "ctv_data" does not exist
! LINE 2: FROM ctv_data GROUP BY v, h ORDER BY 1,3,2
!              ^
  -- only null, no column name, 2 columns: error
  SELECT null,null \crosstabview
  \crosstabview: query must return at least three columns
***************
*** 127,170 ****
  SELECT v,h, string_agg(i::text, E'\n') AS i FROM ctv_data
  GROUP BY v, h ORDER BY h,v
   \crosstabview v h i
!  v  |   h0   | h1 | h2 | h4 | #null# 
! ----+--------+----+----+----+--------
!  v1 | #null# |    | 3 +|    | 
!     |        |    | 7  |    | 
!  v2 |        | 3  |    |    | 
!  v0 |        |    |    | 4 +| 5
!     |        |    |    | -3 | 
! (3 rows)
! 
  \pset null ''
  -- refer to columns by position
  SELECT v,h,string_agg(i::text, E'\n'), string_agg(c, E'\n')
  FROM ctv_data GROUP BY v, h ORDER BY h,v
   \crosstabview 2 1 4
!  h  |  v1  | v2  | v0  
! ----+------+-----+-----
!  h0 | baz  |     | 
!  h1 |      | bar | 
!  h2 | foo +|     | 
!     | quux |     | 
!  h4 |      |     | qux+
!     |      |     | dbl
!     |      |     | qux
! (5 rows)
! 
  -- refer to columns by positions and names mixed
  SELECT v,h, string_agg(i::text, E'\n') AS i, string_agg(c, E'\n') AS c
  FROM ctv_data GROUP BY v, h ORDER BY h,v
   \crosstabview 1 "h" 4
!  v  | h0  | h1  |  h2  | h4  |     
! ----+-----+-----+------+-----+-----
!  v1 | baz |     | foo +|     | 
!     |     |     | quux |     | 
!  v2 |     | bar |      |     | 
!  v0 |     |     |      | qux+| qux
!     |     |     |      | dbl | 
! (3 rows)
! 
  -- refer to columns by quoted names, check downcasing of unquoted name
  SELECT 1 as "22", 2 as b, 3 as "Foo"
   \crosstabview "22" B "Foo"
--- 88,111 ----
  SELECT v,h, string_agg(i::text, E'\n') AS i FROM ctv_data
  GROUP BY v, h ORDER BY h,v
   \crosstabview v h i
! ERROR:  relation "ctv_data" does not exist
! LINE 1: SELECT v,h, string_agg(i::text, E'\n') AS i FROM ctv_data
!                                                          ^
  \pset null ''
  -- refer to columns by position
  SELECT v,h,string_agg(i::text, E'\n'), string_agg(c, E'\n')
  FROM ctv_data GROUP BY v, h ORDER BY h,v
   \crosstabview 2 1 4
! ERROR:  relation "ctv_data" does not exist
! LINE 2: FROM ctv_data GROUP BY v, h ORDER BY h,v
!              ^
  -- refer to columns by positions and names mixed
  SELECT v,h, string_agg(i::text, E'\n') AS i, string_agg(c, E'\n') AS c
  FROM ctv_data GROUP BY v, h ORDER BY h,v
   \crosstabview 1 "h" 4
! ERROR:  relation "ctv_data" does not exist
! LINE 2: FROM ctv_data GROUP BY v, h ORDER BY h,v
!              ^
  -- refer to columns by quoted names, check downcasing of unquoted name
  SELECT 1 as "22", 2 as b, 3 as "Foo"
   \crosstabview "22" B "Foo"
***************
*** 176,182 ****
  -- error: bad column name
  SELECT v,h,c,i FROM ctv_data
   \crosstabview v h j
! \crosstabview: column name not found: "j"
  -- error: need to quote name
  SELECT 1 as "22", 2 as b, 3 as "Foo"
   \crosstabview 1 2 Foo
--- 117,125 ----
  -- error: bad column name
  SELECT v,h,c,i FROM ctv_data
   \crosstabview v h j
! ERROR:  relation "ctv_data" does not exist
! LINE 1: SELECT v,h,c,i FROM ctv_data
!                             ^
  -- error: need to quote name
  SELECT 1 as "22", 2 as b, 3 as "Foo"
   \crosstabview 1 2 Foo
***************
*** 188,198 ****
  -- error: bad column number
  SELECT v,h,i,c FROM ctv_data
   \crosstabview 2 1 5
! \crosstabview: column number 5 is out of range 1..4
  -- error: same H and V columns
  SELECT v,h,i,c FROM ctv_data
   \crosstabview 2 h 4
! \crosstabview: vertical and horizontal headers must be different columns
  -- error: too many columns
  SELECT a,a,1 FROM generate_series(1,3000) AS a
   \crosstabview
--- 131,145 ----
  -- error: bad column number
  SELECT v,h,i,c FROM ctv_data
   \crosstabview 2 1 5
! ERROR:  relation "ctv_data" does not exist
! LINE 1: SELECT v,h,i,c FROM ctv_data
!                             ^
  -- error: same H and V columns
  SELECT v,h,i,c FROM ctv_data
   \crosstabview 2 h 4
! ERROR:  relation "ctv_data" does not exist
! LINE 1: SELECT v,h,i,c FROM ctv_data
!                             ^
  -- error: too many columns
  SELECT a,a,1 FROM generate_series(1,3000) AS a
   \crosstabview
***************
*** 201,206 ****
--- 148,154 ----
  SELECT 1 \crosstabview
  \crosstabview: query must return at least three columns
  DROP TABLE ctv_data;
+ ERROR:  table "ctv_data" does not exist
  -- check error reporting (bug #14476)
  CREATE TABLE ctv_data (x int, y int, v text);
  INSERT INTO ctv_data SELECT 1, x, '*' || x FROM generate_series(1,10) x;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/select_parallel_4.out"	2025-07-31 16:07:15.001067882 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/select_parallel.out"	2025-07-31 16:39:47.597693568 +0800
***************
*** 20,26 ****
   Finalize Aggregate
     ->  Remote Subquery Scan on all (datanode_1,datanode_2)
           ->  Gather
!                Workers Planned: 1
                 ->  Partial Aggregate
                       ->  Append
                             ->  Parallel Seq Scan on a_star
--- 20,26 ----
   Finalize Aggregate
     ->  Remote Subquery Scan on all (datanode_1,datanode_2)
           ->  Gather
!                Workers Planned: 3
                 ->  Partial Aggregate
                       ->  Append
                             ->  Parallel Seq Scan on a_star
***************
*** 386,392 ****
  -- provoke error in worker
  SAVEPOINT settings;
  select stringu1::int2 from tenk1 where unique1 = 1;
! ERROR:  invalid input syntax for integer: "BAAAAA"
  ROLLBACK TO SAVEPOINT settings;
  -- test interaction with set-returning functions
  SAVEPOINT settings;
--- 386,392 ----
  -- provoke error in worker
  SAVEPOINT settings;
  select stringu1::int2 from tenk1 where unique1 = 1;
! ERROR:  node:datanode_1, backend_pid:383271, nodename:datanode_1,backend_pid:383271,message:invalid input syntax for integer: "BAAAAA"
  ROLLBACK TO SAVEPOINT settings;
  -- test interaction with set-returning functions
  SAVEPOINT settings;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/publication.out"	2025-07-31 16:07:14.997067946 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/publication.out"	2025-07-31 16:39:47.867687830 +0800
***************
*** 79,85 ****
   data   | text    |           |          |                                          | extended |              | 
  Indexes:
      "testpub_tbl2_pkey" PRIMARY KEY, btree (id)
! Distribute By: HASH(id)
  Location Nodes: ALL DATANODES
  
  \dRp+ testpub_foralltables
--- 79,85 ----
   data   | text    |           |          |                                          | extended |              | 
  Indexes:
      "testpub_tbl2_pkey" PRIMARY KEY, btree (id)
! Distribute By: SHARD(id)
  Location Nodes: ALL DATANODES
  
  \dRp+ testpub_foralltables
***************
*** 133,141 ****
                                Table "pub_test.testpub_nopk"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  foo    | integer |           |          |         | plain   |              | 
   bar    | integer |           |          |         | plain   |              | 
! Distribute By: HASH(foo)
  Location Nodes: ALL DATANODES
  
  \d+ testpub_tbl1
--- 133,141 ----
                                Table "pub_test.testpub_nopk"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  foo    | integer |           | not null |         | plain   |              | 
   bar    | integer |           |          |         | plain   |              | 
! Distribute By: SHARD(foo)
  Location Nodes: ALL DATANODES
  
  \d+ testpub_tbl1
***************
*** 146,152 ****
   data   | text    |           |          |                                          | extended |              | 
  Indexes:
      "testpub_tbl1_pkey" PRIMARY KEY, btree (id)
! Distribute By: HASH(id)
  Location Nodes: ALL DATANODES
  
  \dRp+ testpub_default
--- 146,152 ----
   data   | text    |           |          |                                          | extended |              | 
  Indexes:
      "testpub_tbl1_pkey" PRIMARY KEY, btree (id)
! Distribute By: SHARD(id)
  Location Nodes: ALL DATANODES
  
  \dRp+ testpub_default
***************
*** 163,169 ****
   data   | text    |           |          |                                          | extended |              | 
  Indexes:
      "testpub_tbl1_pkey" PRIMARY KEY, btree (id)
! Distribute By: HASH(id)
  Location Nodes: ALL DATANODES
  
  -- permissions
--- 163,169 ----
   data   | text    |           |          |                                          | extended |              | 
  Indexes:
      "testpub_tbl1_pkey" PRIMARY KEY, btree (id)
! Distribute By: SHARD(id)
  Location Nodes: ALL DATANODES
  
  -- permissions
***************
*** 195,204 ****
  -- fail - must be owner of publication
  SET ROLE regress_publication_user_dummy;
  ALTER PUBLICATION testpub_default RENAME TO testpub_dummy;
! ERROR:  publication "testpub_default" does not exist
  RESET ROLE;
  ALTER PUBLICATION testpub_default RENAME TO testpub_foo;
! ERROR:  publication "testpub_default" does not exist
  \dRp testpub_foo
                    List of publications
   Name | Owner | All tables | Inserts | Updates | Deletes 
--- 195,204 ----
  -- fail - must be owner of publication
  SET ROLE regress_publication_user_dummy;
  ALTER PUBLICATION testpub_default RENAME TO testpub_dummy;
! ERROR:  node:datanode_2, backend_pid:383377, nodename:coord2,backend_pid:383262,message:publication "testpub_default" does not exist
  RESET ROLE;
  ALTER PUBLICATION testpub_default RENAME TO testpub_foo;
! ERROR:  node:datanode_2, backend_pid:383377, nodename:coord2,backend_pid:383262,message:publication "testpub_default" does not exist
  \dRp testpub_foo
                    List of publications
   Name | Owner | All tables | Inserts | Updates | Deletes 
***************
*** 207,213 ****
  
  -- rename back to keep the rest simple
  ALTER PUBLICATION testpub_foo RENAME TO testpub_default;
! ERROR:  publication "testpub_foo" does not exist
  ALTER PUBLICATION testpub_default OWNER TO regress_publication_user2;
  ERROR:  publication "testpub_default" does not exist
  \dRp testpub_default
--- 207,213 ----
  
  -- rename back to keep the rest simple
  ALTER PUBLICATION testpub_foo RENAME TO testpub_default;
! ERROR:  node:datanode_2, backend_pid:383377, nodename:coord2,backend_pid:383262,message:publication "testpub_foo" does not exist
  ALTER PUBLICATION testpub_default OWNER TO regress_publication_user2;
  ERROR:  publication "testpub_default" does not exist
  \dRp testpub_default

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/subscription.out"	2025-07-31 16:07:15.003067850 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/subscription.out"	2025-07-31 16:39:47.739690550 +0800
***************
*** 141,150 ****
  -- fail - must be owner of subscription
  SET ROLE regress_subscription_user_dummy;
  ALTER SUBSCRIPTION testsub RENAME TO testsub_dummy;
! ERROR:  subscription "testsub" does not exist
  RESET ROLE;
  ALTER SUBSCRIPTION testsub RENAME TO testsub_foo;
! ERROR:  subscription "testsub" does not exist
  ALTER SUBSCRIPTION testsub_foo SET (synchronous_commit = local);
  ERROR:  COORDINATOR only supports ALTER OPENTENBASE SUBSCRIPTION
  DETAIL:  The feature is not currently supported
--- 141,150 ----
  -- fail - must be owner of subscription
  SET ROLE regress_subscription_user_dummy;
  ALTER SUBSCRIPTION testsub RENAME TO testsub_dummy;
! ERROR:  node:datanode_2, backend_pid:383377, nodename:coord2,backend_pid:383264,message:subscription "testsub" does not exist
  RESET ROLE;
  ALTER SUBSCRIPTION testsub RENAME TO testsub_foo;
! ERROR:  node:datanode_2, backend_pid:383377, nodename:coord2,backend_pid:383264,message:subscription "testsub" does not exist
  ALTER SUBSCRIPTION testsub_foo SET (synchronous_commit = local);
  ERROR:  COORDINATOR only supports ALTER OPENTENBASE SUBSCRIPTION
  DETAIL:  The feature is not currently supported
***************
*** 159,165 ****
  
  -- rename back to keep the rest simple
  ALTER SUBSCRIPTION testsub_foo RENAME TO testsub;
! ERROR:  subscription "testsub_foo" does not exist
  -- fail - new owner must be superuser
  ALTER SUBSCRIPTION testsub OWNER TO regress_subscription_user2;
  ERROR:  subscription "testsub" does not exist
--- 159,165 ----
  
  -- rename back to keep the rest simple
  ALTER SUBSCRIPTION testsub_foo RENAME TO testsub;
! ERROR:  node:datanode_2, backend_pid:383284, nodename:coord2,backend_pid:383262,message:subscription "testsub_foo" does not exist
  -- fail - new owner must be superuser
  ALTER SUBSCRIPTION testsub OWNER TO regress_subscription_user2;
  ERROR:  subscription "testsub" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/select_views.out"	2025-07-31 16:07:15.002067866 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/select_views.out"	2025-07-31 16:39:49.651494377 +0800
***************
*** 1265,1275 ****
--- 1265,1277 ----
         cnum     text,
         climit   int
  );
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  CREATE TABLE credit_usage (
         cid      int references customer(cid),
         ymd      date,
         usage    int
  );
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  INSERT INTO customer
         VALUES (101, 'regress_alice', '+81-12-3456-7890', 'passwd123'),
                (102, 'regress_bob',   '+01-234-567-8901', 'beafsteak'),
***************
*** 1278,1283 ****
--- 1280,1288 ----
         VALUES (101, '1111-2222-3333-4444', 4000),
                (102, '5555-6666-7777-8888', 3000),
                (103, '9801-2345-6789-0123', 2000);
+ ERROR:  relation "credit_card" does not exist
+ LINE 1: INSERT INTO credit_card
+                     ^
  INSERT INTO credit_usage
         VALUES (101, '2011-09-15', 120),
  	      (101, '2011-10-05',  90),
***************
*** 1288,1293 ****
--- 1293,1301 ----
  	      (102, '2011-10-12', 120),
  	      (102, '2011-10-28', 200),
  	      (103, '2011-10-15', 480);
+ ERROR:  relation "credit_usage" does not exist
+ LINE 1: INSERT INTO credit_usage
+                     ^
  CREATE VIEW my_property_normal AS
         SELECT * FROM customer WHERE name = current_user;
  CREATE VIEW my_property_secure WITH (security_barrier) AS
***************
*** 1295,1313 ****
--- 1303,1337 ----
  CREATE VIEW my_credit_card_normal AS
         SELECT * FROM customer l NATURAL JOIN credit_card r
         WHERE l.name = current_user;
+ ERROR:  relation "credit_card" does not exist
+ LINE 2:        SELECT * FROM customer l NATURAL JOIN credit_card r
+                                                      ^
  CREATE VIEW my_credit_card_secure WITH (security_barrier) AS
         SELECT * FROM customer l NATURAL JOIN credit_card r
         WHERE l.name = current_user;
+ ERROR:  relation "credit_card" does not exist
+ LINE 2:        SELECT * FROM customer l NATURAL JOIN credit_card r
+                                                      ^
  CREATE VIEW my_credit_card_usage_normal AS
         SELECT * FROM my_credit_card_secure l NATURAL JOIN credit_usage r;
+ ERROR:  relation "my_credit_card_secure" does not exist
+ LINE 2:        SELECT * FROM my_credit_card_secure l NATURAL JOIN cr...
+                              ^
  CREATE VIEW my_credit_card_usage_secure WITH (security_barrier) AS
         SELECT * FROM my_credit_card_secure l NATURAL JOIN credit_usage r;
+ ERROR:  relation "my_credit_card_secure" does not exist
+ LINE 2:        SELECT * FROM my_credit_card_secure l NATURAL JOIN cr...
+                              ^
  GRANT SELECT ON my_property_normal TO public;
  GRANT SELECT ON my_property_secure TO public;
  GRANT SELECT ON my_credit_card_normal TO public;
+ ERROR:  relation "my_credit_card_normal" does not exist
  GRANT SELECT ON my_credit_card_secure TO public;
+ ERROR:  relation "my_credit_card_secure" does not exist
  GRANT SELECT ON my_credit_card_usage_normal TO public;
+ ERROR:  relation "my_credit_card_usage_normal" does not exist
  GRANT SELECT ON my_credit_card_usage_secure TO public;
+ ERROR:  relation "my_credit_card_usage_secure" does not exist
  --
  -- Run leaky view scenarios
  --
***************
*** 1390,1433 ****
  --           possible as we can.
  --
  SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
!  cid |     name      |       tel        |  passwd   |        cnum         | climit 
! -----+---------------+------------------+-----------+---------------------+--------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000
! (1 row)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Hash Join
!          Hash Cond: (r.cid = l.cid)
!          ->  Seq Scan on credit_card r
!                Filter: f_leak(cnum)
!          ->  Hash
!                ->  Seq Scan on customer l
!                      Filter: (name = (CURRENT_USER)::text)
! (8 rows)
! 
  SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
!  cid |     name      |       tel        |  passwd   |        cnum         | climit 
! -----+---------------+------------------+-----------+---------------------+--------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000
! (1 row)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Subquery Scan on my_credit_card_secure
!          Filter: f_leak(my_credit_card_secure.cnum)
!          ->  Hash Join
!                Hash Cond: (r.cid = l.cid)
!                ->  Seq Scan on credit_card r
!                ->  Hash
!                      ->  Seq Scan on customer l
!                            Filter: (name = (CURRENT_USER)::text)
! (9 rows)
! 
  --
  -- scenario: an external qualifier can be pushed-down by in-front-of the
  --           views with "security_barrier" attribute, except for operators
--- 1414,1434 ----
  --           possible as we can.
  --
  SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
! ERROR:  relation "my_credit_card_normal" does not exist
! LINE 1: SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
! ERROR:  relation "my_credit_card_normal" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_normal WHER...
!                                           ^
  SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
! ERROR:  relation "my_credit_card_secure" does not exist
! LINE 1: SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
! ERROR:  relation "my_credit_card_secure" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_secure WHER...
!                                           ^
  --
  -- scenario: an external qualifier can be pushed-down by in-front-of the
  --           views with "security_barrier" attribute, except for operators
***************
*** 1435,1495 ****
  --
  SELECT * FROM my_credit_card_usage_normal
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
!  cid |     name      |       tel        |  passwd   |        cnum         | climit |    ymd     | usage 
! -----+---------------+------------------+-----------+---------------------+--------+------------+-------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 2011-10-05 |    90
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 2011-10-18 |   110
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 2011-10-21 |   200
! (3 rows)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_normal
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
!                                      QUERY PLAN                                     
! ------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Nested Loop
!          Join Filter: (l.cid = r.cid)
!          ->  Subquery Scan on l
!                Filter: f_leak(l.cnum)
!                ->  Hash Join
!                      Hash Cond: (r_1.cid = l_1.cid)
!                      ->  Seq Scan on credit_card r_1
!                      ->  Hash
!                            ->  Seq Scan on customer l_1
!                                  Filter: (name = (CURRENT_USER)::text)
!          ->  Seq Scan on credit_usage r
!                Filter: ((ymd >= '10-01-2011'::date) AND (ymd < '11-01-2011'::date))
! (13 rows)
! 
  SELECT * FROM my_credit_card_usage_secure
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
!  cid |     name      |       tel        |  passwd   |        cnum         | climit |    ymd     | usage 
! -----+---------------+------------------+-----------+---------------------+--------+------------+-------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 2011-10-05 |    90
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 2011-10-18 |   110
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 2011-10-21 |   200
! (3 rows)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_secure
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
!                                         QUERY PLAN                                        
! ------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Subquery Scan on my_credit_card_usage_secure
!          Filter: f_leak(my_credit_card_usage_secure.cnum)
!          ->  Nested Loop
!                Join Filter: (l.cid = r.cid)
!                ->  Seq Scan on credit_usage r
!                      Filter: ((ymd >= '10-01-2011'::date) AND (ymd < '11-01-2011'::date))
!                ->  Materialize
!                      ->  Hash Join
!                            Hash Cond: (r_1.cid = l.cid)
!                            ->  Seq Scan on credit_card r_1
!                            ->  Hash
!                                  ->  Seq Scan on customer l
!                                        Filter: (name = (CURRENT_USER)::text)
! (14 rows)
! 
  --
  -- Test for the case when security_barrier gets changed between rewriter
  -- and planner stage.
--- 1436,1459 ----
  --
  SELECT * FROM my_credit_card_usage_normal
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! ERROR:  relation "my_credit_card_usage_normal" does not exist
! LINE 1: SELECT * FROM my_credit_card_usage_normal
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_normal
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! ERROR:  relation "my_credit_card_usage_normal" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_norma...
!                                           ^
  SELECT * FROM my_credit_card_usage_secure
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! ERROR:  relation "my_credit_card_usage_secure" does not exist
! LINE 1: SELECT * FROM my_credit_card_usage_secure
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_secure
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! ERROR:  relation "my_credit_card_usage_secure" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_secur...
!                                           ^
  --
  -- Test for the case when security_barrier gets changed between rewriter
  -- and planner stage.

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/foreign_key_2.out"	2025-07-31 16:07:14.983068168 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/foreign_key.out"	2025-07-31 16:39:51.755343174 +0800
***************
*** 7,12 ****
--- 7,13 ----
  --
  CREATE TABLE PKTABLE ( ptest1 int PRIMARY KEY, ptest2 text ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int REFERENCES PKTABLE MATCH FULL ON DELETE CASCADE ON UPDATE CASCADE, ftest2 int );
+ ERROR:  corrupted catalog, no shard group of 0 found
  -- Insert test data into PKTABLE
  INSERT INTO PKTABLE VALUES (1, 'Test1');
  INSERT INTO PKTABLE VALUES (2, 'Test2');
***************
*** 15,60 ****
  INSERT INTO PKTABLE VALUES (5, 'Test5');
  -- Insert successful rows into FK TABLE
  INSERT INTO FKTABLE VALUES (1, 2);
  INSERT INTO FKTABLE VALUES (2, 3);
  INSERT INTO FKTABLE VALUES (3, 4);
  INSERT INTO FKTABLE VALUES (NULL, 1);
  -- Insert a failed row into FK TABLE
  INSERT INTO FKTABLE VALUES (100, 2);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(100) is not present in table "pktable".
  -- Check FKTABLE
  SELECT * FROM FKTABLE ORDER BY 1, 2;
!  ftest1 | ftest2 
! --------+--------
!       1 |      2
!       2 |      3
!       3 |      4
!         |      1
! (4 rows)
! 
  -- Delete a row from PK TABLE
  DELETE FROM PKTABLE WHERE ptest1=1;
  -- Check FKTABLE for removal of matched row
  SELECT * FROM FKTABLE ORDER BY 1, 2;
!  ftest1 | ftest2 
! --------+--------
!       2 |      3
!       3 |      4
!         |      1
! (3 rows)
! 
  -- Update a row from PK TABLE
  UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
  -- Check FKTABLE for update of matched row
  SELECT * FROM FKTABLE ORDER BY 1, 2;
!  ftest1 | ftest2 
! --------+--------
!       1 |      3
!       3 |      4
!         |      1
! (3 rows)
! 
  DROP TABLE FKTABLE;
  DROP TABLE PKTABLE;
  --
  -- check set NULL and table constraint on multiple columns
--- 16,62 ----
  INSERT INTO PKTABLE VALUES (5, 'Test5');
  -- Insert successful rows into FK TABLE
  INSERT INTO FKTABLE VALUES (1, 2);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (1, 2);
+                     ^
  INSERT INTO FKTABLE VALUES (2, 3);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (2, 3);
+                     ^
  INSERT INTO FKTABLE VALUES (3, 4);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (3, 4);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 1);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 1);
+                     ^
  -- Insert a failed row into FK TABLE
  INSERT INTO FKTABLE VALUES (100, 2);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (100, 2);
!                     ^
  -- Check FKTABLE
  SELECT * FROM FKTABLE ORDER BY 1, 2;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2;
!                       ^
  -- Delete a row from PK TABLE
  DELETE FROM PKTABLE WHERE ptest1=1;
  -- Check FKTABLE for removal of matched row
  SELECT * FROM FKTABLE ORDER BY 1, 2;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2;
!                       ^
  -- Update a row from PK TABLE
  UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
  -- Check FKTABLE for update of matched row
  SELECT * FROM FKTABLE ORDER BY 1, 2;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2;
!                       ^
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  DROP TABLE PKTABLE;
  --
  -- check set NULL and table constraint on multiple columns
***************
*** 62,72 ****
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, CONSTRAINT constrname FOREIGN KEY(ftest1, ftest2)
                         REFERENCES PKTABLE MATCH FULL ON DELETE SET NULL ON UPDATE SET NULL);
  -- Test comments
  COMMENT ON CONSTRAINT constrname_wrong ON FKTABLE IS 'fk constraint comment';
! ERROR:  constraint "constrname_wrong" for table "fktable" does not exist
  COMMENT ON CONSTRAINT constrname ON FKTABLE IS 'fk constraint comment';
  COMMENT ON CONSTRAINT constrname ON FKTABLE IS NULL;
  -- Insert test data into PKTABLE
  INSERT INTO PKTABLE VALUES (1, 2, 'Test1');
  INSERT INTO PKTABLE VALUES (1, 3, 'Test1-2');
--- 64,77 ----
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, CONSTRAINT constrname FOREIGN KEY(ftest1, ftest2)
                         REFERENCES PKTABLE MATCH FULL ON DELETE SET NULL ON UPDATE SET NULL);
+ ERROR:  corrupted catalog, no shard group of 0 found
  -- Test comments
  COMMENT ON CONSTRAINT constrname_wrong ON FKTABLE IS 'fk constraint comment';
! ERROR:  relation "fktable" does not exist
  COMMENT ON CONSTRAINT constrname ON FKTABLE IS 'fk constraint comment';
+ ERROR:  relation "fktable" does not exist
  COMMENT ON CONSTRAINT constrname ON FKTABLE IS NULL;
+ ERROR:  relation "fktable" does not exist
  -- Insert test data into PKTABLE
  INSERT INTO PKTABLE VALUES (1, 2, 'Test1');
  INSERT INTO PKTABLE VALUES (1, 3, 'Test1-2');
***************
*** 76,151 ****
  INSERT INTO PKTABLE VALUES (5, 10, 'Test5');
  -- Insert successful rows into FK TABLE
  INSERT INTO FKTABLE VALUES (1, 2, 4);
  INSERT INTO FKTABLE VALUES (1, 3, 5);
  INSERT INTO FKTABLE VALUES (2, 4, 8);
  INSERT INTO FKTABLE VALUES (3, 6, 12);
  INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
  -- Insert failed rows into FK TABLE
  INSERT INTO FKTABLE VALUES (100, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  Key (ftest1, ftest2)=(100, 2) is not present in table "pktable".
  INSERT INTO FKTABLE VALUES (2, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  Key (ftest1, ftest2)=(2, 2) is not present in table "pktable".
  INSERT INTO FKTABLE VALUES (NULL, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
  INSERT INTO FKTABLE VALUES (1, NULL, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
  -- Check FKTABLE
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      2 |      4
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
! (5 rows)
! 
  -- Delete a row from PK TABLE
  DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
  -- Check FKTABLE for removal of matched row
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
!         |        |      4
! (5 rows)
! 
  -- Delete another row from PK TABLE
  DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
  -- Check FKTABLE (should be no change)
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
!         |        |      4
! (5 rows)
! 
  -- Update a row from PK TABLE
  UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
  -- Check FKTABLE for update of matched row
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       3 |      6 |     12
!         |        |      0
!         |        |      4
!         |        |      8
! (5 rows)
! 
  -- Try altering the column type where foreign keys are involved
  ALTER TABLE PKTABLE ALTER COLUMN ptest1 TYPE bigint;
  ALTER TABLE FKTABLE ALTER COLUMN ftest1 TYPE bigint;
  SELECT * FROM PKTABLE ORDER BY 1, 2, 3;
   ptest1 | ptest2 | ptest3  
  --------+--------+---------
--- 81,152 ----
  INSERT INTO PKTABLE VALUES (5, 10, 'Test5');
  -- Insert successful rows into FK TABLE
  INSERT INTO FKTABLE VALUES (1, 2, 4);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (1, 2, 4);
+                     ^
  INSERT INTO FKTABLE VALUES (1, 3, 5);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (1, 3, 5);
+                     ^
  INSERT INTO FKTABLE VALUES (2, 4, 8);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (2, 4, 8);
+                     ^
  INSERT INTO FKTABLE VALUES (3, 6, 12);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (3, 6, 12);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
+                     ^
  -- Insert failed rows into FK TABLE
  INSERT INTO FKTABLE VALUES (100, 2, 4);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (100, 2, 4);
!                     ^
  INSERT INTO FKTABLE VALUES (2, 2, 4);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (2, 2, 4);
!                     ^
  INSERT INTO FKTABLE VALUES (NULL, 2, 4);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (NULL, 2, 4);
!                     ^
  INSERT INTO FKTABLE VALUES (1, NULL, 4);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (1, NULL, 4);
!                     ^
  -- Check FKTABLE
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!                       ^
  -- Delete a row from PK TABLE
  DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
  -- Check FKTABLE for removal of matched row
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!                       ^
  -- Delete another row from PK TABLE
  DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
  -- Check FKTABLE (should be no change)
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!                       ^
  -- Update a row from PK TABLE
  UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
  -- Check FKTABLE for update of matched row
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!                       ^
  -- Try altering the column type where foreign keys are involved
  ALTER TABLE PKTABLE ALTER COLUMN ptest1 TYPE bigint;
  ALTER TABLE FKTABLE ALTER COLUMN ftest1 TYPE bigint;
+ ERROR:  relation "fktable" does not exist
  SELECT * FROM PKTABLE ORDER BY 1, 2, 3;
   ptest1 | ptest2 | ptest3  
  --------+--------+---------
***************
*** 156,179 ****
  (4 rows)
  
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      3 |      5
!       3 |      6 |     12
!         |        |      0
!         |        |      4
!         |        |      8
! (5 rows)
! 
  DROP TABLE PKTABLE CASCADE;
- NOTICE:  drop cascades to constraint constrname on table fktable
  DROP TABLE FKTABLE;
  --
  -- check set default and table constraint on multiple columns
  --
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int DEFAULT -1, ftest2 int DEFAULT -2, ftest3 int, CONSTRAINT constrname2 FOREIGN KEY(ftest1, ftest2)
                         REFERENCES PKTABLE MATCH FULL ON DELETE SET DEFAULT ON UPDATE SET DEFAULT);
  -- Insert a value in PKTABLE for default
  INSERT INTO PKTABLE VALUES (-1, -2, 'The Default!');
  -- Insert test data into PKTABLE
--- 157,175 ----
  (4 rows)
  
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!                       ^
  DROP TABLE PKTABLE CASCADE;
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  --
  -- check set default and table constraint on multiple columns
  --
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 text, PRIMARY KEY(ptest1, ptest2) ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int DEFAULT -1, ftest2 int DEFAULT -2, ftest3 int, CONSTRAINT constrname2 FOREIGN KEY(ftest1, ftest2)
                         REFERENCES PKTABLE MATCH FULL ON DELETE SET DEFAULT ON UPDATE SET DEFAULT);
+ ERROR:  corrupted catalog, no shard group of 0 found
  -- Insert a value in PKTABLE for default
  INSERT INTO PKTABLE VALUES (-1, -2, 'The Default!');
  -- Insert test data into PKTABLE
***************
*** 185,270 ****
  INSERT INTO PKTABLE VALUES (5, 10, 'Test5');
  -- Insert successful rows into FK TABLE
  INSERT INTO FKTABLE VALUES (1, 2, 4);
  INSERT INTO FKTABLE VALUES (1, 3, 5);
  INSERT INTO FKTABLE VALUES (2, 4, 8);
  INSERT INTO FKTABLE VALUES (3, 6, 12);
  INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
  -- Insert failed rows into FK TABLE
  INSERT INTO FKTABLE VALUES (100, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  Key (ftest1, ftest2)=(100, 2) is not present in table "pktable".
  INSERT INTO FKTABLE VALUES (2, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  Key (ftest1, ftest2)=(2, 2) is not present in table "pktable".
  INSERT INTO FKTABLE VALUES (NULL, 2, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
  INSERT INTO FKTABLE VALUES (1, NULL, 4);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
! DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
  -- Check FKTABLE
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!       1 |      2 |      4
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
! (5 rows)
! 
  -- Delete a row from PK TABLE
  DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
  -- Check FKTABLE to check for removal
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!      -1 |     -2 |      4
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
! (5 rows)
! 
  -- Delete another row from PK TABLE
  DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
  -- Check FKTABLE (should be no change)
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!      -1 |     -2 |      4
!       1 |      3 |      5
!       2 |      4 |      8
!       3 |      6 |     12
!         |        |      0
! (5 rows)
! 
  -- Update a row from PK TABLE
  UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
  -- Check FKTABLE for update of matched row
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!  ftest1 | ftest2 | ftest3 
! --------+--------+--------
!      -1 |     -2 |      4
!      -1 |     -2 |      8
!       1 |      3 |      5
!       3 |      6 |     12
!         |        |      0
! (5 rows)
! 
  -- this should fail for lack of CASCADE
  DROP TABLE PKTABLE;
- ERROR:  cannot drop table pktable because other objects depend on it
- DETAIL:  constraint constrname2 on table fktable depends on table pktable
- HINT:  Use DROP ... CASCADE to drop the dependent objects too.
  DROP TABLE PKTABLE CASCADE;
! NOTICE:  drop cascades to constraint constrname2 on table fktable
  DROP TABLE FKTABLE;
  --
  -- First test, check with no on delete or on update
  --
  CREATE TABLE PKTABLE ( ptest1 int PRIMARY KEY, ptest2 text ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int REFERENCES PKTABLE MATCH FULL, ftest2 int ) DISTRIBUTE BY REPLICATION;
  -- Insert test data into PKTABLE
  INSERT INTO PKTABLE VALUES (1, 'Test1');
  INSERT INTO PKTABLE VALUES (2, 'Test2');
--- 181,260 ----
  INSERT INTO PKTABLE VALUES (5, 10, 'Test5');
  -- Insert successful rows into FK TABLE
  INSERT INTO FKTABLE VALUES (1, 2, 4);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (1, 2, 4);
+                     ^
  INSERT INTO FKTABLE VALUES (1, 3, 5);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (1, 3, 5);
+                     ^
  INSERT INTO FKTABLE VALUES (2, 4, 8);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (2, 4, 8);
+                     ^
  INSERT INTO FKTABLE VALUES (3, 6, 12);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (3, 6, 12);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, NULL, 0);
+                     ^
  -- Insert failed rows into FK TABLE
  INSERT INTO FKTABLE VALUES (100, 2, 4);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (100, 2, 4);
!                     ^
  INSERT INTO FKTABLE VALUES (2, 2, 4);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (2, 2, 4);
!                     ^
  INSERT INTO FKTABLE VALUES (NULL, 2, 4);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (NULL, 2, 4);
!                     ^
  INSERT INTO FKTABLE VALUES (1, NULL, 4);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (1, NULL, 4);
!                     ^
  -- Check FKTABLE
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!                       ^
  -- Delete a row from PK TABLE
  DELETE FROM PKTABLE WHERE ptest1=1 and ptest2=2;
  -- Check FKTABLE to check for removal
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!                       ^
  -- Delete another row from PK TABLE
  DELETE FROM PKTABLE WHERE ptest1=5 and ptest2=10;
  -- Check FKTABLE (should be no change)
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!                       ^
  -- Update a row from PK TABLE
  UPDATE PKTABLE SET ptest1=1 WHERE ptest1=2;
  -- Check FKTABLE for update of matched row
  SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2, 3;
!                       ^
  -- this should fail for lack of CASCADE
  DROP TABLE PKTABLE;
  DROP TABLE PKTABLE CASCADE;
! ERROR:  table "pktable" does not exist
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  --
  -- First test, check with no on delete or on update
  --
  CREATE TABLE PKTABLE ( ptest1 int PRIMARY KEY, ptest2 text ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int REFERENCES PKTABLE MATCH FULL, ftest2 int ) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Insert test data into PKTABLE
  INSERT INTO PKTABLE VALUES (1, 'Test1');
  INSERT INTO PKTABLE VALUES (2, 'Test2');
***************
*** 273,295 ****
  INSERT INTO PKTABLE VALUES (5, 'Test5');
  -- Insert successful rows into FK TABLE
  INSERT INTO FKTABLE VALUES (1, 2);
  INSERT INTO FKTABLE VALUES (2, 3);
  INSERT INTO FKTABLE VALUES (3, 4);
  INSERT INTO FKTABLE VALUES (NULL, 1);
  -- Insert a failed row into FK TABLE
  INSERT INTO FKTABLE VALUES (100, 2);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(100) is not present in table "pktable".
  -- Check FKTABLE
  SELECT * FROM FKTABLE ORDER BY 1, 2;
!  ftest1 | ftest2 
! --------+--------
!       1 |      2
!       2 |      3
!       3 |      4
!         |      1
! (4 rows)
! 
  -- Check PKTABLE
  SELECT * FROM PKTABLE ORDER BY 1, 2;
   ptest1 | ptest2 
--- 263,293 ----
  INSERT INTO PKTABLE VALUES (5, 'Test5');
  -- Insert successful rows into FK TABLE
  INSERT INTO FKTABLE VALUES (1, 2);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (1, 2);
+                     ^
  INSERT INTO FKTABLE VALUES (2, 3);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (2, 3);
+                     ^
  INSERT INTO FKTABLE VALUES (3, 4);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (3, 4);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 1);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 1);
+                     ^
  -- Insert a failed row into FK TABLE
  INSERT INTO FKTABLE VALUES (100, 2);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (100, 2);
!                     ^
  -- Check FKTABLE
  SELECT * FROM FKTABLE ORDER BY 1, 2;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * FROM FKTABLE ORDER BY 1, 2;
!                       ^
  -- Check PKTABLE
  SELECT * FROM PKTABLE ORDER BY 1, 2;
   ptest1 | ptest2 
***************
*** 303,345 ****
  
  -- Delete a row from PK TABLE (should fail)
  DELETE FROM PKTABLE WHERE ptest1=1;
- ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
- DETAIL:  Key (ptest1)=(1) is still referenced from table "fktable".
  -- Delete a row from PK TABLE (should succeed)
  DELETE FROM PKTABLE WHERE ptest1=5;
  -- Check PKTABLE for deletes
  SELECT * FROM PKTABLE ORDER BY 1, 2;
   ptest1 | ptest2 
  --------+--------
-       1 | Test1
        2 | Test2
        3 | Test3
        4 | Test4
! (4 rows)
  
  -- Update a row from PK TABLE (should fail)
  UPDATE PKTABLE SET ptest1=0 WHERE ptest1=2;
- ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
- DETAIL:  Key (ptest1)=(2) is still referenced from table "fktable".
  -- Update a row from PK TABLE (should succeed)
  UPDATE PKTABLE SET ptest1=0 WHERE ptest1=4;
  -- Check PKTABLE for updates
  SELECT * FROM PKTABLE ORDER BY 1, 2;
   ptest1 | ptest2 
  --------+--------
!       0 | Test4
!       1 | Test1
!       2 | Test2
        3 | Test3
! (4 rows)
  
  DROP TABLE FKTABLE;
  DROP TABLE PKTABLE;
  -- MATCH SIMPLE
  -- Base test restricting update/delete
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
  			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE) DISTRIBUTE BY REPLICATION;
  -- Insert Primary Key values
  INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
  INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
--- 301,341 ----
  
  -- Delete a row from PK TABLE (should fail)
  DELETE FROM PKTABLE WHERE ptest1=1;
  -- Delete a row from PK TABLE (should succeed)
  DELETE FROM PKTABLE WHERE ptest1=5;
  -- Check PKTABLE for deletes
  SELECT * FROM PKTABLE ORDER BY 1, 2;
   ptest1 | ptest2 
  --------+--------
        2 | Test2
        3 | Test3
        4 | Test4
! (3 rows)
  
  -- Update a row from PK TABLE (should fail)
  UPDATE PKTABLE SET ptest1=0 WHERE ptest1=2;
  -- Update a row from PK TABLE (should succeed)
  UPDATE PKTABLE SET ptest1=0 WHERE ptest1=4;
+ ERROR:  node:datanode_2, backend_pid:383288, nodename:datanode_1,backend_pid:383271,message:duplicate key value violates unique constraint "pktable_pkey"
+ DETAIL:  Key (ptest1)=(0) already exists.
  -- Check PKTABLE for updates
  SELECT * FROM PKTABLE ORDER BY 1, 2;
   ptest1 | ptest2 
  --------+--------
!       0 | Test2
        3 | Test3
!       4 | Test4
! (3 rows)
  
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  DROP TABLE PKTABLE;
  -- MATCH SIMPLE
  -- Base test restricting update/delete
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
  			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Insert Primary Key values
  INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
  INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
***************
*** 347,409 ****
  INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
  -- Insert Foreign Key values
  INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
  INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
  INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
  INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
  INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
  -- Insert a failed values
  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
  -- Show FKTABLE
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (5 rows)
! 
  -- Try to update something that should fail
  UPDATE PKTABLE set ptest2=5 where ptest2=2;
- ERROR:  update or delete on table "pktable" violates foreign key constraint "constrname3" on table "fktable"
- DETAIL:  Key (ptest1, ptest2, ptest3)=(1, 2, 3) is still referenced from table "fktable".
  -- Try to update something that should succeed
  UPDATE PKTABLE set ptest1=1 WHERE ptest2=3;
  -- Try to delete something that should fail
  DELETE FROM PKTABLE where ptest1=1 and ptest2=2 and ptest3=3;
- ERROR:  update or delete on table "pktable" violates foreign key constraint "constrname3" on table "fktable"
- DETAIL:  Key (ptest1, ptest2, ptest3)=(1, 2, 3) is still referenced from table "fktable".
  -- Try to delete something that should work
  DELETE FROM PKTABLE where ptest1=2;
  -- Show PKTABLE and FKTABLE
  SELECT * from PKTABLE ORDER BY 1, 2, 3,4;
   ptest1 | ptest2 | ptest3 | ptest4 
  --------+--------+--------+--------
-       1 |      2 |      3 | test1
        1 |      3 |      3 | test2
        1 |      3 |      4 | test3
  (3 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (5 rows)
! 
  DROP TABLE FKTABLE;
  DROP TABLE PKTABLE;
  -- cascade update/delete
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
  			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
  			ON DELETE CASCADE ON UPDATE CASCADE);
  -- Insert Primary Key values
  INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
  INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
--- 343,407 ----
  INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
  -- Insert Foreign Key values
  INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
+                     ^
  INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
+                     ^
  -- Insert a failed values
  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
!                     ^
  -- Show FKTABLE
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  -- Try to update something that should fail
  UPDATE PKTABLE set ptest2=5 where ptest2=2;
  -- Try to update something that should succeed
  UPDATE PKTABLE set ptest1=1 WHERE ptest2=3;
  -- Try to delete something that should fail
  DELETE FROM PKTABLE where ptest1=1 and ptest2=2 and ptest3=3;
  -- Try to delete something that should work
  DELETE FROM PKTABLE where ptest1=2;
  -- Show PKTABLE and FKTABLE
  SELECT * from PKTABLE ORDER BY 1, 2, 3,4;
   ptest1 | ptest2 | ptest3 | ptest4 
  --------+--------+--------+--------
        1 |      3 |      3 | test2
        1 |      3 |      4 | test3
+       1 |      5 |      3 | test1
  (3 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  DROP TABLE PKTABLE;
  -- cascade update/delete
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
  			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
  			ON DELETE CASCADE ON UPDATE CASCADE);
+ ERROR:  corrupted catalog, no shard group of 0 found
  -- Insert Primary Key values
  INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
  INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
***************
*** 411,435 ****
  INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
  -- Insert Foreign Key values
  INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
  INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
  INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
  INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
  INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
  -- Insert a failed values
  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
  -- Show FKTABLE
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (5 rows)
! 
  -- Try to update something that will cascade
  UPDATE PKTABLE set ptest2=5 where ptest2=2;
  -- Try to update something that should not cascade
--- 409,443 ----
  INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
  -- Insert Foreign Key values
  INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
+                     ^
  INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
+                     ^
  -- Insert a failed values
  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
!                     ^
  -- Show FKTABLE
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  -- Try to update something that will cascade
  UPDATE PKTABLE set ptest2=5 where ptest2=2;
  -- Try to update something that should not cascade
***************
*** 445,459 ****
  (4 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      5 |      3 |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (5 rows)
! 
  -- Try to delete something that should cascade
  DELETE FROM PKTABLE where ptest1=1 and ptest2=5 and ptest3=3;
  -- Show PKTABLE and FKTABLE
--- 453,461 ----
  (4 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  -- Try to delete something that should cascade
  DELETE FROM PKTABLE where ptest1=1 and ptest2=5 and ptest3=3;
  -- Show PKTABLE and FKTABLE
***************
*** 466,479 ****
  (3 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (4 rows)
! 
  -- Try to delete something that should not have a cascade
  DELETE FROM PKTABLE where ptest1=2;
  -- Show PKTABLE and FKTABLE
--- 468,476 ----
  (3 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  -- Try to delete something that should not have a cascade
  DELETE FROM PKTABLE where ptest1=2;
  -- Show PKTABLE and FKTABLE
***************
*** 485,505 ****
  (2 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (4 rows)
! 
  DROP TABLE FKTABLE;
  DROP TABLE PKTABLE;
  -- set null update / set default delete
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
  CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
  			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
  			ON DELETE SET DEFAULT ON UPDATE SET NULL);
  -- Insert Primary Key values
  INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
  INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
--- 482,499 ----
  (2 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  DROP TABLE PKTABLE;
  -- set null update / set default delete
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) );
  CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int, ftest3 int, ftest4 int,  CONSTRAINT constrname3
  			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
  			ON DELETE SET DEFAULT ON UPDATE SET NULL);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  -- Insert Primary Key values
  INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
  INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
***************
*** 507,533 ****
  INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
  -- Insert Foreign Key values
  INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
  INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
  INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
  INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
  INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
  INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
  -- Insert a failed values
  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
  -- Show FKTABLE
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!       2 |      3 |      4 |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (6 rows)
! 
  -- Try to update something that will set null
  UPDATE PKTABLE set ptest2=5 where ptest2=2;
  -- Try to update something that should not set null
--- 501,539 ----
  INSERT INTO PKTABLE VALUES (2, 4, 5, 'test4');
  -- Insert Foreign Key values
  INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
+                     ^
  INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
+                     ^
  INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
+                     ^
  -- Insert a failed values
  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
!                     ^
  -- Show FKTABLE
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  -- Try to update something that will set null
  UPDATE PKTABLE set ptest2=5 where ptest2=2;
  -- Try to update something that should not set null
***************
*** 543,558 ****
  (4 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       2 |      3 |      4 |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!         |        |        |      1
! (6 rows)
! 
  -- Try to delete something that should set default
  DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
  -- Show PKTABLE and FKTABLE
--- 549,557 ----
  (4 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  -- Try to delete something that should set default
  DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
  -- Show PKTABLE and FKTABLE
***************
*** 565,580 ****
  (3 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       0 |        |        |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!         |        |        |      1
! (6 rows)
! 
  -- Try to delete something that should not set default
  DELETE FROM PKTABLE where ptest2=5;
  -- Show PKTABLE and FKTABLE
--- 564,572 ----
  (3 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  -- Try to delete something that should not set default
  DELETE FROM PKTABLE where ptest2=5;
  -- Show PKTABLE and FKTABLE
***************
*** 586,608 ****
  (2 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       0 |        |        |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!         |        |        |      1
! (6 rows)
! 
  DROP TABLE FKTABLE;
  DROP TABLE PKTABLE;
  -- set default update / set null delete
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int DEFAULT -1, ftest3 int DEFAULT -2, ftest4 int, CONSTRAINT constrname3
  			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
  			ON DELETE SET NULL ON UPDATE SET DEFAULT) DISTRIBUTE BY REPLICATION;
  -- Insert Primary Key values
  INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
  INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
--- 578,595 ----
  (2 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  DROP TABLE PKTABLE;
  -- set default update / set null delete
  CREATE TABLE PKTABLE ( ptest1 int, ptest2 int, ptest3 int, ptest4 text, PRIMARY KEY(ptest1, ptest2, ptest3) ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE FKTABLE ( ftest1 int DEFAULT 0, ftest2 int DEFAULT -1, ftest3 int DEFAULT -2, ftest4 int, CONSTRAINT constrname3
  			FOREIGN KEY(ftest1, ftest2, ftest3) REFERENCES PKTABLE
  			ON DELETE SET NULL ON UPDATE SET DEFAULT) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Insert Primary Key values
  INSERT INTO PKTABLE VALUES (1, 2, 3, 'test1');
  INSERT INTO PKTABLE VALUES (1, 3, 3, 'test2');
***************
*** 611,643 ****
  INSERT INTO PKTABLE VALUES (2, -1, 5, 'test5');
  -- Insert Foreign Key values
  INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
  INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
  INSERT INTO FKTABLE VALUES (2, 4, 5, 1);
  INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
  INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
  INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
  INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
  -- Insert a failed values
  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
! DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
  -- Show FKTABLE
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       1 |      2 |      3 |      1
!       2 |      3 |      4 |      1
!       2 |      4 |      5 |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (7 rows)
! 
  -- Try to update something that will fail
  UPDATE PKTABLE set ptest2=5 where ptest2=2;
- ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
- DETAIL:  Key (ftest1, ftest2, ftest3)=(0, -1, -2) is not present in table "pktable".
  -- Try to update something that will set default
  UPDATE PKTABLE set ptest1=0, ptest2=-1, ptest3=-2 where ptest2=2;
  UPDATE PKTABLE set ptest2=10 where ptest2=4;
--- 598,642 ----
  INSERT INTO PKTABLE VALUES (2, -1, 5, 'test5');
  -- Insert Foreign Key values
  INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (1, 2, 3, 1);
+                     ^
  INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (2, 3, 4, 1);
+                     ^
  INSERT INTO FKTABLE VALUES (2, 4, 5, 1);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (2, 4, 5, 1);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 2, 3, 2);
+                     ^
  INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (2, NULL, 3, 3);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 2, 7, 4);
+                     ^
  INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES (NULL, 3, 4, 5);
+                     ^
  -- Insert a failed values
  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
!                     ^
  -- Show FKTABLE
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  -- Try to update something that will fail
  UPDATE PKTABLE set ptest2=5 where ptest2=2;
  -- Try to update something that will set default
  UPDATE PKTABLE set ptest1=0, ptest2=-1, ptest3=-2 where ptest2=2;
  UPDATE PKTABLE set ptest2=10 where ptest2=4;
***************
*** 647,719 ****
  SELECT * from PKTABLE ORDER BY 1, 2, 3,4;
   ptest1 | ptest2 | ptest3 | ptest4 
  --------+--------+--------+--------
-       0 |     -1 |     -2 | test1
        1 |      2 |      3 | test2
        2 |     -1 |      5 | test5
        2 |      3 |      4 | test3
        2 |     10 |      5 | test4
  (5 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       0 |     -1 |     -2 |      1
!       0 |     -1 |     -2 |      1
!       2 |      3 |      4 |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
! (7 rows)
! 
  -- Try to delete something that should set null
  DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
  -- Show PKTABLE and FKTABLE
  SELECT * from PKTABLE ORDER BY 1, 2, 3,4;
   ptest1 | ptest2 | ptest3 | ptest4 
  --------+--------+--------+--------
-       0 |     -1 |     -2 | test1
        1 |      2 |      3 | test2
        2 |     -1 |      5 | test5
        2 |     10 |      5 | test4
  (4 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       0 |     -1 |     -2 |      1
!       0 |     -1 |     -2 |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!         |        |        |      1
! (7 rows)
! 
  -- Try to delete something that should not set null
  DELETE FROM PKTABLE where ptest2=-1 and ptest3=5;
  -- Show PKTABLE and FKTABLE
  SELECT * from PKTABLE ORDER BY 1, 2, 3,4;
   ptest1 | ptest2 | ptest3 | ptest4 
  --------+--------+--------+--------
-       0 |     -1 |     -2 | test1
        1 |      2 |      3 | test2
        2 |     10 |      5 | test4
  (3 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!  ftest1 | ftest2 | ftest3 | ftest4 
! --------+--------+--------+--------
!       0 |     -1 |     -2 |      1
!       0 |     -1 |     -2 |      1
!       2 |        |      3 |      3
!         |      2 |      3 |      2
!         |      2 |      7 |      4
!         |      3 |      4 |      5
!         |        |        |      1
! (7 rows)
! 
  DROP TABLE FKTABLE;
  DROP TABLE PKTABLE;
  CREATE TABLE PKTABLE (ptest1 int PRIMARY KEY);
  CREATE TABLE FKTABLE_FAIL1 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest2) REFERENCES PKTABLE);
--- 646,695 ----
  SELECT * from PKTABLE ORDER BY 1, 2, 3,4;
   ptest1 | ptest2 | ptest3 | ptest4 
  --------+--------+--------+--------
        1 |      2 |      3 | test2
+       1 |      5 |      3 | test1
        2 |     -1 |      5 | test5
        2 |      3 |      4 | test3
        2 |     10 |      5 | test4
  (5 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  -- Try to delete something that should set null
  DELETE FROM PKTABLE where ptest1=2 and ptest2=3 and ptest3=4;
  -- Show PKTABLE and FKTABLE
  SELECT * from PKTABLE ORDER BY 1, 2, 3,4;
   ptest1 | ptest2 | ptest3 | ptest4 
  --------+--------+--------+--------
        1 |      2 |      3 | test2
+       1 |      5 |      3 | test1
        2 |     -1 |      5 | test5
        2 |     10 |      5 | test4
  (4 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  -- Try to delete something that should not set null
  DELETE FROM PKTABLE where ptest2=-1 and ptest3=5;
  -- Show PKTABLE and FKTABLE
  SELECT * from PKTABLE ORDER BY 1, 2, 3,4;
   ptest1 | ptest2 | ptest3 | ptest4 
  --------+--------+--------+--------
        1 |      2 |      3 | test2
+       1 |      5 |      3 | test1
        2 |     10 |      5 | test4
  (3 rows)
  
  SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
! ERROR:  relation "fktable" does not exist
! LINE 1: SELECT * from FKTABLE ORDER BY 1, 2, 3,4;
!                       ^
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  DROP TABLE PKTABLE;
  CREATE TABLE PKTABLE (ptest1 int PRIMARY KEY);
  CREATE TABLE FKTABLE_FAIL1 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest2) REFERENCES PKTABLE);
***************
*** 728,734 ****
  -- Test for referencing column number smaller than referenced constraint
  CREATE TABLE PKTABLE (ptest1 int, ptest2 int, UNIQUE(ptest1, ptest2));
  CREATE TABLE FKTABLE_FAIL1 (ftest1 int REFERENCES pktable(ptest1));
! ERROR:  there is no unique constraint matching given keys for referenced table "pktable"
  DROP TABLE FKTABLE_FAIL1;
  ERROR:  table "fktable_fail1" does not exist
  DROP TABLE PKTABLE;
--- 704,710 ----
  -- Test for referencing column number smaller than referenced constraint
  CREATE TABLE PKTABLE (ptest1 int, ptest2 int, UNIQUE(ptest1, ptest2));
  CREATE TABLE FKTABLE_FAIL1 (ftest1 int REFERENCES pktable(ptest1));
! ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  DROP TABLE FKTABLE_FAIL1;
  ERROR:  table "fktable_fail1" does not exist
  DROP TABLE PKTABLE;
***************
*** 740,841 ****
  INSERT INTO PKTABLE VALUES(42);
  -- This next should fail, because int=inet does not exist
  CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
  -- This should also fail for the same reason, but here we
  -- give the column name
  CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable(ptest1)) DISTRIBUTE BY REPLICATION;
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
  -- This should succeed, even though they are different types,
  -- because int=int8 exists and is a member of the integer opfamily
  CREATE TABLE FKTABLE (ftest1 int8 REFERENCES pktable) DISTRIBUTE BY REPLICATION;
  -- Check it actually works
  INSERT INTO FKTABLE VALUES(42);		-- should succeed
  INSERT INTO FKTABLE VALUES(43);		-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
  UPDATE FKTABLE SET ftest1 = ftest1;	-- should succeed
  UPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
  DROP TABLE FKTABLE;
  -- This should fail, because we'd have to cast numeric to int which is
  -- not an implicit coercion (or use numeric=numeric, but that's not part
  -- of the integer opfamily)
  CREATE TABLE FKTABLE (ftest1 numeric REFERENCES pktable) DISTRIBUTE BY REPLICATION;
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: numeric and integer.
  DROP TABLE PKTABLE;
  -- On the other hand, this should work because int implicitly promotes to
  -- numeric, and we allow promotion on the FK side
  CREATE TABLE PKTABLE (ptest1 numeric PRIMARY KEY) DISTRIBUTE BY REPLICATION;
  INSERT INTO PKTABLE VALUES(42);
  CREATE TABLE FKTABLE (ftest1 int REFERENCES pktable) DISTRIBUTE BY REPLICATION;
  -- Check it actually works
  INSERT INTO FKTABLE VALUES(42);		-- should succeed
  INSERT INTO FKTABLE VALUES(43);		-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
  UPDATE FKTABLE SET ftest1 = ftest1;	-- should succeed
  UPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should fail
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
  DROP TABLE FKTABLE;
  DROP TABLE PKTABLE;
  -- Two columns, two tables
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, PRIMARY KEY(ptest1, ptest2))  DISTRIBUTE BY REPLICATION;
  -- This should fail, because we just chose really odd types
  CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable) DISTRIBUTE BY REPLICATION;
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
  -- Again, so should this...
  CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2)) DISTRIBUTE BY REPLICATION;
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
  -- This fails because we mixed up the column ordering
  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable) DISTRIBUTE BY REPLICATION;
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
  -- As does this...
  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest1, ptest2)) DISTRIBUTE BY REPLICATION;
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
  -- And again..
  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest2, ptest1)) DISTRIBUTE BY REPLICATION;
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest2" are of incompatible types: integer and inet.
  -- This works...
  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest2, ptest1)) DISTRIBUTE BY REPLICATION;
  DROP TABLE FKTABLE;
  -- As does this
  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2)) DISTRIBUTE BY REPLICATION;
  DROP TABLE FKTABLE;
  DROP TABLE PKTABLE;
  -- Two columns, same table
  -- Make sure this still works...
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
  ptest4) REFERENCES pktable(ptest1, ptest2));
  DROP TABLE PKTABLE;
  -- And this,
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
  ptest4) REFERENCES pktable);
  DROP TABLE PKTABLE;
  -- This shouldn't (mixed up columns)
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
  ptest4) REFERENCES pktable(ptest2, ptest1));
! ERROR:  foreign key constraint "pktable_ptest3_fkey" cannot be implemented
! DETAIL:  Key columns "ptest3" and "ptest2" are of incompatible types: integer and inet.
  -- Nor should this... (same reason, we have 4,3 referencing 1,2 which mismatches types
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
  ptest3) REFERENCES pktable(ptest1, ptest2));
! ERROR:  foreign key constraint "pktable_ptest4_fkey" cannot be implemented
! DETAIL:  Key columns "ptest4" and "ptest1" are of incompatible types: inet and integer.
  -- Not this one either... Same as the last one except we didn't defined the columns being referenced.
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
  ptest3) REFERENCES pktable);
! ERROR:  foreign key constraint "pktable_ptest4_fkey" cannot be implemented
! DETAIL:  Key columns "ptest4" and "ptest1" are of incompatible types: inet and integer.
  --
  -- Now some cases with inheritance
  -- Basic 2 table case: 1 column of matching types.
--- 716,834 ----
  INSERT INTO PKTABLE VALUES(42);
  -- This next should fail, because int=inet does not exist
  CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable);
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- This should also fail for the same reason, but here we
  -- give the column name
  CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable(ptest1)) DISTRIBUTE BY REPLICATION;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- This should succeed, even though they are different types,
  -- because int=int8 exists and is a member of the integer opfamily
  CREATE TABLE FKTABLE (ftest1 int8 REFERENCES pktable) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Check it actually works
  INSERT INTO FKTABLE VALUES(42);		-- should succeed
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES(42);
+                     ^
  INSERT INTO FKTABLE VALUES(43);		-- should fail
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES(43);
!                     ^
  UPDATE FKTABLE SET ftest1 = ftest1;	-- should succeed
+ ERROR:  relation "fktable" does not exist
+ LINE 1: UPDATE FKTABLE SET ftest1 = ftest1;
+                ^
  UPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should fail
! ERROR:  relation "fktable" does not exist
! LINE 1: UPDATE FKTABLE SET ftest1 = ftest1 + 1;
!                ^
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  -- This should fail, because we'd have to cast numeric to int which is
  -- not an implicit coercion (or use numeric=numeric, but that's not part
  -- of the integer opfamily)
  CREATE TABLE FKTABLE (ftest1 numeric REFERENCES pktable) DISTRIBUTE BY REPLICATION;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  DROP TABLE PKTABLE;
  -- On the other hand, this should work because int implicitly promotes to
  -- numeric, and we allow promotion on the FK side
  CREATE TABLE PKTABLE (ptest1 numeric PRIMARY KEY) DISTRIBUTE BY REPLICATION;
  INSERT INTO PKTABLE VALUES(42);
  CREATE TABLE FKTABLE (ftest1 int REFERENCES pktable) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Check it actually works
  INSERT INTO FKTABLE VALUES(42);		-- should succeed
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO FKTABLE VALUES(42);
+                     ^
  INSERT INTO FKTABLE VALUES(43);		-- should fail
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO FKTABLE VALUES(43);
!                     ^
  UPDATE FKTABLE SET ftest1 = ftest1;	-- should succeed
+ ERROR:  relation "fktable" does not exist
+ LINE 1: UPDATE FKTABLE SET ftest1 = ftest1;
+                ^
  UPDATE FKTABLE SET ftest1 = ftest1 + 1;	-- should fail
! ERROR:  relation "fktable" does not exist
! LINE 1: UPDATE FKTABLE SET ftest1 = ftest1 + 1;
!                ^
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  DROP TABLE PKTABLE;
  -- Two columns, two tables
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, PRIMARY KEY(ptest1, ptest2))  DISTRIBUTE BY REPLICATION;
  -- This should fail, because we just chose really odd types
  CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable) DISTRIBUTE BY REPLICATION;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Again, so should this...
  CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2)) DISTRIBUTE BY REPLICATION;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- This fails because we mixed up the column ordering
  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable) DISTRIBUTE BY REPLICATION;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- As does this...
  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest1, ptest2)) DISTRIBUTE BY REPLICATION;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- And again..
  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest2, ptest1)) DISTRIBUTE BY REPLICATION;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- This works...
  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest2, ptest1)) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  -- As does this
  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2)) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  DROP TABLE FKTABLE;
+ ERROR:  table "fktable" does not exist
  DROP TABLE PKTABLE;
  -- Two columns, same table
  -- Make sure this still works...
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
  ptest4) REFERENCES pktable(ptest1, ptest2));
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  DROP TABLE PKTABLE;
+ ERROR:  table "pktable" does not exist
  -- And this,
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
  ptest4) REFERENCES pktable);
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  DROP TABLE PKTABLE;
+ ERROR:  table "pktable" does not exist
  -- This shouldn't (mixed up columns)
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
  ptest4) REFERENCES pktable(ptest2, ptest1));
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Nor should this... (same reason, we have 4,3 referencing 1,2 which mismatches types
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
  ptest3) REFERENCES pktable(ptest1, ptest2));
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Not this one either... Same as the last one except we didn't defined the columns being referenced.
  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
  ptest3) REFERENCES pktable);
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  --
  -- Now some cases with inheritance
  -- Basic 2 table case: 1 column of matching types.
***************
*** 844,902 ****
  WARNING:  Inherited/partition tables inherit distribution from the parent
  DETAIL:  Explicitly specified distribution will be ignored
  create table fktable (ftest1 int references pktable(base1));
  -- now some ins, upd, del
  insert into pktable(base1) values (1);
  insert into pktable(base1) values (2);
  --  let's insert a non-existent fktable value
  insert into fktable(ftest1) values (3);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1)=(3) is not present in table "pktable".
  --  let's make a valid row for that
  insert into pktable(base1) values (3);
  insert into fktable(ftest1) values (3);
  -- let's try removing a row that should fail from pktable
  delete from pktable where base1>2;
- ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
- DETAIL:  Key (base1)=(3) is still referenced from table "fktable".
  -- okay, let's try updating all of the base1 values to *4
  -- which should fail.
  update pktable set base1=base1*4;
- ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
- DETAIL:  Key (base1)=(3) is still referenced from table "fktable".
  -- okay, let's try an update that should work.
  update pktable set base1=base1*4 where base1<3;
  -- and a delete that should work
  delete from pktable where base1>3;
  -- cleanup
  drop table fktable;
  delete from pktable;
  -- Now 2 columns 2 tables, matching types
  create table fktable (ftest1 int, ftest2 int, foreign key(ftest1, ftest2) references pktable(base1, ptest1));
  -- now some ins, upd, del
  insert into pktable(base1, ptest1) values (1, 1);
  insert into pktable(base1, ptest1) values (2, 2);
  --  let's insert a non-existent fktable value
  insert into fktable(ftest1, ftest2) values (3, 1);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
! DETAIL:  Key (ftest1, ftest2)=(3, 1) is not present in table "pktable".
  --  let's make a valid row for that
  insert into pktable(base1,ptest1) values (3, 1);
  insert into fktable(ftest1, ftest2) values (3, 1);
  -- let's try removing a row that should fail from pktable
  delete from pktable where base1>2;
- ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
- DETAIL:  Key (base1, ptest1)=(3, 1) is still referenced from table "fktable".
  -- okay, let's try updating all of the base1 values to *4
  -- which should fail.
  update pktable set base1=base1*4;
- ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
- DETAIL:  Key (base1, ptest1)=(3, 1) is still referenced from table "fktable".
  -- okay, let's try an update that should work.
  update pktable set base1=base1*4 where base1<3;
  -- and a delete that should work
  delete from pktable where base1>3;
  -- cleanup
  drop table fktable;
  drop table pktable;
  drop table pktable_base;
  -- Now we'll do one all in 1 table with 2 columns of matching types
--- 837,899 ----
  WARNING:  Inherited/partition tables inherit distribution from the parent
  DETAIL:  Explicitly specified distribution will be ignored
  create table fktable (ftest1 int references pktable(base1));
+ ERROR:  corrupted catalog, no shard group of 0 found
  -- now some ins, upd, del
  insert into pktable(base1) values (1);
  insert into pktable(base1) values (2);
  --  let's insert a non-existent fktable value
  insert into fktable(ftest1) values (3);
! ERROR:  relation "fktable" does not exist
! LINE 1: insert into fktable(ftest1) values (3);
!                     ^
  --  let's make a valid row for that
  insert into pktable(base1) values (3);
  insert into fktable(ftest1) values (3);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: insert into fktable(ftest1) values (3);
+                     ^
  -- let's try removing a row that should fail from pktable
  delete from pktable where base1>2;
  -- okay, let's try updating all of the base1 values to *4
  -- which should fail.
  update pktable set base1=base1*4;
  -- okay, let's try an update that should work.
  update pktable set base1=base1*4 where base1<3;
  -- and a delete that should work
  delete from pktable where base1>3;
  -- cleanup
  drop table fktable;
+ ERROR:  table "fktable" does not exist
  delete from pktable;
  -- Now 2 columns 2 tables, matching types
  create table fktable (ftest1 int, ftest2 int, foreign key(ftest1, ftest2) references pktable(base1, ptest1));
+ ERROR:  corrupted catalog, no shard group of 0 found
  -- now some ins, upd, del
  insert into pktable(base1, ptest1) values (1, 1);
  insert into pktable(base1, ptest1) values (2, 2);
  --  let's insert a non-existent fktable value
  insert into fktable(ftest1, ftest2) values (3, 1);
! ERROR:  relation "fktable" does not exist
! LINE 1: insert into fktable(ftest1, ftest2) values (3, 1);
!                     ^
  --  let's make a valid row for that
  insert into pktable(base1,ptest1) values (3, 1);
  insert into fktable(ftest1, ftest2) values (3, 1);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: insert into fktable(ftest1, ftest2) values (3, 1);
+                     ^
  -- let's try removing a row that should fail from pktable
  delete from pktable where base1>2;
  -- okay, let's try updating all of the base1 values to *4
  -- which should fail.
  update pktable set base1=base1*4;
  -- okay, let's try an update that should work.
  update pktable set base1=base1*4 where base1<3;
  -- and a delete that should work
  delete from pktable where base1>3;
  -- cleanup
  drop table fktable;
+ ERROR:  table "fktable" does not exist
  drop table pktable;
  drop table pktable_base;
  -- Now we'll do one all in 1 table with 2 columns of matching types
***************
*** 905,951 ****
                                               pktable(base1, ptest1)) inherits (pktable_base) DISTRIBUTE BY REPLICATION;
  WARNING:  Inherited/partition tables inherit distribution from the parent
  DETAIL:  Explicitly specified distribution will be ignored
  insert into pktable (base1, ptest1, base2, ptest2) values (1, 1, 1, 1);
  insert into pktable (base1, ptest1, base2, ptest2) values (2, 1, 1, 1);
  insert into pktable (base1, ptest1, base2, ptest2) values (2, 2, 2, 1);
  insert into pktable (base1, ptest1, base2, ptest2) values (1, 3, 2, 2);
  -- fails (3,2) isn't in base1, ptest1
  insert into pktable (base1, ptest1, base2, ptest2) values (2, 3, 3, 2);
! ERROR:  insert or update on table "pktable" violates foreign key constraint "pktable_base2_fkey"
! DETAIL:  Key (base2, ptest2)=(3, 2) is not present in table "pktable".
  -- fails (2,2) is being referenced
  delete from pktable where base1=2;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "pktable_base2_fkey" on table "pktable"
! DETAIL:  Key (base1, ptest1)=(2, 2) is still referenced from table "pktable".
  -- fails (1,1) is being referenced (twice)
  update pktable set base1=3 where base1=1;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "pktable_base2_fkey" on table "pktable"
! DETAIL:  Key (base1, ptest1)=(1, 1) is still referenced from table "pktable".
  -- this sequence of two deletes will work, since after the first there will be no (2,*) references
  delete from pktable where base2=2;
  delete from pktable where base1=2;
  drop table pktable;
  drop table pktable_base;
  -- 2 columns (2 tables), mismatched types
  create table pktable_base(base1 int not null) DISTRIBUTE BY REPLICATION;
  create table pktable(ptest1 inet, primary key(base1, ptest1)) inherits (pktable_base);
  -- just generally bad types (with and without column references on the referenced table)
  create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "base1" are of incompatible types: cidr and integer.
  create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable(base1, ptest1)) DISTRIBUTE BY REPLICATION;
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "base1" are of incompatible types: cidr and integer.
  -- let's mix up which columns reference which
  create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable) DISTRIBUTE BY REPLICATION;
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "base1" are of incompatible types: inet and integer.
  create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable(base1, ptest1)) DISTRIBUTE BY REPLICATION;
! ERROR:  foreign key constraint "fktable_ftest2_fkey" cannot be implemented
! DETAIL:  Key columns "ftest2" and "base1" are of incompatible types: inet and integer.
  create table fktable(ftest1 int, ftest2 inet, foreign key(ftest1, ftest2) references pktable(ptest1, base1));
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: integer and inet.
  drop table pktable;
  drop table pktable_base;
  -- 2 columns (1 table), mismatched types
--- 902,966 ----
                                               pktable(base1, ptest1)) inherits (pktable_base) DISTRIBUTE BY REPLICATION;
  WARNING:  Inherited/partition tables inherit distribution from the parent
  DETAIL:  Explicitly specified distribution will be ignored
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  insert into pktable (base1, ptest1, base2, ptest2) values (1, 1, 1, 1);
+ ERROR:  relation "pktable" does not exist
+ LINE 1: insert into pktable (base1, ptest1, base2, ptest2) values (1...
+                     ^
  insert into pktable (base1, ptest1, base2, ptest2) values (2, 1, 1, 1);
+ ERROR:  relation "pktable" does not exist
+ LINE 1: insert into pktable (base1, ptest1, base2, ptest2) values (2...
+                     ^
  insert into pktable (base1, ptest1, base2, ptest2) values (2, 2, 2, 1);
+ ERROR:  relation "pktable" does not exist
+ LINE 1: insert into pktable (base1, ptest1, base2, ptest2) values (2...
+                     ^
  insert into pktable (base1, ptest1, base2, ptest2) values (1, 3, 2, 2);
+ ERROR:  relation "pktable" does not exist
+ LINE 1: insert into pktable (base1, ptest1, base2, ptest2) values (1...
+                     ^
  -- fails (3,2) isn't in base1, ptest1
  insert into pktable (base1, ptest1, base2, ptest2) values (2, 3, 3, 2);
! ERROR:  relation "pktable" does not exist
! LINE 1: insert into pktable (base1, ptest1, base2, ptest2) values (2...
!                     ^
  -- fails (2,2) is being referenced
  delete from pktable where base1=2;
! ERROR:  relation "pktable" does not exist
! LINE 1: delete from pktable where base1=2;
!                     ^
  -- fails (1,1) is being referenced (twice)
  update pktable set base1=3 where base1=1;
! ERROR:  relation "pktable" does not exist
! LINE 1: update pktable set base1=3 where base1=1;
!                ^
  -- this sequence of two deletes will work, since after the first there will be no (2,*) references
  delete from pktable where base2=2;
+ ERROR:  relation "pktable" does not exist
+ LINE 1: delete from pktable where base2=2;
+                     ^
  delete from pktable where base1=2;
+ ERROR:  relation "pktable" does not exist
+ LINE 1: delete from pktable where base1=2;
+                     ^
  drop table pktable;
+ ERROR:  table "pktable" does not exist
  drop table pktable_base;
  -- 2 columns (2 tables), mismatched types
  create table pktable_base(base1 int not null) DISTRIBUTE BY REPLICATION;
  create table pktable(ptest1 inet, primary key(base1, ptest1)) inherits (pktable_base);
  -- just generally bad types (with and without column references on the referenced table)
  create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable);
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable(base1, ptest1)) DISTRIBUTE BY REPLICATION;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- let's mix up which columns reference which
  create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable) DISTRIBUTE BY REPLICATION;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable(base1, ptest1)) DISTRIBUTE BY REPLICATION;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  create table fktable(ftest1 int, ftest2 inet, foreign key(ftest1, ftest2) references pktable(ptest1, base1));
! ERROR:  corrupted catalog, no shard group of 0 found
  drop table pktable;
  drop table pktable_base;
  -- 2 columns (1 table), mismatched types
***************
*** 982,1021 ****
  	id		INT4 PRIMARY KEY,
  	fk		INT4 REFERENCES pktable DEFERRABLE
  ) DISTRIBUTE BY REPLICATION;
  -- default to immediate: should fail
  INSERT INTO fktable VALUES (5, 10);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(10) is not present in table "pktable".
  -- explicitly defer the constraint
  BEGIN;
  SET CONSTRAINTS ALL DEFERRED;
  INSERT INTO fktable VALUES (10, 15);
  INSERT INTO pktable VALUES (15, 0); -- make the FK insert valid
  COMMIT;
  DROP TABLE fktable, pktable;
  -- deferrable, initially deferred
  CREATE TABLE pktable (
  	id		INT4 PRIMARY KEY,
  	other	INT4
  ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE fktable (
  	id		INT4 PRIMARY KEY,
  	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED
  ) DISTRIBUTE BY REPLICATION;
  -- default to deferred, should succeed
  BEGIN;
  INSERT INTO fktable VALUES (100, 200);
  INSERT INTO pktable VALUES (200, 500); -- make the FK insert valid
  COMMIT;
  -- default to deferred, explicitly make immediate
  BEGIN;
  SET CONSTRAINTS ALL IMMEDIATE;
  -- should fail
  INSERT INTO fktable VALUES (500, 1000);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(1000) is not present in table "pktable".
  COMMIT;
  DROP TABLE fktable, pktable;
  -- tricky behavior: according to SQL99, if a deferred constraint is set
  -- to 'immediate' mode, it should be checked for validity *immediately*,
  -- not when the current transaction commits (i.e. the mode change applies
--- 997,1051 ----
  	id		INT4 PRIMARY KEY,
  	fk		INT4 REFERENCES pktable DEFERRABLE
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- default to immediate: should fail
  INSERT INTO fktable VALUES (5, 10);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO fktable VALUES (5, 10);
!                     ^
  -- explicitly defer the constraint
  BEGIN;
  SET CONSTRAINTS ALL DEFERRED;
  INSERT INTO fktable VALUES (10, 15);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO fktable VALUES (10, 15);
+                     ^
  INSERT INTO pktable VALUES (15, 0); -- make the FK insert valid
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  COMMIT;
  DROP TABLE fktable, pktable;
+ ERROR:  table "fktable" does not exist
  -- deferrable, initially deferred
  CREATE TABLE pktable (
  	id		INT4 PRIMARY KEY,
  	other	INT4
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  relation "pktable" already exists
  CREATE TABLE fktable (
  	id		INT4 PRIMARY KEY,
  	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- default to deferred, should succeed
  BEGIN;
  INSERT INTO fktable VALUES (100, 200);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO fktable VALUES (100, 200);
+                     ^
  INSERT INTO pktable VALUES (200, 500); -- make the FK insert valid
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  COMMIT;
  -- default to deferred, explicitly make immediate
  BEGIN;
  SET CONSTRAINTS ALL IMMEDIATE;
  -- should fail
  INSERT INTO fktable VALUES (500, 1000);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO fktable VALUES (500, 1000);
!                     ^
  COMMIT;
  DROP TABLE fktable, pktable;
+ ERROR:  table "fktable" does not exist
  -- tricky behavior: according to SQL99, if a deferred constraint is set
  -- to 'immediate' mode, it should be checked for validity *immediately*,
  -- not when the current transaction commits (i.e. the mode change applies
***************
*** 1024,1062 ****
  	id		INT4 PRIMARY KEY,
  	other	INT4
  ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE fktable (
  	id		INT4 PRIMARY KEY,
  	fk		INT4 REFERENCES pktable DEFERRABLE
  ) DISTRIBUTE BY REPLICATION;
  BEGIN;
  SET CONSTRAINTS ALL DEFERRED;
  -- should succeed, for now
  INSERT INTO fktable VALUES (1000, 2000);
  -- should cause transaction abort, due to preceding error
  SET CONSTRAINTS ALL IMMEDIATE;
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(2000) is not present in table "pktable".
  INSERT INTO pktable VALUES (2000, 3); -- too late
  ERROR:  current transaction is aborted, commands ignored until end of transaction block
  COMMIT;
  DROP TABLE fktable, pktable;
  -- deferrable, initially deferred
  CREATE TABLE pktable (
  	id		INT4 PRIMARY KEY,
  	other	INT4
  ) DISTRIBUTE BY REPLICATION;
  CREATE TABLE fktable (
  	id		INT4 PRIMARY KEY,
  	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED
  ) DISTRIBUTE BY REPLICATION;
  BEGIN;
  -- no error here
  INSERT INTO fktable VALUES (100, 200);
  -- error here on commit
  COMMIT;
- ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
- DETAIL:  Key (fk)=(200) is not present in table "pktable".
  DROP TABLE pktable, fktable;
  -- test notice about expensive referential integrity checks,
  -- where the index cannot be used because of type incompatibilities.
  CREATE TEMP TABLE pktable (
--- 1054,1101 ----
  	id		INT4 PRIMARY KEY,
  	other	INT4
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  relation "pktable" already exists
  CREATE TABLE fktable (
  	id		INT4 PRIMARY KEY,
  	fk		INT4 REFERENCES pktable DEFERRABLE
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  BEGIN;
  SET CONSTRAINTS ALL DEFERRED;
  -- should succeed, for now
  INSERT INTO fktable VALUES (1000, 2000);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO fktable VALUES (1000, 2000);
+                     ^
  -- should cause transaction abort, due to preceding error
  SET CONSTRAINTS ALL IMMEDIATE;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  INSERT INTO pktable VALUES (2000, 3); -- too late
  ERROR:  current transaction is aborted, commands ignored until end of transaction block
  COMMIT;
  DROP TABLE fktable, pktable;
+ ERROR:  table "fktable" does not exist
  -- deferrable, initially deferred
  CREATE TABLE pktable (
  	id		INT4 PRIMARY KEY,
  	other	INT4
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  relation "pktable" already exists
  CREATE TABLE fktable (
  	id		INT4 PRIMARY KEY,
  	fk		INT4 REFERENCES pktable DEFERRABLE INITIALLY DEFERRED
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  BEGIN;
  -- no error here
  INSERT INTO fktable VALUES (100, 200);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO fktable VALUES (100, 200);
+                     ^
  -- error here on commit
  COMMIT;
  DROP TABLE pktable, fktable;
+ ERROR:  table "fktable" does not exist
  -- test notice about expensive referential integrity checks,
  -- where the index cannot be used because of type incompatibilities.
  CREATE TEMP TABLE pktable (
***************
*** 1072,1127 ****
          x4      TEXT,
          x5      INT2
  ) DISTRIBUTE BY REPLICATION;
  -- check individual constraints with alter table.
  -- should fail
  -- varchar does not promote to real
  ALTER TABLE fktable ADD CONSTRAINT fk_2_3
  FOREIGN KEY (x2) REFERENCES pktable(id3);
! ERROR:  foreign key constraint "fk_2_3" cannot be implemented
! DETAIL:  Key columns "x2" and "id3" are of incompatible types: character varying and real.
  -- nor to int4
  ALTER TABLE fktable ADD CONSTRAINT fk_2_1
  FOREIGN KEY (x2) REFERENCES pktable(id1);
! ERROR:  foreign key constraint "fk_2_1" cannot be implemented
! DETAIL:  Key columns "x2" and "id1" are of incompatible types: character varying and integer.
  -- real does not promote to int4
  ALTER TABLE fktable ADD CONSTRAINT fk_3_1
  FOREIGN KEY (x3) REFERENCES pktable(id1);
! ERROR:  foreign key constraint "fk_3_1" cannot be implemented
! DETAIL:  Key columns "x3" and "id1" are of incompatible types: real and integer.
  -- int4 does not promote to text
  ALTER TABLE fktable ADD CONSTRAINT fk_1_2
  FOREIGN KEY (x1) REFERENCES pktable(id2);
! ERROR:  foreign key constraint "fk_1_2" cannot be implemented
! DETAIL:  Key columns "x1" and "id2" are of incompatible types: integer and character varying.
  -- should succeed
  -- int4 promotes to real
  ALTER TABLE fktable ADD CONSTRAINT fk_1_3
  FOREIGN KEY (x1) REFERENCES pktable(id3);
  -- text is compatible with varchar
  ALTER TABLE fktable ADD CONSTRAINT fk_4_2
  FOREIGN KEY (x4) REFERENCES pktable(id2);
  -- int2 is part of integer opfamily as of 8.0
  ALTER TABLE fktable ADD CONSTRAINT fk_5_1
  FOREIGN KEY (x5) REFERENCES pktable(id1);
  -- check multikey cases, especially out-of-order column lists
  -- these should work
  ALTER TABLE fktable ADD CONSTRAINT fk_123_123
  FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id1,id2,id3);
  ALTER TABLE fktable ADD CONSTRAINT fk_213_213
  FOREIGN KEY (x2,x1,x3) REFERENCES pktable(id2,id1,id3);
  ALTER TABLE fktable ADD CONSTRAINT fk_253_213
  FOREIGN KEY (x2,x5,x3) REFERENCES pktable(id2,id1,id3);
  -- these should fail
  ALTER TABLE fktable ADD CONSTRAINT fk_123_231
  FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id2,id3,id1);
! ERROR:  foreign key constraint "fk_123_231" cannot be implemented
! DETAIL:  Key columns "x1" and "id2" are of incompatible types: integer and character varying.
  ALTER TABLE fktable ADD CONSTRAINT fk_241_132
  FOREIGN KEY (x2,x4,x1) REFERENCES pktable(id1,id3,id2);
! ERROR:  foreign key constraint "fk_241_132" cannot be implemented
! DETAIL:  Key columns "x2" and "id1" are of incompatible types: character varying and integer.
  DROP TABLE pktable, fktable;
  -- test a tricky case: we can elide firing the FK check trigger during
  -- an UPDATE if the UPDATE did not change the foreign key
  -- field. However, we can't do this if our transaction was the one that
--- 1111,1168 ----
          x4      TEXT,
          x5      INT2
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- check individual constraints with alter table.
  -- should fail
  -- varchar does not promote to real
  ALTER TABLE fktable ADD CONSTRAINT fk_2_3
  FOREIGN KEY (x2) REFERENCES pktable(id3);
! ERROR:  relation "fktable" does not exist
  -- nor to int4
  ALTER TABLE fktable ADD CONSTRAINT fk_2_1
  FOREIGN KEY (x2) REFERENCES pktable(id1);
! ERROR:  relation "fktable" does not exist
  -- real does not promote to int4
  ALTER TABLE fktable ADD CONSTRAINT fk_3_1
  FOREIGN KEY (x3) REFERENCES pktable(id1);
! ERROR:  relation "fktable" does not exist
  -- int4 does not promote to text
  ALTER TABLE fktable ADD CONSTRAINT fk_1_2
  FOREIGN KEY (x1) REFERENCES pktable(id2);
! ERROR:  relation "fktable" does not exist
  -- should succeed
  -- int4 promotes to real
  ALTER TABLE fktable ADD CONSTRAINT fk_1_3
  FOREIGN KEY (x1) REFERENCES pktable(id3);
+ ERROR:  relation "fktable" does not exist
  -- text is compatible with varchar
  ALTER TABLE fktable ADD CONSTRAINT fk_4_2
  FOREIGN KEY (x4) REFERENCES pktable(id2);
+ ERROR:  relation "fktable" does not exist
  -- int2 is part of integer opfamily as of 8.0
  ALTER TABLE fktable ADD CONSTRAINT fk_5_1
  FOREIGN KEY (x5) REFERENCES pktable(id1);
+ ERROR:  relation "fktable" does not exist
  -- check multikey cases, especially out-of-order column lists
  -- these should work
  ALTER TABLE fktable ADD CONSTRAINT fk_123_123
  FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id1,id2,id3);
+ ERROR:  relation "fktable" does not exist
  ALTER TABLE fktable ADD CONSTRAINT fk_213_213
  FOREIGN KEY (x2,x1,x3) REFERENCES pktable(id2,id1,id3);
+ ERROR:  relation "fktable" does not exist
  ALTER TABLE fktable ADD CONSTRAINT fk_253_213
  FOREIGN KEY (x2,x5,x3) REFERENCES pktable(id2,id1,id3);
+ ERROR:  relation "fktable" does not exist
  -- these should fail
  ALTER TABLE fktable ADD CONSTRAINT fk_123_231
  FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id2,id3,id1);
! ERROR:  relation "fktable" does not exist
  ALTER TABLE fktable ADD CONSTRAINT fk_241_132
  FOREIGN KEY (x2,x4,x1) REFERENCES pktable(id1,id3,id2);
! ERROR:  relation "fktable" does not exist
  DROP TABLE pktable, fktable;
+ ERROR:  table "fktable" does not exist
  -- test a tricky case: we can elide firing the FK check trigger during
  -- an UPDATE if the UPDATE did not change the foreign key
  -- field. However, we can't do this if our transaction was the one that
***************
*** 1132,1207 ****
      id int primary key,
      other int
  ) DISTRIBUTE BY REPLICATION;
  CREATE TEMP TABLE fktable (
      id int primary key,
      fk int references pktable deferrable initially deferred
  ) DISTRIBUTE BY REPLICATION;
  INSERT INTO pktable VALUES (5, 10);
  BEGIN;
  -- doesn't match PK, but no error yet
  INSERT INTO fktable VALUES (0, 20);
  -- don't change FK
  UPDATE fktable SET id = id + 1;
  -- should catch error from initial INSERT
  COMMIT;
- ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
- DETAIL:  Key (fk)=(20) is not present in table "pktable".
  -- check same case when insert is in a different subtransaction than update
  BEGIN;
  -- doesn't match PK, but no error yet
  INSERT INTO fktable VALUES (0, 20);
  -- UPDATE will be in a subxact
  SAVEPOINT savept1;
  -- don't change FK
  UPDATE fktable SET id = id + 1;
  -- should catch error from initial INSERT
  COMMIT;
- ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
- DETAIL:  Key (fk)=(20) is not present in table "pktable".
  BEGIN;
  -- INSERT will be in a subxact
  SAVEPOINT savept1;
  -- doesn't match PK, but no error yet
  INSERT INTO fktable VALUES (0, 20);
  RELEASE SAVEPOINT savept1;
  -- don't change FK
  UPDATE fktable SET id = id + 1;
  -- should catch error from initial INSERT
  COMMIT;
- ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
- DETAIL:  Key (fk)=(20) is not present in table "pktable".
  BEGIN;
  -- doesn't match PK, but no error yet
  INSERT INTO fktable VALUES (0, 20);
  -- UPDATE will be in a subxact
  SAVEPOINT savept1;
  -- don't change FK
  UPDATE fktable SET id = id + 1;
  -- Roll back the UPDATE
  ROLLBACK TO savept1;
  -- should catch error from initial INSERT
  COMMIT;
- ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
- DETAIL:  Key (fk)=(20) is not present in table "pktable".
  --
  -- check ALTER CONSTRAINT
  --
  INSERT INTO fktable VALUES (1, 5);
  ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY IMMEDIATE;
  BEGIN;
  -- doesn't match FK, should throw error now
  UPDATE pktable SET id = 10 WHERE id = 5;
! ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_fk_fkey" on table "fktable"
! DETAIL:  Key (id)=(5) is still referenced from table "fktable".
  COMMIT;
  BEGIN;
  -- doesn't match PK, should throw error now
  INSERT INTO fktable VALUES (0, 20);
! ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
! DETAIL:  Key (fk)=(20) is not present in table "pktable".
  COMMIT;
  -- try additional syntax
  ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE;
  -- illegal option
  ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE INITIALLY DEFERRED;
  ERROR:  constraint declared INITIALLY DEFERRED must be DEFERRABLE
--- 1173,1269 ----
      id int primary key,
      other int
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  relation "pktable" already exists
  CREATE TEMP TABLE fktable (
      id int primary key,
      fk int references pktable deferrable initially deferred
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  INSERT INTO pktable VALUES (5, 10);
  BEGIN;
  -- doesn't match PK, but no error yet
  INSERT INTO fktable VALUES (0, 20);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO fktable VALUES (0, 20);
+                     ^
  -- don't change FK
  UPDATE fktable SET id = id + 1;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  -- should catch error from initial INSERT
  COMMIT;
  -- check same case when insert is in a different subtransaction than update
  BEGIN;
  -- doesn't match PK, but no error yet
  INSERT INTO fktable VALUES (0, 20);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO fktable VALUES (0, 20);
+                     ^
  -- UPDATE will be in a subxact
  SAVEPOINT savept1;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  -- don't change FK
  UPDATE fktable SET id = id + 1;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  -- should catch error from initial INSERT
  COMMIT;
  BEGIN;
  -- INSERT will be in a subxact
  SAVEPOINT savept1;
  -- doesn't match PK, but no error yet
  INSERT INTO fktable VALUES (0, 20);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO fktable VALUES (0, 20);
+                     ^
  RELEASE SAVEPOINT savept1;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  -- don't change FK
  UPDATE fktable SET id = id + 1;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  -- should catch error from initial INSERT
  COMMIT;
  BEGIN;
  -- doesn't match PK, but no error yet
  INSERT INTO fktable VALUES (0, 20);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO fktable VALUES (0, 20);
+                     ^
  -- UPDATE will be in a subxact
  SAVEPOINT savept1;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  -- don't change FK
  UPDATE fktable SET id = id + 1;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  -- Roll back the UPDATE
  ROLLBACK TO savept1;
+ ERROR:  no such savepoint
  -- should catch error from initial INSERT
  COMMIT;
  --
  -- check ALTER CONSTRAINT
  --
  INSERT INTO fktable VALUES (1, 5);
+ ERROR:  relation "fktable" does not exist
+ LINE 1: INSERT INTO fktable VALUES (1, 5);
+                     ^
  ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY IMMEDIATE;
+ ERROR:  relation "fktable" does not exist
  BEGIN;
  -- doesn't match FK, should throw error now
  UPDATE pktable SET id = 10 WHERE id = 5;
! ERROR:  column "id" does not exist
! LINE 1: UPDATE pktable SET id = 10 WHERE id = 5;
!                                          ^
  COMMIT;
  BEGIN;
  -- doesn't match PK, should throw error now
  INSERT INTO fktable VALUES (0, 20);
! ERROR:  relation "fktable" does not exist
! LINE 1: INSERT INTO fktable VALUES (0, 20);
!                     ^
  COMMIT;
  -- try additional syntax
  ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE;
+ ERROR:  relation "fktable" does not exist
  -- illegal option
  ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE INITIALLY DEFERRED;
  ERROR:  constraint declared INITIALLY DEFERRED must be DEFERRABLE
***************
*** 1223,1277 ****
    worker INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL,
    checked_by INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL
  ) DISTRIBUTE BY REPLICATION;
  INSERT INTO tasks VALUES (1,1,NULL,NULL);
  INSERT INTO tasks VALUES (2,2,2,NULL);
  INSERT INTO tasks VALUES (3,3,3,3);
  SELECT * FROM tasks ORDER BY 1, 2, 3,4;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   2 |     2 |      2 |           
!   3 |     3 |      3 |          3
! (3 rows)
! 
  UPDATE users SET id = 4 WHERE id = 3;
  SELECT * FROM tasks ORDER BY 1, 2, 3,4;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   2 |     2 |      2 |           
!   3 |     4 |      4 |          4
! (3 rows)
! 
  DELETE FROM users WHERE id = 4;
  SELECT * FROM tasks ORDER BY 1, 2, 3,4;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   2 |     2 |      2 |           
!   3 |       |        |           
! (3 rows)
! 
  -- could fail with only 2 changes to make, if row was already updated
  BEGIN;
  UPDATE tasks set id=id WHERE id=2;
  SELECT * FROM tasks ORDER BY 1, 2, 3,4;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   2 |     2 |      2 |           
!   3 |       |        |           
! (3 rows)
! 
  DELETE FROM users WHERE id = 2;
  SELECT * FROM tasks ORDER BY 1, 2, 3,4;
!  id | owner | worker | checked_by 
! ----+-------+--------+------------
!   1 |     1 |        |           
!   2 |       |        |           
!   3 |       |        |           
! (3 rows)
! 
  COMMIT;
  --
  -- Test self-referential FK with CASCADE (bug #6268)
--- 1285,1329 ----
    worker INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL,
    checked_by INT REFERENCES users ON UPDATE CASCADE ON DELETE SET NULL
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  INSERT INTO tasks VALUES (1,1,NULL,NULL);
+ ERROR:  relation "tasks" does not exist
+ LINE 1: INSERT INTO tasks VALUES (1,1,NULL,NULL);
+                     ^
  INSERT INTO tasks VALUES (2,2,2,NULL);
+ ERROR:  relation "tasks" does not exist
+ LINE 1: INSERT INTO tasks VALUES (2,2,2,NULL);
+                     ^
  INSERT INTO tasks VALUES (3,3,3,3);
+ ERROR:  relation "tasks" does not exist
+ LINE 1: INSERT INTO tasks VALUES (3,3,3,3);
+                     ^
  SELECT * FROM tasks ORDER BY 1, 2, 3,4;
! ERROR:  relation "tasks" does not exist
! LINE 1: SELECT * FROM tasks ORDER BY 1, 2, 3,4;
!                       ^
  UPDATE users SET id = 4 WHERE id = 3;
  SELECT * FROM tasks ORDER BY 1, 2, 3,4;
! ERROR:  relation "tasks" does not exist
! LINE 1: SELECT * FROM tasks ORDER BY 1, 2, 3,4;
!                       ^
  DELETE FROM users WHERE id = 4;
  SELECT * FROM tasks ORDER BY 1, 2, 3,4;
! ERROR:  relation "tasks" does not exist
! LINE 1: SELECT * FROM tasks ORDER BY 1, 2, 3,4;
!                       ^
  -- could fail with only 2 changes to make, if row was already updated
  BEGIN;
  UPDATE tasks set id=id WHERE id=2;
+ ERROR:  relation "tasks" does not exist
+ LINE 1: UPDATE tasks set id=id WHERE id=2;
+                ^
  SELECT * FROM tasks ORDER BY 1, 2, 3,4;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  DELETE FROM users WHERE id = 2;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT * FROM tasks ORDER BY 1, 2, 3,4;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  COMMIT;
  --
  -- Test self-referential FK with CASCADE (bug #6268)
***************
*** 1282,1308 ****
      foreign key (b) references selfref (a)
          on update cascade on delete cascade
  ) DISTRIBUTE BY REPLICATION;
  insert into selfref (a, b)
  values
      (0, 0),
      (1, 1);
  begin;
      update selfref set a = 123 where a = 0;
      select a, b from selfref;
!   a  |  b  
! -----+-----
!    1 |   1
!  123 | 123
! (2 rows)
! 
      update selfref set a = 456 where a = 123;
      select a, b from selfref;
!   a  |  b  
! -----+-----
!    1 |   1
!  456 | 456
! (2 rows)
! 
  commit;
  --
  -- Test that SET DEFAULT actions recognize updates to default values
--- 1334,1358 ----
      foreign key (b) references selfref (a)
          on update cascade on delete cascade
  ) DISTRIBUTE BY REPLICATION;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  insert into selfref (a, b)
  values
      (0, 0),
      (1, 1);
+ ERROR:  relation "selfref" does not exist
+ LINE 1: insert into selfref (a, b)
+                     ^
  begin;
      update selfref set a = 123 where a = 0;
+ ERROR:  relation "selfref" does not exist
+ LINE 1: update selfref set a = 123 where a = 0;
+                ^
      select a, b from selfref;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
      update selfref set a = 456 where a = 123;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
      select a, b from selfref;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  commit;
  --
  -- Test that SET DEFAULT actions recognize updates to default values
***************
*** 1310,1399 ****
  create temp table defp (f1 int primary key);
  create temp table defc (f1 int default 0
                          references defp on delete set default);
  insert into defp values (0), (1), (2);
  insert into defc values (2);
  select * from defc;
!  f1 
! ----
!   2
! (1 row)
! 
  delete from defp where f1 = 2;
- ERROR:  insert or update on table "defc" violates foreign key constraint "defc_f1_fkey"
- DETAIL:  Key (f1)=(0) is not present in table "defp".
  select * from defc;
!  f1 
! ----
!   2
! (1 row)
! 
  delete from defp where f1 = 0; -- fail
  alter table defc alter column f1 set default 1;
  delete from defp where f1 = 0;
  select * from defc;
!  f1 
! ----
!   2
! (1 row)
! 
  delete from defp where f1 = 1; -- fail
  --
  -- Test the difference between NO ACTION and RESTRICT
  --
  create temp table pp (f1 int primary key);
  create temp table cc (f1 int references pp on update no action);
  insert into pp values(12);
  insert into pp values(11);
  update pp set f1=f1+1;
  ERROR:  Distributed column or partition column "f1" can't be updated in current version
  insert into cc values(13);
! ERROR:  insert or update on table "cc" violates foreign key constraint "cc_f1_fkey"
! DETAIL:  Key (f1)=(13) is not present in table "pp".
  update pp set f1=f1+1;
  ERROR:  Distributed column or partition column "f1" can't be updated in current version
  update pp set f1=f1+1; -- fail
  ERROR:  Distributed column or partition column "f1" can't be updated in current version
  drop table pp, cc;
  create temp table pp (f1 int primary key);
  create temp table cc (f1 int references pp on update restrict);
  insert into pp values(12);
  insert into pp values(11);
  update pp set f1=f1+1;
  ERROR:  Distributed column or partition column "f1" can't be updated in current version
  insert into cc values(13);
! ERROR:  insert or update on table "cc" violates foreign key constraint "cc_f1_fkey"
! DETAIL:  Key (f1)=(13) is not present in table "pp".
  update pp set f1=f1+1; -- fail
  ERROR:  Distributed column or partition column "f1" can't be updated in current version
  drop table pp, cc;
  --
  -- Test interaction of foreign-key optimization with rules (bug #14219)
  --
  create temp table t1 (a integer primary key, b text);
  create temp table t2 (a integer, b integer references t1) distribute by hash (b);
  create rule r1 as on delete to t1 do delete from t2 where t2.b = old.a;
  explain (costs off) delete from t1 where a = 1;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1)
!    ->  Delete on t2
!          ->  Nested Loop
!                ->  Seq Scan on t2
!                      Filter: (b = 1)
!                ->  Materialize
!                      ->  Remote Subquery Scan on all (datanode_1)
!                            ->  Index Scan using t1_pkey on t1
!                                  Index Cond: (a = 1)
!  
   Remote Fast Query Execution
     Node/s: datanode_1
     ->  Delete on t1
           ->  Index Scan using t1_pkey on t1
                 Index Cond: (a = 1)
! (15 rows)
  
  delete from t1 where a = 1;
  drop rule r1 on t1;
  explain (costs off, nodes off) delete from t1 where a = 1;
                   QUERY PLAN                 
  --------------------------------------------
--- 1360,1452 ----
  create temp table defp (f1 int primary key);
  create temp table defc (f1 int default 0
                          references defp on delete set default);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  insert into defp values (0), (1), (2);
  insert into defc values (2);
+ ERROR:  relation "defc" does not exist
+ LINE 1: insert into defc values (2);
+                     ^
  select * from defc;
! ERROR:  relation "defc" does not exist
! LINE 1: select * from defc;
!                       ^
  delete from defp where f1 = 2;
  select * from defc;
! ERROR:  relation "defc" does not exist
! LINE 1: select * from defc;
!                       ^
  delete from defp where f1 = 0; -- fail
  alter table defc alter column f1 set default 1;
+ ERROR:  relation "defc" does not exist
  delete from defp where f1 = 0;
  select * from defc;
! ERROR:  relation "defc" does not exist
! LINE 1: select * from defc;
!                       ^
  delete from defp where f1 = 1; -- fail
  --
  -- Test the difference between NO ACTION and RESTRICT
  --
  create temp table pp (f1 int primary key);
  create temp table cc (f1 int references pp on update no action);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  insert into pp values(12);
  insert into pp values(11);
  update pp set f1=f1+1;
  ERROR:  Distributed column or partition column "f1" can't be updated in current version
  insert into cc values(13);
! ERROR:  relation "cc" does not exist
! LINE 1: insert into cc values(13);
!                     ^
  update pp set f1=f1+1;
  ERROR:  Distributed column or partition column "f1" can't be updated in current version
  update pp set f1=f1+1; -- fail
  ERROR:  Distributed column or partition column "f1" can't be updated in current version
  drop table pp, cc;
+ ERROR:  table "cc" does not exist
  create temp table pp (f1 int primary key);
+ ERROR:  relation "pp" already exists
  create temp table cc (f1 int references pp on update restrict);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  insert into pp values(12);
+ ERROR:  node:datanode_1, backend_pid:384303, nodename:datanode_1,backend_pid:384303,message:duplicate key value violates unique constraint "pp_pkey"
+ DETAIL:  Key (f1)=(12) already exists.
  insert into pp values(11);
+ ERROR:  node:datanode_2, backend_pid:384324, nodename:datanode_2,backend_pid:384324,message:duplicate key value violates unique constraint "pp_pkey"
+ DETAIL:  Key (f1)=(11) already exists.
  update pp set f1=f1+1;
  ERROR:  Distributed column or partition column "f1" can't be updated in current version
  insert into cc values(13);
! ERROR:  relation "cc" does not exist
! LINE 1: insert into cc values(13);
!                     ^
  update pp set f1=f1+1; -- fail
  ERROR:  Distributed column or partition column "f1" can't be updated in current version
  drop table pp, cc;
+ ERROR:  table "cc" does not exist
  --
  -- Test interaction of foreign-key optimization with rules (bug #14219)
  --
  create temp table t1 (a integer primary key, b text);
  create temp table t2 (a integer, b integer references t1) distribute by hash (b);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  create rule r1 as on delete to t1 do delete from t2 where t2.b = old.a;
+ ERROR:  relation "t2" does not exist
+ LINE 1: create rule r1 as on delete to t1 do delete from t2 where t2...
+                                                          ^
  explain (costs off) delete from t1 where a = 1;
!                  QUERY PLAN                 
! --------------------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1
     ->  Delete on t1
           ->  Index Scan using t1_pkey on t1
                 Index Cond: (a = 1)
! (5 rows)
  
  delete from t1 where a = 1;
  drop rule r1 on t1;
+ ERROR:  rule "r1" for relation "t1" does not exist
  explain (costs off, nodes off) delete from t1 where a = 1;
                   QUERY PLAN                 
  --------------------------------------------
***************
*** 1409,1414 ****
--- 1462,1468 ----
  --
  create table pktable2(f1 int primary key);
  create table fktable2(f1 int references pktable2 deferrable initially deferred);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  insert into pktable2 values(1);
  -- Since subtransactions are not supported in XL, these tests make no sense
  -- begin;
***************
*** 1429,1443 ****
  --
  begin;
  insert into fktable2 values(2);
  alter table fktable2 drop constraint fktable2_f1_fkey;
! ERROR:  cannot ALTER TABLE "fktable2" because it has pending trigger events
  commit;
  begin;
  delete from pktable2 where f1 = 1;
  alter table fktable2 drop constraint fktable2_f1_fkey;
! ERROR:  cannot ALTER TABLE "pktable2" because it has pending trigger events
  commit;
  drop table pktable2, fktable2;
  -- Altering a type referenced by a foreign key needs to drop/recreate the FK.
  -- Ensure that works.
  CREATE TABLE fk_notpartitioned_pk (a INT, PRIMARY KEY(a), CHECK (a > 0));
--- 1483,1501 ----
  --
  begin;
  insert into fktable2 values(2);
+ ERROR:  relation "fktable2" does not exist
+ LINE 1: insert into fktable2 values(2);
+                     ^
  alter table fktable2 drop constraint fktable2_f1_fkey;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  commit;
  begin;
  delete from pktable2 where f1 = 1;
  alter table fktable2 drop constraint fktable2_f1_fkey;
! ERROR:  relation "fktable2" does not exist
  commit;
  drop table pktable2, fktable2;
+ ERROR:  table "fktable2" does not exist
  -- Altering a type referenced by a foreign key needs to drop/recreate the FK.
  -- Ensure that works.
  CREATE TABLE fk_notpartitioned_pk (a INT, PRIMARY KEY(a), CHECK (a > 0));
***************
*** 1453,1458 ****
--- 1511,1517 ----
  LINE 1: INSERT INTO fk_partitioned_fk VALUES (1);
                      ^
  ALTER TABLE fk_notpartitioned_pk ALTER COLUMN a TYPE bigint;
+ ERROR:  cannot alter type of column named in distributed key
  DELETE FROM fk_notpartitioned_pk WHERE a = 1;
  DROP TABLE fk_notpartitioned_pk, fk_partitioned_fk;
  ERROR:  table "fk_partitioned_fk" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/cluster.out"	2025-07-31 16:07:14.980068216 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/cluster.out"	2025-07-31 16:39:50.914623094 +0800
***************
*** 9,18 ****
--- 9,23 ----
  	d TEXT,
  	CONSTRAINT clstr_tst_con FOREIGN KEY (b) REFERENCES clstr_tst_s)
  	DISTRIBUTE BY HASH (b);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  CREATE INDEX clstr_tst_b ON clstr_tst (b);
+ ERROR:  relation "clstr_tst" does not exist
  CREATE INDEX clstr_tst_c ON clstr_tst (c);
+ ERROR:  relation "clstr_tst" does not exist
  CREATE INDEX clstr_tst_c_b ON clstr_tst (c,b);
+ ERROR:  relation "clstr_tst" does not exist
  CREATE INDEX clstr_tst_b_c ON clstr_tst (b,c);
+ ERROR:  relation "clstr_tst" does not exist
  INSERT INTO clstr_tst_s (b) VALUES (0);
  INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
  INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
***************
*** 20,274 ****
  INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
  INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
  CREATE TABLE clstr_tst_inh () INHERITS (clstr_tst);
  INSERT INTO clstr_tst (b, c) VALUES (11, 'once');
  INSERT INTO clstr_tst (b, c) VALUES (10, 'diez');
  INSERT INTO clstr_tst (b, c) VALUES (31, 'treinta y uno');
  INSERT INTO clstr_tst (b, c) VALUES (22, 'veintidos');
  INSERT INTO clstr_tst (b, c) VALUES (3, 'tres');
  INSERT INTO clstr_tst (b, c) VALUES (20, 'veinte');
  INSERT INTO clstr_tst (b, c) VALUES (23, 'veintitres');
  INSERT INTO clstr_tst (b, c) VALUES (21, 'veintiuno');
  INSERT INTO clstr_tst (b, c) VALUES (4, 'cuatro');
  INSERT INTO clstr_tst (b, c) VALUES (14, 'catorce');
  INSERT INTO clstr_tst (b, c) VALUES (2, 'dos');
  INSERT INTO clstr_tst (b, c) VALUES (18, 'dieciocho');
  INSERT INTO clstr_tst (b, c) VALUES (27, 'veintisiete');
  INSERT INTO clstr_tst (b, c) VALUES (25, 'veinticinco');
  INSERT INTO clstr_tst (b, c) VALUES (13, 'trece');
  INSERT INTO clstr_tst (b, c) VALUES (28, 'veintiocho');
  INSERT INTO clstr_tst (b, c) VALUES (32, 'treinta y dos');
  INSERT INTO clstr_tst (b, c) VALUES (5, 'cinco');
  INSERT INTO clstr_tst (b, c) VALUES (29, 'veintinueve');
  INSERT INTO clstr_tst (b, c) VALUES (1, 'uno');
  INSERT INTO clstr_tst (b, c) VALUES (24, 'veinticuatro');
  INSERT INTO clstr_tst (b, c) VALUES (30, 'treinta');
  INSERT INTO clstr_tst (b, c) VALUES (12, 'doce');
  INSERT INTO clstr_tst (b, c) VALUES (17, 'diecisiete');
  INSERT INTO clstr_tst (b, c) VALUES (9, 'nueve');
  INSERT INTO clstr_tst (b, c) VALUES (19, 'diecinueve');
  INSERT INTO clstr_tst (b, c) VALUES (26, 'veintiseis');
  INSERT INTO clstr_tst (b, c) VALUES (15, 'quince');
  INSERT INTO clstr_tst (b, c) VALUES (7, 'siete');
  INSERT INTO clstr_tst (b, c) VALUES (16, 'dieciseis');
  INSERT INTO clstr_tst (b, c) VALUES (8, 'ocho');
  -- This entry is needed to test that TOASTED values are copied correctly.
  INSERT INTO clstr_tst (b, c, d) VALUES (6, 'seis', repeat('xyzzy', 100000));
  CLUSTER clstr_tst_c ON clstr_tst;
  SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY a, b, c;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!   1 | 11 | once          |                                |       
!   2 | 10 | diez          |                                |       
!   3 | 31 | treinta y uno |                                |       
!   4 | 22 | veintidos     |                                |       
!   5 |  3 | tres          |                                |       
!   6 | 20 | veinte        |                                |       
!   7 | 23 | veintitres    |                                |       
!   8 | 21 | veintiuno     |                                |       
!   9 |  4 | cuatro        |                                |       
!  10 | 14 | catorce       |                                |       
!  11 |  2 | dos           |                                |       
!  12 | 18 | dieciocho     |                                |       
!  13 | 27 | veintisiete   |                                |       
!  14 | 25 | veinticinco   |                                |       
!  15 | 13 | trece         |                                |       
!  16 | 28 | veintiocho    |                                |       
!  17 | 32 | treinta y dos |                                |       
!  18 |  5 | cinco         |                                |       
!  19 | 29 | veintinueve   |                                |       
!  20 |  1 | uno           |                                |       
!  21 | 24 | veinticuatro  |                                |       
!  22 | 30 | treinta       |                                |       
!  23 | 12 | doce          |                                |       
!  24 | 17 | diecisiete    |                                |       
!  25 |  9 | nueve         |                                |       
!  26 | 19 | diecinueve    |                                |       
!  27 | 26 | veintiseis    |                                |       
!  28 | 15 | quince        |                                |       
!  29 |  7 | siete         |                                |       
!  30 | 16 | dieciseis     |                                |       
!  31 |  8 | ocho          |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
! (32 rows)
! 
  SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY a;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!   1 | 11 | once          |                                |       
!   2 | 10 | diez          |                                |       
!   3 | 31 | treinta y uno |                                |       
!   4 | 22 | veintidos     |                                |       
!   5 |  3 | tres          |                                |       
!   6 | 20 | veinte        |                                |       
!   7 | 23 | veintitres    |                                |       
!   8 | 21 | veintiuno     |                                |       
!   9 |  4 | cuatro        |                                |       
!  10 | 14 | catorce       |                                |       
!  11 |  2 | dos           |                                |       
!  12 | 18 | dieciocho     |                                |       
!  13 | 27 | veintisiete   |                                |       
!  14 | 25 | veinticinco   |                                |       
!  15 | 13 | trece         |                                |       
!  16 | 28 | veintiocho    |                                |       
!  17 | 32 | treinta y dos |                                |       
!  18 |  5 | cinco         |                                |       
!  19 | 29 | veintinueve   |                                |       
!  20 |  1 | uno           |                                |       
!  21 | 24 | veinticuatro  |                                |       
!  22 | 30 | treinta       |                                |       
!  23 | 12 | doce          |                                |       
!  24 | 17 | diecisiete    |                                |       
!  25 |  9 | nueve         |                                |       
!  26 | 19 | diecinueve    |                                |       
!  27 | 26 | veintiseis    |                                |       
!  28 | 15 | quince        |                                |       
!  29 |  7 | siete         |                                |       
!  30 | 16 | dieciseis     |                                |       
!  31 |  8 | ocho          |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
! (32 rows)
! 
  SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY b;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!  20 |  1 | uno           |                                |       
!  11 |  2 | dos           |                                |       
!   5 |  3 | tres          |                                |       
!   9 |  4 | cuatro        |                                |       
!  18 |  5 | cinco         |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
!  29 |  7 | siete         |                                |       
!  31 |  8 | ocho          |                                |       
!  25 |  9 | nueve         |                                |       
!   2 | 10 | diez          |                                |       
!   1 | 11 | once          |                                |       
!  23 | 12 | doce          |                                |       
!  15 | 13 | trece         |                                |       
!  10 | 14 | catorce       |                                |       
!  28 | 15 | quince        |                                |       
!  30 | 16 | dieciseis     |                                |       
!  24 | 17 | diecisiete    |                                |       
!  12 | 18 | dieciocho     |                                |       
!  26 | 19 | diecinueve    |                                |       
!   6 | 20 | veinte        |                                |       
!   8 | 21 | veintiuno     |                                |       
!   4 | 22 | veintidos     |                                |       
!   7 | 23 | veintitres    |                                |       
!  21 | 24 | veinticuatro  |                                |       
!  14 | 25 | veinticinco   |                                |       
!  27 | 26 | veintiseis    |                                |       
!  13 | 27 | veintisiete   |                                |       
!  16 | 28 | veintiocho    |                                |       
!  19 | 29 | veintinueve   |                                |       
!  22 | 30 | treinta       |                                |       
!   3 | 31 | treinta y uno |                                |       
!  17 | 32 | treinta y dos |                                |       
! (32 rows)
! 
  SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY c;
!  a  | b  |       c       |           substring            | length 
! ----+----+---------------+--------------------------------+--------
!  10 | 14 | catorce       |                                |       
!  18 |  5 | cinco         |                                |       
!   9 |  4 | cuatro        |                                |       
!  26 | 19 | diecinueve    |                                |       
!  12 | 18 | dieciocho     |                                |       
!  30 | 16 | dieciseis     |                                |       
!  24 | 17 | diecisiete    |                                |       
!   2 | 10 | diez          |                                |       
!  23 | 12 | doce          |                                |       
!  11 |  2 | dos           |                                |       
!  25 |  9 | nueve         |                                |       
!  31 |  8 | ocho          |                                |       
!   1 | 11 | once          |                                |       
!  28 | 15 | quince        |                                |       
!  32 |  6 | seis          | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
!  29 |  7 | siete         |                                |       
!  15 | 13 | trece         |                                |       
!  22 | 30 | treinta       |                                |       
!  17 | 32 | treinta y dos |                                |       
!   3 | 31 | treinta y uno |                                |       
!   5 |  3 | tres          |                                |       
!  20 |  1 | uno           |                                |       
!   6 | 20 | veinte        |                                |       
!  14 | 25 | veinticinco   |                                |       
!  21 | 24 | veinticuatro  |                                |       
!   4 | 22 | veintidos     |                                |       
!  19 | 29 | veintinueve   |                                |       
!  16 | 28 | veintiocho    |                                |       
!  27 | 26 | veintiseis    |                                |       
!  13 | 27 | veintisiete   |                                |       
!   7 | 23 | veintitres    |                                |       
!   8 | 21 | veintiuno     |                                |       
! (32 rows)
! 
  -- Verify that inheritance link still works
  INSERT INTO clstr_tst_inh VALUES (0, 100, 'in child table');
  SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY a, b, c;
!  a  |  b  |       c        |           substring            | length 
! ----+-----+----------------+--------------------------------+--------
!   0 | 100 | in child table |                                |       
!   1 |  11 | once           |                                |       
!   2 |  10 | diez           |                                |       
!   3 |  31 | treinta y uno  |                                |       
!   4 |  22 | veintidos      |                                |       
!   5 |   3 | tres           |                                |       
!   6 |  20 | veinte         |                                |       
!   7 |  23 | veintitres     |                                |       
!   8 |  21 | veintiuno      |                                |       
!   9 |   4 | cuatro         |                                |       
!  10 |  14 | catorce        |                                |       
!  11 |   2 | dos            |                                |       
!  12 |  18 | dieciocho      |                                |       
!  13 |  27 | veintisiete    |                                |       
!  14 |  25 | veinticinco    |                                |       
!  15 |  13 | trece          |                                |       
!  16 |  28 | veintiocho     |                                |       
!  17 |  32 | treinta y dos  |                                |       
!  18 |   5 | cinco          |                                |       
!  19 |  29 | veintinueve    |                                |       
!  20 |   1 | uno            |                                |       
!  21 |  24 | veinticuatro   |                                |       
!  22 |  30 | treinta        |                                |       
!  23 |  12 | doce           |                                |       
!  24 |  17 | diecisiete     |                                |       
!  25 |   9 | nueve          |                                |       
!  26 |  19 | diecinueve     |                                |       
!  27 |  26 | veintiseis     |                                |       
!  28 |  15 | quince         |                                |       
!  29 |   7 | siete          |                                |       
!  30 |  16 | dieciseis      |                                |       
!  31 |   8 | ocho           |                                |       
!  32 |   6 | seis           | xyzzyxyzzyxyzzyxyzzyxyzzyxyzzy | 500000
! (33 rows)
! 
  -- Verify that foreign key link still works
  INSERT INTO clstr_tst (b, c) VALUES (1111, 'this should fail');
! ERROR:  insert or update on table "clstr_tst" violates foreign key constraint "clstr_tst_con"
! DETAIL:  Key (b)=(1111) is not present in table "clstr_tst_s".
  SELECT conname FROM pg_constraint WHERE conrelid = 'clstr_tst'::regclass
  ORDER BY 1;
!     conname    
! ---------------
!  clstr_tst_con
! (1 row)
! 
  SELECT relname, relkind,
      EXISTS(SELECT 1 FROM pg_class WHERE oid = c.reltoastrelid) AS hastoast
  FROM pg_class c WHERE relname LIKE 'clstr_tst%' ORDER BY relname;
         relname        | relkind | hastoast 
  ----------------------+---------+----------
-  clstr_tst            | r       | t
-  clstr_tst_a_seq      | S       | f
-  clstr_tst_b          | i       | f
-  clstr_tst_b_c        | i       | f
-  clstr_tst_c          | i       | f
-  clstr_tst_c_b        | i       | f
-  clstr_tst_inh        | r       | t
   clstr_tst_s          | r       | f
   clstr_tst_s_pkey     | i       | f
   clstr_tst_s_rf_a_seq | S       | f
! (10 rows)
  
  -- Verify that indisclustered is correctly set
  SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
--- 25,206 ----
  INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
  INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
  CREATE TABLE clstr_tst_inh () INHERITS (clstr_tst);
+ ERROR:  relation "clstr_tst" does not exist
  INSERT INTO clstr_tst (b, c) VALUES (11, 'once');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (11, 'once');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (10, 'diez');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (10, 'diez');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (31, 'treinta y uno');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (31, 'treinta y uno');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (22, 'veintidos');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (22, 'veintidos');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (3, 'tres');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (3, 'tres');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (20, 'veinte');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (20, 'veinte');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (23, 'veintitres');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (23, 'veintitres');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (21, 'veintiuno');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (21, 'veintiuno');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (4, 'cuatro');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (4, 'cuatro');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (14, 'catorce');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (14, 'catorce');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (2, 'dos');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (2, 'dos');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (18, 'dieciocho');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (18, 'dieciocho');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (27, 'veintisiete');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (27, 'veintisiete');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (25, 'veinticinco');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (25, 'veinticinco');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (13, 'trece');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (13, 'trece');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (28, 'veintiocho');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (28, 'veintiocho');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (32, 'treinta y dos');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (32, 'treinta y dos');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (5, 'cinco');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (5, 'cinco');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (29, 'veintinueve');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (29, 'veintinueve');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (1, 'uno');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (1, 'uno');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (24, 'veinticuatro');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (24, 'veinticuatro');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (30, 'treinta');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (30, 'treinta');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (12, 'doce');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (12, 'doce');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (17, 'diecisiete');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (17, 'diecisiete');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (9, 'nueve');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (9, 'nueve');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (19, 'diecinueve');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (19, 'diecinueve');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (26, 'veintiseis');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (26, 'veintiseis');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (15, 'quince');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (15, 'quince');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (7, 'siete');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (7, 'siete');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (16, 'dieciseis');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (16, 'dieciseis');
+                     ^
  INSERT INTO clstr_tst (b, c) VALUES (8, 'ocho');
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c) VALUES (8, 'ocho');
+                     ^
  -- This entry is needed to test that TOASTED values are copied correctly.
  INSERT INTO clstr_tst (b, c, d) VALUES (6, 'seis', repeat('xyzzy', 100000));
+ ERROR:  relation "clstr_tst" does not exist
+ LINE 1: INSERT INTO clstr_tst (b, c, d) VALUES (6, 'seis', repeat('x...
+                     ^
  CLUSTER clstr_tst_c ON clstr_tst;
+ ERROR:  relation "clstr_tst" does not exist
  SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY a, b, c;
! ERROR:  relation "clstr_tst" does not exist
! LINE 1: SELECT a,b,c,substring(d for 30), length(d) from clstr_tst O...
!                                                          ^
  SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY a;
! ERROR:  relation "clstr_tst" does not exist
! LINE 1: SELECT a,b,c,substring(d for 30), length(d) from clstr_tst O...
!                                                          ^
  SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY b;
! ERROR:  relation "clstr_tst" does not exist
! LINE 1: SELECT a,b,c,substring(d for 30), length(d) from clstr_tst O...
!                                                          ^
  SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY c;
! ERROR:  relation "clstr_tst" does not exist
! LINE 1: SELECT a,b,c,substring(d for 30), length(d) from clstr_tst O...
!                                                          ^
  -- Verify that inheritance link still works
  INSERT INTO clstr_tst_inh VALUES (0, 100, 'in child table');
+ ERROR:  relation "clstr_tst_inh" does not exist
+ LINE 1: INSERT INTO clstr_tst_inh VALUES (0, 100, 'in child table');
+                     ^
  SELECT a,b,c,substring(d for 30), length(d) from clstr_tst ORDER BY a, b, c;
! ERROR:  relation "clstr_tst" does not exist
! LINE 1: SELECT a,b,c,substring(d for 30), length(d) from clstr_tst O...
!                                                          ^
  -- Verify that foreign key link still works
  INSERT INTO clstr_tst (b, c) VALUES (1111, 'this should fail');
! ERROR:  relation "clstr_tst" does not exist
! LINE 1: INSERT INTO clstr_tst (b, c) VALUES (1111, 'this should fail...
!                     ^
  SELECT conname FROM pg_constraint WHERE conrelid = 'clstr_tst'::regclass
  ORDER BY 1;
! ERROR:  relation "clstr_tst" does not exist
! LINE 1: ...ELECT conname FROM pg_constraint WHERE conrelid = 'clstr_tst...
!                                                              ^
  SELECT relname, relkind,
      EXISTS(SELECT 1 FROM pg_class WHERE oid = c.reltoastrelid) AS hastoast
  FROM pg_class c WHERE relname LIKE 'clstr_tst%' ORDER BY relname;
         relname        | relkind | hastoast 
  ----------------------+---------+----------
   clstr_tst_s          | r       | f
   clstr_tst_s_pkey     | i       | f
   clstr_tst_s_rf_a_seq | S       | f
! (3 rows)
  
  -- Verify that indisclustered is correctly set
  SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
***************
*** 276,300 ****
  	AND indrelid=pg_class_2.oid
  	AND pg_class_2.relname = 'clstr_tst'
  	AND indisclustered;
!    relname   
! -------------
!  clstr_tst_c
! (1 row)
  
  -- Try changing indisclustered
  ALTER TABLE clstr_tst CLUSTER ON clstr_tst_b_c;
  SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
  WHERE pg_class.oid=indexrelid
  	AND indrelid=pg_class_2.oid
  	AND pg_class_2.relname = 'clstr_tst'
  	AND indisclustered;
!     relname    
! ---------------
!  clstr_tst_b_c
! (1 row)
  
  -- Try turning off all clustering
  ALTER TABLE clstr_tst SET WITHOUT CLUSTER;
  SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
  WHERE pg_class.oid=indexrelid
  	AND indrelid=pg_class_2.oid
--- 208,232 ----
  	AND indrelid=pg_class_2.oid
  	AND pg_class_2.relname = 'clstr_tst'
  	AND indisclustered;
!  relname 
! ---------
! (0 rows)
  
  -- Try changing indisclustered
  ALTER TABLE clstr_tst CLUSTER ON clstr_tst_b_c;
+ ERROR:  relation "clstr_tst" does not exist
  SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
  WHERE pg_class.oid=indexrelid
  	AND indrelid=pg_class_2.oid
  	AND pg_class_2.relname = 'clstr_tst'
  	AND indisclustered;
!  relname 
! ---------
! (0 rows)
  
  -- Try turning off all clustering
  ALTER TABLE clstr_tst SET WITHOUT CLUSTER;
+ ERROR:  relation "clstr_tst" does not exist
  SELECT pg_class.relname FROM pg_index, pg_class, pg_class AS pg_class_2
  WHERE pg_class.oid=indexrelid
  	AND indrelid=pg_class_2.oid

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/guc_1.out"	2025-07-31 16:07:14.984068152 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/guc.out"	2025-07-31 16:39:50.910623179 +0800
***************
*** 544,551 ****
                                  Table "testschema.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO testtab VALUES (1), (2), (3);
--- 544,551 ----
                                  Table "testschema.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO testtab VALUES (1), (2), (3);
***************
*** 564,571 ****
                                  Table "testschema.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO testtab VALUES (1), (2), (3);
--- 564,571 ----
                                  Table "testschema.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO testtab VALUES (1), (2), (3);
***************
*** 584,591 ****
                                  Table "testschema.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO testtab VALUES (1), (2), (3);
--- 584,591 ----
                                  Table "testschema.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO testtab VALUES (1), (2), (3);
***************
*** 604,611 ****
                                 Table "testschema 3.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO testtab VALUES (1), (2), (3);
--- 604,611 ----
                                 Table "testschema 3.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO testtab VALUES (1), (2), (3);
***************
*** 629,636 ****
                                    Table "SELECT.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  CREATE TABLE "testschema 3".testtab (a int);
--- 629,636 ----
                                    Table "SELECT.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  CREATE TABLE "testschema 3".testtab (a int);
***************
*** 638,645 ****
                                    Table "SELECT.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO "testschema 3".testtab VALUES (1), (2), (3);
--- 638,645 ----
                                    Table "SELECT.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  INSERT INTO "testschema 3".testtab VALUES (1), (2), (3);
***************
*** 665,672 ****
                                    Table "SELECT.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           |          |         | plain   |              | 
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
  SELECT * FROM testtab order by 1;
--- 665,672 ----
                                    Table "SELECT.testtab"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  a      | integer |           | not null |         | plain   |              | 
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  
  SELECT * FROM testtab order by 1;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/tsearch.out"	2025-07-31 16:07:15.005067818 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/tsearch.out"	2025-07-31 16:39:50.892623562 +0800
***************
*** 1593,1600 ****
  CREATE TRIGGER tsvectorupdate
  BEFORE UPDATE OR INSERT ON test_tsvector
  FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger(a, 'pg_catalog.english', t);
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
   count 
  -------
--- 1593,1598 ----
***************
*** 1610,1615 ****
--- 1608,1615 ----
  
  DELETE FROM test_tsvector WHERE t = '345 qwerty';
  INSERT INTO test_tsvector (t, a) VALUES (null, null);
+ ERROR:  null value in column "t" violates not-null constraint
+ DETAIL:  Failing row contains (null, ).
  SELECT count(*) FROM test_tsvector WHERE a @@ to_tsquery('345&qwerty');
   count 
  -------

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/foreign_data.out"	2025-07-31 16:07:14.983068168 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/foreign_data.out"	2025-07-31 16:39:52.551233913 +0800
***************
*** 36,42 ****
  
  -- CREATE FOREIGN DATA WRAPPER
  CREATE FOREIGN DATA WRAPPER foo VALIDATOR bar;            -- ERROR
! ERROR:  function bar(text[], oid) does not exist
  CREATE FOREIGN DATA WRAPPER foo;
  \dew
                          List of foreign-data wrappers
--- 36,42 ----
  
  -- CREATE FOREIGN DATA WRAPPER
  CREATE FOREIGN DATA WRAPPER foo VALIDATOR bar;            -- ERROR
! ERROR:  node:datanode_1, backend_pid:384325, nodename:coord2,backend_pid:383269,message:function bar(text[], oid) does not exist
  CREATE FOREIGN DATA WRAPPER foo;
  \dew
                          List of foreign-data wrappers
***************
*** 48,54 ****
  (3 rows)
  
  CREATE FOREIGN DATA WRAPPER foo; -- duplicate
! ERROR:  foreign-data wrapper "foo" already exists
  DROP FOREIGN DATA WRAPPER foo;
  CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1');
  \dew+
--- 48,54 ----
  (3 rows)
  
  CREATE FOREIGN DATA WRAPPER foo; -- duplicate
! ERROR:  node:datanode_2, backend_pid:384311, nodename:coord2,backend_pid:383339,message:foreign-data wrapper "foo" already exists
  DROP FOREIGN DATA WRAPPER foo;
  CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1');
  \dew+
***************
*** 62,68 ****
  
  DROP FOREIGN DATA WRAPPER foo;
  CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', testing '2');   -- ERROR
! ERROR:  option "testing" provided more than once
  CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', another '2');
  \dew+
                                                         List of foreign-data wrappers
--- 62,68 ----
  
  DROP FOREIGN DATA WRAPPER foo;
  CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', testing '2');   -- ERROR
! ERROR:  node:datanode_2, backend_pid:384357, nodename:coord2,backend_pid:383339,message:option "testing" provided more than once
  CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', another '2');
  \dew+
                                                         List of foreign-data wrappers
***************
*** 76,82 ****
  DROP FOREIGN DATA WRAPPER foo;
  SET ROLE regress_test_role;
  CREATE FOREIGN DATA WRAPPER foo; -- ERROR
! ERROR:  permission denied to create foreign-data wrapper "foo"
  HINT:  Must be superuser to create a foreign-data wrapper.
  RESET ROLE;
  CREATE FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
--- 76,82 ----
  DROP FOREIGN DATA WRAPPER foo;
  SET ROLE regress_test_role;
  CREATE FOREIGN DATA WRAPPER foo; -- ERROR
! ERROR:  node:datanode_2, backend_pid:383282, nodename:coord2,backend_pid:383339,message:permission denied to create foreign-data wrapper "foo"
  HINT:  Must be superuser to create a foreign-data wrapper.
  RESET ROLE;
  CREATE FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
***************
*** 95,101 ****
  LINE 1: ALTER FOREIGN DATA WRAPPER foo;
                                        ^
  ALTER FOREIGN DATA WRAPPER foo VALIDATOR bar;               -- ERROR
! ERROR:  function bar(text[], oid) does not exist
  ALTER FOREIGN DATA WRAPPER foo NO VALIDATOR;
  \dew+
                                                  List of foreign-data wrappers
--- 95,101 ----
  LINE 1: ALTER FOREIGN DATA WRAPPER foo;
                                        ^
  ALTER FOREIGN DATA WRAPPER foo VALIDATOR bar;               -- ERROR
! ERROR:  node:datanode_2, backend_pid:384324, nodename:coord2,backend_pid:383342,message:function bar(text[], oid) does not exist
  ALTER FOREIGN DATA WRAPPER foo NO VALIDATOR;
  \dew+
                                                  List of foreign-data wrappers
***************
*** 108,116 ****
  
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '1', b '2');
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (SET c '4');         -- ERROR
! ERROR:  option "c" not found
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP c);            -- ERROR
! ERROR:  option "c" not found
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD x '1', DROP x);
  \dew+
                                                   List of foreign-data wrappers
--- 108,116 ----
  
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '1', b '2');
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (SET c '4');         -- ERROR
! ERROR:  node:datanode_2, backend_pid:383282, nodename:coord2,backend_pid:384455,message:option "c" not found
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP c);            -- ERROR
! ERROR:  node:datanode_2, backend_pid:383377, nodename:coord2,backend_pid:384455,message:option "c" not found
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD x '1', DROP x);
  \dew+
                                                   List of foreign-data wrappers
***************
*** 133,139 ****
  
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '2');
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (b '4');             -- ERROR
! ERROR:  option "b" provided more than once
  \dew+
                                                       List of foreign-data wrappers
      Name    |           Owner           | Handler |        Validator         | Access privileges |      FDW options      | Description 
--- 133,139 ----
  
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '2');
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (b '4');             -- ERROR
! ERROR:  node:datanode_2, backend_pid:384371, nodename:coord2,backend_pid:383270,message:option "b" provided more than once
  \dew+
                                                       List of foreign-data wrappers
      Name    |           Owner           | Handler |        Validator         | Access privileges |      FDW options      | Description 
***************
*** 145,151 ****
  
  SET ROLE regress_test_role;
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
  HINT:  Must be superuser to alter a foreign-data wrapper.
  SET ROLE regress_test_role_super;
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');
--- 145,151 ----
  
  SET ROLE regress_test_role;
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');         -- ERROR
! ERROR:  node:datanode_2, backend_pid:384371, nodename:coord2,backend_pid:383270,message:permission denied to alter foreign-data wrapper "foo"
  HINT:  Must be superuser to alter a foreign-data wrapper.
  SET ROLE regress_test_role_super;
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');
***************
*** 165,171 ****
  ALTER ROLE regress_test_role_super NOSUPERUSER;
  SET ROLE regress_test_role_super;
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD e '6');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
  HINT:  Must be superuser to alter a foreign-data wrapper.
  RESET ROLE;
  \dew+
--- 165,171 ----
  ALTER ROLE regress_test_role_super NOSUPERUSER;
  SET ROLE regress_test_role_super;
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD e '6');         -- ERROR
! ERROR:  node:datanode_2, backend_pid:384324, nodename:coord2,backend_pid:383344,message:permission denied to alter foreign-data wrapper "foo"
  HINT:  Must be superuser to alter a foreign-data wrapper.
  RESET ROLE;
  \dew+
***************
*** 222,228 ****
  COMMENT ON SERVER s1 IS 'foreign server';
  CREATE USER MAPPING FOR current_user SERVER s1;
  CREATE USER MAPPING FOR current_user SERVER s1;				-- ERROR
! ERROR:  user mapping for "regress_foreign_data_user" already exists for server s1
  CREATE USER MAPPING IF NOT EXISTS FOR current_user SERVER s1; -- NOTICE
  NOTICE:  user mapping for "regress_foreign_data_user" already exists for server s1, skipping
  \dew+
--- 222,228 ----
  COMMENT ON SERVER s1 IS 'foreign server';
  CREATE USER MAPPING FOR current_user SERVER s1;
  CREATE USER MAPPING FOR current_user SERVER s1;				-- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:383261,message:user mapping for "regress_foreign_data_user" already exists for server s1
  CREATE USER MAPPING IF NOT EXISTS FOR current_user SERVER s1; -- NOTICE
  NOTICE:  user mapping for "regress_foreign_data_user" already exists for server s1, skipping
  \dew+
***************
*** 283,293 ****
  
  -- exercise CREATE SERVER
  CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERROR
! ERROR:  foreign-data wrapper "foo" does not exist
  CREATE FOREIGN DATA WRAPPER foo OPTIONS ("test wrapper" 'true');
  CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
  CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERROR
! ERROR:  server "s1" already exists
  CREATE SERVER IF NOT EXISTS s1 FOREIGN DATA WRAPPER foo;	-- No ERROR, just NOTICE
  NOTICE:  server "s1" already exists, skipping
  CREATE SERVER s2 FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
--- 283,293 ----
  
  -- exercise CREATE SERVER
  CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERROR
! ERROR:  node:datanode_2, backend_pid:383377, nodename:coord2,backend_pid:383270,message:foreign-data wrapper "foo" does not exist
  CREATE FOREIGN DATA WRAPPER foo OPTIONS ("test wrapper" 'true');
  CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
  CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:server "s1" already exists
  CREATE SERVER IF NOT EXISTS s1 FOREIGN DATA WRAPPER foo;	-- No ERROR, just NOTICE
  NOTICE:  server "s1" already exists, skipping
  CREATE SERVER s2 FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
***************
*** 297,303 ****
  CREATE SERVER s6 VERSION '16.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
  CREATE SERVER s7 TYPE 'oracle' VERSION '17.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
  CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (foo '1'); -- ERROR
! ERROR:  invalid option "foo"
  HINT:  Valid options in this context are: authtype, service, connect_timeout, dbname, host, hostaddr, port, tty, options, requiressl, sslmode, gsslib
  CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (host 'localhost', dbname 's8db');
  \des+
--- 297,303 ----
  CREATE SERVER s6 VERSION '16.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
  CREATE SERVER s7 TYPE 'oracle' VERSION '17.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
  CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (foo '1'); -- ERROR
! ERROR:  node:datanode_2, backend_pid:384324, nodename:coord2,backend_pid:384455,message:invalid option "foo"
  HINT:  Valid options in this context are: authtype, service, connect_timeout, dbname, host, hostaddr, port, tty, options, requiressl, sslmode, gsslib
  CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (host 'localhost', dbname 's8db');
  \des+
***************
*** 316,322 ****
  
  SET ROLE regress_test_role;
  CREATE SERVER t1 FOREIGN DATA WRAPPER foo;                 -- ERROR: no usage on FDW
! ERROR:  permission denied for foreign-data wrapper foo
  RESET ROLE;
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
  SET ROLE regress_test_role;
--- 316,322 ----
  
  SET ROLE regress_test_role;
  CREATE SERVER t1 FOREIGN DATA WRAPPER foo;                 -- ERROR: no usage on FDW
! ERROR:  node:datanode_2, backend_pid:384324, nodename:coord2,backend_pid:384455,message:permission denied for foreign-data wrapper foo
  RESET ROLE;
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
  SET ROLE regress_test_role;
***************
*** 341,347 ****
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_indirect;
  SET ROLE regress_test_role;
  CREATE SERVER t2 FOREIGN DATA WRAPPER foo;                 -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
  RESET ROLE;
  GRANT regress_test_indirect TO regress_test_role;
  SET ROLE regress_test_role;
--- 341,347 ----
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_indirect;
  SET ROLE regress_test_role;
  CREATE SERVER t2 FOREIGN DATA WRAPPER foo;                 -- ERROR
! ERROR:  node:datanode_1, backend_pid:383376, nodename:coord2,backend_pid:384455,message:permission denied for foreign-data wrapper foo
  RESET ROLE;
  GRANT regress_test_indirect TO regress_test_role;
  SET ROLE regress_test_role;
***************
*** 370,376 ****
  LINE 1: ALTER SERVER s0;
                         ^
  ALTER SERVER s0 OPTIONS (a '1');                            -- ERROR
! ERROR:  server "s0" does not exist
  ALTER SERVER s1 VERSION '1.0' OPTIONS (servername 's1');
  ALTER SERVER s2 VERSION '1.1';
  ALTER SERVER s3 OPTIONS ("tns name" 'orcl', port '1521');
--- 370,376 ----
  LINE 1: ALTER SERVER s0;
                         ^
  ALTER SERVER s0 OPTIONS (a '1');                            -- ERROR
! ERROR:  node:datanode_2, backend_pid:384324, nodename:coord2,backend_pid:384455,message:server "s0" does not exist
  ALTER SERVER s1 VERSION '1.0' OPTIONS (servername 's1');
  ALTER SERVER s2 VERSION '1.1';
  ALTER SERVER s3 OPTIONS ("tns name" 'orcl', port '1521');
***************
*** 396,402 ****
  
  SET ROLE regress_test_role;
  ALTER SERVER s1 VERSION '1.1';                              -- ERROR
! ERROR:  must be owner of foreign server s1
  ALTER SERVER s1 OWNER TO regress_test_role;                 -- ERROR
  ERROR:  must be owner of foreign server s1
  RESET ROLE;
--- 396,402 ----
  
  SET ROLE regress_test_role;
  ALTER SERVER s1 VERSION '1.1';                              -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s1
  ALTER SERVER s1 OWNER TO regress_test_role;                 -- ERROR
  ERROR:  must be owner of foreign server s1
  RESET ROLE;
***************
*** 408,414 ****
  ERROR:  permission denied for foreign-data wrapper foo
  RESET ROLE;
  ALTER SERVER s8 OPTIONS (foo '1');                          -- ERROR option validation
! ERROR:  invalid option "foo"
  HINT:  Valid options in this context are: authtype, service, connect_timeout, dbname, host, hostaddr, port, tty, options, requiressl, sslmode, gsslib
  ALTER SERVER s8 OPTIONS (connect_timeout '30', SET dbname 'db1', DROP host);
  SET ROLE regress_test_role;
--- 408,414 ----
  ERROR:  permission denied for foreign-data wrapper foo
  RESET ROLE;
  ALTER SERVER s8 OPTIONS (foo '1');                          -- ERROR option validation
! ERROR:  node:datanode_2, backend_pid:384324, nodename:coord2,backend_pid:383270,message:invalid option "foo"
  HINT:  Valid options in this context are: authtype, service, connect_timeout, dbname, host, hostaddr, port, tty, options, requiressl, sslmode, gsslib
  ALTER SERVER s8 OPTIONS (connect_timeout '30', SET dbname 'db1', DROP host);
  SET ROLE regress_test_role;
***************
*** 557,571 ****
  
  -- CREATE USER MAPPING
  CREATE USER MAPPING FOR regress_test_missing_role SERVER s1;  -- ERROR
! ERROR:  role "regress_test_missing_role" does not exist
  CREATE USER MAPPING FOR current_user SERVER s1;             -- ERROR
! ERROR:  server "s1" does not exist
  CREATE USER MAPPING FOR current_user SERVER s4;
  CREATE USER MAPPING FOR user SERVER s4;                     -- ERROR duplicate
! ERROR:  user mapping for "regress_foreign_data_user" already exists for server s4
  CREATE USER MAPPING FOR public SERVER s4 OPTIONS ("this mapping" 'is public');
  CREATE USER MAPPING FOR user SERVER s8 OPTIONS (username 'test', password 'secret');    -- ERROR
! ERROR:  invalid option "username"
  HINT:  Valid options in this context are: user, password
  CREATE USER MAPPING FOR user SERVER s8 OPTIONS (user 'test', password 'secret');
  ALTER SERVER s5 OWNER TO regress_test_role;
--- 557,571 ----
  
  -- CREATE USER MAPPING
  CREATE USER MAPPING FOR regress_test_missing_role SERVER s1;  -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:383270,message:role "regress_test_missing_role" does not exist
  CREATE USER MAPPING FOR current_user SERVER s1;             -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:383270,message:server "s1" does not exist
  CREATE USER MAPPING FOR current_user SERVER s4;
  CREATE USER MAPPING FOR user SERVER s4;                     -- ERROR duplicate
! ERROR:  node:datanode_1, backend_pid:384363, nodename:coord2,backend_pid:383270,message:user mapping for "regress_foreign_data_user" already exists for server s4
  CREATE USER MAPPING FOR public SERVER s4 OPTIONS ("this mapping" 'is public');
  CREATE USER MAPPING FOR user SERVER s8 OPTIONS (username 'test', password 'secret');    -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:383270,message:invalid option "username"
  HINT:  Valid options in this context are: user, password
  CREATE USER MAPPING FOR user SERVER s8 OPTIONS (user 'test', password 'secret');
  ALTER SERVER s5 OWNER TO regress_test_role;
***************
*** 574,582 ****
  CREATE USER MAPPING FOR current_user SERVER s5;
  CREATE USER MAPPING FOR current_user SERVER s6 OPTIONS (username 'test');
  CREATE USER MAPPING FOR current_user SERVER s7;             -- ERROR
! ERROR:  permission denied for foreign server s7
  CREATE USER MAPPING FOR public SERVER s8;                   -- ERROR
! ERROR:  must be owner of foreign server s8
  RESET ROLE;
  ALTER SERVER t1 OWNER TO regress_test_indirect;
  SET ROLE regress_test_role;
--- 574,582 ----
  CREATE USER MAPPING FOR current_user SERVER s5;
  CREATE USER MAPPING FOR current_user SERVER s6 OPTIONS (username 'test');
  CREATE USER MAPPING FOR current_user SERVER s7;             -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:permission denied for foreign server s7
  CREATE USER MAPPING FOR public SERVER s8;                   -- ERROR
! ERROR:  node:datanode_2, backend_pid:384324, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s8
  RESET ROLE;
  ALTER SERVER t1 OWNER TO regress_test_indirect;
  SET ROLE regress_test_role;
***************
*** 598,616 ****
  
  -- ALTER USER MAPPING
  ALTER USER MAPPING FOR regress_test_missing_role SERVER s4 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  role "regress_test_missing_role" does not exist
  ALTER USER MAPPING FOR user SERVER ss4 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  server "ss4" does not exist
  ALTER USER MAPPING FOR public SERVER s5 OPTIONS (gotcha 'true');            -- ERROR
! ERROR:  user mapping for "public" does not exist for the server
  ALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (username 'test');    -- ERROR
! ERROR:  invalid option "username"
  HINT:  Valid options in this context are: user, password
  ALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (DROP user, SET password 'public');
  SET ROLE regress_test_role;
  ALTER USER MAPPING FOR current_user SERVER s5 OPTIONS (ADD modified '1');
  ALTER USER MAPPING FOR public SERVER s4 OPTIONS (ADD modified '1'); -- ERROR
! ERROR:  must be owner of foreign server s4
  ALTER USER MAPPING FOR public SERVER t1 OPTIONS (ADD modified '1');
  RESET ROLE;
  \deu+
--- 598,616 ----
  
  -- ALTER USER MAPPING
  ALTER USER MAPPING FOR regress_test_missing_role SERVER s4 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:383270,message:role "regress_test_missing_role" does not exist
  ALTER USER MAPPING FOR user SERVER ss4 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:383270,message:server "ss4" does not exist
  ALTER USER MAPPING FOR public SERVER s5 OPTIONS (gotcha 'true');            -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:383270,message:user mapping for "public" does not exist for the server
  ALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (username 'test');    -- ERROR
! ERROR:  node:datanode_2, backend_pid:384324, nodename:coord2,backend_pid:384455,message:invalid option "username"
  HINT:  Valid options in this context are: user, password
  ALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (DROP user, SET password 'public');
  SET ROLE regress_test_role;
  ALTER USER MAPPING FOR current_user SERVER s5 OPTIONS (ADD modified '1');
  ALTER USER MAPPING FOR public SERVER s4 OPTIONS (ADD modified '1'); -- ERROR
! ERROR:  node:datanode_1, backend_pid:384303, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s4
  ALTER USER MAPPING FOR public SERVER t1 OPTIONS (ADD modified '1');
  RESET ROLE;
  \deu+
***************
*** 628,638 ****
  
  -- DROP USER MAPPING
  DROP USER MAPPING FOR regress_test_missing_role SERVER s4;  -- ERROR
! ERROR:  role "regress_test_missing_role" does not exist
  DROP USER MAPPING FOR user SERVER ss4;
! ERROR:  server "ss4" does not exist
  DROP USER MAPPING FOR public SERVER s7;                     -- ERROR
! ERROR:  user mapping for "public" does not exist for the server
  DROP USER MAPPING IF EXISTS FOR regress_test_missing_role SERVER s4;
  NOTICE:  role "regress_test_missing_role" does not exist, skipping
  DROP USER MAPPING IF EXISTS FOR user SERVER ss4;
--- 628,638 ----
  
  -- DROP USER MAPPING
  DROP USER MAPPING FOR regress_test_missing_role SERVER s4;  -- ERROR
! ERROR:  node:datanode_2, backend_pid:384324, nodename:coord2,backend_pid:383270,message:role "regress_test_missing_role" does not exist
  DROP USER MAPPING FOR user SERVER ss4;
! ERROR:  node:datanode_2, backend_pid:384324, nodename:coord2,backend_pid:383270,message:server "ss4" does not exist
  DROP USER MAPPING FOR public SERVER s7;                     -- ERROR
! ERROR:  node:datanode_2, backend_pid:384324, nodename:coord2,backend_pid:383270,message:user mapping for "public" does not exist for the server
  DROP USER MAPPING IF EXISTS FOR regress_test_missing_role SERVER s4;
  NOTICE:  role "regress_test_missing_role" does not exist, skipping
  DROP USER MAPPING IF EXISTS FOR user SERVER ss4;
***************
*** 642,648 ****
  CREATE USER MAPPING FOR public SERVER s8;
  SET ROLE regress_test_role;
  DROP USER MAPPING FOR public SERVER s8;                     -- ERROR
! ERROR:  must be owner of foreign server s8
  RESET ROLE;
  DROP SERVER s7;
  \deu
--- 642,648 ----
  CREATE USER MAPPING FOR public SERVER s8;
  SET ROLE regress_test_role;
  DROP USER MAPPING FOR public SERVER s8;                     -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:383270,message:must be owner of foreign server s8
  RESET ROLE;
  DROP SERVER s7;
  \deu
***************
*** 1114,1123 ****
  -- Privileges
  SET ROLE regress_unprivileged_role;
  CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR
! ERROR:  permission denied to create foreign-data wrapper "foobar"
  HINT:  Must be superuser to create a foreign-data wrapper.
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
  HINT:  Must be superuser to alter a foreign-data wrapper.
  ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_unprivileged_role; -- ERROR
  ERROR:  permission denied to change owner of foreign-data wrapper "foo"
--- 1114,1123 ----
  -- Privileges
  SET ROLE regress_unprivileged_role;
  CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:permission denied to create foreign-data wrapper "foobar"
  HINT:  Must be superuser to create a foreign-data wrapper.
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:permission denied to alter foreign-data wrapper "foo"
  HINT:  Must be superuser to alter a foreign-data wrapper.
  ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_unprivileged_role; -- ERROR
  ERROR:  permission denied to change owner of foreign-data wrapper "foo"
***************
*** 1127,1135 ****
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERROR
  ERROR:  permission denied for foreign-data wrapper foo
  CREATE SERVER s9 FOREIGN DATA WRAPPER foo;                      -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
  ALTER SERVER s4 VERSION '0.5';                                  -- ERROR
! ERROR:  must be owner of foreign server s4
  ALTER SERVER s4 OWNER TO regress_unprivileged_role;             -- ERROR
  ERROR:  must be owner of foreign server s4
  DROP SERVER s4;                                                 -- ERROR
--- 1127,1135 ----
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERROR
  ERROR:  permission denied for foreign-data wrapper foo
  CREATE SERVER s9 FOREIGN DATA WRAPPER foo;                      -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:permission denied for foreign-data wrapper foo
  ALTER SERVER s4 VERSION '0.5';                                  -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s4
  ALTER SERVER s4 OWNER TO regress_unprivileged_role;             -- ERROR
  ERROR:  must be owner of foreign server s4
  DROP SERVER s4;                                                 -- ERROR
***************
*** 1137,1156 ****
  GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;          -- ERROR
  ERROR:  permission denied for foreign server s4
  CREATE USER MAPPING FOR public SERVER s4;                       -- ERROR
! ERROR:  must be owner of foreign server s4
  ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  must be owner of foreign server s6
  DROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERROR
! ERROR:  must be owner of foreign server s6
  RESET ROLE;
  GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO regress_unprivileged_role;
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_unprivileged_role WITH GRANT OPTION;
  SET ROLE regress_unprivileged_role;
  CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR
! ERROR:  permission denied to create foreign-data wrapper "foobar"
  HINT:  Must be superuser to create a foreign-data wrapper.
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR
! ERROR:  permission denied to alter foreign-data wrapper "foo"
  HINT:  Must be superuser to alter a foreign-data wrapper.
  DROP FOREIGN DATA WRAPPER foo;                                  -- ERROR
  ERROR:  must be owner of foreign-data wrapper foo
--- 1137,1156 ----
  GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;          -- ERROR
  ERROR:  permission denied for foreign server s4
  CREATE USER MAPPING FOR public SERVER s4;                       -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s4
  ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s6
  DROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s6
  RESET ROLE;
  GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO regress_unprivileged_role;
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_unprivileged_role WITH GRANT OPTION;
  SET ROLE regress_unprivileged_role;
  CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:permission denied to create foreign-data wrapper "foobar"
  HINT:  Must be superuser to create a foreign-data wrapper.
  ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:permission denied to alter foreign-data wrapper "foo"
  HINT:  Must be superuser to alter a foreign-data wrapper.
  DROP FOREIGN DATA WRAPPER foo;                                  -- ERROR
  ERROR:  must be owner of foreign-data wrapper foo
***************
*** 1159,1177 ****
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
  CREATE SERVER s9 FOREIGN DATA WRAPPER postgresql;
  ALTER SERVER s6 VERSION '0.5';                                  -- ERROR
! ERROR:  must be owner of foreign server s6
  DROP SERVER s6;                                                 -- ERROR
  ERROR:  must be owner of foreign server s6
  GRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role;          -- ERROR
  ERROR:  permission denied for foreign server s6
  GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
  CREATE USER MAPPING FOR public SERVER s6;                       -- ERROR
! ERROR:  must be owner of foreign server s6
  CREATE USER MAPPING FOR public SERVER s9;
  ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  must be owner of foreign server s6
  DROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERROR
! ERROR:  must be owner of foreign server s6
  RESET ROLE;
  REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_unprivileged_role; -- ERROR
  ERROR:  dependent privileges exist
--- 1159,1177 ----
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
  CREATE SERVER s9 FOREIGN DATA WRAPPER postgresql;
  ALTER SERVER s6 VERSION '0.5';                                  -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s6
  DROP SERVER s6;                                                 -- ERROR
  ERROR:  must be owner of foreign server s6
  GRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role;          -- ERROR
  ERROR:  permission denied for foreign server s6
  GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
  CREATE USER MAPPING FOR public SERVER s6;                       -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s6
  CREATE USER MAPPING FOR public SERVER s9;
  ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s6
  DROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s6
  RESET ROLE;
  REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_unprivileged_role; -- ERROR
  ERROR:  dependent privileges exist
***************
*** 1181,1187 ****
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERROR
  ERROR:  permission denied for foreign-data wrapper foo
  CREATE SERVER s10 FOREIGN DATA WRAPPER foo;                     -- ERROR
! ERROR:  permission denied for foreign-data wrapper foo
  ALTER SERVER s9 VERSION '1.1';
  GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
  CREATE USER MAPPING FOR current_user SERVER s9;
--- 1181,1187 ----
  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERROR
  ERROR:  permission denied for foreign-data wrapper foo
  CREATE SERVER s10 FOREIGN DATA WRAPPER foo;                     -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:permission denied for foreign-data wrapper foo
  ALTER SERVER s9 VERSION '1.1';
  GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
  CREATE USER MAPPING FOR current_user SERVER s9;
***************
*** 1195,1201 ****
  GRANT USAGE ON FOREIGN SERVER s9 TO regress_unprivileged_role;
  SET ROLE regress_unprivileged_role;
  ALTER SERVER s9 VERSION '1.2';                                  -- ERROR
! ERROR:  must be owner of foreign server s9
  GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;          -- WARNING
  WARNING:  no privileges were granted for "s9"
  CREATE USER MAPPING FOR current_user SERVER s9;
--- 1195,1201 ----
  GRANT USAGE ON FOREIGN SERVER s9 TO regress_unprivileged_role;
  SET ROLE regress_unprivileged_role;
  ALTER SERVER s9 VERSION '1.2';                                  -- ERROR
! ERROR:  node:datanode_2, backend_pid:383288, nodename:coord2,backend_pid:384455,message:must be owner of foreign server s9
  GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;          -- WARNING
  WARNING:  no privileges were granted for "s9"
  CREATE USER MAPPING FOR current_user SERVER s9;
***************
*** 1271,1323 ****
  ON foreign_schema.foreign_table_1
  FOR EACH STATEMENT
  EXECUTE PROCEDURE dummy_trigger();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  CREATE TRIGGER trigtest_after_stmt AFTER INSERT OR UPDATE OR DELETE
  ON foreign_schema.foreign_table_1
  FOR EACH STATEMENT
  EXECUTE PROCEDURE dummy_trigger();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  CREATE TRIGGER trigtest_after_stmt_tt AFTER INSERT OR UPDATE OR DELETE -- ERROR
  ON foreign_schema.foreign_table_1
  REFERENCING NEW TABLE AS new_table
  FOR EACH STATEMENT
  EXECUTE PROCEDURE dummy_trigger();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
  CREATE TRIGGER trigtest_before_row BEFORE INSERT OR UPDATE OR DELETE
  ON foreign_schema.foreign_table_1
  FOR EACH ROW
  EXECUTE PROCEDURE dummy_trigger();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  CREATE TRIGGER trigtest_after_row AFTER INSERT OR UPDATE OR DELETE
  ON foreign_schema.foreign_table_1
  FOR EACH ROW
  EXECUTE PROCEDURE dummy_trigger();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  CREATE CONSTRAINT TRIGGER trigtest_constraint AFTER INSERT OR UPDATE OR DELETE
  ON foreign_schema.foreign_table_1
  FOR EACH ROW
  EXECUTE PROCEDURE dummy_trigger();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
  ALTER FOREIGN TABLE foreign_schema.foreign_table_1
  	DISABLE TRIGGER trigtest_before_stmt;
- ERROR:  trigger "trigtest_before_stmt" for table "foreign_table_1" does not exist
  ALTER FOREIGN TABLE foreign_schema.foreign_table_1
  	ENABLE TRIGGER trigtest_before_stmt;
- ERROR:  trigger "trigtest_before_stmt" for table "foreign_table_1" does not exist
  DROP TRIGGER trigtest_before_stmt ON foreign_schema.foreign_table_1;
- ERROR:  trigger "trigtest_before_stmt" for table "foreign_table_1" does not exist
  DROP TRIGGER trigtest_before_row ON foreign_schema.foreign_table_1;
- ERROR:  trigger "trigtest_before_row" for table "foreign_table_1" does not exist
  DROP TRIGGER trigtest_after_stmt ON foreign_schema.foreign_table_1;
- ERROR:  trigger "trigtest_after_stmt" for table "foreign_table_1" does not exist
  DROP TRIGGER trigtest_after_row ON foreign_schema.foreign_table_1;
- ERROR:  trigger "trigtest_after_row" for table "foreign_table_1" does not exist
  DROP FUNCTION dummy_trigger();
  -- Table inheritance
  CREATE TABLE pt1 (
--- 1271,1309 ----
  ON foreign_schema.foreign_table_1
  FOR EACH STATEMENT
  EXECUTE PROCEDURE dummy_trigger();
  CREATE TRIGGER trigtest_after_stmt AFTER INSERT OR UPDATE OR DELETE
  ON foreign_schema.foreign_table_1
  FOR EACH STATEMENT
  EXECUTE PROCEDURE dummy_trigger();
  CREATE TRIGGER trigtest_after_stmt_tt AFTER INSERT OR UPDATE OR DELETE -- ERROR
  ON foreign_schema.foreign_table_1
  REFERENCING NEW TABLE AS new_table
  FOR EACH STATEMENT
  EXECUTE PROCEDURE dummy_trigger();
! ERROR:  "foreign_table_1" is a foreign table
! DETAIL:  Triggers on foreign tables cannot have transition tables.
  CREATE TRIGGER trigtest_before_row BEFORE INSERT OR UPDATE OR DELETE
  ON foreign_schema.foreign_table_1
  FOR EACH ROW
  EXECUTE PROCEDURE dummy_trigger();
  CREATE TRIGGER trigtest_after_row AFTER INSERT OR UPDATE OR DELETE
  ON foreign_schema.foreign_table_1
  FOR EACH ROW
  EXECUTE PROCEDURE dummy_trigger();
  CREATE CONSTRAINT TRIGGER trigtest_constraint AFTER INSERT OR UPDATE OR DELETE
  ON foreign_schema.foreign_table_1
  FOR EACH ROW
  EXECUTE PROCEDURE dummy_trigger();
! ERROR:  "foreign_table_1" is a foreign table
! DETAIL:  Foreign tables cannot have constraint triggers.
  ALTER FOREIGN TABLE foreign_schema.foreign_table_1
  	DISABLE TRIGGER trigtest_before_stmt;
  ALTER FOREIGN TABLE foreign_schema.foreign_table_1
  	ENABLE TRIGGER trigtest_before_stmt;
  DROP TRIGGER trigtest_before_stmt ON foreign_schema.foreign_table_1;
  DROP TRIGGER trigtest_before_row ON foreign_schema.foreign_table_1;
  DROP TRIGGER trigtest_after_stmt ON foreign_schema.foreign_table_1;
  DROP TRIGGER trigtest_after_row ON foreign_schema.foreign_table_1;
  DROP FUNCTION dummy_trigger();
  -- Table inheritance
  CREATE TABLE pt1 (
***************
*** 1335,1341 ****
   c2     | text    |           |          |         | extended |              | 
   c3     | date    |           |          |         | plain    |              | 
  Child tables: ft2
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1321,1327 ----
   c2     | text    |           |          |         | extended |              | 
   c3     | date    |           |          |         | plain    |              | 
  Child tables: ft2
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1357,1363 ****
   c1     | integer |           | not null |         | plain    |              | 
   c2     | text    |           |          |         | extended |              | 
   c3     | date    |           |          |         | plain    |              | 
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  CREATE FOREIGN TABLE ft2 (
--- 1343,1349 ----
   c1     | integer |           | not null |         | plain    |              | 
   c2     | text    |           |          |         | extended |              | 
   c3     | date    |           |          |         | plain    |              | 
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  CREATE FOREIGN TABLE ft2 (
***************
*** 1384,1390 ****
   c2     | text    |           |          |         | extended |              | 
   c3     | date    |           |          |         | plain    |              | 
  Child tables: ft2
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1370,1376 ----
   c2     | text    |           |          |         | extended |              | 
   c3     | date    |           |          |         | plain    |              | 
  Child tables: ft2
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1439,1445 ****
   c7     | integer |           | not null |         | plain    |              | 
   c8     | integer |           |          |         | plain    |              | 
  Child tables: ft2
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1425,1431 ----
   c7     | integer |           | not null |         | plain    |              | 
   c8     | integer |           |          |         | plain    |              | 
  Child tables: ft2
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1486,1492 ****
   c7     | integer |           |          |         | plain    |              | 
   c8     | text    |           |          |         | external |              | 
  Child tables: ft2
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1472,1478 ----
   c7     | integer |           |          |         | plain    |              | 
   c8     | text    |           |          |         | external |              | 
  Child tables: ft2
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1519,1525 ****
   c2     | text    |           |          |         | extended |              | 
   c3     | date    |           |          |         | plain    |              | 
  Child tables: ft2
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1505,1511 ----
   c2     | text    |           |          |         | extended |              | 
   c3     | date    |           |          |         | plain    |              | 
  Child tables: ft2
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1559,1565 ****
      "pt1chk1" CHECK (c1 > 0) NO INHERIT
      "pt1chk2" CHECK (c2 <> ''::text)
  Child tables: ft2
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1545,1551 ----
      "pt1chk1" CHECK (c1 > 0) NO INHERIT
      "pt1chk2" CHECK (c2 <> ''::text)
  Child tables: ft2
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1602,1608 ****
      "pt1chk1" CHECK (c1 > 0) NO INHERIT
      "pt1chk2" CHECK (c2 <> ''::text)
  Child tables: ft2
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1588,1594 ----
      "pt1chk1" CHECK (c1 > 0) NO INHERIT
      "pt1chk2" CHECK (c2 <> ''::text)
  Child tables: ft2
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1634,1640 ****
  Check constraints:
      "pt1chk3" CHECK (c2 <> ''::text) NOT VALID
  Child tables: ft2
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1620,1626 ----
  Check constraints:
      "pt1chk3" CHECK (c2 <> ''::text) NOT VALID
  Child tables: ft2
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1663,1669 ****
  Check constraints:
      "pt1chk3" CHECK (c2 <> ''::text)
  Child tables: ft2
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1649,1655 ----
  Check constraints:
      "pt1chk3" CHECK (c2 <> ''::text)
  Child tables: ft2
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1693,1699 ****
      "pt1chk3" CHECK (c2 <> ''::text)
  Child tables: ft2
  Has OIDs: yes
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1679,1685 ----
      "pt1chk3" CHECK (c2 <> ''::text)
  Child tables: ft2
  Has OIDs: yes
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1724,1730 ****
  Check constraints:
      "pt1chk3" CHECK (c2 <> ''::text)
  Child tables: ft2
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1710,1716 ----
  Check constraints:
      "pt1chk3" CHECK (c2 <> ''::text)
  Child tables: ft2
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1757,1763 ****
  Check constraints:
      "f2_check" CHECK (f2 <> ''::text)
  Child tables: ft2
! Distribute By: HASH(f1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
--- 1743,1749 ----
  Check constraints:
      "f2_check" CHECK (f2 <> ''::text)
  Child tables: ft2
! Distribute By: SHARD(f1)
  Location Nodes: ALL DATANODES
  
  \d+ ft2
***************
*** 1822,1828 ****
   c3     | date    |           |          |         | plain    |              | 
  Partition key: LIST (c1)
  Partitions: pt2_1 FOR VALUES IN (1)
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ pt2_1
--- 1808,1814 ----
   c3     | date    |           |          |         | plain    |              | 
  Partition key: LIST (c1)
  Partitions: pt2_1 FOR VALUES IN (1)
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ pt2_1
***************
*** 1869,1875 ****
   c3     | date    |           |          |         | plain    |              | 
  Partition key: LIST (c1)
  Number of partitions: 0
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  CREATE FOREIGN TABLE pt2_1 (
--- 1855,1861 ----
   c3     | date    |           |          |         | plain    |              | 
  Partition key: LIST (c1)
  Number of partitions: 0
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  CREATE FOREIGN TABLE pt2_1 (
***************
*** 1898,1904 ****
   c3     | date    |           |          |         | plain    |              | 
  Partition key: LIST (c1)
  Partitions: pt2_1 FOR VALUES IN (1)
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ pt2_1
--- 1884,1890 ----
   c3     | date    |           |          |         | plain    |              | 
  Partition key: LIST (c1)
  Partitions: pt2_1 FOR VALUES IN (1)
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ pt2_1
***************
*** 1928,1934 ****
   c3     | date    |           |          |         | plain    |              | 
  Partition key: LIST (c1)
  Partitions: pt2_1 FOR VALUES IN (1)
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ pt2_1
--- 1914,1920 ----
   c3     | date    |           |          |         | plain    |              | 
  Partition key: LIST (c1)
  Partitions: pt2_1 FOR VALUES IN (1)
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ pt2_1
***************
*** 1960,1966 ****
   c3     | date    |           |          |         | plain    |              | 
  Partition key: LIST (c1)
  Number of partitions: 0
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ pt2_1
--- 1946,1952 ----
   c3     | date    |           |          |         | plain    |              | 
  Partition key: LIST (c1)
  Number of partitions: 0
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ pt2_1
***************
*** 1992,1998 ****
  Check constraints:
      "pt2chk1" CHECK (c1 > 0)
  Number of partitions: 0
! Distribute By: HASH(c1)
  Location Nodes: ALL DATANODES
  
  \d+ pt2_1
--- 1978,1984 ----
  Check constraints:
      "pt2chk1" CHECK (c1 > 0)
  Number of partitions: 0
! Distribute By: SHARD(c1)
  Location Nodes: ALL DATANODES
  
  \d+ pt2_1

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/window_2.out"	2025-07-31 16:07:15.007067787 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/window.out"	2025-07-31 16:39:50.458632779 +0800
***************
*** 604,610 ****
                 ->  Sort
                       Sort Key: ((tenk1.ten + tenk1.four))
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: (ten + four)
                             ->  Partial HashAggregate
                                   Group Key: (tenk1.ten + tenk1.four)
                                   ->  Seq Scan on tenk1
--- 604,610 ----
                 ->  Sort
                       Sort Key: ((tenk1.ten + tenk1.four))
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: (ten + four)
                             ->  Partial HashAggregate
                                   Group Key: (tenk1.ten + tenk1.four)
                                   ->  Seq Scan on tenk1
***************
*** 948,961 ****
            min(salary) OVER (PARTITION BY depname || 'A', depname) depminsalary
     FROM empsalary) emp
  WHERE depname = 'sales';
!                                  QUERY PLAN                                  
! -----------------------------------------------------------------------------
   Subquery Scan on emp
     ->  WindowAgg
           ->  Sort
                 Sort Key: (((empsalary.depname)::text || 'A'::text))
                 ->  WindowAgg
!                      ->  Remote Subquery Scan on all (datanode_1,datanode_2)
                             ->  Seq Scan on empsalary
                                   Filter: ((depname)::text = 'sales'::text)
  (8 rows)
--- 948,961 ----
            min(salary) OVER (PARTITION BY depname || 'A', depname) depminsalary
     FROM empsalary) emp
  WHERE depname = 'sales';
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
   Subquery Scan on emp
     ->  WindowAgg
           ->  Sort
                 Sort Key: (((empsalary.depname)::text || 'A'::text))
                 ->  WindowAgg
!                      ->  Remote Subquery Scan on all (datanode_1)
                             ->  Seq Scan on empsalary
                                   Filter: ((depname)::text = 'sales'::text)
  (8 rows)

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/json.out"	2025-07-31 16:07:14.989068073 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/json.out"	2025-07-31 16:39:50.100640384 +0800
***************
*** 365,382 ****
  CREATE TEMP TABLE rows DISTRIBUTED RANDOMLY AS
  SELECT x, 'txt' || x as y
  FROM generate_series(1,3) AS x;
  SELECT row_to_json(q,true)
  FROM rows q ORDER BY x, y;
!  row_to_json  
! --------------
!  {"x":1,     +
!   "y":"txt1"}
!  {"x":2,     +
!   "y":"txt2"}
!  {"x":3,     +
!   "y":"txt3"}
! (3 rows)
! 
  SELECT row_to_json(row((select array_agg(x) as d from generate_series(5,10) x)),false);
        row_to_json      
  -----------------------
--- 365,376 ----
  CREATE TEMP TABLE rows DISTRIBUTED RANDOMLY AS
  SELECT x, 'txt' || x as y
  FROM generate_series(1,3) AS x;
+ ERROR:  Cannot support distribute type: RoundRobin
  SELECT row_to_json(q,true)
  FROM rows q ORDER BY x, y;
! ERROR:  relation "rows" does not exist
! LINE 2: FROM rows q ORDER BY x, y;
!              ^
  SELECT row_to_json(row((select array_agg(x) as d from generate_series(5,10) x)),false);
        row_to_json      
  -----------------------
***************
*** 474,496 ****
  
  SELECT json_agg(q ORDER BY x, y)
    FROM rows q;
!        json_agg        
! -----------------------
!  [{"x":1,"y":"txt1"}, +
!   {"x":2,"y":"txt2"}, +
!   {"x":3,"y":"txt3"}]
! (1 row)
! 
  UPDATE rows SET x = NULL WHERE x = 1;
  SELECT json_agg(q ORDER BY x NULLS FIRST, y)
    FROM rows q;
!          json_agg         
! --------------------------
!  [{"x":null,"y":"txt1"}, +
!   {"x":2,"y":"txt2"},    +
!   {"x":3,"y":"txt3"}]
! (1 row)
! 
  -- non-numeric output
  SELECT row_to_json(q)
  FROM (SELECT 'NaN'::float8 AS "float8field") q;
--- 468,485 ----
  
  SELECT json_agg(q ORDER BY x, y)
    FROM rows q;
! ERROR:  relation "rows" does not exist
! LINE 2:   FROM rows q;
!                ^
  UPDATE rows SET x = NULL WHERE x = 1;
+ ERROR:  relation "rows" does not exist
+ LINE 1: UPDATE rows SET x = NULL WHERE x = 1;
+                ^
  SELECT json_agg(q ORDER BY x NULLS FIRST, y)
    FROM rows q;
! ERROR:  relation "rows" does not exist
! LINE 2:   FROM rows q;
!                ^
  -- non-numeric output
  SELECT row_to_json(q)
  FROM (SELECT 'NaN'::float8 AS "float8field") q;
***************
*** 643,653 ****
  SELECT json_object_keys(test_json)
  FROM test_json
  WHERE json_type = 'scalar';
! ERROR:  cannot call json_object_keys on a scalar
  SELECT json_object_keys(test_json)
  FROM test_json
  WHERE json_type = 'array';
! ERROR:  cannot call json_object_keys on an array
  SELECT json_object_keys(test_json)
  FROM test_json
  WHERE json_type = 'object';
--- 632,642 ----
  SELECT json_object_keys(test_json)
  FROM test_json
  WHERE json_type = 'scalar';
! ERROR:  node:datanode_2, backend_pid:383352, nodename:datanode_2,backend_pid:383352,message:cannot call json_object_keys on a scalar
  SELECT json_object_keys(test_json)
  FROM test_json
  WHERE json_type = 'array';
! ERROR:  node:datanode_2, backend_pid:383352, nodename:datanode_2,backend_pid:383352,message:cannot call json_object_keys on an array
  SELECT json_object_keys(test_json)
  FROM test_json
  WHERE json_type = 'object';

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/jsonb.out"	2025-07-31 16:07:14.990068057 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/jsonb.out"	2025-07-31 16:39:50.590460777 +0800
***************
*** 357,362 ****
--- 357,363 ----
  CREATE TEMP TABLE rows DISTRIBUTED RANDOMLY AS
  SELECT x, 'txt' || x as y
  FROM generate_series(1,3) AS x;
+ ERROR:  Cannot support distribute type: RoundRobin
  SELECT jsonb_agg(q)
    FROM ( SELECT $$a$$ || x AS b, y AS c,
                 ARRAY[ROW(x.*,ARRAY[1,2,3]),
***************
*** 370,388 ****
  
  SELECT jsonb_agg(q ORDER BY x, y)
    FROM rows q;
!                                jsonb_agg                               
! -----------------------------------------------------------------------
!  [{"x": 1, "y": "txt1"}, {"x": 2, "y": "txt2"}, {"x": 3, "y": "txt3"}]
! (1 row)
! 
  UPDATE rows SET x = NULL WHERE x = 1;
  SELECT jsonb_agg(q ORDER BY x NULLS FIRST, y)
    FROM rows q;
!                                 jsonb_agg                                 
! --------------------------------------------------------------------------
!  [{"x": null, "y": "txt1"}, {"x": 2, "y": "txt2"}, {"x": 3, "y": "txt3"}]
! (1 row)
! 
  -- jsonb extraction functions
  CREATE TEMP TABLE test_jsonb (
         json_type text,
--- 371,388 ----
  
  SELECT jsonb_agg(q ORDER BY x, y)
    FROM rows q;
! ERROR:  relation "rows" does not exist
! LINE 2:   FROM rows q;
!                ^
  UPDATE rows SET x = NULL WHERE x = 1;
+ ERROR:  relation "rows" does not exist
+ LINE 1: UPDATE rows SET x = NULL WHERE x = 1;
+                ^
  SELECT jsonb_agg(q ORDER BY x NULLS FIRST, y)
    FROM rows q;
! ERROR:  relation "rows" does not exist
! LINE 2:   FROM rows q;
!                ^
  -- jsonb extraction functions
  CREATE TEMP TABLE test_jsonb (
         json_type text,
***************
*** 507,515 ****
  (1 row)
  
  SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'scalar';
! ERROR:  cannot call jsonb_object_keys on a scalar
  SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'array';
! ERROR:  cannot call jsonb_object_keys on an array
  SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'object';
   jsonb_object_keys 
  -------------------
--- 507,515 ----
  (1 row)
  
  SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'scalar';
! ERROR:  node:datanode_2, backend_pid:383267, nodename:datanode_2,backend_pid:383267,message:cannot call jsonb_object_keys on a scalar
  SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'array';
! ERROR:  node:datanode_2, backend_pid:383267, nodename:datanode_2,backend_pid:383267,message:cannot call jsonb_object_keys on an array
  SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'object';
   jsonb_object_keys 
  -------------------
***************
*** 1110,1135 ****
  
  -- array exists - array elements should behave as keys
  SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
!  count 
! -------
!      3
! (1 row)
! 
  -- type sensitive array exists - should return no rows (since "exists" only
  -- matches strings that are either object keys or array elements)
  SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
!  count 
! -------
!      0
! (1 row)
! 
  -- However, a raw scalar is *contained* within the array
  SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
!  count 
! -------
!      1
! (1 row)
! 
  SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['a','b']);
   jsonb_exists_any 
  ------------------
--- 1110,1129 ----
  
  -- array exists - array elements should behave as keys
  SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
!                              ^
  -- type sensitive array exists - should return no rows (since "exists" only
  -- matches strings that are either object keys or array elements)
  SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text...
!                              ^
  -- However, a raw scalar is *contained* within the array
  SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jso...
!                              ^
  SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['a','b']);
   jsonb_exists_any 
  ------------------
***************
*** 2471,2476 ****
--- 2465,2471 ----
  
  -- test type info caching in jsonb_populate_record()
  CREATE TEMP TABLE jsbpoptest (js jsonb);
+ ERROR:  Column js is not a shard distributable data type
  INSERT INTO jsbpoptest
  SELECT '{
  	"jsa": [1, "2", null, 4],
***************
*** 2478,2491 ****
  	"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}]
  }'::jsonb
  FROM generate_series(1, 3);
  SELECT (jsonb_populate_record(NULL::jsbrec, js)).* FROM jsbpoptest;
!  i | ia | ia1 | ia2 | ia3 | ia1d | ia2d | t | ta | c | ca | ts | js | jsb |        jsa         |                rec                |                          reca                          
! ---+----+-----+-----+-----+------+------+---+----+---+----+----+----+-----+--------------------+-----------------------------------+--------------------------------------------------------
!    |    |     |     |     |      |      |   |    |   |    |    |    |     | {1,"\"2\"",NULL,4} | (abc,,"Thu Jan 02 00:00:00 2003") | {"(abc,456,)",NULL,"(,,\"Thu Jan 02 00:00:00 2003\")"}
!    |    |     |     |     |      |      |   |    |   |    |    |    |     | {1,"\"2\"",NULL,4} | (abc,,"Thu Jan 02 00:00:00 2003") | {"(abc,456,)",NULL,"(,,\"Thu Jan 02 00:00:00 2003\")"}
!    |    |     |     |     |      |      |   |    |   |    |    |    |     | {1,"\"2\"",NULL,4} | (abc,,"Thu Jan 02 00:00:00 2003") | {"(abc,456,)",NULL,"(,,\"Thu Jan 02 00:00:00 2003\")"}
! (3 rows)
! 
  DROP TYPE jsbrec;
  DROP TYPE jsbrec_i_not_null;
  DROP DOMAIN jsb_int_not_null;
--- 2473,2485 ----
  	"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}]
  }'::jsonb
  FROM generate_series(1, 3);
+ ERROR:  relation "jsbpoptest" does not exist
+ LINE 1: INSERT INTO jsbpoptest
+                     ^
  SELECT (jsonb_populate_record(NULL::jsbrec, js)).* FROM jsbpoptest;
! ERROR:  relation "jsbpoptest" does not exist
! LINE 1: ... (jsonb_populate_record(NULL::jsbrec, js)).* FROM jsbpoptest...
!                                                              ^
  DROP TYPE jsbrec;
  DROP TYPE jsbrec_i_not_null;
  DROP DOMAIN jsb_int_not_null;
***************
*** 2493,2709 ****
  DROP DOMAIN jsb_int_array_2d;
  -- indexing
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!  count 
! -------
!      1
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!  count 
! -------
!     15
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
!  count 
! -------
!      2
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!  count 
! -------
!      2
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!  count 
! -------
!      2
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j ? 'public';
!  count 
! -------
!    194
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j ? 'bar';
!  count 
! -------
!      0
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
!  count 
! -------
!    337
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
!  count 
! -------
!     42
! (1 row)
! 
  CREATE INDEX jidx ON testjsonb USING gin (j);
  SET enable_seqscan = off;
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!  count 
! -------
!      1
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!  count 
! -------
!     15
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
!  count 
! -------
!      2
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!  count 
! -------
!      2
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!  count 
! -------
!      2
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"array":["foo"]}';
!  count 
! -------
!      3
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"array":["bar"]}';
!  count 
! -------
!      3
! (1 row)
! 
  -- exercise GIN_SEARCH_MODE_ALL
  SELECT count(*) FROM testjsonb WHERE j @> '{}';
!  count 
! -------
!   1012
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j ? 'public';
!  count 
! -------
!    194
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j ? 'bar';
!  count 
! -------
!      0
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
!  count 
! -------
!    337
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
!  count 
! -------
!     42
! (1 row)
! 
  -- array exists - array elements should behave as keys (for GIN index scans too)
  CREATE INDEX jidx_array ON testjsonb USING gin((j->'array'));
  SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
!  count 
! -------
!      3
! (1 row)
! 
  -- type sensitive array exists - should return no rows (since "exists" only
  -- matches strings that are either object keys or array elements)
  SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
!  count 
! -------
!      0
! (1 row)
! 
  -- However, a raw scalar is *contained* within the array
  SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
!  count 
! -------
!      1
! (1 row)
! 
  RESET enable_seqscan;
  SELECT count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow;
!  count 
! -------
!   4791
! (1 row)
! 
  SELECT key, count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow GROUP BY key ORDER BY count DESC, key;
!     key    | count 
! -----------+-------
!  line      |   884
!  query     |   207
!  pos       |   203
!  node      |   202
!  space     |   197
!  status    |   195
!  public    |   194
!  title     |   190
!  wait      |   190
!  org       |   189
!  user      |   189
!  coauthors |   188
!  disabled  |   185
!  indexed   |   184
!  cleaned   |   180
!  bad       |   179
!  date      |   179
!  world     |   176
!  state     |   172
!  subtitle  |   169
!  auth      |   168
!  abstract  |   161
!  array     |     5
!  age       |     2
!  foo       |     2
!  fool      |     1
! (26 rows)
! 
  -- sort/hash
  SELECT count(distinct j) FROM testjsonb;
!  count 
! -------
!    894
! (1 row)
! 
  SET enable_hashagg = off;
  SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
!  count 
! -------
!    894
! (1 row)
! 
  SET enable_hashagg = on;
  SET enable_sort = off;
  SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
!  count 
! -------
!    894
! (1 row)
! 
  SELECT distinct * FROM (values (jsonb '{}' || ''::text),('{}')) v(j);
   j  
  ----
--- 2487,2622 ----
  DROP DOMAIN jsb_int_array_2d;
  -- indexing
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "pu...
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j ? 'public';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j ? 'public';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j ? 'bar';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j ? 'bar';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','di...
!                              ^
  SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','di...
!                              ^
  CREATE INDEX jidx ON testjsonb USING gin (j);
+ ERROR:  relation "testjsonb" does not exist
  SET enable_seqscan = off;
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "pu...
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"array":["foo"]}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"array":["foo"]}...
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"array":["bar"]}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"array":["bar"]}...
!                              ^
  -- exercise GIN_SEARCH_MODE_ALL
  SELECT count(*) FROM testjsonb WHERE j @> '{}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j ? 'public';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j ? 'public';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j ? 'bar';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j ? 'bar';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','di...
!                              ^
  SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','di...
!                              ^
  -- array exists - array elements should behave as keys (for GIN index scans too)
  CREATE INDEX jidx_array ON testjsonb USING gin((j->'array'));
+ ERROR:  relation "testjsonb" does not exist
  SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
!                              ^
  -- type sensitive array exists - should return no rows (since "exists" only
  -- matches strings that are either object keys or array elements)
  SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text...
!                              ^
  -- However, a raw scalar is *contained* within the array
  SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jso...
!                              ^
  RESET enable_seqscan;
  SELECT count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow;
! ERROR:  relation "testjsonb" does not exist
! LINE 1: ...CT count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb)...
!                                                              ^
  SELECT key, count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow GROUP BY key ORDER BY count DESC, key;
! ERROR:  relation "testjsonb" does not exist
! LINE 1: ...y, count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb)...
!                                                              ^
  -- sort/hash
  SELECT count(distinct j) FROM testjsonb;
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(distinct j) FROM testjsonb;
!                                       ^
  SET enable_hashagg = off;
  SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
! ERROR:  relation "testjsonb" does not exist
! LINE 1: ...ELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb ...
!                                                              ^
  SET enable_hashagg = on;
  SET enable_sort = off;
  SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
! ERROR:  relation "testjsonb" does not exist
! LINE 1: ...ELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb ...
!                                                              ^
  SELECT distinct * FROM (values (jsonb '{}' || ''::text),('{}')) v(j);
   j  
  ----
***************
*** 2714,2778 ****
  RESET enable_hashagg;
  RESET enable_sort;
  DROP INDEX jidx;
  DROP INDEX jidx_array;
  -- btree
  CREATE INDEX jidx ON testjsonb USING btree (j);
  SET enable_seqscan = off;
  SELECT count(*) FROM testjsonb WHERE j > '{"p":1}';
!  count 
! -------
!    884
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j = '{"pos":98, "line":371, "node":"CBA", "indexed":true}';
!  count 
! -------
!      1
! (1 row)
! 
  --gin path opclass
  DROP INDEX jidx;
  CREATE INDEX jidx ON testjsonb USING gin (j jsonb_path_ops);
  SET enable_seqscan = off;
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!  count 
! -------
!      1
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!  count 
! -------
!     15
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
!  count 
! -------
!      2
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!  count 
! -------
!      2
! (1 row)
! 
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!  count 
! -------
!      2
! (1 row)
! 
  -- exercise GIN_SEARCH_MODE_ALL
  SELECT count(*) FROM testjsonb WHERE j @> '{}';
!  count 
! -------
!   1012
! (1 row)
! 
  RESET enable_seqscan;
  DROP INDEX jidx;
  -- nested tests
  SELECT '{"ff":{"a":12,"b":16}}'::jsonb;
             jsonb            
--- 2627,2681 ----
  RESET enable_hashagg;
  RESET enable_sort;
  DROP INDEX jidx;
+ ERROR:  index "jidx" does not exist
  DROP INDEX jidx_array;
+ ERROR:  index "jidx_array" does not exist
  -- btree
  CREATE INDEX jidx ON testjsonb USING btree (j);
+ ERROR:  relation "testjsonb" does not exist
  SET enable_seqscan = off;
  SELECT count(*) FROM testjsonb WHERE j > '{"p":1}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j > '{"p":1}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j = '{"pos":98, "line":371, "node":"CBA", "indexed":true}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j = '{"pos":98, "line":...
!                              ^
  --gin path opclass
  DROP INDEX jidx;
+ ERROR:  index "jidx" does not exist
  CREATE INDEX jidx ON testjsonb USING gin (j jsonb_path_ops);
+ ERROR:  relation "testjsonb" does not exist
  SET enable_seqscan = off;
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "pu...
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
!                              ^
  SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
!                              ^
  -- exercise GIN_SEARCH_MODE_ALL
  SELECT count(*) FROM testjsonb WHERE j @> '{}';
! ERROR:  relation "testjsonb" does not exist
! LINE 1: SELECT count(*) FROM testjsonb WHERE j @> '{}';
!                              ^
  RESET enable_seqscan;
  DROP INDEX jidx;
+ ERROR:  index "jidx" does not exist
  -- nested tests
  SELECT '{"ff":{"a":12,"b":16}}'::jsonb;
             jsonb            
***************
*** 2926,2977 ****
  
  -- check some corner cases for indexed nested containment (bug #13756)
  create temp table nestjsonb (j jsonb);
  insert into nestjsonb (j) values ('{"a":[["b",{"x":1}],["b",{"x":2}]],"c":3}');
  insert into nestjsonb (j) values ('[[14,2,3]]');
  insert into nestjsonb (j) values ('[1,[14,2,3]]');
  create index on nestjsonb using gin(j jsonb_path_ops);
  set enable_seqscan = on;
  set enable_bitmapscan = off;
  select * from nestjsonb where j @> '{"a":[[{"x":2}]]}'::jsonb;
!                          j                         
! ---------------------------------------------------
!  {"a": [["b", {"x": 1}], ["b", {"x": 2}]], "c": 3}
! (1 row)
! 
  select * from nestjsonb where j @> '{"c":3}';
!                          j                         
! ---------------------------------------------------
!  {"a": [["b", {"x": 1}], ["b", {"x": 2}]], "c": 3}
! (1 row)
! 
  select * from nestjsonb where j @> '[[14]]' order by j;
!         j        
! -----------------
!  [[14, 2, 3]]
!  [1, [14, 2, 3]]
! (2 rows)
! 
  set enable_seqscan = off;
  set enable_bitmapscan = on;
  select * from nestjsonb where j @> '{"a":[[{"x":2}]]}'::jsonb;
!                          j                         
! ---------------------------------------------------
!  {"a": [["b", {"x": 1}], ["b", {"x": 2}]], "c": 3}
! (1 row)
! 
  select * from nestjsonb where j @> '{"c":3}';
!                          j                         
! ---------------------------------------------------
!  {"a": [["b", {"x": 1}], ["b", {"x": 2}]], "c": 3}
! (1 row)
! 
  select * from nestjsonb where j @> '[[14]]' order by j;
!         j        
! -----------------
!  [[14, 2, 3]]
!  [1, [14, 2, 3]]
! (2 rows)
! 
  reset enable_seqscan;
  reset enable_bitmapscan;
  -- nested object field / array index lookup
--- 2829,2877 ----
  
  -- check some corner cases for indexed nested containment (bug #13756)
  create temp table nestjsonb (j jsonb);
+ ERROR:  Column j is not a shard distributable data type
  insert into nestjsonb (j) values ('{"a":[["b",{"x":1}],["b",{"x":2}]],"c":3}');
+ ERROR:  relation "nestjsonb" does not exist
+ LINE 1: insert into nestjsonb (j) values ('{"a":[["b",{"x":1}],["b",...
+                     ^
  insert into nestjsonb (j) values ('[[14,2,3]]');
+ ERROR:  relation "nestjsonb" does not exist
+ LINE 1: insert into nestjsonb (j) values ('[[14,2,3]]');
+                     ^
  insert into nestjsonb (j) values ('[1,[14,2,3]]');
+ ERROR:  relation "nestjsonb" does not exist
+ LINE 1: insert into nestjsonb (j) values ('[1,[14,2,3]]');
+                     ^
  create index on nestjsonb using gin(j jsonb_path_ops);
+ ERROR:  relation "nestjsonb" does not exist
  set enable_seqscan = on;
  set enable_bitmapscan = off;
  select * from nestjsonb where j @> '{"a":[[{"x":2}]]}'::jsonb;
! ERROR:  relation "nestjsonb" does not exist
! LINE 1: select * from nestjsonb where j @> '{"a":[[{"x":2}]]}'::json...
!                       ^
  select * from nestjsonb where j @> '{"c":3}';
! ERROR:  relation "nestjsonb" does not exist
! LINE 1: select * from nestjsonb where j @> '{"c":3}';
!                       ^
  select * from nestjsonb where j @> '[[14]]' order by j;
! ERROR:  relation "nestjsonb" does not exist
! LINE 1: select * from nestjsonb where j @> '[[14]]' order by j;
!                       ^
  set enable_seqscan = off;
  set enable_bitmapscan = on;
  select * from nestjsonb where j @> '{"a":[[{"x":2}]]}'::jsonb;
! ERROR:  relation "nestjsonb" does not exist
! LINE 1: select * from nestjsonb where j @> '{"a":[[{"x":2}]]}'::json...
!                       ^
  select * from nestjsonb where j @> '{"c":3}';
! ERROR:  relation "nestjsonb" does not exist
! LINE 1: select * from nestjsonb where j @> '{"c":3}';
!                       ^
  select * from nestjsonb where j @> '[[14]]' order by j;
! ERROR:  relation "nestjsonb" does not exist
! LINE 1: select * from nestjsonb where j @> '[[14]]' order by j;
!                       ^
  reset enable_seqscan;
  reset enable_bitmapscan;
  -- nested object field / array index lookup

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/indirect_toast_1.out"	2025-07-31 16:07:14.985068136 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/indirect_toast.out"	2025-07-31 16:39:50.371634628 +0800
***************
*** 57,64 ****
          ON toasttest
          FOR EACH ROW
          EXECUTE PROCEDURE update_using_indirect();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- modification without changing varlenas
  --UPDATE toasttest SET cnt = cnt +1 RETURNING substring(toasttest::text, 1, 200);
  UPDATE toasttest SET cnt = cnt +1;
--- 57,62 ----

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/rangefuncs.out"	2025-07-31 16:07:14.997067946 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/rangefuncs.out"	2025-07-31 16:39:53.534353941 +0800
***************
*** 1686,1694 ****
  end $$ language plpgsql;
  create trigger tnoticetrigger after insert on tt for each row
  execute procedure noticetrigger();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  select insert_tt2('foolme','barme') order by 1 limit 1;
   insert_tt2 
  ------------
           11
--- 1686,1694 ----
  end $$ language plpgsql;
  create trigger tnoticetrigger after insert on tt for each row
  execute procedure noticetrigger();
  select insert_tt2('foolme','barme') order by 1 limit 1;
+ NOTICE:  noticetrigger 11 foolme
+ NOTICE:  noticetrigger 12 barme
   insert_tt2 
  ------------
           11
***************
*** 1716,1721 ****
--- 1716,1723 ----
  create rule insert_tt_rule as on insert to tt do also
    insert into tt_log values(new.*);
  select insert_tt2('foollog','barlog') limit 1;
+ NOTICE:  noticetrigger 13 foollog
+ NOTICE:  noticetrigger 14 barlog
   insert_tt2 
  ------------
           13

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/plancache.out"	2025-07-31 16:07:14.995067978 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/plancache.out"	2025-07-31 16:39:56.130699643 +0800
***************
*** 261,278 ****
  prepare pstmt_def_insert (int) as insert into list_part_def values($1);
  -- should fail
  execute pstmt_def_insert(null);
! ERROR:  new row for relation "list_part_def" violates partition constraint
  DETAIL:  Failing row contains (null).
  execute pstmt_def_insert(1);
! ERROR:  new row for relation "list_part_def" violates partition constraint
  DETAIL:  Failing row contains (1).
  create table list_part_2 partition of list_parted for values in (2);
  execute pstmt_def_insert(2);
! ERROR:  new row for relation "list_part_def" violates partition constraint
  DETAIL:  Failing row contains (2).
  alter table list_parted detach partition list_part_null;
  -- should be ok
  execute pstmt_def_insert(null);
  drop table list_part_1;
  -- should be ok
  execute pstmt_def_insert(1);
--- 261,280 ----
  prepare pstmt_def_insert (int) as insert into list_part_def values($1);
  -- should fail
  execute pstmt_def_insert(null);
! ERROR:  node:datanode_1, backend_pid:384365, nodename:datanode_1,backend_pid:384365,message:null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null).
  execute pstmt_def_insert(1);
! ERROR:  node:datanode_1, backend_pid:384365, nodename:datanode_1,backend_pid:384365,message:new row for relation "list_part_def" violates partition constraint
  DETAIL:  Failing row contains (1).
  create table list_part_2 partition of list_parted for values in (2);
  execute pstmt_def_insert(2);
! ERROR:  node:datanode_1, backend_pid:384365, nodename:datanode_1,backend_pid:384365,message:new row for relation "list_part_def" violates partition constraint
  DETAIL:  Failing row contains (2).
  alter table list_parted detach partition list_part_null;
  -- should be ok
  execute pstmt_def_insert(null);
+ ERROR:  node:datanode_1, backend_pid:384365, nodename:datanode_1,backend_pid:384365,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  drop table list_part_1;
  -- should be ok
  execute pstmt_def_insert(1);

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/limit.out"	2025-07-31 16:07:14.990068057 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/limit.out"	2025-07-31 16:39:54.445548121 +0800
***************
*** 522,528 ****
                                   Group Key: tenk1.thousand
                                   ->  Remote Subquery Scan on all (datanode_1,datanode_2)
                                         Output: thousand, PARTIAL sum(tenthous)
!                                        Distribute results by H: thousand
                                         ->  Partial HashAggregate
                                               Output: thousand, PARTIAL sum(tenthous)
                                               Group Key: tenk1.thousand
--- 522,528 ----
                                   Group Key: tenk1.thousand
                                   ->  Remote Subquery Scan on all (datanode_1,datanode_2)
                                         Output: thousand, PARTIAL sum(tenthous)
!                                        Distribute results by S: thousand
                                         ->  Partial HashAggregate
                                               Output: thousand, PARTIAL sum(tenthous)
                                               Group Key: tenk1.thousand

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/plpgsql_1.out"	2025-07-31 16:07:14.996067961 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/plpgsql.out"	2025-07-31 16:40:07.903262782 +0800
***************
*** 103,110 ****
  ' language plpgsql;
  create trigger tg_room_au after update
      on Room for each row execute procedure tg_room_au();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * AFTER DELETE on Room
  -- *	- delete wall slots in this room
--- 103,108 ----
***************
*** 117,124 ****
  ' language plpgsql;
  create trigger tg_room_ad after delete
      on Room for each row execute procedure tg_room_ad();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE INSERT or UPDATE on WSlot
  -- *	- Check that room exists
--- 115,120 ----
***************
*** 133,140 ****
  $$ language plpgsql;
  create trigger tg_wslot_biu before insert or update
      on WSlot for each row execute procedure tg_wslot_biu();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * AFTER UPDATE on PField
  -- *	- Let PSlots of this field follow
--- 129,134 ----
***************
*** 149,156 ****
  ' language plpgsql;
  create trigger tg_pfield_au after update
      on PField for each row execute procedure tg_pfield_au();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * AFTER DELETE on PField
  -- *	- Remove all slots of this patchfield
--- 143,149 ----
  ' language plpgsql;
  create trigger tg_pfield_au after update
      on PField for each row execute procedure tg_pfield_au();
! ERROR:  TRIGGER is not supported on replication table
  -- ************************************************************
  -- * AFTER DELETE on PField
  -- *	- Remove all slots of this patchfield
***************
*** 163,170 ****
  ' language plpgsql;
  create trigger tg_pfield_ad after delete
      on PField for each row execute procedure tg_pfield_ad();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE INSERT or UPDATE on PSlot
  -- *	- Ensure that our patchfield does exist
--- 156,162 ----
  ' language plpgsql;
  create trigger tg_pfield_ad after delete
      on PField for each row execute procedure tg_pfield_ad();
! ERROR:  TRIGGER is not supported on replication table
  -- ************************************************************
  -- * BEFORE INSERT or UPDATE on PSlot
  -- *	- Ensure that our patchfield does exist
***************
*** 183,190 ****
  $proc$ language plpgsql;
  create trigger tg_pslot_biu before insert or update
      on PSlot for each row execute procedure tg_pslot_biu();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * AFTER UPDATE on System
  -- *	- If system name changes let interfaces follow
--- 175,180 ----
***************
*** 199,206 ****
  ' language plpgsql;
  create trigger tg_system_au after update
      on System for each row execute procedure tg_system_au();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE INSERT or UPDATE on IFace
  -- *	- set the slotname to IF.sysname.ifname
--- 189,194 ----
***************
*** 226,233 ****
  $$ language plpgsql;
  create trigger tg_iface_biu before insert or update
      on IFace for each row execute procedure tg_iface_biu();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * AFTER INSERT or UPDATE or DELETE on Hub
  -- *	- insert/delete/rename slots as required
--- 214,219 ----
***************
*** 256,263 ****
  ' language plpgsql;
  create trigger tg_hub_a after insert or update or delete
      on Hub for each row execute procedure tg_hub_a();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * Support function to add/remove slots of Hub
  -- ************************************************************
--- 242,247 ----
***************
*** 320,327 ****
  ' language plpgsql;
  create trigger tg_hslot_biu before insert or update
      on HSlot for each row execute procedure tg_hslot_biu();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE DELETE on HSlot
  -- *	- prevent from manual manipulation
--- 304,309 ----
***************
*** 342,349 ****
  ' language plpgsql;
  create trigger tg_hslot_bd before delete
      on HSlot for each row execute procedure tg_hslot_bd();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE INSERT on all slots
  -- *	- Check name prefix
--- 324,329 ----
***************
*** 358,381 ****
  ' language plpgsql;
  create trigger tg_chkslotname before insert
      on PSlot for each row execute procedure tg_chkslotname('PS');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_chkslotname before insert
      on WSlot for each row execute procedure tg_chkslotname('WS');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_chkslotname before insert
      on PLine for each row execute procedure tg_chkslotname('PL');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_chkslotname before insert
      on IFace for each row execute procedure tg_chkslotname('IF');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_chkslotname before insert
      on PHone for each row execute procedure tg_chkslotname('PH');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE INSERT or UPDATE on all slots with slotlink
  -- *	- Set slotlink to empty string if NULL value given
--- 338,351 ----
***************
*** 390,413 ****
  ' language plpgsql;
  create trigger tg_chkslotlink before insert or update
      on PSlot for each row execute procedure tg_chkslotlink();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_chkslotlink before insert or update
      on WSlot for each row execute procedure tg_chkslotlink();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_chkslotlink before insert or update
      on IFace for each row execute procedure tg_chkslotlink();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_chkslotlink before insert or update
      on HSlot for each row execute procedure tg_chkslotlink();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_chkslotlink before insert or update
      on PHone for each row execute procedure tg_chkslotlink();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE INSERT or UPDATE on all slots with backlink
  -- *	- Set backlink to empty string if NULL value given
--- 360,373 ----
***************
*** 422,437 ****
  ' language plpgsql;
  create trigger tg_chkbacklink before insert or update
      on PSlot for each row execute procedure tg_chkbacklink();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_chkbacklink before insert or update
      on WSlot for each row execute procedure tg_chkbacklink();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_chkbacklink before insert or update
      on PLine for each row execute procedure tg_chkbacklink();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE UPDATE on PSlot
  -- *	- do delete/insert instead of update if name changes
--- 382,391 ----
***************
*** 458,465 ****
  ' language plpgsql;
  create trigger tg_pslot_bu before update
      on PSlot for each row execute procedure tg_pslot_bu();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE UPDATE on WSlot
  -- *	- do delete/insert instead of update if name changes
--- 412,417 ----
***************
*** 486,493 ****
  ' language plpgsql;
  create trigger tg_wslot_bu before update
      on WSlot for each row execute procedure tg_Wslot_bu();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE UPDATE on PLine
  -- *	- do delete/insert instead of update if name changes
--- 438,443 ----
***************
*** 514,521 ****
  ' language plpgsql;
  create trigger tg_pline_bu before update
      on PLine for each row execute procedure tg_pline_bu();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE UPDATE on IFace
  -- *	- do delete/insert instead of update if name changes
--- 464,469 ----
***************
*** 542,549 ****
  ' language plpgsql;
  create trigger tg_iface_bu before update
      on IFace for each row execute procedure tg_iface_bu();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE UPDATE on HSlot
  -- *	- do delete/insert instead of update if name changes
--- 490,495 ----
***************
*** 570,577 ****
  ' language plpgsql;
  create trigger tg_hslot_bu before update
      on HSlot for each row execute procedure tg_hslot_bu();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * BEFORE UPDATE on PHone
  -- *	- do delete/insert instead of update if name changes
--- 516,521 ----
***************
*** 596,603 ****
  ' language plpgsql;
  create trigger tg_phone_bu before update
      on PHone for each row execute procedure tg_phone_bu();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * AFTER INSERT or UPDATE or DELETE on slot with backlink
  -- *	- Ensure that the opponent correctly points back to us
--- 540,545 ----
***************
*** 637,652 ****
  ' language plpgsql;
  create trigger tg_backlink_a after insert or update or delete
      on PSlot for each row execute procedure tg_backlink_a('PS');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_backlink_a after insert or update or delete
      on WSlot for each row execute procedure tg_backlink_a('WS');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_backlink_a after insert or update or delete
      on PLine for each row execute procedure tg_backlink_a('PL');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * Support function to set the opponents backlink field
  -- * if it does not already point to the requested slot
--- 579,588 ----
***************
*** 785,808 ****
  ' language plpgsql;
  create trigger tg_slotlink_a after insert or update or delete
      on PSlot for each row execute procedure tg_slotlink_a('PS');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_slotlink_a after insert or update or delete
      on WSlot for each row execute procedure tg_slotlink_a('WS');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_slotlink_a after insert or update or delete
      on IFace for each row execute procedure tg_slotlink_a('IF');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_slotlink_a after insert or update or delete
      on HSlot for each row execute procedure tg_slotlink_a('HS');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger tg_slotlink_a after insert or update or delete
      on PHone for each row execute procedure tg_slotlink_a('PH');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- ************************************************************
  -- * Support function to set the opponents slotlink field
  -- * if it does not already point to the requested slot
--- 721,734 ----
***************
*** 1222,1229 ****
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      |                     
!  WS.001.1b            | 001      |                      |                     
   WS.001.2a            | 001      |                      |                     
   WS.001.2b            | 001      |                      |                     
   WS.001.3a            | 001      |                      |                     
--- 1148,1155 ----
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a3          
   WS.001.2a            | 001      |                      |                     
   WS.001.2b            | 001      |                      |                     
   WS.001.3a            | 001      |                      |                     
***************
*** 1245,1253 ****
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      |                     
   WS.001.1b            | 001      |                      |                     
!  WS.001.2a            | 001      |                      |                     
   WS.001.2b            | 001      |                      |                     
   WS.001.3a            | 001      |                      |                     
   WS.001.3b            | 001      |                      |                     
--- 1171,1179 ----
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
   WS.001.1b            | 001      |                      |                     
!  WS.001.2a            | 001      |                      | PS.base.a3          
   WS.001.2b            | 001      |                      |                     
   WS.001.3a            | 001      |                      |                     
   WS.001.3b            | 001      |                      |                     
***************
*** 1268,1276 ****
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      |                     
!  WS.001.1b            | 001      |                      |                     
!  WS.001.2a            | 001      |                      |                     
   WS.001.2b            | 001      |                      |                     
   WS.001.3a            | 001      |                      |                     
   WS.001.3b            | 001      |                      |                     
--- 1194,1202 ----
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a2          
!  WS.001.2a            | 001      |                      | PS.base.a3          
   WS.001.2b            | 001      |                      |                     
   WS.001.3a            | 001      |                      |                     
   WS.001.3b            | 001      |                      |                     
***************
*** 1297,1305 ****
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      |                     
!  WS.001.1b            | 001      |                      |                     
!  WS.001.2a            | 001      |                      |                     
   WS.001.2b            | 001      |                      | PS.base.a4          
   WS.001.3a            | 001      |                      | PS.base.a6          
   WS.001.3b            | 001      |                      |                     
--- 1223,1231 ----
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a2          
!  WS.001.2a            | 001      |                      | PS.base.a3          
   WS.001.2b            | 001      |                      | PS.base.a4          
   WS.001.3a            | 001      |                      | PS.base.a6          
   WS.001.3b            | 001      |                      |                     
***************
*** 1311,1330 ****
   PS.base.a1           | PF0_1  |                      | WS.001.1a           
   PS.base.a2           | PF0_1  |                      | WS.001.1b           
   PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      |                     
   PS.base.a5           | PF0_1  |                      |                     
!  PS.base.a6           | PF0_1  |                      |                     
  (6 rows)
  
  update WSlot set backlink = 'PS.base.a6' where slotname = 'WS.001.3b';
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      |                     
!  WS.001.1b            | 001      |                      |                     
!  WS.001.2a            | 001      |                      |                     
   WS.001.2b            | 001      |                      | PS.base.a4          
!  WS.001.3a            | 001      |                      | PS.base.a6          
   WS.001.3b            | 001      |                      | PS.base.a6          
  (6 rows)
  
--- 1237,1256 ----
   PS.base.a1           | PF0_1  |                      | WS.001.1a           
   PS.base.a2           | PF0_1  |                      | WS.001.1b           
   PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      | WS.001.2b           
   PS.base.a5           | PF0_1  |                      |                     
!  PS.base.a6           | PF0_1  |                      | WS.001.3a           
  (6 rows)
  
  update WSlot set backlink = 'PS.base.a6' where slotname = 'WS.001.3b';
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a2          
!  WS.001.2a            | 001      |                      | PS.base.a3          
   WS.001.2b            | 001      |                      | PS.base.a4          
!  WS.001.3a            | 001      |                      |                     
   WS.001.3b            | 001      |                      | PS.base.a6          
  (6 rows)
  
***************
*** 1334,1351 ****
   PS.base.a1           | PF0_1  |                      | WS.001.1a           
   PS.base.a2           | PF0_1  |                      | WS.001.1b           
   PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      |                     
   PS.base.a5           | PF0_1  |                      |                     
!  PS.base.a6           | PF0_1  |                      |                     
  (6 rows)
  
  update WSlot set backlink = 'PS.base.a5' where slotname = 'WS.001.3a';
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      |                     
!  WS.001.1b            | 001      |                      |                     
!  WS.001.2a            | 001      |                      |                     
   WS.001.2b            | 001      |                      | PS.base.a4          
   WS.001.3a            | 001      |                      | PS.base.a5          
   WS.001.3b            | 001      |                      | PS.base.a6          
--- 1260,1277 ----
   PS.base.a1           | PF0_1  |                      | WS.001.1a           
   PS.base.a2           | PF0_1  |                      | WS.001.1b           
   PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      | WS.001.2b           
   PS.base.a5           | PF0_1  |                      |                     
!  PS.base.a6           | PF0_1  |                      | WS.001.3b           
  (6 rows)
  
  update WSlot set backlink = 'PS.base.a5' where slotname = 'WS.001.3a';
  select * from WSlot where roomno = '001' order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a2          
!  WS.001.2a            | 001      |                      | PS.base.a3          
   WS.001.2b            | 001      |                      | PS.base.a4          
   WS.001.3a            | 001      |                      | PS.base.a5          
   WS.001.3b            | 001      |                      | PS.base.a6          
***************
*** 1357,1365 ****
   PS.base.a1           | PF0_1  |                      | WS.001.1a           
   PS.base.a2           | PF0_1  |                      | WS.001.1b           
   PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      |                     
!  PS.base.a5           | PF0_1  |                      |                     
!  PS.base.a6           | PF0_1  |                      |                     
  (6 rows)
  
  insert into PField values ('PF1_2', 'Phonelines first floor');
--- 1283,1291 ----
   PS.base.a1           | PF0_1  |                      | WS.001.1a           
   PS.base.a2           | PF0_1  |                      | WS.001.1b           
   PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      | WS.001.2b           
!  PS.base.a5           | PF0_1  |                      | WS.001.3a           
!  PS.base.a6           | PF0_1  |                      | WS.001.3b           
  (6 rows)
  
  insert into PField values ('PF1_2', 'Phonelines first floor');
***************
*** 1385,1393 ****
   PS.base.a1           | PF0_1  |                      | WS.001.1a           
   PS.base.a2           | PF0_1  |                      | WS.001.1b           
   PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      |                     
!  PS.base.a5           | PF0_1  |                      |                     
!  PS.base.a6           | PF0_1  |                      |                     
   PS.base.b1           | PF0_1  |                      | WS.002.1a           
   PS.base.b2           | PF0_1  |                      | WS.002.1b           
   PS.base.b3           | PF0_1  |                      | WS.002.2a           
--- 1311,1319 ----
   PS.base.a1           | PF0_1  |                      | WS.001.1a           
   PS.base.a2           | PF0_1  |                      | WS.001.1b           
   PS.base.a3           | PF0_1  |                      | WS.001.2a           
!  PS.base.a4           | PF0_1  |                      | WS.001.2b           
!  PS.base.a5           | PF0_1  |                      | WS.001.3a           
!  PS.base.a6           | PF0_1  |                      | WS.001.3b           
   PS.base.b1           | PF0_1  |                      | WS.002.1a           
   PS.base.b2           | PF0_1  |                      | WS.002.1b           
   PS.base.b3           | PF0_1  |                      | WS.002.2a           
***************
*** 1453,1500 ****
  select * from WSlot order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      |                     
!  WS.001.1b            | 001      |                      |                     
!  WS.001.2a            | 001      |                      |                     
   WS.001.2b            | 001      |                      | PS.base.a4          
   WS.001.3a            | 001      |                      | PS.base.a5          
   WS.001.3b            | 001      |                      | PS.base.a6          
!  WS.002.1a            | 002      |                      |                     
!  WS.002.1b            | 002      |                      |                     
!  WS.002.2a            | 002      |                      |                     
!  WS.002.2b            | 002      |                      |                     
!  WS.002.3a            | 002      |                      |                     
!  WS.002.3b            | 002      |                      |                     
!  WS.003.1a            | 003      |                      |                     
!  WS.003.1b            | 003      |                      |                     
!  WS.003.2a            | 003      |                      |                     
!  WS.003.2b            | 003      |                      |                     
!  WS.003.3a            | 003      |                      |                     
!  WS.003.3b            | 003      |                      |                     
!  WS.101.1a            | 101      |                      |                     
!  WS.101.1b            | 101      |                      |                     
!  WS.101.2a            | 101      |                      |                     
!  WS.101.2b            | 101      |                      |                     
!  WS.101.3a            | 101      |                      |                     
!  WS.101.3b            | 101      |                      |                     
!  WS.102.1a            | 102      |                      |                     
!  WS.102.1b            | 102      |                      |                     
!  WS.102.2a            | 102      |                      |                     
!  WS.102.2b            | 102      |                      |                     
!  WS.102.3a            | 102      |                      |                     
!  WS.102.3b            | 102      |                      |                     
!  WS.105.1a            | 105      |                      |                     
!  WS.105.1b            | 105      |                      |                     
!  WS.105.2a            | 105      |                      |                     
!  WS.105.2b            | 105      |                      |                     
!  WS.105.3a            | 105      |                      |                     
!  WS.105.3b            | 105      |                      |                     
!  WS.106.1a            | 106      |                      |                     
!  WS.106.1b            | 106      |                      |                     
!  WS.106.2a            | 106      |                      |                     
!  WS.106.2b            | 106      |                      |                     
!  WS.106.3a            | 106      |                      |                     
!  WS.106.3b            | 106      |                      |                     
  (42 rows)
  
  --
--- 1379,1426 ----
  select * from WSlot order by slotname;
         slotname       |  roomno  |       slotlink       |       backlink       
  ----------------------+----------+----------------------+----------------------
!  WS.001.1a            | 001      |                      | PS.base.a1          
!  WS.001.1b            | 001      |                      | PS.base.a2          
!  WS.001.2a            | 001      |                      | PS.base.a3          
   WS.001.2b            | 001      |                      | PS.base.a4          
   WS.001.3a            | 001      |                      | PS.base.a5          
   WS.001.3b            | 001      |                      | PS.base.a6          
!  WS.002.1a            | 002      |                      | PS.base.b1          
!  WS.002.1b            | 002      |                      | PS.base.b2          
!  WS.002.2a            | 002      |                      | PS.base.b3          
!  WS.002.2b            | 002      |                      | PS.base.b4          
!  WS.002.3a            | 002      |                      | PS.base.b5          
!  WS.002.3b            | 002      |                      | PS.base.b6          
!  WS.003.1a            | 003      |                      | PS.base.c1          
!  WS.003.1b            | 003      |                      | PS.base.c2          
!  WS.003.2a            | 003      |                      | PS.base.c3          
!  WS.003.2b            | 003      |                      | PS.base.c4          
!  WS.003.3a            | 003      |                      | PS.base.c5          
!  WS.003.3b            | 003      |                      | PS.base.c6          
!  WS.101.1a            | 101      |                      | PS.first.a1         
!  WS.101.1b            | 101      |                      | PS.first.a2         
!  WS.101.2a            | 101      |                      | PS.first.a3         
!  WS.101.2b            | 101      |                      | PS.first.a4         
!  WS.101.3a            | 101      |                      | PS.first.a5         
!  WS.101.3b            | 101      |                      | PS.first.a6         
!  WS.102.1a            | 102      |                      | PS.first.b1         
!  WS.102.1b            | 102      |                      | PS.first.b2         
!  WS.102.2a            | 102      |                      | PS.first.b3         
!  WS.102.2b            | 102      |                      | PS.first.b4         
!  WS.102.3a            | 102      |                      | PS.first.b5         
!  WS.102.3b            | 102      |                      | PS.first.b6         
!  WS.105.1a            | 105      |                      | PS.first.c1         
!  WS.105.1b            | 105      |                      | PS.first.c2         
!  WS.105.2a            | 105      |                      | PS.first.c3         
!  WS.105.2b            | 105      |                      | PS.first.c4         
!  WS.105.3a            | 105      |                      | PS.first.c5         
!  WS.105.3b            | 105      |                      | PS.first.c6         
!  WS.106.1a            | 106      |                      | PS.first.d1         
!  WS.106.1b            | 106      |                      | PS.first.d2         
!  WS.106.2a            | 106      |                      | PS.first.d3         
!  WS.106.2b            | 106      |                      | PS.first.d4         
!  WS.106.3a            | 106      |                      | PS.first.d5         
!  WS.106.3b            | 106      |                      | PS.first.d6         
  (42 rows)
  
  --
***************
*** 1504,1518 ****
--- 1430,1494 ----
  -- backlink field.
  --
  insert into PLine values ('PL.001', '-0', 'Central call', 'PS.base.ta1');
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set backlink = blname where slotname = myname"
+ PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+ PL/pgSQL function tg_backlink_a() line 7 at assignment
  insert into PLine values ('PL.002', '-101', '', 'PS.base.ta2');
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set backlink = blname where slotname = myname"
+ PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+ PL/pgSQL function tg_backlink_a() line 7 at assignment
  insert into PLine values ('PL.003', '-102', '', 'PS.base.ta3');
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set backlink = blname where slotname = myname"
+ PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+ PL/pgSQL function tg_backlink_a() line 7 at assignment
  insert into PLine values ('PL.004', '-103', '', 'PS.base.ta5');
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set backlink = blname where slotname = myname"
+ PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+ PL/pgSQL function tg_backlink_a() line 7 at assignment
  insert into PLine values ('PL.005', '-104', '', 'PS.base.ta6');
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set backlink = blname where slotname = myname"
+ PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+ PL/pgSQL function tg_backlink_a() line 7 at assignment
  insert into PLine values ('PL.006', '-106', '', 'PS.base.tb2');
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set backlink = blname where slotname = myname"
+ PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+ PL/pgSQL function tg_backlink_a() line 7 at assignment
  insert into PLine values ('PL.007', '-108', '', 'PS.base.tb3');
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set backlink = blname where slotname = myname"
+ PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+ PL/pgSQL function tg_backlink_a() line 7 at assignment
  insert into PLine values ('PL.008', '-109', '', 'PS.base.tb4');
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set backlink = blname where slotname = myname"
+ PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+ PL/pgSQL function tg_backlink_a() line 7 at assignment
  insert into PLine values ('PL.009', '-121', '', 'PS.base.tb5');
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set backlink = blname where slotname = myname"
+ PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+ PL/pgSQL function tg_backlink_a() line 7 at assignment
  insert into PLine values ('PL.010', '-122', '', 'PS.base.tb6');
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set backlink = blname where slotname = myname"
+ PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+ PL/pgSQL function tg_backlink_a() line 7 at assignment
  insert into PLine values ('PL.015', '-134', '', 'PS.first.ta1');
  insert into PLine values ('PL.016', '-137', '', 'PS.first.ta3');
  insert into PLine values ('PL.017', '-139', '', 'PS.first.ta4');
***************
*** 1522,1527 ****
--- 1498,1508 ----
  insert into PLine values ('PL.021', '-365', '', 'PS.first.tb5');
  insert into PLine values ('PL.022', '-367', '', 'PS.first.tb6');
  insert into PLine values ('PL.028', '-501', 'Fax entrance', 'PS.base.ta2');
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set backlink = blname where slotname = myname"
+ PL/pgSQL function tg_backlink_set(character,character) line 23 at SQL statement
+ PL/pgSQL function tg_backlink_a() line 7 at assignment
  insert into PLine values ('PL.029', '-502', 'Fax first floor', 'PS.first.ta1');
  --
  -- Buy some phones, plug them into the wall and patch the
***************
*** 1529,1540 ****
--- 1510,1541 ----
  --
  insert into PHone values ('PH.hc001', 'Hicom standard', 'WS.001.1a');
  update PSlot set slotlink = 'PS.base.ta1' where slotname = 'PS.base.a1';
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set slotlink = blname where slotname = myname"
+ PL/pgSQL function tg_slotlink_set(character,character) line 33 at SQL statement
+ PL/pgSQL function tg_slotlink_a() line 17 at assignment
  insert into PHone values ('PH.hc002', 'Hicom standard', 'WS.002.1a');
  update PSlot set slotlink = 'PS.base.ta5' where slotname = 'PS.base.b1';
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set slotlink = blname where slotname = myname"
+ PL/pgSQL function tg_slotlink_set(character,character) line 33 at SQL statement
+ PL/pgSQL function tg_slotlink_a() line 17 at assignment
  insert into PHone values ('PH.hc003', 'Hicom standard', 'WS.002.2a');
  update PSlot set slotlink = 'PS.base.tb2' where slotname = 'PS.base.b3';
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set slotlink = blname where slotname = myname"
+ PL/pgSQL function tg_slotlink_set(character,character) line 33 at SQL statement
+ PL/pgSQL function tg_slotlink_a() line 17 at assignment
  insert into PHone values ('PH.fax001', 'Canon fax', 'WS.001.2a');
  update PSlot set slotlink = 'PS.base.ta2' where slotname = 'PS.base.a3';
+ ERROR:  Patchfield "PF0_X" does not exist
+ CONTEXT:  PL/pgSQL function tg_pslot_biu() line 8 at RAISE
+ SQL statement "update PSlot set slotlink = blname where slotname = myname"
+ PL/pgSQL function tg_slotlink_set(character,character) line 33 at SQL statement
+ PL/pgSQL function tg_slotlink_a() line 17 at assignment
  --
  -- Install a hub at one of the patchfields, plug a computers
  -- ethernet interface into the wall and patch it to the hub.
***************
*** 1548,1573 ****
  --
  -- PGXCTODO: This is failing due to issue 3522907, complicated SELECT queries in plpgsql functions
  select * from PField_v1 where pfname = 'PF0_1' order by slotname;
!  pfname |       slotname       |          backside          |      patch       
! --------+----------------------+----------------------------+------------------
!  PF0_1  | PS.base.a1           | WS.001.1a in room 001 -> - | PS.base.ta1 -> -
!  PF0_1  | PS.base.a2           | WS.001.1b in room 001 -> - | -
!  PF0_1  | PS.base.a3           | WS.001.2a in room 001 -> - | PS.base.ta2 -> -
!  PF0_1  | PS.base.a4           | -                          | -
!  PF0_1  | PS.base.a5           | -                          | -
!  PF0_1  | PS.base.a6           | -                          | -
!  PF0_1  | PS.base.b1           | WS.002.1a in room 002 -> - | PS.base.ta5 -> -
!  PF0_1  | PS.base.b2           | WS.002.1b in room 002 -> - | 
!  PF0_1  | PS.base.b3           | WS.002.2a in room 002 -> - | PS.base.tb2 -> -
!  PF0_1  | PS.base.b4           | WS.002.2b in room 002 -> - | -
!  PF0_1  | PS.base.b5           | WS.002.3a in room 002 -> - | -
!  PF0_1  | PS.base.b6           | WS.002.3b in room 002 -> - | -
!  PF0_1  | PS.base.c1           | WS.003.1a in room 003 -> - | -
!  PF0_1  | PS.base.c2           | WS.003.1b in room 003 -> - | -
!  PF0_1  | PS.base.c3           | WS.003.2a in room 003 -> - | -
!  PF0_1  | PS.base.c4           | WS.003.2b in room 003 -> - | -
!  PF0_1  | PS.base.c5           | WS.003.3a in room 003 -> - | -
!  PF0_1  | PS.base.c6           | WS.003.3b in room 003 -> - | -
  (18 rows)
  
  select * from PField_v1 where pfname = 'PF0_2' order by slotname;
--- 1549,1574 ----
  --
  -- PGXCTODO: This is failing due to issue 3522907, complicated SELECT queries in plpgsql functions
  select * from PField_v1 where pfname = 'PF0_1' order by slotname;
!  pfname |       slotname       |                         backside                         |            patch            
! --------+----------------------+----------------------------------------------------------+-----------------------------
!  PF0_1  | PS.base.a1           | WS.001.1a in room 001 -> Phone PH.hc001 (Hicom standard) | -
!  PF0_1  | PS.base.a2           | WS.001.1b in room 001 -> -                               | -
!  PF0_1  | PS.base.a3           | WS.001.2a in room 001 -> Phone PH.fax001 (Canon fax)     | -
!  PF0_1  | PS.base.a4           | WS.001.2b in room 001 -> -                               | -
!  PF0_1  | PS.base.a5           | WS.001.3a in room 001 -> -                               | -
!  PF0_1  | PS.base.a6           | WS.001.3b in room 001 -> -                               | -
!  PF0_1  | PS.base.b1           | WS.002.1a in room 002 -> Phone PH.hc002 (Hicom standard) | -
!  PF0_1  | PS.base.b2           | WS.002.1b in room 002 -> orion IF eth0 (PC)              | Patchfield PF0_1 hub slot 1
!  PF0_1  | PS.base.b3           | WS.002.2a in room 002 -> Phone PH.hc003 (Hicom standard) | -
!  PF0_1  | PS.base.b4           | WS.002.2b in room 002 -> -                               | -
!  PF0_1  | PS.base.b5           | WS.002.3a in room 002 -> -                               | -
!  PF0_1  | PS.base.b6           | WS.002.3b in room 002 -> -                               | -
!  PF0_1  | PS.base.c1           | WS.003.1a in room 003 -> -                               | -
!  PF0_1  | PS.base.c2           | WS.003.1b in room 003 -> -                               | -
!  PF0_1  | PS.base.c3           | WS.003.2a in room 003 -> -                               | -
!  PF0_1  | PS.base.c4           | WS.003.2b in room 003 -> -                               | -
!  PF0_1  | PS.base.c5           | WS.003.3a in room 003 -> -                               | -
!  PF0_1  | PS.base.c6           | WS.003.3b in room 003 -> -                               | -
  (18 rows)
  
  select * from PField_v1 where pfname = 'PF0_2' order by slotname;
***************
*** 1579,1601 ****
  -- Finally we want errors
  --
  insert into PField values ('PF1_1', 'should fail due to unique index');
! ERROR:  duplicate key value violates unique constraint "pfield_name"
  DETAIL:  Key (name)=(PF1_1) already exists.
  update PSlot set backlink = 'WS.not.there' where slotname = 'PS.base.a1';
  update PSlot set backlink = 'XX.illegal' where slotname = 'PS.base.a1';
  update PSlot set slotlink = 'PS.not.there' where slotname = 'PS.base.a1';
  update PSlot set slotlink = 'XX.illegal' where slotname = 'PS.base.a1';
  insert into HSlot values ('HS', 'base.hub1', 1, '');
  insert into HSlot values ('HS', 'base.hub1', 20, '');
! ERROR:  duplicate key value violates unique constraint "hslot_name"
! DETAIL:  Key (slotname)=(HS                  ) already exists.
  delete from HSlot;
  insert into IFace values ('IF', 'notthere', 'eth0', '');
! ERROR:  duplicate key value violates unique constraint "iface_name"
! DETAIL:  Key (slotname)=(IF                  ) already exists.
  insert into IFace values ('IF', 'orion', 'ethernet_interface_name_too_long', '');
! ERROR:  duplicate key value violates unique constraint "iface_name"
! DETAIL:  Key (slotname)=(IF                  ) already exists.
  --
  -- The following tests are unrelated to the scenario outlined above;
  -- they merely exercise specific parts of PL/pgSQL
--- 1580,1618 ----
  -- Finally we want errors
  --
  insert into PField values ('PF1_1', 'should fail due to unique index');
! ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_1,backend_pid:383266,message:duplicate key value violates unique constraint "pfield_name"
  DETAIL:  Key (name)=(PF1_1) already exists.
  update PSlot set backlink = 'WS.not.there' where slotname = 'PS.base.a1';
+ ERROR:  WS.not.there         does not exist
+ CONTEXT:  PL/pgSQL function tg_backlink_set(character,character) line 30 at RAISE
+ PL/pgSQL function tg_backlink_a() line 17 at assignment
  update PSlot set backlink = 'XX.illegal' where slotname = 'PS.base.a1';
+ ERROR:  illegal backlink beginning with XX
+ CONTEXT:  PL/pgSQL function tg_backlink_set(character,character) line 47 at RAISE
+ PL/pgSQL function tg_backlink_a() line 17 at assignment
  update PSlot set slotlink = 'PS.not.there' where slotname = 'PS.base.a1';
+ ERROR:  PS.not.there         does not exist
+ CONTEXT:  PL/pgSQL function tg_slotlink_set(character,character) line 30 at RAISE
+ PL/pgSQL function tg_slotlink_a() line 17 at assignment
  update PSlot set slotlink = 'XX.illegal' where slotname = 'PS.base.a1';
+ ERROR:  illegal slotlink beginning with XX
+ CONTEXT:  PL/pgSQL function tg_slotlink_set(character,character) line 77 at RAISE
+ PL/pgSQL function tg_slotlink_a() line 17 at assignment
  insert into HSlot values ('HS', 'base.hub1', 1, '');
+ ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_2,backend_pid:384291,message:duplicate key value violates unique constraint "hslot_name"
+ DETAIL:  Key (slotname)=(HS.base.hub1.1      ) already exists.
  insert into HSlot values ('HS', 'base.hub1', 20, '');
! ERROR:  no manual manipulation of HSlot
! CONTEXT:  PL/pgSQL function tg_hslot_biu() line 12 at RAISE
  delete from HSlot;
+ ERROR:  no manual manipulation of HSlot
+ CONTEXT:  PL/pgSQL function tg_hslot_bd() line 12 at RAISE
  insert into IFace values ('IF', 'notthere', 'eth0', '');
! ERROR:  system "notthere" does not exist
! CONTEXT:  PL/pgSQL function tg_iface_biu() line 8 at RAISE
  insert into IFace values ('IF', 'orion', 'ethernet_interface_name_too_long', '');
! ERROR:  IFace slotname "IF.orion.ethernet_interface_name_too_long" too long (20 char max)
! CONTEXT:  PL/pgSQL function tg_iface_biu() line 14 at RAISE
  --
  -- The following tests are unrelated to the scenario outlined above;
  -- they merely exercise specific parts of PL/pgSQL
***************
*** 1623,1628 ****
--- 1640,1646 ----
  -- Test the FOUND magic variable
  --
  CREATE TABLE found_test_tbl (a int) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create function test_found()
    returns boolean as '
    declare
***************
*** 1659,1680 ****
    return true;
    end;' language plpgsql;
  select test_found();
!  test_found 
! ------------
!  t
! (1 row)
! 
  select * from found_test_tbl order by 1;
!   a  
! -----
!    2
!    3
!    4
!    5
!    6
!  100
! (6 rows)
! 
  --
  -- Test set-returning functions for PL/pgSQL
  --
--- 1677,1691 ----
    return true;
    end;' language plpgsql;
  select test_found();
! ERROR:  relation "found_test_tbl" does not exist
! LINE 1: insert into found_test_tbl values (1)
!                     ^
! QUERY:  insert into found_test_tbl values (1)
! CONTEXT:  PL/pgSQL function test_found() line 4 at SQL statement
  select * from found_test_tbl order by 1;
! ERROR:  relation "found_test_tbl" does not exist
! LINE 1: select * from found_test_tbl order by 1;
!                       ^
  --
  -- Test set-returning functions for PL/pgSQL
  --
***************
*** 1687,1703 ****
  	END LOOP;
  	RETURN;
  END;' language plpgsql;
  select * from test_table_func_rec() order by 1;
!   a  
! -----
!    2
!    3
!    4
!    5
!    6
!  100
! (6 rows)
! 
  create function test_table_func_row() returns setof found_test_tbl as '
  DECLARE
  	row found_test_tbl%ROWTYPE;
--- 1698,1709 ----
  	END LOOP;
  	RETURN;
  END;' language plpgsql;
+ ERROR:  type "found_test_tbl" does not exist
  select * from test_table_func_rec() order by 1;
! ERROR:  function test_table_func_rec() does not exist
! LINE 1: select * from test_table_func_rec() order by 1;
!                       ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  create function test_table_func_row() returns setof found_test_tbl as '
  DECLARE
  	row found_test_tbl%ROWTYPE;
***************
*** 1707,1723 ****
  	END LOOP;
  	RETURN;
  END;' language plpgsql;
  select * from test_table_func_row() order by 1;
!   a  
! -----
!    2
!    3
!    4
!    5
!    6
!  100
! (6 rows)
! 
  create function test_ret_set_scalar(int,int) returns setof int as '
  DECLARE
  	i int;
--- 1713,1724 ----
  	END LOOP;
  	RETURN;
  END;' language plpgsql;
+ ERROR:  type "found_test_tbl" does not exist
  select * from test_table_func_row() order by 1;
! ERROR:  function test_table_func_row() does not exist
! LINE 1: select * from test_table_func_row() order by 1;
!                       ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  create function test_ret_set_scalar(int,int) returns setof int as '
  DECLARE
  	i int;
***************
*** 2153,2163 ****
  --
  create temp table master(f1 int primary key);
  create temp table slave(f1 int references master deferrable);
  insert into master values(1);
  insert into slave values(1);
  insert into slave values(2);	-- fails
! ERROR:  insert or update on table "slave" violates foreign key constraint "slave_f1_fkey"
! DETAIL:  Key (f1)=(2) is not present in table "master".
  create function trap_foreign_key(int) returns int as $$
  begin
  	begin	-- start a subtransaction
--- 2154,2169 ----
  --
  create temp table master(f1 int primary key);
  create temp table slave(f1 int references master deferrable);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  insert into master values(1);
  insert into slave values(1);
+ ERROR:  relation "slave" does not exist
+ LINE 1: insert into slave values(1);
+                     ^
  insert into slave values(2);	-- fails
! ERROR:  relation "slave" does not exist
! LINE 1: insert into slave values(2);
!                     ^
  create function trap_foreign_key(int) returns int as $$
  begin
  	begin	-- start a subtransaction
***************
*** 2181,2221 ****
  	return 1;
  end$$ language plpgsql;
  select trap_foreign_key(1);
!  trap_foreign_key 
! ------------------
!                 1
! (1 row)
! 
  select trap_foreign_key(2);	-- detects FK violation
! NOTICE:  caught foreign_key_violation
!  trap_foreign_key 
! ------------------
!                 0
! (1 row)
! 
  begin;
    set constraints all deferred;
    select trap_foreign_key(2);	-- should not detect FK violation
!  trap_foreign_key 
! ------------------
!                 1
! (1 row)
! 
    savepoint x;
      set constraints all immediate; -- fails
! ERROR:  insert or update on table "slave" violates foreign key constraint "slave_f1_fkey"
! DETAIL:  Key (f1)=(2) is not present in table "master".
    rollback to x;
    select trap_foreign_key_2();  -- detects FK violation
! NOTICE:  caught foreign_key_violation
!  trap_foreign_key_2 
! --------------------
!                   0
! (1 row)
! 
  commit;				-- still fails
- ERROR:  insert or update on table "slave" violates foreign key constraint "slave_f1_fkey"
- DETAIL:  Key (f1)=(2) is not present in table "master".
  drop function trap_foreign_key(int);
  drop function trap_foreign_key_2();
  --
--- 2187,2220 ----
  	return 1;
  end$$ language plpgsql;
  select trap_foreign_key(1);
! ERROR:  relation "slave" does not exist
! LINE 1: insert into slave values($1)
!                     ^
! QUERY:  insert into slave values($1)
! CONTEXT:  PL/pgSQL function trap_foreign_key(integer) line 4 at SQL statement
  select trap_foreign_key(2);	-- detects FK violation
! ERROR:  relation "slave" does not exist
! LINE 1: insert into slave values($1)
!                     ^
! QUERY:  insert into slave values($1)
! CONTEXT:  PL/pgSQL function trap_foreign_key(integer) line 4 at SQL statement
  begin;
    set constraints all deferred;
    select trap_foreign_key(2);	-- should not detect FK violation
! ERROR:  relation "slave" does not exist
! LINE 1: insert into slave values($1)
!                     ^
! QUERY:  insert into slave values($1)
! CONTEXT:  PL/pgSQL function trap_foreign_key(integer) line 4 at SQL statement
    savepoint x;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
      set constraints all immediate; -- fails
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
    rollback to x;
+ ERROR:  no such savepoint
    select trap_foreign_key_2();  -- detects FK violation
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  commit;				-- still fails
  drop function trap_foreign_key(int);
  drop function trap_foreign_key_2();
  --
***************
*** 3355,3364 ****
  CONTEXT:  PL/pgSQL function footest() line 10 at SQL statement
  -- test warnings and errors
  set plpgsql.extra_warnings to 'all';
! ERROR:  syntax error at or near "all"
  set plpgsql.extra_warnings to 'none';
  set plpgsql.extra_errors to 'all';
! ERROR:  syntax error at or near "all"
  set plpgsql.extra_errors to 'none';
  -- test warnings when shadowing a variable
  set plpgsql.extra_warnings to 'shadowed_variables';
--- 3354,3363 ----
  CONTEXT:  PL/pgSQL function footest() line 10 at SQL statement
  -- test warnings and errors
  set plpgsql.extra_warnings to 'all';
! ERROR:  node:datanode_2, backend_pid:384291, nodename:coord2,backend_pid:383263,message:syntax error at or near "all"
  set plpgsql.extra_warnings to 'none';
  set plpgsql.extra_errors to 'all';
! ERROR:  node:datanode_1, backend_pid:383266, nodename:coord2,backend_pid:383263,message:syntax error at or near "all"
  set plpgsql.extra_errors to 'none';
  -- test warnings when shadowing a variable
  set plpgsql.extra_warnings to 'shadowed_variables';
***************
*** 5885,5901 ****
    REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable
    FOR EACH STATEMENT
    EXECUTE PROCEDURE transition_table_base_ins_func();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
  CREATE TRIGGER transition_table_base_ins_trig
    AFTER INSERT ON transition_table_base
    REFERENCING NEW TABLE AS newtable
    FOR EACH STATEMENT
    EXECUTE PROCEDURE transition_table_base_ins_func();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  INSERT INTO transition_table_base VALUES (1, 'One'), (2, 'Two');
  INSERT INTO transition_table_base VALUES (3, 'Three'), (4, 'Four');
  CREATE OR REPLACE FUNCTION transition_table_base_upd_func()
    RETURNS trigger
    LANGUAGE plpgsql
--- 5884,5903 ----
    REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable
    FOR EACH STATEMENT
    EXECUTE PROCEDURE transition_table_base_ins_func();
! ERROR:  OLD TABLE can only be specified for a DELETE or UPDATE trigger
  CREATE TRIGGER transition_table_base_ins_trig
    AFTER INSERT ON transition_table_base
    REFERENCING NEW TABLE AS newtable
    FOR EACH STATEMENT
    EXECUTE PROCEDURE transition_table_base_ins_func();
  INSERT INTO transition_table_base VALUES (1, 'One'), (2, 'Two');
+ INFO:  Named Tuplestore Scan
+   Output: id, val
+ 
  INSERT INTO transition_table_base VALUES (3, 'Three'), (4, 'Four');
+ INFO:  Named Tuplestore Scan
+   Output: id, val
+ 
  CREATE OR REPLACE FUNCTION transition_table_base_upd_func()
    RETURNS trigger
    LANGUAGE plpgsql
***************
*** 5922,5932 ****
    REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable
    FOR EACH STATEMENT
    EXECUTE PROCEDURE transition_table_base_upd_func();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  UPDATE transition_table_base
    SET val = '*' || val || '*'
    WHERE id BETWEEN 2 AND 3;
  CREATE TABLE transition_table_level1
  (
        level1_no serial NOT NULL ,
--- 5924,5942 ----
    REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable
    FOR EACH STATEMENT
    EXECUTE PROCEDURE transition_table_base_upd_func();
  UPDATE transition_table_base
    SET val = '*' || val || '*'
    WHERE id BETWEEN 2 AND 3;
+ INFO:  Hash Full Join
+   Output: COALESCE(ot.id, nt.id), ot.val, nt.val
+   Hash Cond: (ot.id = nt.id)
+   ->  Named Tuplestore Scan
+         Output: ot.id, ot.val
+   ->  Hash
+         Output: nt.id, nt.val
+         ->  Named Tuplestore Scan
+               Output: nt.id, nt.val
+ 
  CREATE TABLE transition_table_level1
  (
        level1_no serial NOT NULL ,
***************
*** 5965,5972 ****
    REFERENCING OLD TABLE AS p
    FOR EACH STATEMENT EXECUTE PROCEDURE
      transition_table_level1_ri_parent_del_func();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  CREATE FUNCTION transition_table_level1_ri_parent_upd_func()
    RETURNS TRIGGER
    LANGUAGE plpgsql
--- 5975,5980 ----
***************
*** 5994,6001 ****
    REFERENCING OLD TABLE AS d NEW TABLE AS i
    FOR EACH STATEMENT EXECUTE PROCEDURE
      transition_table_level1_ri_parent_upd_func();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  CREATE FUNCTION transition_table_level2_ri_child_insupd_func()
    RETURNS TRIGGER
    LANGUAGE plpgsql
--- 6002,6007 ----
***************
*** 6016,6030 ****
    REFERENCING NEW TABLE AS i
    FOR EACH STATEMENT EXECUTE PROCEDURE
      transition_table_level2_ri_child_insupd_func();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  CREATE TRIGGER transition_table_level2_ri_child_upd_trigger
    AFTER UPDATE ON transition_table_level2
    REFERENCING NEW TABLE AS i
    FOR EACH STATEMENT EXECUTE PROCEDURE
      transition_table_level2_ri_child_insupd_func();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  -- create initial test data
  INSERT INTO transition_table_level1 (level1_no)
    SELECT generate_series(1,200);
--- 6022,6032 ----
***************
*** 6056,6078 ****
    REFERENCING OLD TABLE AS d
    FOR EACH STATEMENT EXECUTE PROCEDURE
      transition_table_level2_bad_usage_func();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  DELETE FROM transition_table_level2
    WHERE level2_no BETWEEN 301 AND 305;
  DROP TRIGGER transition_table_level2_bad_usage_trigger
    ON transition_table_level2;
- ERROR:  trigger "transition_table_level2_bad_usage_trigger" for table "transition_table_level2" does not exist
  -- attempt modifications which would break RI (should all fail)
  DELETE FROM transition_table_level1
    WHERE level1_no = 25;
  UPDATE transition_table_level1 SET level1_no = -1
    WHERE level1_no = 30;
  ERROR:  Distributed column or partition column "level1_no" can't be updated in current version
  INSERT INTO transition_table_level2 (level2_no, parent_no)
    VALUES (10000, 10000);
  UPDATE transition_table_level2 SET parent_no = 2000
    WHERE level2_no = 40;
  -- attempt modifications which would not break RI (should all succeed)
  DELETE FROM transition_table_level1
    WHERE level1_no BETWEEN 201 AND 1000;
--- 6058,6086 ----
    REFERENCING OLD TABLE AS d
    FOR EACH STATEMENT EXECUTE PROCEDURE
      transition_table_level2_bad_usage_func();
  DELETE FROM transition_table_level2
    WHERE level2_no BETWEEN 301 AND 305;
+ ERROR:  relation "d" cannot be the target of a modifying statement
+ CONTEXT:  SQL statement "INSERT INTO d VALUES (1000000, 1000000, 'x')"
+ PL/pgSQL function transition_table_level2_bad_usage_func() line 3 at SQL statement
  DROP TRIGGER transition_table_level2_bad_usage_trigger
    ON transition_table_level2;
  -- attempt modifications which would break RI (should all fail)
  DELETE FROM transition_table_level1
    WHERE level1_no = 25;
+ ERROR:  RI error
+ CONTEXT:  PL/pgSQL function transition_table_level1_ri_parent_del_func() line 6 at RAISE
  UPDATE transition_table_level1 SET level1_no = -1
    WHERE level1_no = 30;
  ERROR:  Distributed column or partition column "level1_no" can't be updated in current version
  INSERT INTO transition_table_level2 (level2_no, parent_no)
    VALUES (10000, 10000);
+ ERROR:  RI error
+ CONTEXT:  PL/pgSQL function transition_table_level2_ri_child_insupd_func() line 8 at RAISE
  UPDATE transition_table_level2 SET parent_no = 2000
    WHERE level2_no = 40;
+ ERROR:  RI error
+ CONTEXT:  PL/pgSQL function transition_table_level2_ri_child_insupd_func() line 8 at RAISE
  -- attempt modifications which would not break RI (should all succeed)
  DELETE FROM transition_table_level1
    WHERE level1_no BETWEEN 201 AND 1000;
***************
*** 6081,6087 ****
  SELECT count(*) FROM transition_table_level1;
   count 
  -------
!    199
  (1 row)
  
  DELETE FROM transition_table_level2
--- 6089,6095 ----
  SELECT count(*) FROM transition_table_level1;
   count 
  -------
!    200
  (1 row)
  
  DELETE FROM transition_table_level2
***************
*** 6089,6095 ****
  SELECT count(*) FROM transition_table_level2;
   count 
  -------
!   9985
  (1 row)
  
  CREATE TABLE alter_table_under_transition_tables
--- 6097,6103 ----
  SELECT count(*) FROM transition_table_level2;
   count 
  -------
!   9989
  (1 row)
  
  CREATE TABLE alter_table_under_transition_tables
***************
*** 6115,6144 ****
    REFERENCING OLD TABLE AS d NEW TABLE AS i
    FOR EACH STATEMENT EXECUTE PROCEDURE
      alter_table_under_transition_tables_upd_func();
! ERROR:  Postgres-XL does not support TRIGGER yet
! DETAIL:  The feature is not currently supported
  -- should work
  CREATE TRIGGER alter_table_under_transition_tables_upd_trigger
    AFTER UPDATE ON alter_table_under_transition_tables
    REFERENCING OLD TABLE AS d NEW TABLE AS i
    FOR EACH STATEMENT EXECUTE PROCEDURE
      alter_table_under_transition_tables_upd_func();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  INSERT INTO alter_table_under_transition_tables
    VALUES (1, '1'), (2, '2'), (3, '3');
  UPDATE alter_table_under_transition_tables
    SET name = name || name;
  -- now change 'name' to an integer to see what happens...
  ALTER TABLE alter_table_under_transition_tables
    ALTER COLUMN name TYPE int USING name::integer;
  UPDATE alter_table_under_transition_tables
    SET name = (name::text || name::text)::integer;
  -- now drop column 'name'
  ALTER TABLE alter_table_under_transition_tables
    DROP column name;
  UPDATE alter_table_under_transition_tables
    SET id = id;
  --
  -- Check type parsing and record fetching from partitioned tables
  --
--- 6123,6158 ----
    REFERENCING OLD TABLE AS d NEW TABLE AS i
    FOR EACH STATEMENT EXECUTE PROCEDURE
      alter_table_under_transition_tables_upd_func();
! ERROR:  TRUNCATE triggers with transition tables are not supported
  -- should work
  CREATE TRIGGER alter_table_under_transition_tables_upd_trigger
    AFTER UPDATE ON alter_table_under_transition_tables
    REFERENCING OLD TABLE AS d NEW TABLE AS i
    FOR EACH STATEMENT EXECUTE PROCEDURE
      alter_table_under_transition_tables_upd_func();
  INSERT INTO alter_table_under_transition_tables
    VALUES (1, '1'), (2, '2'), (3, '3');
  UPDATE alter_table_under_transition_tables
    SET name = name || name;
+ WARNING:  old table = 1=1,2=2,3=3, new table = 1=11,2=22,3=33
+ NOTICE:  one = 1
  -- now change 'name' to an integer to see what happens...
  ALTER TABLE alter_table_under_transition_tables
    ALTER COLUMN name TYPE int USING name::integer;
  UPDATE alter_table_under_transition_tables
    SET name = (name::text || name::text)::integer;
+ WARNING:  old table = 1=11,2=22,3=33, new table = 1=1111,2=2222,3=3333
+ NOTICE:  one = 1
  -- now drop column 'name'
  ALTER TABLE alter_table_under_transition_tables
    DROP column name;
  UPDATE alter_table_under_transition_tables
    SET id = id;
+ ERROR:  column "name" does not exist
+ LINE 1: SELECT (SELECT string_agg(id || '=' || name, ',') FROM d)
+                                                ^
+ QUERY:  SELECT (SELECT string_agg(id || '=' || name, ',') FROM d)
+ CONTEXT:  PL/pgSQL function alter_table_under_transition_tables_upd_func() line 3 at RAISE
  --
  -- Check type parsing and record fetching from partitioned tables
  --

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/copy2_1.out"	2025-07-31 16:07:14.981068200 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/copy2.out"	2025-07-31 16:39:56.388506883 +0800
***************
*** 19,29 ****
  ' LANGUAGE plpgsql;
  CREATE TRIGGER trg_x_after AFTER INSERT ON x
  FOR EACH ROW EXECUTE PROCEDURE fn_x_after();
! ERROR:  Postgres-XL does not support TRIGGER yet
  DETAIL:  The feature is not currently supported
  CREATE TRIGGER trg_x_before BEFORE INSERT ON x
  FOR EACH ROW EXECUTE PROCEDURE fn_x_before();
! ERROR:  Postgres-XL does not support TRIGGER yet
  DETAIL:  The feature is not currently supported
  COPY x (a, b, c, d, e) from stdin;
  COPY x (b, d) from stdin;
--- 19,29 ----
  ' LANGUAGE plpgsql;
  CREATE TRIGGER trg_x_after AFTER INSERT ON x
  FOR EACH ROW EXECUTE PROCEDURE fn_x_after();
! ERROR:  node:coord2, backend_pid:384447, nodename:coord2,backend_pid:384447,message:Postgres-XL does not support TRIGGER yet
  DETAIL:  The feature is not currently supported
  CREATE TRIGGER trg_x_before BEFORE INSERT ON x
  FOR EACH ROW EXECUTE PROCEDURE fn_x_before();
! ERROR:  node:coord2, backend_pid:384447, nodename:coord2,backend_pid:384447,message:Postgres-XL does not support TRIGGER yet
  DETAIL:  The feature is not currently supported
  COPY x (a, b, c, d, e) from stdin;
  COPY x (b, d) from stdin;
***************
*** 245,266 ****
  -- test handling of nonstandard null marker that violates escaping rules
  CREATE TEMP TABLE testnull(a int, b text);
  INSERT INTO testnull VALUES (1, E'\\0'), (NULL, NULL);
  COPY testnull TO stdout WITH NULL AS E'\\0';
- 1	\\0
- \0	\0
  COPY testnull FROM stdin WITH NULL AS E'\\0';
  SELECT * FROM testnull ORDER BY 1,2;
!  a  | b  
! ----+----
!   1 | \0
!  42 | \0
!     | 
!     | 
! (4 rows)
  
  BEGIN;
  CREATE TABLE vistest (LIKE testeoc);
! ERROR:  relation "testeoc" does not exist
  COPY vistest FROM stdin CSV;
  ERROR:  current transaction is aborted, commands ignored until end of transaction block
  a0
--- 245,264 ----
  -- test handling of nonstandard null marker that violates escaping rules
  CREATE TEMP TABLE testnull(a int, b text);
  INSERT INTO testnull VALUES (1, E'\\0'), (NULL, NULL);
+ ERROR:  node:datanode_1, backend_pid:383359, nodename:datanode_1,backend_pid:383359,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, null).
  COPY testnull TO stdout WITH NULL AS E'\\0';
  COPY testnull FROM stdin WITH NULL AS E'\\0';
+ ERROR:  node:datanode_1, backend_pid:383359, nodename:datanode_1,backend_pid:383359,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, null).
  SELECT * FROM testnull ORDER BY 1,2;
!  a | b 
! ---+---
! (0 rows)
  
  BEGIN;
  CREATE TABLE vistest (LIKE testeoc);
! ERROR:  node:coord2, backend_pid:384447, nodename:coord2,backend_pid:384447,message:relation "testeoc" does not exist
  COPY vistest FROM stdin CSV;
  ERROR:  current transaction is aborted, commands ignored until end of transaction block
  a0
***************
*** 462,468 ****
  -- should fail with not-null constraint violation
  BEGIN;
  COPY forcetest (a, b, c) FROM STDIN WITH (FORMAT csv, FORCE_NULL(b), FORCE_NOT_NULL(c));
! ERROR:  null value in column "b" violates not-null constraint
  DETAIL:  Failing row contains (3, null, , null, null).
  ROLLBACK;
  -- should fail with "not referenced by COPY" error
--- 460,466 ----
  -- should fail with not-null constraint violation
  BEGIN;
  COPY forcetest (a, b, c) FROM STDIN WITH (FORMAT csv, FORCE_NULL(b), FORCE_NOT_NULL(c));
! ERROR:  node:datanode_2, backend_pid:383284, nodename:datanode_2,backend_pid:383284,message:null value in column "b" violates not-null constraint
  DETAIL:  Failing row contains (3, null, , null, null).
  ROLLBACK;
  -- should fail with "not referenced by COPY" error
***************
*** 488,509 ****
                                 Table "public.check_con_tbl"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  f1     | integer |           |          |         | plain   |              | 
  Check constraints:
      "check_con_tbl_check" CHECK (check_con_function(check_con_tbl.*))
! Distribute By: HASH(f1)
  Location Nodes: ALL DATANODES
  
  copy check_con_tbl from stdin;
  copy check_con_tbl from stdin;
! ERROR:  new row for relation "check_con_tbl" violates check constraint "check_con_tbl_check"
  DETAIL:  Failing row contains (0).
  select * from check_con_tbl;
   f1 
  ----
!   1
!    
! (2 rows)
  
  -- test with RLS enabled.
  CREATE ROLE regress_rls_copy_user;
--- 486,507 ----
                                 Table "public.check_con_tbl"
   Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
  --------+---------+-----------+----------+---------+---------+--------------+-------------
!  f1     | integer |           | not null |         | plain   |              | 
  Check constraints:
      "check_con_tbl_check" CHECK (check_con_function(check_con_tbl.*))
! Distribute By: SHARD(f1)
  Location Nodes: ALL DATANODES
  
  copy check_con_tbl from stdin;
+ ERROR:  node:datanode_1, backend_pid:383359, nodename:datanode_1,backend_pid:383359,message:null value in column "f1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  copy check_con_tbl from stdin;
! ERROR:  node:datanode_2, backend_pid:383284, nodename:datanode_2,backend_pid:383284,message:new row for relation "check_con_tbl" violates check constraint "check_con_tbl_check"
  DETAIL:  Failing row contains (0).
  select * from check_con_tbl;
   f1 
  ----
! (0 rows)
  
  -- test with RLS enabled.
  CREATE ROLE regress_rls_copy_user;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/temp.out"	2025-07-31 16:07:15.004067834 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/temp.out"	2025-07-31 16:39:55.854518215 +0800
***************
*** 117,138 ****
  CREATE TEMP TABLE temptest1(col int PRIMARY KEY);
  CREATE TEMP TABLE temptest2(col int REFERENCES temptest1)
    ON COMMIT DELETE ROWS;
  INSERT INTO temptest1 VALUES (1);
  INSERT INTO temptest2 VALUES (1);
  COMMIT;
  SELECT * FROM temptest1;
!  col 
! -----
!    1
! (1 row)
! 
  --SELECT * FROM temptest2;
  BEGIN;
  CREATE TEMP TABLE temptest3(col int PRIMARY KEY) ON COMMIT DELETE ROWS;
  CREATE TEMP TABLE temptest4(col int REFERENCES temptest3);
  COMMIT;
- ERROR:  unsupported ON COMMIT and foreign key combination
- DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  -- Test manipulation of temp schema's placement in search path
  create table public.whereami (f1 text);
  insert into public.whereami values ('public');
--- 117,138 ----
  CREATE TEMP TABLE temptest1(col int PRIMARY KEY);
  CREATE TEMP TABLE temptest2(col int REFERENCES temptest1)
    ON COMMIT DELETE ROWS;
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  INSERT INTO temptest1 VALUES (1);
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  INSERT INTO temptest2 VALUES (1);
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  COMMIT;
  SELECT * FROM temptest1;
! ERROR:  relation "temptest1" does not exist
! LINE 1: SELECT * FROM temptest1;
!                       ^
  --SELECT * FROM temptest2;
  BEGIN;
  CREATE TEMP TABLE temptest3(col int PRIMARY KEY) ON COMMIT DELETE ROWS;
  CREATE TEMP TABLE temptest4(col int REFERENCES temptest3);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  COMMIT;
  -- Test manipulation of temp schema's placement in search path
  create table public.whereami (f1 text);
  insert into public.whereami values ('public');

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/domain.out"	2025-07-31 16:07:14.982068184 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/domain.out"	2025-07-31 16:39:59.694436750 +0800
***************
*** 44,50 ****
             );
  INSERT INTO basictest values ('88', 'haha', 'short', '123.12');      -- Good
  INSERT INTO basictest values ('88', 'haha', 'short text', '123.12'); -- Bad varchar
! ERROR:  value too long for type character varying(5)
  INSERT INTO basictest values ('88', 'haha', 'short', '123.1212');    -- Truncate numeric
  -- Test copy
  COPY basictest (testvarchar) FROM stdin; -- fail
--- 44,50 ----
             );
  INSERT INTO basictest values ('88', 'haha', 'short', '123.12');      -- Good
  INSERT INTO basictest values ('88', 'haha', 'short text', '123.12'); -- Bad varchar
! ERROR:  node:datanode_2, backend_pid:384632, nodename:datanode_1,backend_pid:384633,message:value too long for type character varying(5)
  INSERT INTO basictest values ('88', 'haha', 'short', '123.1212');    -- Truncate numeric
  -- Test copy
  COPY basictest (testvarchar) FROM stdin; -- fail
***************
*** 106,112 ****
  INSERT INTO domarrtest values ('{2,2}', '{{"a"},{"c"}}');
  INSERT INTO domarrtest values (NULL, '{{"a","b","c"},{"d","e","f"}}');
  INSERT INTO domarrtest values (NULL, '{{"toolong","b","c"},{"d","e","f"}}');
! ERROR:  value too long for type character varying(4)
  INSERT INTO domarrtest (testint4arr[1], testint4arr[3]) values (11,22);
  select * from domarrtest order by 1, 2;
    testint4arr  |    testchar4arr     
--- 106,112 ----
  INSERT INTO domarrtest values ('{2,2}', '{{"a"},{"c"}}');
  INSERT INTO domarrtest values (NULL, '{{"a","b","c"},{"d","e","f"}}');
  INSERT INTO domarrtest values (NULL, '{{"toolong","b","c"},{"d","e","f"}}');
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:383338,message:value too long for type character varying(4)
  INSERT INTO domarrtest (testint4arr[1], testint4arr[3]) values (11,22);
  select * from domarrtest order by 1, 2;
    testint4arr  |    testchar4arr     
***************
*** 206,212 ****
  insert into dcomptable values (array[row(3,4), row(5,6)]::comptype[]);
  insert into dcomptable values (array[row(7,8)::comptype, row(9,10)::comptype]);
  insert into dcomptable values (array[row(1,2)]::dcomptypea);  -- fail on uniqueness
! ERROR:  duplicate key value violates unique constraint "dcomptable_d1_key"
  DETAIL:  Key (d1)=((public.comptype){"(1,2)"}) already exists.
  insert into dcomptable (d1[1]) values(row(9,10));
  insert into dcomptable (d1[1].r) values(11);
--- 206,212 ----
  insert into dcomptable values (array[row(3,4), row(5,6)]::comptype[]);
  insert into dcomptable values (array[row(7,8)::comptype, row(9,10)::comptype]);
  insert into dcomptable values (array[row(1,2)]::dcomptypea);  -- fail on uniqueness
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384633,message:duplicate key value violates unique constraint "dcomptable_d1_key"
  DETAIL:  Key (d1)=((public.comptype){"(1,2)"}) already exists.
  insert into dcomptable (d1[1]) values(row(9,10));
  insert into dcomptable (d1[1].r) values(11);
***************
*** 254,271 ****
  
  alter domain dcomptypea add constraint c1 check (value[1].r <= value[1].i);
  alter domain dcomptypea add constraint c2 check (value[1].r > value[1].i);  -- fail
! ERROR:  column "d1" of table "dcomptable" contains values that violate the new constraint
  select array[row(2,1)]::dcomptypea;  -- fail
  ERROR:  value for domain dcomptypea violates check constraint "c1"
  insert into dcomptable values (array[row(1,2)]::comptype[]);
  insert into dcomptable values (array[row(2,1)]::comptype[]);  -- fail
! ERROR:  value for domain dcomptypea violates check constraint "c1"
  insert into dcomptable (d1[1].r) values(99);
  insert into dcomptable (d1[1].r, d1[1].i) values(99, 100);
  insert into dcomptable (d1[1].r, d1[1].i) values(100, 99);  -- fail
! ERROR:  value for domain dcomptypea violates check constraint "c1"
  update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;  -- fail
! ERROR:  value for domain dcomptypea violates check constraint "c1"
  update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
    where d1[1].i > 0;
  select * from dcomptable order by 1;
--- 254,271 ----
  
  alter domain dcomptypea add constraint c1 check (value[1].r <= value[1].i);
  alter domain dcomptypea add constraint c2 check (value[1].r > value[1].i);  -- fail
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:383338,message:column "d1" of table "dcomptable" contains values that violate the new constraint
  select array[row(2,1)]::dcomptypea;  -- fail
  ERROR:  value for domain dcomptypea violates check constraint "c1"
  insert into dcomptable values (array[row(1,2)]::comptype[]);
  insert into dcomptable values (array[row(2,1)]::comptype[]);  -- fail
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:384633,message:value for domain dcomptypea violates check constraint "c1"
  insert into dcomptable (d1[1].r) values(99);
  insert into dcomptable (d1[1].r, d1[1].i) values(99, 100);
  insert into dcomptable (d1[1].r, d1[1].i) values(100, 99);  -- fail
! ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_1,backend_pid:384666,message:value for domain dcomptypea violates check constraint "c1"
  update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;  -- fail
! ERROR:  node:datanode_2, backend_pid:384640, nodename:datanode_1,backend_pid:384617,message:value for domain dcomptypea violates check constraint "c1"
  update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
    where d1[1].i > 0;
  select * from dcomptable order by 1;
***************
*** 325,355 ****
             , col5 dcheck CHECK (col5 IN ('c', 'd'))
             );
  INSERT INTO nulltest DEFAULT VALUES;
! ERROR:  domain dnotnull does not allow null values
  INSERT INTO nulltest values ('a', 'b', 'c', 'd', 'c');  -- Good
  insert into nulltest values ('a', 'b', 'c', 'd', NULL);
! ERROR:  domain dcheck does not allow null values
  insert into nulltest values ('a', 'b', 'c', 'd', 'a');
! ERROR:  new row for relation "nulltest" violates check constraint "nulltest_col5_check"
  DETAIL:  Failing row contains (a, b, c, d, a).
  INSERT INTO nulltest values (NULL, 'b', 'c', 'd', 'd');
! ERROR:  domain dnotnull does not allow null values
  INSERT INTO nulltest values ('a', NULL, 'c', 'd', 'c');
! ERROR:  domain dnotnull does not allow null values
  INSERT INTO nulltest values ('a', 'b', NULL, 'd', 'c');
! ERROR:  null value in column "col3" violates not-null constraint
  DETAIL:  Failing row contains (a, b, null, d, c).
  INSERT INTO nulltest values ('a', 'b', 'c', NULL, 'd'); -- Good
  -- Test copy
  COPY nulltest FROM stdin; --fail
! ERROR:  null value in column "col3" violates not-null constraint
  DETAIL:  Failing row contains (a, b, null, d, d).
  COPY nulltest FROM stdin; --fail
  ERROR:  domain dcheck does not allow null values
  CONTEXT:  COPY nulltest, line 1, column col5: null input, nodetype:1(1:cn,0:dn)
  -- Last row is bad
  COPY nulltest FROM stdin;
! ERROR:  new row for relation "nulltest" violates check constraint "nulltest_col5_check"
  DETAIL:  Failing row contains (a, b, c, null, a).
  select * from nulltest order by 1, 2, 3, 4, 5;
   col1 | col2 | col3 | col4 | col5 
--- 325,355 ----
             , col5 dcheck CHECK (col5 IN ('c', 'd'))
             );
  INSERT INTO nulltest DEFAULT VALUES;
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:383338,message:domain dnotnull does not allow null values
  INSERT INTO nulltest values ('a', 'b', 'c', 'd', 'c');  -- Good
  insert into nulltest values ('a', 'b', 'c', 'd', NULL);
! ERROR:  node:datanode_2, backend_pid:384628, nodename:datanode_1,backend_pid:384633,message:domain dcheck does not allow null values
  insert into nulltest values ('a', 'b', 'c', 'd', 'a');
! ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_1,backend_pid:383266,message:new row for relation "nulltest" violates check constraint "nulltest_col5_check"
  DETAIL:  Failing row contains (a, b, c, d, a).
  INSERT INTO nulltest values (NULL, 'b', 'c', 'd', 'd');
! ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_1,backend_pid:383266,message:domain dnotnull does not allow null values
  INSERT INTO nulltest values ('a', NULL, 'c', 'd', 'c');
! ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_1,backend_pid:383266,message:domain dnotnull does not allow null values
  INSERT INTO nulltest values ('a', 'b', NULL, 'd', 'c');
! ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_1,backend_pid:383266,message:null value in column "col3" violates not-null constraint
  DETAIL:  Failing row contains (a, b, null, d, c).
  INSERT INTO nulltest values ('a', 'b', 'c', NULL, 'd'); -- Good
  -- Test copy
  COPY nulltest FROM stdin; --fail
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:383338,message:null value in column "col3" violates not-null constraint
  DETAIL:  Failing row contains (a, b, null, d, d).
  COPY nulltest FROM stdin; --fail
  ERROR:  domain dcheck does not allow null values
  CONTEXT:  COPY nulltest, line 1, column col5: null input, nodetype:1(1:cn,0:dn)
  -- Last row is bad
  COPY nulltest FROM stdin;
! ERROR:  node:datanode_1, backend_pid:383338, nodename:datanode_2,backend_pid:383358,message:new row for relation "nulltest" violates check constraint "nulltest_col5_check"
  DETAIL:  Failing row contains (a, b, c, null, a).
  select * from nulltest order by 1, 2, 3, 4, 5;
   col1 | col2 | col3 | col4 | col5 
***************
*** 370,376 ****
  SELECT cast(cast(NULL as dnull) as dnotnull); -- fail
  ERROR:  domain dnotnull does not allow null values
  SELECT cast(col4 as dnotnull) from nulltest; -- fail
! ERROR:  domain dnotnull does not allow null values
  -- cleanup
  drop table nulltest;
  drop domain dnotnull restrict;
--- 370,376 ----
  SELECT cast(cast(NULL as dnull) as dnotnull); -- fail
  ERROR:  domain dnotnull does not allow null values
  SELECT cast(col4 as dnotnull) from nulltest; -- fail
! ERROR:  node:datanode_1, backend_pid:384633, nodename:datanode_1,backend_pid:384633,message:domain dnotnull does not allow null values
  -- cleanup
  drop table nulltest;
  drop domain dnotnull restrict;
***************
*** 394,407 ****
              , col8 ddef5
              );
  insert into defaulttest(col4) values(0); -- fails, col5 defaults to null
! ERROR:  null value in column "col5" violates not-null constraint
  DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).
  alter table defaulttest alter column col5 drop default;
  insert into defaulttest default values; -- succeeds, inserts domain default
  -- We used to treat SET DEFAULT NULL as equivalent to DROP DEFAULT; wrong
  alter table defaulttest alter column col5 set default null;
  insert into defaulttest(col4) values(0); -- fails
! ERROR:  null value in column "col5" violates not-null constraint
  DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).
  alter table defaulttest alter column col5 drop default;
  insert into defaulttest default values;
--- 394,407 ----
              , col8 ddef5
              );
  insert into defaulttest(col4) values(0); -- fails, col5 defaults to null
! ERROR:  node:datanode_2, backend_pid:384628, nodename:datanode_1,backend_pid:383266,message:null value in column "col5" violates not-null constraint
  DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).
  alter table defaulttest alter column col5 drop default;
  insert into defaulttest default values; -- succeeds, inserts domain default
  -- We used to treat SET DEFAULT NULL as equivalent to DROP DEFAULT; wrong
  alter table defaulttest alter column col5 set default null;
  insert into defaulttest(col4) values(0); -- fails
! ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_1,backend_pid:383338,message:null value in column "col5" violates not-null constraint
  DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).
  alter table defaulttest alter column col5 drop default;
  insert into defaulttest default values;
***************
*** 426,439 ****
  );
  insert into domnotnull default values;
  alter domain dnotnulltest set not null; -- fails
! ERROR:  column "col1" of table "domnotnull" contains null values
  update domnotnull set col1 = 5;
  alter domain dnotnulltest set not null; -- fails
! ERROR:  column "col2" of table "domnotnull" contains null values
  update domnotnull set col2 = 6;
  alter domain dnotnulltest set not null;
  update domnotnull set col1 = null; -- fails
! ERROR:  domain dnotnulltest does not allow null values
  alter domain dnotnulltest drop not null;
  update domnotnull set col1 = null;
  drop domain dnotnulltest cascade;
--- 426,439 ----
  );
  insert into domnotnull default values;
  alter domain dnotnulltest set not null; -- fails
! ERROR:  node:datanode_1, backend_pid:384633, nodename:datanode_2,backend_pid:383358,message:column "col1" of table "domnotnull" contains null values
  update domnotnull set col1 = 5;
  alter domain dnotnulltest set not null; -- fails
! ERROR:  node:datanode_1, backend_pid:384633, nodename:datanode_2,backend_pid:383358,message:column "col2" of table "domnotnull" contains null values
  update domnotnull set col2 = 6;
  alter domain dnotnulltest set not null;
  update domnotnull set col1 = null; -- fails
! ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_1,backend_pid:383338,message:domain dnotnulltest does not allow null values
  alter domain dnotnulltest drop not null;
  update domnotnull set col1 = null;
  drop domain dnotnulltest cascade;
***************
*** 475,491 ****
  insert into domcontest values (1);
  insert into domcontest values (2);
  alter domain con add constraint t check (VALUE < 1); -- fails
! ERROR:  column "col1" of table "domcontest" contains values that violate the new constraint
  alter domain con add constraint t check (VALUE < 34);
  alter domain con add check (VALUE > 0);
  insert into domcontest values (-5); -- fails
! ERROR:  value for domain con violates check constraint "con_check"
  insert into domcontest values (42); -- fails
! ERROR:  value for domain con violates check constraint "t"
  insert into domcontest values (5);
  alter domain con drop constraint t;
  insert into domcontest values (-5); --fails
! ERROR:  value for domain con violates check constraint "con_check"
  insert into domcontest values (42);
  alter domain con drop constraint nonexistent;
  ERROR:  constraint "nonexistent" of domain "con" does not exist
--- 475,491 ----
  insert into domcontest values (1);
  insert into domcontest values (2);
  alter domain con add constraint t check (VALUE < 1); -- fails
! ERROR:  node:datanode_2, backend_pid:384628, nodename:datanode_1,backend_pid:383338,message:column "col1" of table "domcontest" contains values that violate the new constraint
  alter domain con add constraint t check (VALUE < 34);
  alter domain con add check (VALUE > 0);
  insert into domcontest values (-5); -- fails
! ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_1,backend_pid:384633,message:value for domain con violates check constraint "con_check"
  insert into domcontest values (42); -- fails
! ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_1,backend_pid:384633,message:value for domain con violates check constraint "t"
  insert into domcontest values (5);
  alter domain con drop constraint t;
  insert into domcontest values (-5); --fails
! ERROR:  node:datanode_2, backend_pid:384628, nodename:datanode_1,backend_pid:384633,message:value for domain con violates check constraint "con_check"
  insert into domcontest values (42);
  alter domain con drop constraint nonexistent;
  ERROR:  constraint "nonexistent" of domain "con" does not exist
***************
*** 496,505 ****
  CREATE TABLE thethings (stuff things);
  INSERT INTO thethings (stuff) VALUES (55);
  ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11);
! ERROR:  column "stuff" of table "thethings" contains values that violate the new constraint
  ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11) NOT VALID;
  ALTER DOMAIN things VALIDATE CONSTRAINT meow;
! ERROR:  column "stuff" of table "thethings" contains values that violate the new constraint
  UPDATE thethings SET stuff = 10;
  ALTER DOMAIN things VALIDATE CONSTRAINT meow;
  -- Confirm ALTER DOMAIN with RULES.
--- 496,505 ----
  CREATE TABLE thethings (stuff things);
  INSERT INTO thethings (stuff) VALUES (55);
  ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11);
! ERROR:  node:datanode_2, backend_pid:384291, nodename:datanode_1,backend_pid:383338,message:column "stuff" of table "thethings" contains values that violate the new constraint
  ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11) NOT VALID;
  ALTER DOMAIN things VALIDATE CONSTRAINT meow;
! ERROR:  node:datanode_1, backend_pid:383338, nodename:datanode_2,backend_pid:384291,message:column "stuff" of table "thethings" contains values that violate the new constraint
  UPDATE thethings SET stuff = 10;
  ALTER DOMAIN things VALIDATE CONSTRAINT meow;
  -- Confirm ALTER DOMAIN with RULES.
***************
*** 507,541 ****
  create domain dom as integer;
  create view domview as select cast(col1 as dom) from domtab;
  insert into domtab (col1) values (null);
  insert into domtab (col1) values (5);
  select * from domview order by 1;
   col1 
  ------
      5
!      
! (2 rows)
  
  alter domain dom set not null;
  select * from domview; -- fail
! ERROR:  domain dom does not allow null values
  alter domain dom drop not null;
  select * from domview order by 1;
   col1 
  ------
      5
!      
! (2 rows)
  
  alter domain dom add constraint domchkgt6 check(value > 6);
  select * from domview; --fail
! ERROR:  value for domain dom violates check constraint "domchkgt6"
  alter domain dom drop constraint domchkgt6 restrict;
  select * from domview order by 1;
   col1 
  ------
      5
!      
! (2 rows)
  
  -- cleanup
  drop domain ddef1 restrict;
--- 507,544 ----
  create domain dom as integer;
  create view domview as select cast(col1 as dom) from domtab;
  insert into domtab (col1) values (null);
+ ERROR:  node:datanode_1, backend_pid:383338, nodename:datanode_1,backend_pid:383338,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  insert into domtab (col1) values (5);
  select * from domview order by 1;
   col1 
  ------
      5
! (1 row)
  
  alter domain dom set not null;
  select * from domview; -- fail
!  col1 
! ------
!     5
! (1 row)
! 
  alter domain dom drop not null;
  select * from domview order by 1;
   col1 
  ------
      5
! (1 row)
  
  alter domain dom add constraint domchkgt6 check(value > 6);
  select * from domview; --fail
! ERROR:  node:datanode_1, backend_pid:384633, nodename:datanode_1,backend_pid:384633,message:value for domain dom violates check constraint "domchkgt6"
  alter domain dom drop constraint domchkgt6 restrict;
  select * from domview order by 1;
   col1 
  ------
      5
! (1 row)
  
  -- cleanup
  drop domain ddef1 restrict;
***************
*** 571,585 ****
  create temp table dtest(f1 dtop);
  insert into dtest values('x123');
  insert into dtest values('x1234'); -- fail, implicit coercion
! ERROR:  value too long for type character varying(4)
  insert into dtest values('y1234'); -- fail, implicit coercion
! ERROR:  value too long for type character varying(4)
  insert into dtest values('y123'); -- fail
! ERROR:  value for domain dtop violates check constraint "dinter_check"
  insert into dtest values('yz23'); -- fail
! ERROR:  value for domain dtop violates check constraint "dinter_check"
  insert into dtest values('xz23'); -- fail
! ERROR:  value for domain dtop violates check constraint "dtop_check"
  drop table dtest;
  drop domain vchar4 cascade;
  NOTICE:  drop cascades to 2 other objects
--- 574,588 ----
  create temp table dtest(f1 dtop);
  insert into dtest values('x123');
  insert into dtest values('x1234'); -- fail, implicit coercion
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:384633,message:value too long for type character varying(4)
  insert into dtest values('y1234'); -- fail, implicit coercion
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:384633,message:value too long for type character varying(4)
  insert into dtest values('y123'); -- fail
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:384633,message:value for domain dtop violates check constraint "dinter_check"
  insert into dtest values('yz23'); -- fail
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:384633,message:value for domain dtop violates check constraint "dinter_check"
  insert into dtest values('xz23'); -- fail
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:384633,message:value for domain dtop violates check constraint "dtop_check"
  drop table dtest;
  drop domain vchar4 cascade;
  NOTICE:  drop cascades to 2 other objects
***************
*** 594,604 ****
  insert into domain_test values (1, 2);
  -- should fail
  alter table domain_test add column c str_domain;
! ERROR:  domain str_domain does not allow null values
  create domain str_domain2 as text check (value <> 'foo') default 'foo';
  -- should fail
  alter table domain_test add column d str_domain2;
! ERROR:  value for domain str_domain2 violates check constraint "str_domain2_check"
  -- Check that domain constraints on prepared statement parameters of
  -- unknown type are enforced correctly.
  create domain pos_int as int4 check (value > 0) not null;
--- 597,607 ----
  insert into domain_test values (1, 2);
  -- should fail
  alter table domain_test add column c str_domain;
! ERROR:  node:datanode_1, backend_pid:384633, nodename:datanode_1,backend_pid:384633,message:domain str_domain does not allow null values
  create domain str_domain2 as text check (value <> 'foo') default 'foo';
  -- should fail
  alter table domain_test add column d str_domain2;
! ERROR:  node:datanode_1, backend_pid:384633, nodename:datanode_1,backend_pid:384633,message:value for domain str_domain2 violates check constraint "str_domain2_check"
  -- Check that domain constraints on prepared statement parameters of
  -- unknown type are enforced correctly.
  create domain pos_int as int4 check (value > 0) not null;
***************
*** 688,699 ****
  create domain posint2 as posint check (value % 2 = 0);
  create table ddtest2(f1 posint2);
  insert into ddtest2 values(11); -- fail
! ERROR:  value for domain posint2 violates check constraint "posint2_check"
  insert into ddtest2 values(-2); -- fail
! ERROR:  value for domain posint2 violates check constraint "c1"
  insert into ddtest2 values(2);
  alter domain posint add constraint c2 check(value >= 10); -- fail
! ERROR:  column "f1" of table "ddtest2" contains values that violate the new constraint
  alter domain posint add constraint c2 check(value > 0); -- OK
  drop table ddtest2;
  drop type ddtest1;
--- 691,702 ----
  create domain posint2 as posint check (value % 2 = 0);
  create table ddtest2(f1 posint2);
  insert into ddtest2 values(11); -- fail
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:384633,message:value for domain posint2 violates check constraint "posint2_check"
  insert into ddtest2 values(-2); -- fail
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:384633,message:value for domain posint2 violates check constraint "c1"
  insert into ddtest2 values(2);
  alter domain posint add constraint c2 check(value >= 10); -- fail
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:384633,message:column "f1" of table "ddtest2" contains values that violate the new constraint
  alter domain posint add constraint c2 check(value > 0); -- OK
  drop table ddtest2;
  drop type ddtest1;
***************
*** 771,780 ****
  create temp table op (f1 orderedpair);
  insert into op values (array[1,2]);
  insert into op values (array[2,1]);  -- fail
! ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
  update op set f1[2] = 3;
  update op set f1[2] = 0;  -- fail
! ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
  select * from op;
    f1   
  -------
--- 774,783 ----
  create temp table op (f1 orderedpair);
  insert into op values (array[1,2]);
  insert into op values (array[2,1]);  -- fail
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:384633,message:value for domain orderedpair violates check constraint "orderedpair_check"
  update op set f1[2] = 3;
  update op set f1[2] = 0;  -- fail
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_2,backend_pid:383358,message:value for domain orderedpair violates check constraint "orderedpair_check"
  select * from op;
    f1   
  -------
***************
*** 849,855 ****
  insert into dom_table values ('1');
  insert into dom_table values (1);
  insert into dom_table values (null);
! ERROR:  value for domain inotnull violates check constraint "inotnull_check"
  drop table dom_table;
  drop domain inotnull;
  drop function sql_is_distinct_from(anyelement, anyelement);
--- 852,858 ----
  insert into dom_table values ('1');
  insert into dom_table values (1);
  insert into dom_table values (null);
! ERROR:  node:datanode_2, backend_pid:383358, nodename:datanode_1,backend_pid:384633,message:value for domain inotnull violates check constraint "inotnull_check"
  drop table dom_table;
  drop domain inotnull;
  drop function sql_is_distinct_from(anyelement, anyelement);

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/prepare.out"	2025-07-31 16:07:14.997067946 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/prepare.out"	2025-07-31 16:39:59.976430769 +0800
***************
*** 347,420 ****
  -- gb18030 test
  --
  CREATE DATABASE gb18030_db template template0 encoding = gb18030 LC_COLLATE = 'zh_CN.gb18030' LC_CTYPE = 'zh_CN.gb18030';
  \c gb18030_db;
! -- set client_encoding
! SET client_encoding = utf8;
! CREATE TABLE tbl_test(id int primary key, name varchar(3));
! INSERT INTO tbl_test VALUES (3, '');
! BEGIN;
! INSERT INTO tbl_test VALUES (4, '');
! INSERT INTO tbl_test VALUES (5, '');
! COMMIT;
! BEGIN;
! INSERT INTO tbl_test VALUES (6, '');
! INSERT INTO tbl_test VALUES (7, '');
! ROLLBACK;
! SELECT * FROM tbl_test ORDER BY id;
!  id | name 
! ----+------
!   3 | 
!   4 | 
!   5 | 
! (3 rows)
! 
! SHOW client_encoding;
!  client_encoding 
! -----------------
!  UTF8
! (1 row)
! 
! PREPARE ps_test (int) AS select * from tbl_test where id < $1 order by id;
! EXECUTE ps_test(20);
!  id | name 
! ----+------
!   3 | 
!   4 | 
!   5 | 
! (3 rows)
! 
! SHOW client_encoding;
!  client_encoding 
! -----------------
!  UTF8
! (1 row)
! 
! EXECUTE ps_test(20);
!  id | name 
! ----+------
!   3 | 
!   4 | 
!   5 | 
! (3 rows)
! 
! SHOW client_encoding;
!  client_encoding 
! -----------------
!  UTF8
! (1 row)
! 
! EXECUTE ps_test(20);
!  id | name 
! ----+------
!   3 | 
!   4 | 
!   5 | 
! (3 rows)
! 
! SHOW client_encoding;
!  client_encoding 
! -----------------
!  UTF8
! (1 row)
! 
! DEALLOCATE PREPARE ps_test;
--- 347,352 ----
  -- gb18030 test
  --
  CREATE DATABASE gb18030_db template template0 encoding = gb18030 LC_COLLATE = 'zh_CN.gb18030' LC_CTYPE = 'zh_CN.gb18030';
+ ERROR:  invalid locale name: "zh_CN.gb18030"
  \c gb18030_db;
! \connect: FATAL:  database "gb18030_db" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/truncate.out"	2025-07-31 16:07:15.005067818 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/truncate.out"	2025-07-31 16:39:58.070471196 +0800
***************
*** 31,98 ****
  
  -- Test foreign-key checks
  CREATE TABLE trunc_b (a int REFERENCES truncate_a);
  CREATE TABLE trunc_c (a serial PRIMARY KEY) DISTRIBUTE BY REPLICATION;
  CREATE TABLE trunc_d (a int REFERENCES trunc_c);
  CREATE TABLE trunc_e (a int REFERENCES truncate_a, b int REFERENCES trunc_c);
  TRUNCATE TABLE truncate_a;		-- fail
- ERROR:  cannot truncate a table referenced in a foreign key constraint
- DETAIL:  Table "trunc_b" references "truncate_a".
- HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE truncate_a,trunc_b;		-- fail
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_e" references "truncate_a".
! HINT:  Truncate table "trunc_e" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE truncate_a,trunc_b,trunc_e;	-- ok
  TRUNCATE TABLE truncate_a,trunc_e;		-- fail
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_b" references "truncate_a".
! HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE trunc_c;		-- fail
- ERROR:  cannot truncate a table referenced in a foreign key constraint
- DETAIL:  Table "trunc_d" references "trunc_c".
- HINT:  Truncate table "trunc_d" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE trunc_c,trunc_d;		-- fail
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_e" references "trunc_c".
! HINT:  Truncate table "trunc_e" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE trunc_c,trunc_d,trunc_e;	-- ok
  TRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a;	-- fail
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_b" references "truncate_a".
! HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a,trunc_b;	-- ok
  TRUNCATE TABLE truncate_a RESTRICT; -- fail
- ERROR:  cannot truncate a table referenced in a foreign key constraint
- DETAIL:  Table "trunc_b" references "truncate_a".
- HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE truncate_a CASCADE;  -- ok
- NOTICE:  truncate cascades to table "trunc_b"
- NOTICE:  truncate cascades to table "trunc_e"
  -- circular references
  ALTER TABLE truncate_a ADD FOREIGN KEY (col1) REFERENCES trunc_c;
  -- Add some data to verify that truncating actually works ...
  INSERT INTO trunc_c VALUES (1);
  INSERT INTO truncate_a VALUES (1);
  INSERT INTO trunc_b VALUES (1);
  INSERT INTO trunc_d VALUES (1);
  INSERT INTO trunc_e VALUES (1,1);
  TRUNCATE TABLE trunc_c;
  ERROR:  cannot truncate a table referenced in a foreign key constraint
  DETAIL:  Table "truncate_a" references "trunc_c".
  HINT:  Truncate table "truncate_a" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE trunc_c,truncate_a;
- ERROR:  cannot truncate a table referenced in a foreign key constraint
- DETAIL:  Table "trunc_d" references "trunc_c".
- HINT:  Truncate table "trunc_d" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE trunc_c,truncate_a,trunc_d;
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_e" references "trunc_c".
! HINT:  Truncate table "trunc_e" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e;
! ERROR:  cannot truncate a table referenced in a foreign key constraint
! DETAIL:  Table "trunc_b" references "truncate_a".
! HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e,trunc_b;
  -- Verify that truncating did actually work
  SELECT * FROM truncate_a
     UNION ALL
--- 31,88 ----
  
  -- Test foreign-key checks
  CREATE TABLE trunc_b (a int REFERENCES truncate_a);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  CREATE TABLE trunc_c (a serial PRIMARY KEY) DISTRIBUTE BY REPLICATION;
  CREATE TABLE trunc_d (a int REFERENCES trunc_c);
+ ERROR:  corrupted catalog, no shard group of 0 found
  CREATE TABLE trunc_e (a int REFERENCES truncate_a, b int REFERENCES trunc_c);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  TRUNCATE TABLE truncate_a;		-- fail
  TRUNCATE TABLE truncate_a,trunc_b;		-- fail
! ERROR:  relation "trunc_b" does not exist
  TRUNCATE TABLE truncate_a,trunc_b,trunc_e;	-- ok
+ ERROR:  relation "trunc_b" does not exist
  TRUNCATE TABLE truncate_a,trunc_e;		-- fail
! ERROR:  relation "trunc_e" does not exist
  TRUNCATE TABLE trunc_c;		-- fail
  TRUNCATE TABLE trunc_c,trunc_d;		-- fail
! ERROR:  relation "trunc_d" does not exist
  TRUNCATE TABLE trunc_c,trunc_d,trunc_e;	-- ok
+ ERROR:  relation "trunc_d" does not exist
  TRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a;	-- fail
! ERROR:  relation "trunc_d" does not exist
  TRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a,trunc_b;	-- ok
+ ERROR:  relation "trunc_d" does not exist
  TRUNCATE TABLE truncate_a RESTRICT; -- fail
  TRUNCATE TABLE truncate_a CASCADE;  -- ok
  -- circular references
  ALTER TABLE truncate_a ADD FOREIGN KEY (col1) REFERENCES trunc_c;
  -- Add some data to verify that truncating actually works ...
  INSERT INTO trunc_c VALUES (1);
  INSERT INTO truncate_a VALUES (1);
  INSERT INTO trunc_b VALUES (1);
+ ERROR:  relation "trunc_b" does not exist
+ LINE 1: INSERT INTO trunc_b VALUES (1);
+                     ^
  INSERT INTO trunc_d VALUES (1);
+ ERROR:  relation "trunc_d" does not exist
+ LINE 1: INSERT INTO trunc_d VALUES (1);
+                     ^
  INSERT INTO trunc_e VALUES (1,1);
+ ERROR:  relation "trunc_e" does not exist
+ LINE 1: INSERT INTO trunc_e VALUES (1,1);
+                     ^
  TRUNCATE TABLE trunc_c;
  ERROR:  cannot truncate a table referenced in a foreign key constraint
  DETAIL:  Table "truncate_a" references "trunc_c".
  HINT:  Truncate table "truncate_a" at the same time, or use TRUNCATE ... CASCADE.
  TRUNCATE TABLE trunc_c,truncate_a;
  TRUNCATE TABLE trunc_c,truncate_a,trunc_d;
! ERROR:  relation "trunc_d" does not exist
  TRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e;
! ERROR:  relation "trunc_d" does not exist
  TRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e,trunc_b;
+ ERROR:  relation "trunc_d" does not exist
  -- Verify that truncating did actually work
  SELECT * FROM truncate_a
     UNION ALL
***************
*** 101,126 ****
   SELECT * FROM trunc_b
     UNION ALL
   SELECT * FROM trunc_d;
!  col1 
! ------
! (0 rows)
! 
  SELECT * FROM trunc_e;
!  a | b 
! ---+---
! (0 rows)
! 
  -- Add data again to test TRUNCATE ... CASCADE
  INSERT INTO trunc_c VALUES (1);
  INSERT INTO truncate_a VALUES (1);
  INSERT INTO trunc_b VALUES (1);
  INSERT INTO trunc_d VALUES (1);
  INSERT INTO trunc_e VALUES (1,1);
  TRUNCATE TABLE trunc_c CASCADE;  -- ok
  NOTICE:  truncate cascades to table "truncate_a"
- NOTICE:  truncate cascades to table "trunc_d"
- NOTICE:  truncate cascades to table "trunc_e"
- NOTICE:  truncate cascades to table "trunc_b"
  SELECT * FROM truncate_a
     UNION ALL
   SELECT * FROM trunc_c
--- 91,120 ----
   SELECT * FROM trunc_b
     UNION ALL
   SELECT * FROM trunc_d;
! ERROR:  relation "trunc_b" does not exist
! LINE 5:  SELECT * FROM trunc_b
!                        ^
  SELECT * FROM trunc_e;
! ERROR:  relation "trunc_e" does not exist
! LINE 1: SELECT * FROM trunc_e;
!                       ^
  -- Add data again to test TRUNCATE ... CASCADE
  INSERT INTO trunc_c VALUES (1);
  INSERT INTO truncate_a VALUES (1);
  INSERT INTO trunc_b VALUES (1);
+ ERROR:  relation "trunc_b" does not exist
+ LINE 1: INSERT INTO trunc_b VALUES (1);
+                     ^
  INSERT INTO trunc_d VALUES (1);
+ ERROR:  relation "trunc_d" does not exist
+ LINE 1: INSERT INTO trunc_d VALUES (1);
+                     ^
  INSERT INTO trunc_e VALUES (1,1);
+ ERROR:  relation "trunc_e" does not exist
+ LINE 1: INSERT INTO trunc_e VALUES (1,1);
+                     ^
  TRUNCATE TABLE trunc_c CASCADE;  -- ok
  NOTICE:  truncate cascades to table "truncate_a"
  SELECT * FROM truncate_a
     UNION ALL
   SELECT * FROM trunc_c
***************
*** 128,143 ****
   SELECT * FROM trunc_b
     UNION ALL
   SELECT * FROM trunc_d;
!  col1 
! ------
! (0 rows)
! 
  SELECT * FROM trunc_e;
!  a | b 
! ---+---
! (0 rows)
! 
  DROP TABLE truncate_a,trunc_c,trunc_b,trunc_d,trunc_e CASCADE;
  -- Test TRUNCATE with inheritance
  CREATE TABLE trunc_f (col1 integer primary key);
  INSERT INTO trunc_f VALUES (1);
--- 122,136 ----
   SELECT * FROM trunc_b
     UNION ALL
   SELECT * FROM trunc_d;
! ERROR:  relation "trunc_b" does not exist
! LINE 5:  SELECT * FROM trunc_b
!                        ^
  SELECT * FROM trunc_e;
! ERROR:  relation "trunc_e" does not exist
! LINE 1: SELECT * FROM trunc_e;
!                       ^
  DROP TABLE truncate_a,trunc_c,trunc_b,trunc_d,trunc_e CASCADE;
+ ERROR:  table "trunc_b" does not exist
  -- Test TRUNCATE with inheritance
  CREATE TABLE trunc_f (col1 integer primary key);
  INSERT INTO trunc_f VALUES (1);
***************
*** 300,307 ****
  BEFORE TRUNCATE ON trunc_trigger_test
  FOR EACH STATEMENT
  EXECUTE PROCEDURE trunctrigger('before trigger truncate');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  SELECT count(*) as "Row count in test table" FROM trunc_trigger_test;
   Row count in test table 
  -------------------------
--- 293,298 ----
***************
*** 321,332 ****
  (1 row)
  
  SELECT * FROM trunc_trigger_log;
!  tgop | tglevel | tgwhen | tgargv | tgtable | rowcount 
! ------+---------+--------+--------+---------+----------
! (0 rows)
  
  DROP TRIGGER t ON trunc_trigger_test;
- ERROR:  trigger "t" for table "trunc_trigger_test" does not exist
  truncate trunc_trigger_log;
  -- same test with an after trigger
  INSERT INTO trunc_trigger_test VALUES(1, 'foo', 'bar'), (2, 'baz', 'quux');
--- 312,324 ----
  (1 row)
  
  SELECT * FROM trunc_trigger_log;
!    tgop   |  tglevel  | tgwhen |         tgargv          |      tgtable       | rowcount 
! ----------+-----------+--------+-------------------------+--------------------+----------
!  TRUNCATE | STATEMENT | BEFORE | before trigger truncate | trunc_trigger_test |        2
!  TRUNCATE | STATEMENT | BEFORE | before trigger truncate | trunc_trigger_test |        2
! (2 rows)
  
  DROP TRIGGER t ON trunc_trigger_test;
  truncate trunc_trigger_log;
  -- same test with an after trigger
  INSERT INTO trunc_trigger_test VALUES(1, 'foo', 'bar'), (2, 'baz', 'quux');
***************
*** 334,341 ****
  AFTER TRUNCATE ON trunc_trigger_test
  FOR EACH STATEMENT
  EXECUTE PROCEDURE trunctrigger('after trigger truncate');
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  SELECT count(*) as "Row count in test table" FROM trunc_trigger_test;
   Row count in test table 
  -------------------------
--- 326,331 ----
***************
*** 355,363 ****
  (1 row)
  
  SELECT * FROM trunc_trigger_log;
!  tgop | tglevel | tgwhen | tgargv | tgtable | rowcount 
! ------+---------+--------+--------+---------+----------
! (0 rows)
  
  DROP TABLE trunc_trigger_test;
  DROP TABLE trunc_trigger_log;
--- 345,355 ----
  (1 row)
  
  SELECT * FROM trunc_trigger_log;
!    tgop   |  tglevel  | tgwhen |         tgargv         |      tgtable       | rowcount 
! ----------+-----------+--------+------------------------+--------------------+----------
!  TRUNCATE | STATEMENT | AFTER  | after trigger truncate | trunc_trigger_test |        2
!  TRUNCATE | STATEMENT | AFTER  | after trigger truncate | trunc_trigger_test |        2
! (2 rows)
  
  DROP TABLE trunc_trigger_test;
  DROP TABLE trunc_trigger_log;
***************
*** 366,405 ****
  CREATE SEQUENCE truncate_a_id1 START WITH 33;
  CREATE TABLE truncate_a (id serial,
                           id1 integer default nextval('truncate_a_id1'));
  ALTER SEQUENCE truncate_a_id1 OWNED BY truncate_a.id1;
  INSERT INTO truncate_a DEFAULT VALUES;
  INSERT INTO truncate_a DEFAULT VALUES;
  SELECT * FROM truncate_a;
!  id | id1 
! ----+-----
!   1 |  33
!   2 |  34
! (2 rows)
  
  TRUNCATE truncate_a;
  INSERT INTO truncate_a DEFAULT VALUES;
  INSERT INTO truncate_a DEFAULT VALUES;
  SELECT * FROM truncate_a;
!  id | id1 
! ----+-----
!   3 |  35
!   4 |  36
! (2 rows)
  
  TRUNCATE truncate_a RESTART IDENTITY;
  ERROR:  PGXC does not support RESTART IDENTITY yet
  DETAIL:  The feature is not supported currently
  INSERT INTO truncate_a DEFAULT VALUES;
  INSERT INTO truncate_a DEFAULT VALUES;
  SELECT * FROM truncate_a ORDER BY 1, 2;
!  id | id1 
! ----+-----
!   3 |  35
!   4 |  36
!   5 |  37
!   6 |  38
! (4 rows)
! 
  CREATE TABLE truncate_b (id int GENERATED ALWAYS AS IDENTITY (START WITH 44));
  INSERT INTO truncate_b DEFAULT VALUES;
  INSERT INTO truncate_b DEFAULT VALUES;
--- 358,402 ----
  CREATE SEQUENCE truncate_a_id1 START WITH 33;
  CREATE TABLE truncate_a (id serial,
                           id1 integer default nextval('truncate_a_id1'));
+ ERROR:  relation "truncate_a" already exists
  ALTER SEQUENCE truncate_a_id1 OWNED BY truncate_a.id1;
+ ERROR:  column "id1" of relation "truncate_a" does not exist
  INSERT INTO truncate_a DEFAULT VALUES;
+ ERROR:  node:datanode_1, backend_pid:383338, nodename:datanode_1,backend_pid:383338,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  INSERT INTO truncate_a DEFAULT VALUES;
+ ERROR:  node:datanode_1, backend_pid:383338, nodename:datanode_1,backend_pid:383338,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  SELECT * FROM truncate_a;
!  col1 
! ------
! (0 rows)
  
  TRUNCATE truncate_a;
  INSERT INTO truncate_a DEFAULT VALUES;
+ ERROR:  node:datanode_1, backend_pid:383266, nodename:datanode_1,backend_pid:383266,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  INSERT INTO truncate_a DEFAULT VALUES;
+ ERROR:  node:datanode_1, backend_pid:383266, nodename:datanode_1,backend_pid:383266,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  SELECT * FROM truncate_a;
!  col1 
! ------
! (0 rows)
  
  TRUNCATE truncate_a RESTART IDENTITY;
  ERROR:  PGXC does not support RESTART IDENTITY yet
  DETAIL:  The feature is not supported currently
  INSERT INTO truncate_a DEFAULT VALUES;
+ ERROR:  node:datanode_1, backend_pid:383266, nodename:datanode_1,backend_pid:383266,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  INSERT INTO truncate_a DEFAULT VALUES;
+ ERROR:  node:datanode_1, backend_pid:383266, nodename:datanode_1,backend_pid:383266,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  SELECT * FROM truncate_a ORDER BY 1, 2;
! ERROR:  ORDER BY position 2 is not in select list
! LINE 1: SELECT * FROM truncate_a ORDER BY 1, 2;
!                                              ^
  CREATE TABLE truncate_b (id int GENERATED ALWAYS AS IDENTITY (START WITH 44));
  INSERT INTO truncate_b DEFAULT VALUES;
  INSERT INTO truncate_b DEFAULT VALUES;
***************
*** 438,472 ****
  BEGIN;
  -- TRUNCATE truncate_a RESTART IDENTITY;
  INSERT INTO truncate_a DEFAULT VALUES;
  SELECT * FROM truncate_a ORDER BY 1, 2;
!  id | id1 
! ----+-----
!   3 |  35
!   4 |  36
!   5 |  37
!   6 |  38
!   7 |  39
! (5 rows)
! 
  ROLLBACK;
  INSERT INTO truncate_a DEFAULT VALUES;
  INSERT INTO truncate_a DEFAULT VALUES;
  SELECT * FROM truncate_a ORDER BY 1, 2;
!  id | id1 
! ----+-----
!   3 |  35
!   4 |  36
!   5 |  37
!   6 |  38
!   8 |  40
!   9 |  41
! (6 rows)
! 
  DROP TABLE truncate_a;
  SELECT nextval('truncate_a_id1'); -- fail, seq should have been dropped
! ERROR:  relation "truncate_a_id1" does not exist
! LINE 1: SELECT nextval('truncate_a_id1');
!                        ^
  -- partitioned table
  CREATE TABLE truncparted (a int, b char) PARTITION BY LIST (a);
  -- error, can't truncate a partitioned table
--- 435,462 ----
  BEGIN;
  -- TRUNCATE truncate_a RESTART IDENTITY;
  INSERT INTO truncate_a DEFAULT VALUES;
+ ERROR:  node:datanode_1, backend_pid:384633, nodename:datanode_1,backend_pid:384633,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  SELECT * FROM truncate_a ORDER BY 1, 2;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  INSERT INTO truncate_a DEFAULT VALUES;
+ ERROR:  node:datanode_1, backend_pid:384633, nodename:datanode_1,backend_pid:384633,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  INSERT INTO truncate_a DEFAULT VALUES;
+ ERROR:  node:datanode_1, backend_pid:383338, nodename:datanode_1,backend_pid:383338,message:null value in column "col1" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  SELECT * FROM truncate_a ORDER BY 1, 2;
! ERROR:  ORDER BY position 2 is not in select list
! LINE 1: SELECT * FROM truncate_a ORDER BY 1, 2;
!                                              ^
  DROP TABLE truncate_a;
  SELECT nextval('truncate_a_id1'); -- fail, seq should have been dropped
!  nextval 
! ---------
!       33
! (1 row)
! 
  -- partitioned table
  CREATE TABLE truncparted (a int, b char) PARTITION BY LIST (a);
  -- error, can't truncate a partitioned table

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/alter_table.out"	2025-07-31 16:07:14.978068248 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/alter_table.out"	2025-07-31 16:40:06.895284130 +0800
***************
*** 44,54 ****
  	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
  	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
  	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
  SELECT * FROM tmp;
!  initial | a |  b   |  c   |  d  |  e  | f |           g           |              h               | i |                                               j                                                |   k    |   l   |  m  |        n        |       p       |     q     |           r           |              s              |          t          |                      u                      |            v             |        w         |     x     |     y     |     z     
! ---------+---+------+------+-----+-----+---+-----------------------+------------------------------+---+------------------------------------------------------------------------------------------------+--------+-------+-----+-----------------+---------------+-----------+-----------------------+-----------------------------+---------------------+---------------------------------------------+--------------------------+------------------+-----------+-----------+-----------
!          | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | Mon May 01 00:30:30 1995 PDT | c | {"Mon May 01 00:30:30 1995 PDT","Mon Aug 24 14:43:07 1992 PDT","Wed Dec 31 16:00:00 1969 PST"} | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | magnetic disk | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | ["Wed Dec 31 16:00:00 1969 PST" "infinity"] | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
! (1 row)
  
  DROP TABLE tmp;
  -- the wolf bug - schema mods caused inconsistent row descriptors
--- 44,55 ----
  	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
  	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
  	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
+ ERROR:  node:datanode_1, backend_pid:384617, nodename:datanode_1,backend_pid:384617,message:null value in column "initial" violates not-null constraint
+ DETAIL:  Failing row contains (null, 4, name, text, 4.1, 4.1, 2, ((4.1,4.1),(3.1,3.1)), Mon May 01 00:30:30 1995 PDT, c, {"Mon May 01 00:30:30 1995 PDT","Mon Aug 24 14:43:07 1992 PDT","..., 314159, (1,1), 512, 1 2 3 4 5 6 7 8, magnetic disk, (1.1,1.1), [(4.1,4.1),(3.1,3.1)], ((0,2),(4.1,4.1),(3.1,3.1)), (4.1,4.1),(3.1,3.1), ["Wed Dec 31 16:00:00 1969 PST" "infinity"], Thu Jan 01 00:00:00 1970, @ 1 hour 10 secs, {1,2,3,4}, {1,2,3,4}, {1,2,3,4}).
  SELECT * FROM tmp;
!  initial | a | b | c | d | e | f | g | h | i | j | k | l | m | n | p | q | r | s | t | u | v | w | x | y | z 
! ---------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
! (0 rows)
  
  DROP TABLE tmp;
  -- the wolf bug - schema mods caused inconsistent row descriptors
***************
*** 89,99 ****
  	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
  	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
  	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
  SELECT * FROM tmp;
!  initial | a |  b   |  c   |  d  |  e  | f |           g           |              h               | i |                                               j                                                |   k    |   l   |  m  |        n        |       p       |     q     |           r           |              s              |          t          |                      u                      |            v             |        w         |     x     |     y     |     z     
! ---------+---+------+------+-----+-----+---+-----------------------+------------------------------+---+------------------------------------------------------------------------------------------------+--------+-------+-----+-----------------+---------------+-----------+-----------------------+-----------------------------+---------------------+---------------------------------------------+--------------------------+------------------+-----------+-----------+-----------
!          | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | Mon May 01 00:30:30 1995 PDT | c | {"Mon May 01 00:30:30 1995 PDT","Mon Aug 24 14:43:07 1992 PDT","Wed Dec 31 16:00:00 1969 PST"} | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | magnetic disk | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | ["Wed Dec 31 16:00:00 1969 PST" "infinity"] | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
! (1 row)
  
  DROP TABLE tmp;
  --
--- 90,101 ----
  	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
  	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
  	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
+ ERROR:  node:datanode_1, backend_pid:384633, nodename:datanode_1,backend_pid:384633,message:null value in column "initial" violates not-null constraint
+ DETAIL:  Failing row contains (null, 4, name, text, 4.1, 4.1, 2, ((4.1,4.1),(3.1,3.1)), Mon May 01 00:30:30 1995 PDT, c, {"Mon May 01 00:30:30 1995 PDT","Mon Aug 24 14:43:07 1992 PDT","..., 314159, (1,1), 512, 1 2 3 4 5 6 7 8, magnetic disk, (1.1,1.1), [(4.1,4.1),(3.1,3.1)], ((0,2),(4.1,4.1),(3.1,3.1)), (4.1,4.1),(3.1,3.1), ["Wed Dec 31 16:00:00 1969 PST" "infinity"], Thu Jan 01 00:00:00 1970, @ 1 hour 10 secs, {1,2,3,4}, {1,2,3,4}, {1,2,3,4}).
  SELECT * FROM tmp;
!  initial | a | b | c | d | e | f | g | h | i | j | k | l | m | n | p | q | r | s | t | u | v | w | x | y | z 
! ---------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
! (0 rows)
  
  DROP TABLE tmp;
  --
***************
*** 233,239 ****
         Table "public.constraint_rename_test"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
   c      | integer |           |          | 
  Check constraints:
--- 235,241 ----
         Table "public.constraint_rename_test"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
   c      | integer |           |          | 
  Check constraints:
***************
*** 246,252 ****
        Table "public.constraint_rename_test2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
   c      | integer |           |          | 
   d      | integer |           |          | 
--- 248,254 ----
        Table "public.constraint_rename_test2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
   c      | integer |           |          | 
   d      | integer |           |          | 
***************
*** 255,269 ****
  Inherits: constraint_rename_test
  
  ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo; -- fail
! ERROR:  cannot rename inherited constraint "con1"
  ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- fail
! ERROR:  inherited constraint "con1" must be renamed in child tables too
  ALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- ok
  \d constraint_rename_test
         Table "public.constraint_rename_test"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
   c      | integer |           |          | 
  Check constraints:
--- 257,271 ----
  Inherits: constraint_rename_test
  
  ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo; -- fail
! ERROR:  node:datanode_2, backend_pid:384671, nodename:coord2,backend_pid:384618,message:cannot rename inherited constraint "con1"
  ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- fail
! ERROR:  node:datanode_1, backend_pid:384666, nodename:coord2,backend_pid:384618,message:inherited constraint "con1" must be renamed in child tables too
  ALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- ok
  \d constraint_rename_test
         Table "public.constraint_rename_test"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
   c      | integer |           |          | 
  Check constraints:
***************
*** 274,280 ****
        Table "public.constraint_rename_test2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
   c      | integer |           |          | 
   d      | integer |           |          | 
--- 276,282 ----
        Table "public.constraint_rename_test2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
   c      | integer |           |          | 
   d      | integer |           |          | 
***************
*** 289,295 ****
         Table "public.constraint_rename_test"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
   c      | integer |           |          | 
  Check constraints:
--- 291,297 ----
         Table "public.constraint_rename_test"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
   c      | integer |           |          | 
  Check constraints:
***************
*** 301,307 ****
        Table "public.constraint_rename_test2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
   c      | integer |           |          | 
   d      | integer |           |          | 
--- 303,309 ----
        Table "public.constraint_rename_test2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
   c      | integer |           |          | 
   d      | integer |           |          | 
***************
*** 359,394 ****
  INSERT INTO tmp3 values (5,50);
  -- Try (and fail) to add constraint due to invalid source columns
  ALTER TABLE tmp3 add constraint tmpconstr foreign key(c) references tmp2 match full;
! ERROR:  column "c" referenced in foreign key constraint does not exist
  -- Try (and fail) to add constraint due to invalid destination columns explicitly given
  ALTER TABLE tmp3 add constraint tmpconstr foreign key(a) references tmp2(b) match full;
! ERROR:  column "b" referenced in foreign key constraint does not exist
  -- Try (and fail) to add constraint due to invalid data
  ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full;
! ERROR:  insert or update on table "tmp3" violates foreign key constraint "tmpconstr"
! DETAIL:  Key (a)=(5) is not present in table "tmp2".
  -- Delete failing row
  DELETE FROM tmp3 where a=5;
  -- Try (and succeed)
  ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full;
  ALTER TABLE tmp3 drop constraint tmpconstr;
  INSERT INTO tmp3 values (5,50);
  -- Try NOT VALID and then VALIDATE CONSTRAINT, but fails. Delete failure then re-validate
  ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full NOT VALID;
  ALTER TABLE tmp3 validate constraint tmpconstr;
! ERROR:  insert or update on table "tmp3" violates foreign key constraint "tmpconstr"
! DETAIL:  Key (a)=(5) is not present in table "tmp2".
  -- Delete failing row
  DELETE FROM tmp3 where a=5;
  -- Try (and succeed) and repeat to show it works on already valid constraint
  ALTER TABLE tmp3 validate constraint tmpconstr;
  ALTER TABLE tmp3 validate constraint tmpconstr;
  -- Try a non-verified CHECK constraint
  ALTER TABLE tmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10); -- fail
! ERROR:  check constraint "b_greater_than_ten" is violated by some row
  ALTER TABLE tmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10) NOT VALID; -- succeeds
  ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- fails
! ERROR:  check constraint "b_greater_than_ten" is violated by some row
  DELETE FROM tmp3 WHERE NOT b > 10;
  ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
  ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
--- 361,399 ----
  INSERT INTO tmp3 values (5,50);
  -- Try (and fail) to add constraint due to invalid source columns
  ALTER TABLE tmp3 add constraint tmpconstr foreign key(c) references tmp2 match full;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Try (and fail) to add constraint due to invalid destination columns explicitly given
  ALTER TABLE tmp3 add constraint tmpconstr foreign key(a) references tmp2(b) match full;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Try (and fail) to add constraint due to invalid data
  ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Delete failing row
  DELETE FROM tmp3 where a=5;
  -- Try (and succeed)
  ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  ALTER TABLE tmp3 drop constraint tmpconstr;
+ ERROR:  constraint "tmpconstr" of relation "tmp3" does not exist
  INSERT INTO tmp3 values (5,50);
  -- Try NOT VALID and then VALIDATE CONSTRAINT, but fails. Delete failure then re-validate
  ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full NOT VALID;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  ALTER TABLE tmp3 validate constraint tmpconstr;
! ERROR:  constraint "tmpconstr" of relation "tmp3" does not exist
  -- Delete failing row
  DELETE FROM tmp3 where a=5;
  -- Try (and succeed) and repeat to show it works on already valid constraint
  ALTER TABLE tmp3 validate constraint tmpconstr;
+ ERROR:  constraint "tmpconstr" of relation "tmp3" does not exist
  ALTER TABLE tmp3 validate constraint tmpconstr;
+ ERROR:  constraint "tmpconstr" of relation "tmp3" does not exist
  -- Try a non-verified CHECK constraint
  ALTER TABLE tmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10); -- fail
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_2,backend_pid:384671,message:check constraint "b_greater_than_ten" is violated by some row
  ALTER TABLE tmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10) NOT VALID; -- succeeds
  ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- fails
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:check constraint "b_greater_than_ten" is violated by some row
  DELETE FROM tmp3 WHERE NOT b > 10;
  ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
  ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
***************
*** 404,410 ****
  INSERT INTO tmp6 VALUES (6, 30), (7, 16);
  ALTER TABLE tmp3 ADD CONSTRAINT b_le_20 CHECK (b <= 20) NOT VALID;
  ALTER TABLE tmp3 VALIDATE CONSTRAINT b_le_20;	-- fails
! ERROR:  check constraint "b_le_20" is violated by some row
  DELETE FROM tmp6 WHERE b > 20;
  ALTER TABLE tmp3 VALIDATE CONSTRAINT b_le_20;	-- succeeds
  -- An already validated constraint must not be revalidated
--- 409,415 ----
  INSERT INTO tmp6 VALUES (6, 30), (7, 16);
  ALTER TABLE tmp3 ADD CONSTRAINT b_le_20 CHECK (b <= 20) NOT VALID;
  ALTER TABLE tmp3 VALIDATE CONSTRAINT b_le_20;	-- fails
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:check constraint "b_le_20" is violated by some row
  DELETE FROM tmp6 WHERE b > 20;
  ALTER TABLE tmp3 VALIDATE CONSTRAINT b_le_20;	-- succeeds
  -- An already validated constraint must not be revalidated
***************
*** 422,428 ****
  alter table parent_noinh_convalid add constraint check_a_is_2 check (a = 2) no inherit not valid;
  -- fail, because of the row in parent
  alter table parent_noinh_convalid validate constraint check_a_is_2;
! ERROR:  check constraint "check_a_is_2" is violated by some row
  delete from only parent_noinh_convalid;
  -- ok (parent itself contains no violating rows)
  alter table parent_noinh_convalid validate constraint check_a_is_2;
--- 427,433 ----
  alter table parent_noinh_convalid add constraint check_a_is_2 check (a = 2) no inherit not valid;
  -- fail, because of the row in parent
  alter table parent_noinh_convalid validate constraint check_a_is_2;
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:check constraint "check_a_is_2" is violated by some row
  delete from only parent_noinh_convalid;
  -- ok (parent itself contains no violating rows)
  alter table parent_noinh_convalid validate constraint check_a_is_2;
***************
*** 453,459 ****
              Table "public.nv_parent"
   Column | Type | Collation | Nullable | Default 
  --------+------+-----------+----------+---------
!  d      | date |           |          | 
  Check constraints:
      "nv_parent_check" CHECK (false) NO INHERIT
  
--- 458,464 ----
              Table "public.nv_parent"
   Column | Type | Collation | Nullable | Default 
  --------+------+-----------+----------+---------
!  d      | date |           | not null | 
  Check constraints:
      "nv_parent_check" CHECK (false) NO INHERIT
  
***************
*** 524,530 ****
            Table "public.nv_child_2009"
   Column | Type | Collation | Nullable | Default 
  --------+------+-----------+----------+---------
!  d      | date |           |          | 
  Check constraints:
      "nv_child_2009_d_check" CHECK (d >= '01-01-2009'::date AND d <= '12-31-2009'::date)
      "nv_parent_d_check" CHECK (d >= '01-01-2001'::date AND d <= '12-31-2099'::date) NOT VALID
--- 529,535 ----
            Table "public.nv_child_2009"
   Column | Type | Collation | Nullable | Default 
  --------+------+-----------+----------+---------
!  d      | date |           | not null | 
  Check constraints:
      "nv_child_2009_d_check" CHECK (d >= '01-01-2009'::date AND d <= '12-31-2009'::date)
      "nv_parent_d_check" CHECK (d >= '01-01-2001'::date AND d <= '12-31-2099'::date) NOT VALID
***************
*** 539,569 ****
  CREATE TEMP TABLE FKTABLE (ftest1 inet) DISTRIBUTE BY REPLICATION;
  -- This next should fail, because int=inet does not exist
  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
  -- This should also fail for the same reason, but here we
  -- give the column name
  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable(ptest1);
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
  DROP TABLE FKTABLE;
  -- This should succeed, even though they are different types,
  -- because int=int8 exists and is a member of the integer opfamily
  CREATE TEMP TABLE FKTABLE (ftest1 int8) DISTRIBUTE BY REPLICATION;
  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
  -- Check it actually works
  INSERT INTO FKTABLE VALUES(42);		-- should succeed
  INSERT INTO FKTABLE VALUES(43);		-- should fail
- ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
- DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
  DROP TABLE FKTABLE;
  -- This should fail, because we'd have to cast numeric to int which is
  -- not an implicit coercion (or use numeric=numeric, but that's not part
  -- of the integer opfamily)
  CREATE TEMP TABLE FKTABLE (ftest1 numeric) DISTRIBUTE BY REPLICATION;
  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
! ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
! DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: numeric and integer.
  DROP TABLE FKTABLE;
  DROP TABLE PKTABLE;
  -- On the other hand, this should work because int implicitly promotes to
--- 544,570 ----
  CREATE TEMP TABLE FKTABLE (ftest1 inet) DISTRIBUTE BY REPLICATION;
  -- This next should fail, because int=inet does not exist
  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- This should also fail for the same reason, but here we
  -- give the column name
  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable(ptest1);
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  DROP TABLE FKTABLE;
  -- This should succeed, even though they are different types,
  -- because int=int8 exists and is a member of the integer opfamily
  CREATE TEMP TABLE FKTABLE (ftest1 int8) DISTRIBUTE BY REPLICATION;
  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  -- Check it actually works
  INSERT INTO FKTABLE VALUES(42);		-- should succeed
  INSERT INTO FKTABLE VALUES(43);		-- should fail
  DROP TABLE FKTABLE;
  -- This should fail, because we'd have to cast numeric to int which is
  -- not an implicit coercion (or use numeric=numeric, but that's not part
  -- of the integer opfamily)
  CREATE TEMP TABLE FKTABLE (ftest1 numeric) DISTRIBUTE BY REPLICATION;
  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  DROP TABLE FKTABLE;
  DROP TABLE PKTABLE;
  -- On the other hand, this should work because int implicitly promotes to
***************
*** 575,582 ****
  -- Check it actually works
  INSERT INTO FKTABLE VALUES(42);		-- should succeed
  INSERT INTO FKTABLE VALUES(43);		-- should fail
- ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
- DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
  DROP TABLE FKTABLE;
  DROP TABLE PKTABLE;
  CREATE TEMP TABLE PKTABLE (ptest1 int, ptest2 inet,
--- 576,581 ----
***************
*** 610,620 ****
--- 609,623 ----
    ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
  ALTER TABLE FKTABLE ADD CONSTRAINT fkdd FOREIGN KEY(ftest1) REFERENCES pktable
    ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
+ ERROR:  deferrable constraint on shard table is not supported.
  ALTER TABLE FKTABLE ADD CONSTRAINT fkdi FOREIGN KEY(ftest1) REFERENCES pktable
    ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE;
+ ERROR:  deferrable constraint on shard table is not supported.
  ALTER TABLE FKTABLE ADD CONSTRAINT fknd2 FOREIGN KEY(ftest1) REFERENCES pktable
    ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
+ ERROR:  deferrable constraint on shard table is not supported.
  ALTER TABLE FKTABLE ALTER CONSTRAINT fknd2 NOT DEFERRABLE;
+ ERROR:  constraint "fknd2" of relation "fktable" does not exist
  ALTER TABLE FKTABLE ADD CONSTRAINT fkdd2 FOREIGN KEY(ftest1) REFERENCES pktable
    ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
  ALTER TABLE FKTABLE ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED;
***************
*** 627,645 ****
  ORDER BY 1,2,3;
   conname |         tgfoid         | tgtype | tgdeferrable | tginitdeferred 
  ---------+------------------------+--------+--------------+----------------
-  fkdd    | "RI_FKey_cascade_del"  |      9 | f            | f
-  fkdd    | "RI_FKey_noaction_upd" |     17 | t            | t
   fkdd2   | "RI_FKey_cascade_del"  |      9 | f            | f
   fkdd2   | "RI_FKey_noaction_upd" |     17 | t            | t
-  fkdi    | "RI_FKey_cascade_del"  |      9 | f            | f
-  fkdi    | "RI_FKey_noaction_upd" |     17 | t            | f
   fkdi2   | "RI_FKey_cascade_del"  |      9 | f            | f
   fkdi2   | "RI_FKey_noaction_upd" |     17 | t            | f
   fknd    | "RI_FKey_cascade_del"  |      9 | f            | f
   fknd    | "RI_FKey_noaction_upd" |     17 | f            | f
!  fknd2   | "RI_FKey_cascade_del"  |      9 | f            | f
!  fknd2   | "RI_FKey_noaction_upd" |     17 | f            | f
! (12 rows)
  
  SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
  FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
--- 630,642 ----
  ORDER BY 1,2,3;
   conname |         tgfoid         | tgtype | tgdeferrable | tginitdeferred 
  ---------+------------------------+--------+--------------+----------------
   fkdd2   | "RI_FKey_cascade_del"  |      9 | f            | f
   fkdd2   | "RI_FKey_noaction_upd" |     17 | t            | t
   fkdi2   | "RI_FKey_cascade_del"  |      9 | f            | f
   fkdi2   | "RI_FKey_noaction_upd" |     17 | t            | f
   fknd    | "RI_FKey_cascade_del"  |      9 | f            | f
   fknd    | "RI_FKey_noaction_upd" |     17 | f            | f
! (6 rows)
  
  SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
  FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
***************
*** 647,665 ****
  ORDER BY 1,2,3;
   conname |       tgfoid        | tgtype | tgdeferrable | tginitdeferred 
  ---------+---------------------+--------+--------------+----------------
-  fkdd    | "RI_FKey_check_ins" |      5 | t            | t
-  fkdd    | "RI_FKey_check_upd" |     17 | t            | t
   fkdd2   | "RI_FKey_check_ins" |      5 | t            | t
   fkdd2   | "RI_FKey_check_upd" |     17 | t            | t
-  fkdi    | "RI_FKey_check_ins" |      5 | t            | f
-  fkdi    | "RI_FKey_check_upd" |     17 | t            | f
   fkdi2   | "RI_FKey_check_ins" |      5 | t            | f
   fkdi2   | "RI_FKey_check_upd" |     17 | t            | f
   fknd    | "RI_FKey_check_ins" |      5 | f            | f
   fknd    | "RI_FKey_check_upd" |     17 | f            | f
!  fknd2   | "RI_FKey_check_ins" |      5 | f            | f
!  fknd2   | "RI_FKey_check_upd" |     17 | f            | f
! (12 rows)
  
  -- temp tables should go away by themselves, need not drop them.
  -- test check constraint adding
--- 644,656 ----
  ORDER BY 1,2,3;
   conname |       tgfoid        | tgtype | tgdeferrable | tginitdeferred 
  ---------+---------------------+--------+--------------+----------------
   fkdd2   | "RI_FKey_check_ins" |      5 | t            | t
   fkdd2   | "RI_FKey_check_upd" |     17 | t            | t
   fkdi2   | "RI_FKey_check_ins" |      5 | t            | f
   fkdi2   | "RI_FKey_check_upd" |     17 | t            | f
   fknd    | "RI_FKey_check_ins" |      5 | f            | f
   fknd    | "RI_FKey_check_upd" |     17 | f            | f
! (6 rows)
  
  -- temp tables should go away by themselves, need not drop them.
  -- test check constraint adding
***************
*** 668,674 ****
  alter table atacc1 add constraint atacc_test1 check (test>3);
  -- should fail
  insert into atacc1 (test) values (2);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
  DETAIL:  Failing row contains (2).
  -- should succeed
  insert into atacc1 (test) values (4);
--- 659,665 ----
  alter table atacc1 add constraint atacc_test1 check (test>3);
  -- should fail
  insert into atacc1 (test) values (2);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:new row for relation "atacc1" violates check constraint "atacc_test1"
  DETAIL:  Failing row contains (2).
  -- should succeed
  insert into atacc1 (test) values (4);
***************
*** 679,685 ****
  insert into atacc1 (test) values (2);
  -- add a check constraint (fails)
  alter table atacc1 add constraint atacc_test1 check (test>3);
! ERROR:  check constraint "atacc_test1" is violated by some row
  insert into atacc1 (test) values (4);
  drop table atacc1;
  -- let's do one where the check fails because the column doesn't exist
--- 670,676 ----
  insert into atacc1 (test) values (2);
  -- add a check constraint (fails)
  alter table atacc1 add constraint atacc_test1 check (test>3);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:check constraint "atacc_test1" is violated by some row
  insert into atacc1 (test) values (4);
  drop table atacc1;
  -- let's do one where the check fails because the column doesn't exist
***************
*** 695,701 ****
  alter table atacc1 add constraint atacc_test1 check (test+test2<test3*4);
  -- should fail
  insert into atacc1 (test,test2,test3) values (4,4,2);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
  DETAIL:  Failing row contains (4, 4, 2).
  -- should succeed
  insert into atacc1 (test,test2,test3) values (4,4,5);
--- 686,692 ----
  alter table atacc1 add constraint atacc_test1 check (test+test2<test3*4);
  -- should fail
  insert into atacc1 (test,test2,test3) values (4,4,2);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:new row for relation "atacc1" violates check constraint "atacc_test1"
  DETAIL:  Failing row contains (4, 4, 2).
  -- should succeed
  insert into atacc1 (test,test2,test3) values (4,4,5);
***************
*** 705,731 ****
  alter table atacc1 add check (test2>test);
  -- should fail for $2
  insert into atacc1 (test2, test) values (3, 4);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_check"
  DETAIL:  Failing row contains (4, 3).
  drop table atacc1;
  -- inheritance related tests
  create table atacc1 (test int) distribute by roundrobin;
  create table atacc2 (test2 int) distribute by roundrobin;
  create table atacc3 (test3 int) inherits (atacc1, atacc2);
  alter table atacc2 add constraint foo check (test2>0);
  -- fail and then succeed on atacc2
  insert into atacc2 (test2) values (-3);
! ERROR:  new row for relation "atacc2" violates check constraint "foo"
! DETAIL:  Failing row contains (-3).
  insert into atacc2 (test2) values (3);
  -- fail and then succeed on atacc3
  insert into atacc3 (test2) values (-3);
! ERROR:  new row for relation "atacc3" violates check constraint "foo"
! DETAIL:  Failing row contains (null, -3, null).
  insert into atacc3 (test2) values (3);
  drop table atacc3;
  drop table atacc2;
  drop table atacc1;
  create table atacc1 (test int);
  create table atacc2 (test int);
  -- fail due to missing constraint
--- 696,737 ----
  alter table atacc1 add check (test2>test);
  -- should fail for $2
  insert into atacc1 (test2, test) values (3, 4);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:new row for relation "atacc1" violates check constraint "atacc1_check"
  DETAIL:  Failing row contains (4, 3).
  drop table atacc1;
  -- inheritance related tests
  create table atacc1 (test int) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table atacc2 (test2 int) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table atacc3 (test3 int) inherits (atacc1, atacc2);
+ ERROR:  relation "atacc1" does not exist
  alter table atacc2 add constraint foo check (test2>0);
+ ERROR:  relation "atacc2" does not exist
  -- fail and then succeed on atacc2
  insert into atacc2 (test2) values (-3);
! ERROR:  relation "atacc2" does not exist
! LINE 1: insert into atacc2 (test2) values (-3);
!                     ^
  insert into atacc2 (test2) values (3);
+ ERROR:  relation "atacc2" does not exist
+ LINE 1: insert into atacc2 (test2) values (3);
+                     ^
  -- fail and then succeed on atacc3
  insert into atacc3 (test2) values (-3);
! ERROR:  relation "atacc3" does not exist
! LINE 1: insert into atacc3 (test2) values (-3);
!                     ^
  insert into atacc3 (test2) values (3);
+ ERROR:  relation "atacc3" does not exist
+ LINE 1: insert into atacc3 (test2) values (3);
+                     ^
  drop table atacc3;
+ ERROR:  table "atacc3" does not exist
  drop table atacc2;
+ ERROR:  table "atacc2" does not exist
  drop table atacc1;
+ ERROR:  table "atacc1" does not exist
  create table atacc1 (test int);
  create table atacc2 (test int);
  -- fail due to missing constraint
***************
*** 744,801 ****
  NOTICE:  drop cascades to table atacc2
  -- same things with one created with INHERIT
  create table atacc1 (test int) distribute by roundrobin;
  create table atacc2 (test2 int) distribute by roundrobin;
  create table atacc3 (test3 int) inherits (atacc1, atacc2);
  alter table atacc3 no inherit atacc2;
  -- fail
  alter table atacc3 no inherit atacc2;
! ERROR:  relation "atacc2" is not a parent of relation "atacc3"
  -- make sure it really isn't a child
  insert into atacc3 (test2) values (3);
  select test2 from atacc2;
!  test2 
! -------
! (0 rows)
! 
  -- fail due to missing column
  alter table atacc3 rename test2 to testx;
  alter table atacc3 inherit atacc2;
! ERROR:  child table is missing column "test2"
  -- fail due to mismatched data type
  alter table atacc3 add test2 bool;
  alter table atacc3 inherit atacc2;
! ERROR:  child table "atacc3" has different type for column "test2"
  alter table atacc3 drop test2;
  -- succeed
  alter table atacc3 add test2 int;
  update atacc3 set test2 = 4 where test2 is null;
  alter table atacc3 add constraint foo check (test2>0);
  -- XXX fails in XL because of column position mismatch
  alter table atacc3 inherit atacc2;
! ERROR:  table "atacc3" contains column "test2" at position 5, but parent "atacc2" has it at position 1
! DETAIL:  Postgres-XL requires attribute positions to match
! HINT:  Check for column ordering and dropped columns, if any
  -- fail due to duplicates and circular inheritance
  alter table atacc3 inherit atacc2;
! ERROR:  table "atacc3" contains column "test2" at position 5, but parent "atacc2" has it at position 1
! DETAIL:  Postgres-XL requires attribute positions to match
! HINT:  Check for column ordering and dropped columns, if any
  alter table atacc2 inherit atacc3;
! ERROR:  child table is missing column "test"
  alter table atacc2 inherit atacc2;
! ERROR:  circular inheritance not allowed
! DETAIL:  "atacc2" is already a child of "atacc2".
  -- test that we really are a child now (should see 4 not 3 and cascade should go through)
  -- XXX fails in XL because the previous alter table failed
  select test2 from atacc2;
!  test2 
! -------
! (0 rows)
! 
  drop table atacc2 cascade;
  -- XXX needs a cascade drop in XL because atacc3 is still a child of atacc1
  drop table atacc1 cascade;
! NOTICE:  drop cascades to table atacc3
  -- adding only to a parent is allowed as of 9.2
  create table atacc1 (test int);
  create table atacc2 (test2 int) inherits (atacc1);
--- 750,816 ----
  NOTICE:  drop cascades to table atacc2
  -- same things with one created with INHERIT
  create table atacc1 (test int) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table atacc2 (test2 int) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table atacc3 (test3 int) inherits (atacc1, atacc2);
+ ERROR:  relation "atacc1" does not exist
  alter table atacc3 no inherit atacc2;
+ ERROR:  relation "atacc3" does not exist
  -- fail
  alter table atacc3 no inherit atacc2;
! ERROR:  relation "atacc3" does not exist
  -- make sure it really isn't a child
  insert into atacc3 (test2) values (3);
+ ERROR:  relation "atacc3" does not exist
+ LINE 1: insert into atacc3 (test2) values (3);
+                     ^
  select test2 from atacc2;
! ERROR:  relation "atacc2" does not exist
! LINE 1: select test2 from atacc2;
!                           ^
  -- fail due to missing column
  alter table atacc3 rename test2 to testx;
+ ERROR:  relation "atacc3" does not exist
  alter table atacc3 inherit atacc2;
! ERROR:  relation "atacc3" does not exist
  -- fail due to mismatched data type
  alter table atacc3 add test2 bool;
+ ERROR:  relation "atacc3" does not exist
  alter table atacc3 inherit atacc2;
! ERROR:  relation "atacc3" does not exist
  alter table atacc3 drop test2;
+ ERROR:  relation "atacc3" does not exist
  -- succeed
  alter table atacc3 add test2 int;
+ ERROR:  relation "atacc3" does not exist
  update atacc3 set test2 = 4 where test2 is null;
+ ERROR:  relation "atacc3" does not exist
+ LINE 1: update atacc3 set test2 = 4 where test2 is null;
+                ^
  alter table atacc3 add constraint foo check (test2>0);
+ ERROR:  relation "atacc3" does not exist
  -- XXX fails in XL because of column position mismatch
  alter table atacc3 inherit atacc2;
! ERROR:  relation "atacc3" does not exist
  -- fail due to duplicates and circular inheritance
  alter table atacc3 inherit atacc2;
! ERROR:  relation "atacc3" does not exist
  alter table atacc2 inherit atacc3;
! ERROR:  relation "atacc2" does not exist
  alter table atacc2 inherit atacc2;
! ERROR:  relation "atacc2" does not exist
  -- test that we really are a child now (should see 4 not 3 and cascade should go through)
  -- XXX fails in XL because the previous alter table failed
  select test2 from atacc2;
! ERROR:  relation "atacc2" does not exist
! LINE 1: select test2 from atacc2;
!                           ^
  drop table atacc2 cascade;
+ ERROR:  table "atacc2" does not exist
  -- XXX needs a cascade drop in XL because atacc3 is still a child of atacc1
  drop table atacc1 cascade;
! ERROR:  table "atacc1" does not exist
  -- adding only to a parent is allowed as of 9.2
  create table atacc1 (test int);
  create table atacc2 (test2 int) inherits (atacc1);
***************
*** 805,816 ****
  insert into atacc2 (test) values (-3);
  -- check constraint is there on parent
  insert into atacc1 (test) values (-3);
! ERROR:  new row for relation "atacc1" violates check constraint "foo"
  DETAIL:  Failing row contains (-3).
  insert into atacc1 (test) values (3);
  -- fail, violating row:
  alter table atacc2 add constraint foo check (test>0) no inherit;
! ERROR:  check constraint "foo" is violated by some row
  drop table atacc2;
  drop table atacc1;
  -- test unique constraint adding
--- 820,831 ----
  insert into atacc2 (test) values (-3);
  -- check constraint is there on parent
  insert into atacc1 (test) values (-3);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:new row for relation "atacc1" violates check constraint "foo"
  DETAIL:  Failing row contains (-3).
  insert into atacc1 (test) values (3);
  -- fail, violating row:
  alter table atacc2 add constraint foo check (test>0) no inherit;
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:check constraint "foo" is violated by some row
  drop table atacc2;
  drop table atacc1;
  -- test unique constraint adding
***************
*** 821,827 ****
  insert into atacc1 (test) values (2);
  -- should fail
  insert into atacc1 (test) values (2);
! ERROR:  duplicate key value violates unique constraint "atacc_test1"
  DETAIL:  Key (test)=(2) already exists.
  -- should succeed
  insert into atacc1 (test) values (4);
--- 836,842 ----
  insert into atacc1 (test) values (2);
  -- should fail
  insert into atacc1 (test) values (2);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:duplicate key value violates unique constraint "atacc_test1"
  DETAIL:  Key (test)=(2) already exists.
  -- should succeed
  insert into atacc1 (test) values (4);
***************
*** 829,835 ****
  alter table atacc1 add constraint atacc_oid1 unique(oid);
  -- try to create duplicates via alter table using - should fail
  alter table atacc1 alter column test type integer using 0;
! ERROR:  could not create unique index "atacc_test1"
  DETAIL:  Key (test)=(0) is duplicated.
  drop table atacc1;
  -- let's do one where the unique constraint fails when added
--- 844,850 ----
  alter table atacc1 add constraint atacc_oid1 unique(oid);
  -- try to create duplicates via alter table using - should fail
  alter table atacc1 alter column test type integer using 0;
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:could not create unique index "atacc_test1"
  DETAIL:  Key (test)=(0) is duplicated.
  drop table atacc1;
  -- let's do one where the unique constraint fails when added
***************
*** 839,855 ****
  insert into atacc1 (test) values (2);
  -- add a unique constraint (fails)
  alter table atacc1 add constraint atacc_test1 unique (test);
! ERROR:  could not create unique index "atacc_test1"
  DETAIL:  Key (test)=(2) is duplicated.
  insert into atacc1 (test) values (3);
  drop table atacc1;
  -- let's do one where the unique constraint fails
  -- because the column doesn't exist
  create table atacc1 ( test int ) distribute by roundrobin;
  -- add a unique constraint (fails)
  alter table atacc1 add constraint atacc_test1 unique (test1);
! ERROR:  Cannot locally enforce a unique index on round robin distributed table.
  drop table atacc1;
  -- something a little more complicated
  create table atacc1 ( test int, test2 int);
  -- add a unique constraint
--- 854,872 ----
  insert into atacc1 (test) values (2);
  -- add a unique constraint (fails)
  alter table atacc1 add constraint atacc_test1 unique (test);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_2,backend_pid:384671,message:could not create unique index "atacc_test1"
  DETAIL:  Key (test)=(2) is duplicated.
  insert into atacc1 (test) values (3);
  drop table atacc1;
  -- let's do one where the unique constraint fails
  -- because the column doesn't exist
  create table atacc1 ( test int ) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  -- add a unique constraint (fails)
  alter table atacc1 add constraint atacc_test1 unique (test1);
! ERROR:  relation "atacc1" does not exist
  drop table atacc1;
+ ERROR:  table "atacc1" does not exist
  -- something a little more complicated
  create table atacc1 ( test int, test2 int);
  -- add a unique constraint
***************
*** 858,864 ****
  insert into atacc1 (test,test2) values (4,4);
  -- should fail
  insert into atacc1 (test,test2) values (4,4);
! ERROR:  duplicate key value violates unique constraint "atacc_test1"
  DETAIL:  Key (test, test2)=(4, 4) already exists.
  -- should all succeed
  insert into atacc1 (test,test2) values (4,5);
--- 875,881 ----
  insert into atacc1 (test,test2) values (4,4);
  -- should fail
  insert into atacc1 (test,test2) values (4,4);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:duplicate key value violates unique constraint "atacc_test1"
  DETAIL:  Key (test, test2)=(4, 4) already exists.
  -- should all succeed
  insert into atacc1 (test,test2) values (4,5);
***************
*** 871,877 ****
  -- should fail for @@ second one @@
  insert into atacc1 (test2, test) values (3, 3);
  insert into atacc1 (test2, test) values (2, 3);
! ERROR:  duplicate key value violates unique constraint "atacc1_test_key"
  DETAIL:  Key (test)=(3) already exists.
  drop table atacc1;
  -- test primary key constraint adding
--- 888,894 ----
  -- should fail for @@ second one @@
  insert into atacc1 (test2, test) values (3, 3);
  insert into atacc1 (test2, test) values (2, 3);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:duplicate key value violates unique constraint "atacc1_test_key"
  DETAIL:  Key (test)=(3) already exists.
  drop table atacc1;
  -- test primary key constraint adding
***************
*** 882,894 ****
  insert into atacc1 (test) values (2);
  -- should fail
  insert into atacc1 (test) values (2);
! ERROR:  duplicate key value violates unique constraint "atacc_test1"
  DETAIL:  Key (test)=(2) already exists.
  -- should succeed
  insert into atacc1 (test) values (4);
  -- inserting NULL should fail
  insert into atacc1 (test) values(NULL);
! ERROR:  null value in column "test" violates not-null constraint
  DETAIL:  Failing row contains (null).
  -- try adding a second primary key (should fail)
  alter table atacc1 add constraint atacc_oid1 primary key(oid);
--- 899,911 ----
  insert into atacc1 (test) values (2);
  -- should fail
  insert into atacc1 (test) values (2);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:duplicate key value violates unique constraint "atacc_test1"
  DETAIL:  Key (test)=(2) already exists.
  -- should succeed
  insert into atacc1 (test) values (4);
  -- inserting NULL should fail
  insert into atacc1 (test) values(NULL);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:null value in column "test" violates not-null constraint
  DETAIL:  Failing row contains (null).
  -- try adding a second primary key (should fail)
  alter table atacc1 add constraint atacc_oid1 primary key(oid);
***************
*** 905,911 ****
  insert into atacc1 (test) values (2);
  -- add a primary key (fails)
  alter table atacc1 add constraint atacc_test1 primary key (test);
! ERROR:  could not create unique index "atacc_test1"
  DETAIL:  Key (test)=(2) is duplicated.
  insert into atacc1 (test) values (3);
  drop table atacc1;
--- 922,928 ----
  insert into atacc1 (test) values (2);
  -- add a primary key (fails)
  alter table atacc1 add constraint atacc_test1 primary key (test);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:could not create unique index "atacc_test1"
  DETAIL:  Key (test)=(2) is duplicated.
  insert into atacc1 (test) values (3);
  drop table atacc1;
***************
*** 913,921 ****
  create table atacc1 ( test int );
  -- insert soon to be failing row
  insert into atacc1 (test) values (NULL);
  -- add a primary key (fails)
  alter table atacc1 add constraint atacc_test1 primary key (test);
- ERROR:  column "test" contains null values
  insert into atacc1 (test) values (3);
  drop table atacc1;
  -- let's do one where the primary key constraint fails
--- 930,939 ----
  create table atacc1 ( test int );
  -- insert soon to be failing row
  insert into atacc1 (test) values (NULL);
+ ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "test" violates not-null constraint
+ DETAIL:  Failing row contains (null).
  -- add a primary key (fails)
  alter table atacc1 add constraint atacc_test1 primary key (test);
  insert into atacc1 (test) values (3);
  drop table atacc1;
  -- let's do one where the primary key constraint fails
***************
*** 931,937 ****
  insert into atacc1 (test) values (0);
  -- add a primary key column without a default (fails).
  alter table atacc1 add column test2 int primary key;
! ERROR:  column "test2" contains null values
  -- now add a primary key column with a default (succeeds).
  alter table atacc1 add column test2 int default 0 primary key;
  drop table atacc1;
--- 949,955 ----
  insert into atacc1 (test) values (0);
  -- add a primary key column without a default (fails).
  alter table atacc1 add column test2 int primary key;
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:column "test2" contains null values
  -- now add a primary key column with a default (succeeds).
  alter table atacc1 add column test2 int default 0 primary key;
  drop table atacc1;
***************
*** 946,961 ****
  insert into atacc1 (test,test2) values (4,4);
  -- should fail
  insert into atacc1 (test,test2) values (4,4);
! ERROR:  duplicate key value violates unique constraint "atacc_test1"
  DETAIL:  Key (test, test2)=(4, 4) already exists.
  insert into atacc1 (test,test2) values (NULL,3);
! ERROR:  null value in column "test" violates not-null constraint
  DETAIL:  Failing row contains (null, 3).
  insert into atacc1 (test,test2) values (3, NULL);
! ERROR:  null value in column "test2" violates not-null constraint
  DETAIL:  Failing row contains (3, null).
  insert into atacc1 (test,test2) values (NULL,NULL);
! ERROR:  null value in column "test" violates not-null constraint
  DETAIL:  Failing row contains (null, null).
  -- should all succeed
  insert into atacc1 (test,test2) values (4,5);
--- 964,979 ----
  insert into atacc1 (test,test2) values (4,4);
  -- should fail
  insert into atacc1 (test,test2) values (4,4);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:duplicate key value violates unique constraint "atacc_test1"
  DETAIL:  Key (test, test2)=(4, 4) already exists.
  insert into atacc1 (test,test2) values (NULL,3);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "test" violates not-null constraint
  DETAIL:  Failing row contains (null, 3).
  insert into atacc1 (test,test2) values (3, NULL);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:null value in column "test2" violates not-null constraint
  DETAIL:  Failing row contains (3, null).
  insert into atacc1 (test,test2) values (NULL,NULL);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "test" violates not-null constraint
  DETAIL:  Failing row contains (null, null).
  -- should all succeed
  insert into atacc1 (test,test2) values (4,5);
***************
*** 967,976 ****
  -- only first should succeed
  insert into atacc1 (test2, test) values (3, 3);
  insert into atacc1 (test2, test) values (2, 3);
! ERROR:  duplicate key value violates unique constraint "atacc1_pkey"
  DETAIL:  Key (test)=(3) already exists.
  insert into atacc1 (test2, test) values (1, NULL);
! ERROR:  null value in column "test" violates not-null constraint
  DETAIL:  Failing row contains (null, 1).
  drop table atacc1;
  -- alter table / alter column [set/drop] not null tests
--- 985,994 ----
  -- only first should succeed
  insert into atacc1 (test2, test) values (3, 3);
  insert into atacc1 (test2, test) values (2, 3);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:duplicate key value violates unique constraint "atacc1_pkey"
  DETAIL:  Key (test)=(3) already exists.
  insert into atacc1 (test2, test) values (1, NULL);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "test" violates not-null constraint
  DETAIL:  Failing row contains (null, 1).
  drop table atacc1;
  -- alter table / alter column [set/drop] not null tests
***************
*** 994,1000 ****
  alter table atacc1 alter column test drop not null;
  insert into atacc1 values (null);
  alter table atacc1 alter test set not null;
! ERROR:  column "test" contains null values
  delete from atacc1;
  alter table atacc1 alter test set not null;
  -- try altering a non-existent column, should fail
--- 1012,1018 ----
  alter table atacc1 alter column test drop not null;
  insert into atacc1 values (null);
  alter table atacc1 alter test set not null;
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:column "test" contains null values
  delete from atacc1;
  alter table atacc1 alter test set not null;
  -- try altering a non-existent column, should fail
***************
*** 1020,1050 ****
  create table child (b varchar(255)) inherits (parent);
  alter table parent alter a set not null;
  insert into parent values (NULL);
! ERROR:  null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null).
  insert into child (a, b) values (NULL, 'foo');
! ERROR:  null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null, foo).
  alter table parent alter a drop not null;
  insert into parent values (NULL);
  insert into child (a, b) values (NULL, 'foo');
  alter table only parent alter a set not null;
! ERROR:  column "a" contains null values
  alter table child alter a set not null;
! ERROR:  column "a" contains null values
  delete from parent;
  alter table only parent alter a set not null;
  insert into parent values (NULL);
! ERROR:  null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null).
  alter table child alter a set not null;
  insert into child (a, b) values (NULL, 'foo');
! ERROR:  null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null, foo).
  delete from child;
  alter table child alter a set not null;
  insert into child (a, b) values (NULL, 'foo');
! ERROR:  null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null, foo).
  drop table child;
  drop table parent;
--- 1038,1068 ----
  create table child (b varchar(255)) inherits (parent);
  alter table parent alter a set not null;
  insert into parent values (NULL);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null).
  insert into child (a, b) values (NULL, 'foo');
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null, foo).
  alter table parent alter a drop not null;
  insert into parent values (NULL);
  insert into child (a, b) values (NULL, 'foo');
  alter table only parent alter a set not null;
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:column "a" contains null values
  alter table child alter a set not null;
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:column "a" contains null values
  delete from parent;
  alter table only parent alter a set not null;
  insert into parent values (NULL);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null).
  alter table child alter a set not null;
  insert into child (a, b) values (NULL, 'foo');
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null, foo).
  delete from child;
  alter table child alter a set not null;
  insert into child (a, b) values (NULL, 'foo');
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null, foo).
  drop table child;
  drop table parent;
***************
*** 1056,1063 ****
--- 1074,1085 ----
  insert into def_test default values;
  alter table def_test alter column c1 drop default;
  insert into def_test default values;
+ ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "c1" violates not-null constraint
+ DETAIL:  Failing row contains (null, initial_default).
  alter table def_test alter column c2 drop default;
  insert into def_test default values;
+ ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "c1" violates not-null constraint
+ DETAIL:  Failing row contains (null, null).
  alter table def_test alter column c1 set default 10;
  alter table def_test alter column c2 set default 'new_default';
  insert into def_test default values;
***************
*** 1066,1074 ****
  ----+-----------------
    5 | initial_default
   10 | new_default
!     | initial_default
!     | 
! (4 rows)
  
  -- set defaults to an incorrect type: this should fail
  alter table def_test alter column c1 set default 'wrong_datatype';
--- 1088,1094 ----
  ----+-----------------
    5 | initial_default
   10 | new_default
! (2 rows)
  
  -- set defaults to an incorrect type: this should fail
  alter table def_test alter column c1 set default 'wrong_datatype';
***************
*** 1085,1090 ****
--- 1105,1112 ----
  	on insert to def_view_test
  	do instead insert into def_test select new.*;
  insert into def_view_test default values;
+ ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "c1" violates not-null constraint
+ DETAIL:  Failing row contains (null, null).
  alter table def_view_test alter column c1 set default 45;
  insert into def_view_test default values;
  alter table def_view_test alter column c2 set default 'view_default';
***************
*** 1096,1105 ****
   10 | new_default
   45 | view_default
   45 | 
!     | initial_default
!     | 
!     | 
! (7 rows)
  
  drop rule def_view_test_ins on def_view_test;
  drop view def_view_test;
--- 1118,1124 ----
   10 | new_default
   45 | view_default
   45 | 
! (4 rows)
  
  drop rule def_view_test_ins on def_view_test;
  drop view def_view_test;
***************
*** 1274,1286 ****
  drop view myview;
  -- test some commands to make sure they fail on the dropped column
  analyze atacc1(a);
! ERROR:  column "a" of relation "atacc1" does not exist
  analyze atacc1("........pg.dropped.1........");
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
  vacuum analyze atacc1(a);
! ERROR:  column "a" of relation "atacc1" does not exist
  vacuum analyze atacc1("........pg.dropped.1........");
! ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
  comment on column atacc1.a is 'testing';
  ERROR:  column "a" of relation "atacc1" does not exist
  comment on column atacc1."........pg.dropped.1........" is 'testing';
--- 1293,1305 ----
  drop view myview;
  -- test some commands to make sure they fail on the dropped column
  analyze atacc1(a);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:column "a" of relation "atacc1" does not exist
  analyze atacc1("........pg.dropped.1........");
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:column "........pg.dropped.1........" of relation "atacc1" does not exist
  vacuum analyze atacc1(a);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:column "a" of relation "atacc1" does not exist
  vacuum analyze atacc1("........pg.dropped.1........");
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_1,backend_pid:384666,message:column "........pg.dropped.1........" of relation "atacc1" does not exist
  comment on column atacc1.a is 'testing';
  ERROR:  column "a" of relation "atacc1" does not exist
  comment on column atacc1."........pg.dropped.1........" is 'testing';
***************
*** 1310,1318 ****
  alter table atacc1 alter "........pg.dropped.1........" drop not null;
  ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
  alter table atacc1 rename a to x;
! ERROR:  column "a" does not exist
  alter table atacc1 rename "........pg.dropped.1........" to x;
! ERROR:  column "........pg.dropped.1........" does not exist
  alter table atacc1 add primary key(a);
  ERROR:  column "a" named in key does not exist
  alter table atacc1 add primary key("........pg.dropped.1........");
--- 1329,1337 ----
  alter table atacc1 alter "........pg.dropped.1........" drop not null;
  ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
  alter table atacc1 rename a to x;
! ERROR:  node:datanode_2, backend_pid:384671, nodename:coord2,backend_pid:384618,message:column "a" does not exist
  alter table atacc1 rename "........pg.dropped.1........" to x;
! ERROR:  node:datanode_2, backend_pid:384671, nodename:coord2,backend_pid:384618,message:column "........pg.dropped.1........" does not exist
  alter table atacc1 add primary key(a);
  ERROR:  column "a" named in key does not exist
  alter table atacc1 add primary key("........pg.dropped.1........");
***************
*** 1327,1339 ****
  ERROR:  column "........pg.dropped.1........" does not exist
  create table atacc2 (id int4 unique) distribute by replication;
  alter table atacc1 add foreign key (a) references atacc2(id);
! ERROR:  column "a" referenced in foreign key constraint does not exist
  alter table atacc1 add foreign key ("........pg.dropped.1........") references atacc2(id);
! ERROR:  column "........pg.dropped.1........" referenced in foreign key constraint does not exist
  alter table atacc2 add foreign key (id) references atacc1(a);
! ERROR:  column "a" referenced in foreign key constraint does not exist
  alter table atacc2 add foreign key (id) references atacc1("........pg.dropped.1........");
! ERROR:  column "........pg.dropped.1........" referenced in foreign key constraint does not exist
  drop table atacc2;
  create index "testing_idx" on atacc1(a);
  ERROR:  column "a" does not exist
--- 1346,1358 ----
  ERROR:  column "........pg.dropped.1........" does not exist
  create table atacc2 (id int4 unique) distribute by replication;
  alter table atacc1 add foreign key (a) references atacc2(id);
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  alter table atacc1 add foreign key ("........pg.dropped.1........") references atacc2(id);
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  alter table atacc2 add foreign key (id) references atacc1(a);
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  alter table atacc2 add foreign key (id) references atacc1("........pg.dropped.1........");
! ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  drop table atacc2;
  create index "testing_idx" on atacc1(a);
  ERROR:  column "a" does not exist
***************
*** 1369,1420 ****
  -- test constraint error reporting in presence of dropped columns
  create table atacc1 (id serial primary key, value int check (value < 10));
  insert into atacc1(value) values (100);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
  DETAIL:  Failing row contains (1, 100).
  alter table atacc1 drop column value;
  alter table atacc1 add column value int check (value < 10);
  insert into atacc1(value) values (100);
! ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
  DETAIL:  Failing row contains (2, 100).
  insert into atacc1(id, value) values (null, 0);
! ERROR:  null value in column "id" violates not-null constraint
  DETAIL:  Failing row contains (null, 0).
  drop table atacc1;
  -- test inheritance
  create table parent (a int, b int, c int) distribute by roundrobin;
  insert into parent values (1, 2, 3);
  alter table parent drop a;
  create table child (d varchar(255)) inherits (parent);
  insert into child values (12, 13, 'testing');
  select * from parent order by b;
!  b  | c  
! ----+----
!   2 |  3
!  12 | 13
! (2 rows)
! 
  select * from child;
!  b  | c  |    d    
! ----+----+---------
!  12 | 13 | testing
! (1 row)
! 
  alter table parent drop c;
  select * from parent order by b;
!  b  
! ----
!   2
!  12
! (2 rows)
! 
  select * from child;
!  b  |    d    
! ----+---------
!  12 | testing
! (1 row)
! 
  drop table child;
  drop table parent;
  -- check error cases for inheritance column merging
  create table parent (a float8, b numeric(10,4), c text collate "C");
  create table child (a float4) inherits (parent); -- fail
--- 1388,1441 ----
  -- test constraint error reporting in presence of dropped columns
  create table atacc1 (id serial primary key, value int check (value < 10));
  insert into atacc1(value) values (100);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:new row for relation "atacc1" violates check constraint "atacc1_value_check"
  DETAIL:  Failing row contains (1, 100).
  alter table atacc1 drop column value;
  alter table atacc1 add column value int check (value < 10);
  insert into atacc1(value) values (100);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:new row for relation "atacc1" violates check constraint "atacc1_value_check"
  DETAIL:  Failing row contains (2, 100).
  insert into atacc1(id, value) values (null, 0);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "id" violates not-null constraint
  DETAIL:  Failing row contains (null, 0).
  drop table atacc1;
  -- test inheritance
  create table parent (a int, b int, c int) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  insert into parent values (1, 2, 3);
+ ERROR:  relation "parent" does not exist
+ LINE 1: insert into parent values (1, 2, 3);
+                     ^
  alter table parent drop a;
+ ERROR:  relation "parent" does not exist
  create table child (d varchar(255)) inherits (parent);
+ ERROR:  relation "parent" does not exist
  insert into child values (12, 13, 'testing');
+ ERROR:  relation "child" does not exist
+ LINE 1: insert into child values (12, 13, 'testing');
+                     ^
  select * from parent order by b;
! ERROR:  relation "parent" does not exist
! LINE 1: select * from parent order by b;
!                       ^
  select * from child;
! ERROR:  relation "child" does not exist
! LINE 1: select * from child;
!                       ^
  alter table parent drop c;
+ ERROR:  relation "parent" does not exist
  select * from parent order by b;
! ERROR:  relation "parent" does not exist
! LINE 1: select * from parent order by b;
!                       ^
  select * from child;
! ERROR:  relation "child" does not exist
! LINE 1: select * from child;
!                       ^
  drop table child;
+ ERROR:  table "child" does not exist
  drop table parent;
+ ERROR:  table "parent" does not exist
  -- check error cases for inheritance column merging
  create table parent (a float8, b numeric(10,4), c text collate "C");
  create table child (a float4) inherits (parent); -- fail
***************
*** 1438,1482 ****
  drop table parent;
  -- test copy in/out
  create table test (a int4, b int4, c int4) distribute by roundrobin;
  insert into test values (1,2,3);
  alter table test drop a;
  copy test to stdout;
! 2	3
  copy test(a) to stdout;
! ERROR:  column "a" of relation "test" does not exist
  copy test("........pg.dropped.1........") to stdout;
! ERROR:  column "........pg.dropped.1........" of relation "test" does not exist
  copy test from stdin;
! ERROR:  extra data after last expected column
! CONTEXT:  COPY test, line 1: "10	11	12", nodetype:1(1:cn,0:dn)
  select * from test order by b;
!  b | c 
! ---+---
!  2 | 3
! (1 row)
! 
  copy test from stdin;
  select * from test order by b;
!  b  | c  
! ----+----
!   2 |  3
!  21 | 22
! (2 rows)
! 
  copy test(a) from stdin;
! ERROR:  column "a" of relation "test" does not exist
  copy test("........pg.dropped.1........") from stdin;
! ERROR:  column "........pg.dropped.1........" of relation "test" does not exist
  copy test(b,c) from stdin;
  select * from test order by b;
!  b  | c  
! ----+----
!   2 |  3
!  21 | 22
!  31 | 32
! (3 rows)
! 
  drop table test;
  -- test inheritance
  create table dropColumn (a int, b int, e int) distribute by replication;
  create table dropColumnChild (c int) inherits (dropColumn) distribute by replication;
--- 1459,1510 ----
  drop table parent;
  -- test copy in/out
  create table test (a int4, b int4, c int4) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  insert into test values (1,2,3);
+ ERROR:  relation "test" does not exist
+ LINE 1: insert into test values (1,2,3);
+                     ^
  alter table test drop a;
+ ERROR:  relation "test" does not exist
  copy test to stdout;
! ERROR:  relation "test" does not exist
  copy test(a) to stdout;
! ERROR:  relation "test" does not exist
  copy test("........pg.dropped.1........") to stdout;
! ERROR:  relation "test" does not exist
  copy test from stdin;
! ERROR:  relation "test" does not exist
! 10	11	12
! \.
! invalid command \.
  select * from test order by b;
! ERROR:  syntax error at or near "10"
! LINE 1: 10 11 12
!         ^
  copy test from stdin;
+ ERROR:  relation "test" does not exist
+ 21	22
+ \.
+ invalid command \.
  select * from test order by b;
! ERROR:  syntax error at or near "21"
! LINE 1: 21 22
!         ^
  copy test(a) from stdin;
! ERROR:  relation "test" does not exist
  copy test("........pg.dropped.1........") from stdin;
! ERROR:  relation "test" does not exist
  copy test(b,c) from stdin;
+ ERROR:  relation "test" does not exist
+ 31	32
+ \.
+ invalid command \.
  select * from test order by b;
! ERROR:  syntax error at or near "31"
! LINE 1: 31 32
!         ^
  drop table test;
+ ERROR:  table "test" does not exist
  -- test inheritance
  create table dropColumn (a int, b int, e int) distribute by replication;
  create table dropColumnChild (c int) inherits (dropColumn) distribute by replication;
***************
*** 1497,1507 ****
  create table renameColumnAnother (c int) inherits (renameColumnChild);
  -- these three should fail
  alter table renameColumnChild rename column a to d;
! ERROR:  cannot rename inherited column "a"
  alter table only renameColumnChild rename column a to d;
! ERROR:  inherited column "a" must be renamed in child tables too
  alter table only renameColumn rename column a to d;
! ERROR:  inherited column "a" must be renamed in child tables too
  -- these should work
  alter table renameColumn rename column a to d;
  alter table renameColumnChild rename column b to a;
--- 1525,1535 ----
  create table renameColumnAnother (c int) inherits (renameColumnChild);
  -- these three should fail
  alter table renameColumnChild rename column a to d;
! ERROR:  node:datanode_1, backend_pid:384666, nodename:coord2,backend_pid:384618,message:cannot rename inherited column "a"
  alter table only renameColumnChild rename column a to d;
! ERROR:  node:datanode_2, backend_pid:384671, nodename:coord2,backend_pid:384618,message:inherited column "a" must be renamed in child tables too
  alter table only renameColumn rename column a to d;
! ERROR:  node:datanode_2, backend_pid:384671, nodename:coord2,backend_pid:384618,message:inherited column "a" must be renamed in child tables too
  -- these should work
  alter table renameColumn rename column a to d;
  alter table renameColumnChild rename column b to a;
***************
*** 1517,1628 ****
  ERROR:  column must be added to child tables too
  -- Test corner cases in dropping of inherited columns
  create table p1 (f1 int, f2 int) distribute by roundrobin;
  create table c1 (f1 int not null) inherits(p1) distribute by roundrobin;
! WARNING:  Inherited/partition tables inherit distribution from the parent
! DETAIL:  Explicitly specified distribution will be ignored
! NOTICE:  merging column "f1" with inherited definition
  -- should be rejected since c1.f1 is inherited
  alter table c1 drop column f1;
! ERROR:  cannot drop inherited column "f1"
  -- should work
  alter table p1 drop column f1;
  -- c1.f1 is still there, but no longer inherited
  select f1 from c1;
!  f1 
! ----
! (0 rows)
! 
  alter table c1 drop column f1;
  select f1 from c1;
! ERROR:  column "f1" does not exist
  LINE 1: select f1 from c1;
!                ^
! HINT:  Perhaps you meant to reference the column "c1.f2".
  drop table p1 cascade;
! NOTICE:  drop cascades to table c1
  create table p1 (f1 int, f2 int) distribute by roundrobin;
  create table c1 () inherits(p1) distribute by roundrobin;
! WARNING:  Inherited/partition tables inherit distribution from the parent
! DETAIL:  Explicitly specified distribution will be ignored
  -- should be rejected since c1.f1 is inherited
  alter table c1 drop column f1;
! ERROR:  cannot drop inherited column "f1"
  alter table p1 drop column f1;
  -- c1.f1 is dropped now, since there is no local definition for it
  select f1 from c1;
! ERROR:  column "f1" does not exist
  LINE 1: select f1 from c1;
!                ^
! HINT:  Perhaps you meant to reference the column "c1.f2".
  drop table p1 cascade;
! NOTICE:  drop cascades to table c1
  create table p1 (f1 int, f2 int) distribute by roundrobin;
  create table c1 () inherits(p1) distribute by roundrobin;
! WARNING:  Inherited/partition tables inherit distribution from the parent
! DETAIL:  Explicitly specified distribution will be ignored
  -- should be rejected since c1.f1 is inherited
  alter table c1 drop column f1;
! ERROR:  cannot drop inherited column "f1"
  alter table only p1 drop column f1;
  -- c1.f1 is NOT dropped, but must now be considered non-inherited
  alter table c1 drop column f1;
  drop table p1 cascade;
! NOTICE:  drop cascades to table c1
  create table p1 (f1 int, f2 int) distribute by roundrobin;
  create table c1 (f1 int not null) inherits(p1) distribute by roundrobin;
! WARNING:  Inherited/partition tables inherit distribution from the parent
! DETAIL:  Explicitly specified distribution will be ignored
! NOTICE:  merging column "f1" with inherited definition
  -- should be rejected since c1.f1 is inherited
  alter table c1 drop column f1;
! ERROR:  cannot drop inherited column "f1"
  alter table only p1 drop column f1;
  -- c1.f1 is still there, but no longer inherited
  alter table c1 drop column f1;
  drop table p1 cascade;
! NOTICE:  drop cascades to table c1
  create table p1(id int, name text) distribute by roundrobin;
  create table p2(id2 int, name text, height int) distribute by roundrobin;
  create table c1(age int) inherits(p1,p2);
! NOTICE:  merging multiple inherited definitions of column "name"
  create table gc1() inherits (c1);
  select relname, attname, attinhcount, attislocal
  from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
  where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
  order by relname, attnum;
   relname | attname | attinhcount | attislocal 
  ---------+---------+-------------+------------
!  c1      | id      |           1 | f
!  c1      | name    |           2 | f
!  c1      | id2     |           1 | f
!  c1      | height  |           1 | f
!  c1      | age     |           0 | t
!  gc1     | id      |           1 | f
!  gc1     | name    |           1 | f
!  gc1     | id2     |           1 | f
!  gc1     | height  |           1 | f
!  gc1     | age     |           1 | f
!  p1      | id      |           0 | t
!  p1      | name    |           0 | t
!  p2      | id2     |           0 | t
!  p2      | name    |           0 | t
!  p2      | height  |           0 | t
! (15 rows)
  
  -- should work
  alter table only p1 drop column name;
  -- should work. Now c1.name is local and inhcount is 0.
  alter table p2 drop column name;
  -- should be rejected since its inherited
  alter table gc1 drop column name;
! ERROR:  cannot drop inherited column "name"
  -- should work, and drop gc1.name along
  alter table c1 drop column name;
  -- should fail: column does not exist
  alter table gc1 drop column name;
! ERROR:  column "name" of relation "gc1" does not exist
  -- should work and drop the attribute in all tables
  alter table p2 drop column height;
  -- IF EXISTS test
  create table dropColumnExists ();
  alter table dropColumnExists drop column non_existing; --fail
--- 1545,1650 ----
  ERROR:  column must be added to child tables too
  -- Test corner cases in dropping of inherited columns
  create table p1 (f1 int, f2 int) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table c1 (f1 int not null) inherits(p1) distribute by roundrobin;
! ERROR:  relation "p1" does not exist
  -- should be rejected since c1.f1 is inherited
  alter table c1 drop column f1;
! ERROR:  relation "c1" does not exist
  -- should work
  alter table p1 drop column f1;
+ ERROR:  relation "p1" does not exist
  -- c1.f1 is still there, but no longer inherited
  select f1 from c1;
! ERROR:  relation "c1" does not exist
! LINE 1: select f1 from c1;
!                        ^
  alter table c1 drop column f1;
+ ERROR:  relation "c1" does not exist
  select f1 from c1;
! ERROR:  relation "c1" does not exist
  LINE 1: select f1 from c1;
!                        ^
  drop table p1 cascade;
! ERROR:  table "p1" does not exist
  create table p1 (f1 int, f2 int) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table c1 () inherits(p1) distribute by roundrobin;
! ERROR:  relation "p1" does not exist
  -- should be rejected since c1.f1 is inherited
  alter table c1 drop column f1;
! ERROR:  relation "c1" does not exist
  alter table p1 drop column f1;
+ ERROR:  relation "p1" does not exist
  -- c1.f1 is dropped now, since there is no local definition for it
  select f1 from c1;
! ERROR:  relation "c1" does not exist
  LINE 1: select f1 from c1;
!                        ^
  drop table p1 cascade;
! ERROR:  table "p1" does not exist
  create table p1 (f1 int, f2 int) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table c1 () inherits(p1) distribute by roundrobin;
! ERROR:  relation "p1" does not exist
  -- should be rejected since c1.f1 is inherited
  alter table c1 drop column f1;
! ERROR:  relation "c1" does not exist
  alter table only p1 drop column f1;
+ ERROR:  relation "p1" does not exist
  -- c1.f1 is NOT dropped, but must now be considered non-inherited
  alter table c1 drop column f1;
+ ERROR:  relation "c1" does not exist
  drop table p1 cascade;
! ERROR:  table "p1" does not exist
  create table p1 (f1 int, f2 int) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table c1 (f1 int not null) inherits(p1) distribute by roundrobin;
! ERROR:  relation "p1" does not exist
  -- should be rejected since c1.f1 is inherited
  alter table c1 drop column f1;
! ERROR:  relation "c1" does not exist
  alter table only p1 drop column f1;
+ ERROR:  relation "p1" does not exist
  -- c1.f1 is still there, but no longer inherited
  alter table c1 drop column f1;
+ ERROR:  relation "c1" does not exist
  drop table p1 cascade;
! ERROR:  table "p1" does not exist
  create table p1(id int, name text) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table p2(id2 int, name text, height int) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  create table c1(age int) inherits(p1,p2);
! ERROR:  relation "p1" does not exist
  create table gc1() inherits (c1);
+ ERROR:  relation "c1" does not exist
  select relname, attname, attinhcount, attislocal
  from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
  where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
  order by relname, attnum;
   relname | attname | attinhcount | attislocal 
  ---------+---------+-------------+------------
! (0 rows)
  
  -- should work
  alter table only p1 drop column name;
+ ERROR:  relation "p1" does not exist
  -- should work. Now c1.name is local and inhcount is 0.
  alter table p2 drop column name;
+ ERROR:  relation "p2" does not exist
  -- should be rejected since its inherited
  alter table gc1 drop column name;
! ERROR:  relation "gc1" does not exist
  -- should work, and drop gc1.name along
  alter table c1 drop column name;
+ ERROR:  relation "c1" does not exist
  -- should fail: column does not exist
  alter table gc1 drop column name;
! ERROR:  relation "gc1" does not exist
  -- should work and drop the attribute in all tables
  alter table p2 drop column height;
+ ERROR:  relation "p2" does not exist
  -- IF EXISTS test
  create table dropColumnExists ();
  alter table dropColumnExists drop column non_existing; --fail
***************
*** 1635,1654 ****
  order by relname, attnum;
   relname | attname | attinhcount | attislocal 
  ---------+---------+-------------+------------
!  c1      | id      |           1 | f
!  c1      | id2     |           1 | f
!  c1      | age     |           0 | t
!  gc1     | id      |           1 | f
!  gc1     | id2     |           1 | f
!  gc1     | age     |           1 | f
!  p1      | id      |           0 | t
!  p2      | id2     |           0 | t
! (8 rows)
  
  drop table p1, p2 cascade;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to table c1
! drop cascades to table gc1
  -- test attinhcount tracking with merged columns
  create table depth0();
  create table depth1(c text) inherits (depth0);
--- 1657,1666 ----
  order by relname, attnum;
   relname | attname | attinhcount | attislocal 
  ---------+---------+-------------+------------
! (0 rows)
  
  drop table p1, p2 cascade;
! ERROR:  table "p1" does not exist
  -- test attinhcount tracking with merged columns
  create table depth0();
  create table depth1(c text) inherits (depth0);
***************
*** 1799,1805 ****
  NOTICE:  merging definition of column "f2" for child "c1"
  insert into p1 values (1,2,'abc');
  insert into c1 values(11,'xyz',33,0); -- should fail
! ERROR:  new row for relation "c1" violates check constraint "p1_a1_check"
  DETAIL:  Failing row contains (11, xyz, 33, 0).
  insert into c1 values(11,'xyz',33,22);
  select * from p1 order by f1;
--- 1811,1817 ----
  NOTICE:  merging definition of column "f2" for child "c1"
  insert into p1 values (1,2,'abc');
  insert into c1 values(11,'xyz',33,0); -- should fail
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:new row for relation "c1" violates check constraint "p1_a1_check"
  DETAIL:  Failing row contains (11, xyz, 33, 0).
  insert into c1 values(11,'xyz',33,22);
  select * from p1 order by f1;
***************
*** 1862,1870 ****
  
  -- Simple tests for alter table column type
  alter table foo alter f1 TYPE integer; -- fails
! ERROR:  column "f1" cannot be cast automatically to type integer
! HINT:  You might need to specify "USING f1::integer".
  alter table foo alter f1 TYPE varchar(10);
  create table anothertab (atcol1 serial8, atcol2 boolean,
  	constraint anothertab_chk check (atcol1 <= 3));
  insert into anothertab (atcol1, atcol2) values (default, true);
--- 1874,1882 ----
  
  -- Simple tests for alter table column type
  alter table foo alter f1 TYPE integer; -- fails
! ERROR:  cannot alter type of column named in distributed key
  alter table foo alter f1 TYPE varchar(10);
+ ERROR:  cannot alter type of column named in distributed key
  create table anothertab (atcol1 serial8, atcol2 boolean,
  	constraint anothertab_chk check (atcol1 <= 3));
  insert into anothertab (atcol1, atcol2) values (default, true);
***************
*** 1877,1888 ****
  (2 rows)
  
  alter table anothertab alter column atcol1 type boolean; -- fails
! ERROR:  column "atcol1" cannot be cast automatically to type boolean
! HINT:  You might need to specify "USING atcol1::boolean".
  alter table anothertab alter column atcol1 type boolean using atcol1::int; -- fails
! ERROR:  result of USING clause for column "atcol1" cannot be cast automatically to type boolean
! HINT:  You might need to add an explicit cast.
  alter table anothertab alter column atcol1 type integer;
  select * from anothertab order by atcol1, atcol2;
   atcol1 | atcol2 
  --------+--------
--- 1889,1899 ----
  (2 rows)
  
  alter table anothertab alter column atcol1 type boolean; -- fails
! ERROR:  cannot alter type of column named in distributed key
  alter table anothertab alter column atcol1 type boolean using atcol1::int; -- fails
! ERROR:  cannot alter type of column named in distributed key
  alter table anothertab alter column atcol1 type integer;
+ ERROR:  cannot alter type of column named in distributed key
  select * from anothertab order by atcol1, atcol2;
   atcol1 | atcol2 
  --------+--------
***************
*** 1891,1897 ****
  (2 rows)
  
  insert into anothertab (atcol1, atcol2) values (45, null); -- fails
! ERROR:  new row for relation "anothertab" violates check constraint "anothertab_chk"
  DETAIL:  Failing row contains (45, null).
  insert into anothertab (atcol1, atcol2) values (default, null);
  select * from anothertab order by atcol1, atcol2;
--- 1902,1908 ----
  (2 rows)
  
  insert into anothertab (atcol1, atcol2) values (45, null); -- fails
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:new row for relation "anothertab" violates check constraint "anothertab_chk"
  DETAIL:  Failing row contains (45, null).
  insert into anothertab (atcol1, atcol2) values (default, null);
  select * from anothertab order by atcol1, atcol2;
***************
*** 1916,1927 ****
  
  alter table anothertab alter column atcol1 type boolean
          using case when atcol1 % 2 = 0 then true else false end; -- fails
! ERROR:  default for column "atcol1" cannot be cast automatically to type boolean
  alter table anothertab alter column atcol1 drop default;
  alter table anothertab alter column atcol1 type boolean
          using case when atcol1 % 2 = 0 then true else false end; -- fails
! ERROR:  operator does not exist: boolean <= integer
! HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
  alter table anothertab drop constraint anothertab_chk;
  alter table anothertab drop constraint anothertab_chk; -- fails
  ERROR:  constraint "anothertab_chk" of relation "anothertab" does not exist
--- 1927,1937 ----
  
  alter table anothertab alter column atcol1 type boolean
          using case when atcol1 % 2 = 0 then true else false end; -- fails
! ERROR:  cannot alter type of column named in distributed key
  alter table anothertab alter column atcol1 drop default;
  alter table anothertab alter column atcol1 type boolean
          using case when atcol1 % 2 = 0 then true else false end; -- fails
! ERROR:  cannot alter type of column named in distributed key
  alter table anothertab drop constraint anothertab_chk;
  alter table anothertab drop constraint anothertab_chk; -- fails
  ERROR:  constraint "anothertab_chk" of relation "anothertab" does not exist
***************
*** 1929,1940 ****
  NOTICE:  constraint "anothertab_chk" of relation "anothertab" does not exist, skipping
  alter table anothertab alter column atcol1 type boolean
          using case when atcol1 % 2 = 0 then true else false end;
  select * from anothertab order by atcol1, atcol2;
   atcol1 |    atcol2    
  --------+--------------
!  f      | IT WAS NULL!
!  f      | IT WAS TRUE
!  t      | IT WAS FALSE
  (3 rows)
  
  drop table anothertab;
--- 1939,1951 ----
  NOTICE:  constraint "anothertab_chk" of relation "anothertab" does not exist, skipping
  alter table anothertab alter column atcol1 type boolean
          using case when atcol1 % 2 = 0 then true else false end;
+ ERROR:  cannot alter type of column named in distributed key
  select * from anothertab order by atcol1, atcol2;
   atcol1 |    atcol2    
  --------+--------------
!       1 | IT WAS TRUE
!       2 | IT WAS FALSE
!       3 | IT WAS NULL!
  (3 rows)
  
  drop table anothertab;
***************
*** 1953,1964 ****
  alter table another
    alter f1 type text using f2 || ' more',
    alter f2 type bigint using f1 * 10;
  select * from another order by f1, f2;
!      f1     | f2 
! ------------+----
!  one more   | 10
!  three more | 30
!  two more   | 20
  (3 rows)
  
  drop table another;
--- 1964,1976 ----
  alter table another
    alter f1 type text using f2 || ' more',
    alter f2 type bigint using f1 * 10;
+ ERROR:  cannot alter type of column named in distributed key
  select * from another order by f1, f2;
!  f1 |  f2   
! ----+-------
!   1 | one
!   2 | two
!   3 | three
  (3 rows)
  
  drop table another;
***************
*** 1979,1985 ****
               Table "public.at_part_1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | text    |           |          | 
  Partition of: at_partitioned FOR VALUES FROM (0) TO (1000)
  Indexes:
--- 1991,1997 ----
               Table "public.at_part_1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | text    |           |          | 
  Partition of: at_partitioned FOR VALUES FROM (0) TO (1000)
  Indexes:
***************
*** 1990,1996 ****
               Table "public.at_part_2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | text    |           |          | 
  
  alter table at_partitioned attach partition at_part_2 for values from (1000) to (2000);
--- 2002,2008 ----
               Table "public.at_part_2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | text    |           |          | 
  
  alter table at_partitioned attach partition at_part_2 for values from (1000) to (2000);
***************
*** 1998,2004 ****
               Table "public.at_part_2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | text    |           |          | 
  Partition of: at_partitioned FOR VALUES FROM (1000) TO (2000)
  Indexes:
--- 2010,2016 ----
               Table "public.at_part_2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | text    |           |          | 
  Partition of: at_partitioned FOR VALUES FROM (1000) TO (2000)
  Indexes:
***************
*** 2010,2016 ****
               Table "public.at_part_1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | numeric |           |          | 
  Partition of: at_partitioned FOR VALUES FROM (0) TO (1000)
  Indexes:
--- 2022,2028 ----
               Table "public.at_part_1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | numeric |           |          | 
  Partition of: at_partitioned FOR VALUES FROM (0) TO (1000)
  Indexes:
***************
*** 2021,2027 ****
               Table "public.at_part_2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | numeric |           |          | 
  Partition of: at_partitioned FOR VALUES FROM (1000) TO (2000)
  Indexes:
--- 2033,2039 ----
               Table "public.at_part_2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | numeric |           |          | 
  Partition of: at_partitioned FOR VALUES FROM (1000) TO (2000)
  Indexes:
***************
*** 2035,2041 ****
  alter table recur1 add column f2 recur1[]; -- fails
  ERROR:  composite type recur1 cannot be made a member of itself
  create domain array_of_recur1 as recur1[];
! ERROR:  type "recur1[]" does not exist
  alter table recur1 add column f2 array_of_recur1; -- fails
  ERROR:  type "array_of_recur1" does not exist
  LINE 1: alter table recur1 add column f2 array_of_recur1;
--- 2047,2053 ----
  alter table recur1 add column f2 recur1[]; -- fails
  ERROR:  composite type recur1 cannot be made a member of itself
  create domain array_of_recur1 as recur1[];
! ERROR:  node:coord2, backend_pid:384618, nodename:coord2,backend_pid:384618,message:type "recur1[]" does not exist
  alter table recur1 add column f2 array_of_recur1; -- fails
  ERROR:  type "array_of_recur1" does not exist
  LINE 1: alter table recur1 add column f2 array_of_recur1;
***************
*** 2066,2072 ****
                 Table "public.test_inh_check"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | double precision |           |          | 
   b      | double precision |           |          | 
  Check constraints:
      "test_inh_check_a_check" CHECK (a > 10.2::double precision)
--- 2078,2084 ----
                 Table "public.test_inh_check"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | double precision |           | not null | 
   b      | double precision |           |          | 
  Check constraints:
      "test_inh_check_a_check" CHECK (a > 10.2::double precision)
***************
*** 2076,2082 ****
              Table "public.test_inh_check_child"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | double precision |           |          | 
   b      | double precision |           |          | 
  Check constraints:
      "test_inh_check_a_check" CHECK (a > 10.2::double precision)
--- 2088,2094 ----
              Table "public.test_inh_check_child"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | double precision |           | not null | 
   b      | double precision |           |          | 
  Check constraints:
      "test_inh_check_a_check" CHECK (a > 10.2::double precision)
***************
*** 2093,2116 ****
  (2 rows)
  
  ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
  \d test_inh_check
                 Table "public.test_inh_check"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | numeric          |           |          | 
   b      | double precision |           |          | 
  Check constraints:
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
  Number of child tables: 1 (Use \d+ to list them.)
  
  \d test_inh_check_child
              Table "public.test_inh_check_child"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | numeric          |           |          | 
   b      | double precision |           |          | 
  Check constraints:
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
  Inherits: test_inh_check
  
  select relname, conname, coninhcount, conislocal, connoinherit
--- 2105,2129 ----
  (2 rows)
  
  ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
+ ERROR:  cannot alter type of column named in distributed key
  \d test_inh_check
                 Table "public.test_inh_check"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | double precision |           | not null | 
   b      | double precision |           |          | 
  Check constraints:
!     "test_inh_check_a_check" CHECK (a > 10.2::double precision)
  Number of child tables: 1 (Use \d+ to list them.)
  
  \d test_inh_check_child
              Table "public.test_inh_check_child"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | double precision |           | not null | 
   b      | double precision |           |          | 
  Check constraints:
!     "test_inh_check_a_check" CHECK (a > 10.2::double precision)
  Inherits: test_inh_check
  
  select relname, conname, coninhcount, conislocal, connoinherit
***************
*** 2133,2156 ****
                 Table "public.test_inh_check"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | numeric          |           |          | 
   b      | double precision |           |          | 
  Check constraints:
      "bmerged" CHECK (b > 1::double precision)
      "bnoinherit" CHECK (b > 100::double precision) NO INHERIT
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
  Number of child tables: 1 (Use \d+ to list them.)
  
  \d test_inh_check_child
              Table "public.test_inh_check_child"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | numeric          |           |          | 
   b      | double precision |           |          | 
  Check constraints:
      "blocal" CHECK (b < 1000::double precision)
      "bmerged" CHECK (b > 1::double precision)
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
  Inherits: test_inh_check
  
  select relname, conname, coninhcount, conislocal, connoinherit
--- 2146,2169 ----
                 Table "public.test_inh_check"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | double precision |           | not null | 
   b      | double precision |           |          | 
  Check constraints:
      "bmerged" CHECK (b > 1::double precision)
      "bnoinherit" CHECK (b > 100::double precision) NO INHERIT
!     "test_inh_check_a_check" CHECK (a > 10.2::double precision)
  Number of child tables: 1 (Use \d+ to list them.)
  
  \d test_inh_check_child
              Table "public.test_inh_check_child"
   Column |       Type       | Collation | Nullable | Default 
  --------+------------------+-----------+----------+---------
!  a      | double precision |           | not null | 
   b      | double precision |           |          | 
  Check constraints:
      "blocal" CHECK (b < 1000::double precision)
      "bmerged" CHECK (b > 1::double precision)
!     "test_inh_check_a_check" CHECK (a > 10.2::double precision)
  Inherits: test_inh_check
  
  select relname, conname, coninhcount, conislocal, connoinherit
***************
*** 2170,2196 ****
  ALTER TABLE test_inh_check ALTER COLUMN b TYPE numeric;
  NOTICE:  merging constraint "bmerged" with inherited definition
  \d test_inh_check
!            Table "public.test_inh_check"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | numeric |           |          | 
!  b      | numeric |           |          | 
  Check constraints:
      "bmerged" CHECK (b::double precision > 1::double precision)
      "bnoinherit" CHECK (b::double precision > 100::double precision) NO INHERIT
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
  Number of child tables: 1 (Use \d+ to list them.)
  
  \d test_inh_check_child
!         Table "public.test_inh_check_child"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | numeric |           |          | 
!  b      | numeric |           |          | 
  Check constraints:
      "blocal" CHECK (b::double precision < 1000::double precision)
      "bmerged" CHECK (b::double precision > 1::double precision)
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
  Inherits: test_inh_check
  
  select relname, conname, coninhcount, conislocal, connoinherit
--- 2183,2209 ----
  ALTER TABLE test_inh_check ALTER COLUMN b TYPE numeric;
  NOTICE:  merging constraint "bmerged" with inherited definition
  \d test_inh_check
!                Table "public.test_inh_check"
!  Column |       Type       | Collation | Nullable | Default 
! --------+------------------+-----------+----------+---------
!  a      | double precision |           | not null | 
!  b      | numeric          |           |          | 
  Check constraints:
      "bmerged" CHECK (b::double precision > 1::double precision)
      "bnoinherit" CHECK (b::double precision > 100::double precision) NO INHERIT
!     "test_inh_check_a_check" CHECK (a > 10.2::double precision)
  Number of child tables: 1 (Use \d+ to list them.)
  
  \d test_inh_check_child
!             Table "public.test_inh_check_child"
!  Column |       Type       | Collation | Nullable | Default 
! --------+------------------+-----------+----------+---------
!  a      | double precision |           | not null | 
!  b      | numeric          |           |          | 
  Check constraints:
      "blocal" CHECK (b::double precision < 1000::double precision)
      "bmerged" CHECK (b::double precision > 1::double precision)
!     "test_inh_check_a_check" CHECK (a > 10.2::double precision)
  Inherits: test_inh_check
  
  select relname, conname, coninhcount, conislocal, connoinherit
***************
*** 2219,2231 ****
  CREATE TABLE test_type_diff2_c2 (int_eight int8, int_two int2, int_four int4);
  CREATE TABLE test_type_diff2_c3 (int_two int2, int_four int4, int_eight int8);
  ALTER TABLE test_type_diff2_c1 INHERIT test_type_diff2;
! ERROR:  table "test_type_diff2_c1" contains column "int_two" at position 3, but parent "test_type_diff2" has it at position 1
! DETAIL:  Postgres-XL requires attribute positions to match
! HINT:  Check for column ordering and dropped columns, if any
  ALTER TABLE test_type_diff2_c2 INHERIT test_type_diff2;
! ERROR:  table "test_type_diff2_c2" contains column "int_two" at position 2, but parent "test_type_diff2" has it at position 1
! DETAIL:  Postgres-XL requires attribute positions to match
! HINT:  Check for column ordering and dropped columns, if any
  ALTER TABLE test_type_diff2_c3 INHERIT test_type_diff2;
  INSERT INTO test_type_diff2_c1 VALUES (1, 2, 3);
  INSERT INTO test_type_diff2_c2 VALUES (4, 5, 6);
--- 2232,2240 ----
  CREATE TABLE test_type_diff2_c2 (int_eight int8, int_two int2, int_four int4);
  CREATE TABLE test_type_diff2_c3 (int_two int2, int_four int4, int_eight int8);
  ALTER TABLE test_type_diff2_c1 INHERIT test_type_diff2;
! ERROR:  column "int_two" in child table must be marked NOT NULL
  ALTER TABLE test_type_diff2_c2 INHERIT test_type_diff2;
! ERROR:  column "int_two" in child table must be marked NOT NULL
  ALTER TABLE test_type_diff2_c3 INHERIT test_type_diff2;
  INSERT INTO test_type_diff2_c1 VALUES (1, 2, 3);
  INSERT INTO test_type_diff2_c2 VALUES (4, 5, 6);
***************
*** 2238,2257 ****
  -- check for rollback of ANALYZE corrupting table property flags (bug #11638)
  CREATE TABLE check_fk_presence_1 (id int PRIMARY KEY, t text);
  CREATE TABLE check_fk_presence_2 (id int REFERENCES check_fk_presence_1, t text);
  BEGIN;
  ALTER TABLE check_fk_presence_2 DROP CONSTRAINT check_fk_presence_2_id_fkey;
  ANALYZE check_fk_presence_2;
  ROLLBACK;
  \d check_fk_presence_2
-         Table "public.check_fk_presence_2"
-  Column |  Type   | Collation | Nullable | Default 
- --------+---------+-----------+----------+---------
-  id     | integer |           |          | 
-  t      | text    |           |          | 
- Foreign-key constraints:
-     "check_fk_presence_2_id_fkey" FOREIGN KEY (id) REFERENCES check_fk_presence_1(id)
- 
  DROP TABLE check_fk_presence_1, check_fk_presence_2;
  --
  -- lock levels
  --
--- 2247,2262 ----
  -- check for rollback of ANALYZE corrupting table property flags (bug #11638)
  CREATE TABLE check_fk_presence_1 (id int PRIMARY KEY, t text);
  CREATE TABLE check_fk_presence_2 (id int REFERENCES check_fk_presence_1, t text);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  BEGIN;
  ALTER TABLE check_fk_presence_2 DROP CONSTRAINT check_fk_presence_2_id_fkey;
+ ERROR:  relation "check_fk_presence_2" does not exist
  ANALYZE check_fk_presence_2;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  \d check_fk_presence_2
  DROP TABLE check_fk_presence_1, check_fk_presence_2;
+ ERROR:  table "check_fk_presence_2" does not exist
  --
  -- lock levels
  --
***************
*** 2386,2395 ****
  	for each row
  	execute procedure
  	ttdummy (1, 1);
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  select * from my_locks order by 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  rollback;
  begin;
  select * from my_locks order by 1;
--- 2391,2402 ----
  	for each row
  	execute procedure
  	ttdummy (1, 1);
  select * from my_locks order by 1;
!   relname  |     max_lockmode      
! -----------+-----------------------
!  alterlock | ShareRowExclusiveLock
! (1 row)
! 
  rollback;
  begin;
  select * from my_locks order by 1;
***************
*** 2398,2419 ****
  (0 rows)
  
  alter table alterlock2 add foreign key (f1) references alterlock (f1);
- ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  select * from my_locks order by 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  rollback;
  begin;
  alter table alterlock2
  add constraint alterlock2nv foreign key (f1) references alterlock (f1) NOT VALID;
- ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  select * from my_locks order by 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  commit;
  begin;
  alter table alterlock2 validate constraint alterlock2nv;
- ERROR:  constraint "alterlock2nv" of relation "alterlock2" does not exist
  select * from my_locks order by 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  rollback;
  create or replace view my_locks as
  select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
--- 2405,2442 ----
  (0 rows)
  
  alter table alterlock2 add foreign key (f1) references alterlock (f1);
  select * from my_locks order by 1;
!      relname     |     max_lockmode      
! -----------------+-----------------------
!  alterlock       | ShareRowExclusiveLock
!  alterlock2      | ShareRowExclusiveLock
!  alterlock2_pkey | AccessShareLock
!  alterlock_pkey  | AccessShareLock
! (4 rows)
! 
  rollback;
  begin;
  alter table alterlock2
  add constraint alterlock2nv foreign key (f1) references alterlock (f1) NOT VALID;
  select * from my_locks order by 1;
!   relname   |     max_lockmode      
! ------------+-----------------------
!  alterlock  | ShareRowExclusiveLock
!  alterlock2 | ShareRowExclusiveLock
! (2 rows)
! 
  commit;
  begin;
  alter table alterlock2 validate constraint alterlock2nv;
  select * from my_locks order by 1;
!      relname     |       max_lockmode       
! -----------------+--------------------------
!  alterlock       | RowShareLock
!  alterlock2      | ShareUpdateExclusiveLock
!  alterlock2_pkey | AccessShareLock
!  alterlock_pkey  | AccessShareLock
! (4 rows)
! 
  rollback;
  create or replace view my_locks as
  select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
***************
*** 2635,2641 ****
   d      | boolean |           |          | 
  
  ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
! ERROR:  column "a" does not exist
  ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
  \d test_type
           Composite type "public.test_type"
--- 2658,2664 ----
   d      | boolean |           |          | 
  
  ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
! ERROR:  node:datanode_2, backend_pid:384671, nodename:coord2,backend_pid:384618,message:column "a" does not exist
  ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
  \d test_type
           Composite type "public.test_type"
***************
*** 2732,2738 ****
  Typed table of type: test_type2
  
  ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails
! ERROR:  cannot alter type "test_type2" because it is the type of a typed table
  HINT:  Use ALTER ... CASCADE to alter the typed tables too.
  ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
  \d test_type2
--- 2755,2761 ----
  Typed table of type: test_type2
  
  ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails
! ERROR:  node:datanode_2, backend_pid:384671, nodename:coord2,backend_pid:384618,message:cannot alter type "test_type2" because it is the type of a typed table
  HINT:  Use ALTER ... CASCADE to alter the typed tables too.
  ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
  \d test_type2
***************
*** 2803,2809 ****
                     Table "public.tt7"
   Column |     Type     | Collation | Nullable | Default 
  --------+--------------+-----------+----------+---------
!  x      | integer      |           |          | 
   y      | numeric(8,2) |           |          | 
  
  -- make sure we can drop a constraint on the parent but it remains on the child
--- 2826,2832 ----
                     Table "public.tt7"
   Column |     Type     | Collation | Nullable | Default 
  --------+--------------+-----------+----------+---------
!  x      | integer      |           | not null | 
   y      | numeric(8,2) |           |          | 
  
  -- make sure we can drop a constraint on the parent but it remains on the child
***************
*** 2812,2818 ****
  ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT "test_drop_constr_parent_c_check";
  -- should fail
  INSERT INTO test_drop_constr_child (c) VALUES (NULL);
! ERROR:  new row for relation "test_drop_constr_child" violates check constraint "test_drop_constr_parent_c_check"
  DETAIL:  Failing row contains (null).
  DROP TABLE test_drop_constr_parent CASCADE;
  NOTICE:  drop cascades to table test_drop_constr_child
--- 2835,2841 ----
  ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT "test_drop_constr_parent_c_check";
  -- should fail
  INSERT INTO test_drop_constr_child (c) VALUES (NULL);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:null value in column "c" violates not-null constraint
  DETAIL:  Failing row contains (null).
  DROP TABLE test_drop_constr_parent CASCADE;
  NOTICE:  drop cascades to table test_drop_constr_child
***************
*** 2844,2850 ****
                  Table "alter2.tt8"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   f1     | integer |           |          | 0
  Check constraints:
      "tt8_f_check" CHECK (f1 >= 0 AND f1 <= 10)
--- 2867,2873 ----
                  Table "alter2.tt8"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   f1     | integer |           |          | 0
  Check constraints:
      "tt8_f_check" CHECK (f1 >= 0 AND f1 <= 10)
***************
*** 2890,2896 ****
--- 2913,2921 ----
  ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE int;
  ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE text;
  ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int;
+ ERROR:  cannot alter type of column named in distributed key
  ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
+ ERROR:  cannot alter type of column named in distributed key
  ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE int;
  ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE bigint;
  -- Check that the comments are intact.
***************
*** 2919,2952 ****
  -- to an error and would reduce the test scope.
  CREATE TABLE comment_test_child (
    id text CONSTRAINT comment_test_child_fk REFERENCES comment_test);
  CREATE INDEX comment_test_child_fk ON comment_test_child(id);
  COMMENT ON COLUMN comment_test_child.id IS 'Column ''id'' on comment_test_child';
  COMMENT ON INDEX comment_test_child_fk IS 'Index backing the FOREIGN KEY of comment_test_child';
  COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'FOREIGN KEY constraint of comment_test_child';
  -- Change column type of parent
  ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
  ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int USING id::integer;
! ERROR:  foreign key constraint "comment_test_child_fk" cannot be implemented
! DETAIL:  Key columns "id" and "id" are of incompatible types: text and integer.
  -- Comments should be intact
  SELECT col_description('comment_test_child'::regclass, 1) as comment;
!               comment              
! -----------------------------------
!  Column 'id' on comment_test_child
! (1 row)
! 
  SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
!          index         |                       comment                       
! -----------------------+-----------------------------------------------------
!  comment_test_child_fk | Index backing the FOREIGN KEY of comment_test_child
! (1 row)
! 
  SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
!       constraint       |                   comment                    
! -----------------------+----------------------------------------------
!  comment_test_child_fk | FOREIGN KEY constraint of comment_test_child
! (1 row)
! 
  -- Check that we map relation oids to filenodes and back correctly.  Only
  -- display bad mappings so the test output doesn't change all the time.  A
  -- filenode function call can return NULL for a relation dropped concurrently
--- 2944,2976 ----
  -- to an error and would reduce the test scope.
  CREATE TABLE comment_test_child (
    id text CONSTRAINT comment_test_child_fk REFERENCES comment_test);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  CREATE INDEX comment_test_child_fk ON comment_test_child(id);
+ ERROR:  relation "comment_test_child" does not exist
  COMMENT ON COLUMN comment_test_child.id IS 'Column ''id'' on comment_test_child';
+ ERROR:  relation "comment_test_child" does not exist
  COMMENT ON INDEX comment_test_child_fk IS 'Index backing the FOREIGN KEY of comment_test_child';
+ ERROR:  relation "comment_test_child_fk" does not exist
  COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'FOREIGN KEY constraint of comment_test_child';
+ ERROR:  relation "comment_test_child" does not exist
  -- Change column type of parent
  ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
+ ERROR:  cannot alter type of column named in distributed key
  ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int USING id::integer;
! ERROR:  cannot alter type of column named in distributed key
  -- Comments should be intact
  SELECT col_description('comment_test_child'::regclass, 1) as comment;
! ERROR:  relation "comment_test_child" does not exist
! LINE 1: SELECT col_description('comment_test_child'::regclass, 1) as...
!                                ^
  SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
! ERROR:  relation "comment_test_child" does not exist
! LINE 1: ...class') as comment FROM pg_index where indrelid = 'comment_t...
!                                                              ^
  SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
! ERROR:  relation "comment_test_child" does not exist
! LINE 1: ...') as comment FROM pg_constraint where conrelid = 'comment_t...
!                                                              ^
  -- Check that we map relation oids to filenodes and back correctly.  Only
  -- display bad mappings so the test output doesn't change all the time.  A
  -- filenode function call can return NULL for a relation dropped concurrently
***************
*** 3017,3026 ****
  (5 rows)
  
  CREATE UNLOGGED TABLE unlogged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged1) DISTRIBUTE BY REPLICATION; -- foreign key
  CREATE UNLOGGED TABLE unlogged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged3); -- self-referencing foreign key
  ALTER TABLE unlogged3 SET LOGGED; -- skip self-referencing foreign key
  ALTER TABLE unlogged2 SET LOGGED; -- fails because a foreign key to an unlogged table exists
! ERROR:  could not change table "unlogged2" to logged because it references unlogged table "unlogged1"
  ALTER TABLE unlogged1 SET LOGGED;
  -- check relpersistence of an unlogged table after changing to permanent
  SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
--- 3041,3053 ----
  (5 rows)
  
  CREATE UNLOGGED TABLE unlogged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged1) DISTRIBUTE BY REPLICATION; -- foreign key
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  CREATE UNLOGGED TABLE unlogged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged3); -- self-referencing foreign key
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  ALTER TABLE unlogged3 SET LOGGED; -- skip self-referencing foreign key
+ ERROR:  relation "unlogged3" does not exist
  ALTER TABLE unlogged2 SET LOGGED; -- fails because a foreign key to an unlogged table exists
! ERROR:  relation "unlogged2" does not exist
  ALTER TABLE unlogged1 SET LOGGED;
  -- check relpersistence of an unlogged table after changing to permanent
  SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
***************
*** 3040,3046 ****
--- 3067,3075 ----
  
  ALTER TABLE unlogged1 SET LOGGED; -- silently do nothing
  DROP TABLE unlogged3;
+ ERROR:  table "unlogged3" does not exist
  DROP TABLE unlogged2;
+ ERROR:  table "unlogged2" does not exist
  DROP TABLE unlogged1;
  -- set unlogged
  CREATE TABLE logged1(f1 SERIAL PRIMARY KEY, f2 TEXT) DISTRIBUTE BY REPLICATION;
***************
*** 3061,3071 ****
  (5 rows)
  
  CREATE TABLE logged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged1) DISTRIBUTE BY REPLICATION; -- foreign key
  CREATE TABLE logged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged3); -- self-referencing foreign key
  ALTER TABLE logged1 SET UNLOGGED; -- fails because a foreign key from a permanent table exists
- ERROR:  could not change table "logged1" to unlogged because it references logged table "logged2"
  ALTER TABLE logged3 SET UNLOGGED; -- skip self-referencing foreign key
  ALTER TABLE logged2 SET UNLOGGED;
  ALTER TABLE logged1 SET UNLOGGED;
  -- check relpersistence of a permanent table after changing to unlogged
  SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
--- 3090,3103 ----
  (5 rows)
  
  CREATE TABLE logged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged1) DISTRIBUTE BY REPLICATION; -- foreign key
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  CREATE TABLE logged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged3); -- self-referencing foreign key
+ ERROR:  ADD ForeignKeyConstraint on replication table is forbidden
  ALTER TABLE logged1 SET UNLOGGED; -- fails because a foreign key from a permanent table exists
  ALTER TABLE logged3 SET UNLOGGED; -- skip self-referencing foreign key
+ ERROR:  relation "logged3" does not exist
  ALTER TABLE logged2 SET UNLOGGED;
+ ERROR:  relation "logged2" does not exist
  ALTER TABLE logged1 SET UNLOGGED;
  -- check relpersistence of a permanent table after changing to unlogged
  SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
***************
*** 3085,3091 ****
--- 3117,3125 ----
  
  ALTER TABLE logged1 SET UNLOGGED; -- silently do nothing
  DROP TABLE logged3;
+ ERROR:  table "logged3" does not exist
  DROP TABLE logged2;
+ ERROR:  table "logged2" does not exist
  DROP TABLE logged1;
  -- test ADD COLUMN IF NOT EXISTS
  CREATE TABLE test_add_column(c1 integer);
***************
*** 3093,3099 ****
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
  
  ALTER TABLE test_add_column
  	ADD COLUMN c2 integer;
--- 3127,3133 ----
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           | not null | 
  
  ALTER TABLE test_add_column
  	ADD COLUMN c2 integer;
***************
*** 3101,3107 ****
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
   c2     | integer |           |          | 
  
  ALTER TABLE test_add_column
--- 3135,3141 ----
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           | not null | 
   c2     | integer |           |          | 
  
  ALTER TABLE test_add_column
***************
*** 3111,3117 ****
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
   c2     | integer |           |          | 
  
  ALTER TABLE test_add_column
--- 3145,3151 ----
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           | not null | 
   c2     | integer |           |          | 
  
  ALTER TABLE test_add_column
***************
*** 3121,3127 ****
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
   c2     | integer |           |          | 
  
  ALTER TABLE test_add_column
--- 3155,3161 ----
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           | not null | 
   c2     | integer |           |          | 
  
  ALTER TABLE test_add_column
***************
*** 3132,3138 ****
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
   c2     | integer |           |          | 
  
  ALTER TABLE test_add_column
--- 3166,3172 ----
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           | not null | 
   c2     | integer |           |          | 
  
  ALTER TABLE test_add_column
***************
*** 3143,3149 ****
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
   c2     | integer |           |          | 
   c3     | integer |           |          | 
  
--- 3177,3183 ----
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           | not null | 
   c2     | integer |           |          | 
   c3     | integer |           |          | 
  
***************
*** 3156,3162 ****
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
   c2     | integer |           |          | 
   c3     | integer |           |          | 
  
--- 3190,3196 ----
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           | not null | 
   c2     | integer |           |          | 
   c3     | integer |           |          | 
  
***************
*** 3170,3176 ****
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
   c2     | integer |           |          | 
   c3     | integer |           |          | 
   c4     | integer |           |          | 
--- 3204,3210 ----
            Table "public.test_add_column"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  c1     | integer |           | not null | 
   c2     | integer |           |          | 
   c3     | integer |           |          | 
   c4     | integer |           |          | 
***************
*** 3310,3315 ****
--- 3344,3350 ----
  DETAIL:  Postgres-XL requires attribute positions to match
  HINT:  Check for column ordering and dropped columns, if any
  ALTER TABLE fail_part ALTER b TYPE char (2) COLLATE "POSIX";
+ ERROR:  cannot alter type of column named in distributed key
  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
  ERROR:  table "fail_part" contains column "a" at position 2, but parent "list_parted" has it at position 1
  DETAIL:  Postgres-XL requires attribute positions to match
***************
*** 3374,3380 ****
  CREATE TABLE part_2 (LIKE list_parted2);
  INSERT INTO part_2 VALUES (3, 'a');
  ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
! ERROR:  partition constraint is violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM part_2;
  ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
--- 3409,3415 ----
  CREATE TABLE part_2 (LIKE list_parted2);
  INSERT INTO part_2 VALUES (3, 'a');
  ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:partition constraint is violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM part_2;
  ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
***************
*** 3383,3389 ****
  INSERT INTO list_parted2_def VALUES (11, 'z');
  CREATE TABLE part_3 (LIKE list_parted2);
  ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
! ERROR:  updated partition constraint for default partition would be violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM list_parted2_def WHERE a = 11;
  ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
--- 3418,3424 ----
  INSERT INTO list_parted2_def VALUES (11, 'z');
  CREATE TABLE part_3 (LIKE list_parted2);
  ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:updated partition constraint for default partition would be violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM list_parted2_def WHERE a = 11;
  ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
***************
*** 3397,3402 ****
--- 3432,3438 ----
  -- an explicit NOT NULL constraint on the partition key column for the
  -- validation scan to be skipped;
  ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
+ INFO:  partition constraint for table "part_3_4" is implied by existing constraints
  -- adding a NOT NULL constraint will cause the scan to be skipped
  ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
  ALTER TABLE part_3_4 ALTER a SET NOT NULL;
***************
*** 3419,3425 ****
  INSERT INTO part1 VALUES (1, 10);
  -- Remember the TO bound is exclusive
  ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
! ERROR:  partition constraint is violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM part1;
  ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
--- 3455,3461 ----
  INSERT INTO part1 VALUES (1, 10);
  -- Remember the TO bound is exclusive
  ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:partition constraint is violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM part1;
  ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
***************
*** 3441,3447 ****
  INSERT INTO partr_def1 VALUES (2, 10);
  CREATE TABLE part3 (LIKE range_parted);
  ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (2, 10) TO (2, 20);
! ERROR:  updated partition constraint for default partition would be violated by some row
  -- Attaching partitions should be successful when there are no overlapping rows
  ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (3, 10) TO (3, 20);
  -- check that leaf partitions are scanned when attaching a partitioned
--- 3477,3483 ----
  INSERT INTO partr_def1 VALUES (2, 10);
  CREATE TABLE part3 (LIKE range_parted);
  ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (2, 10) TO (2, 20);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:updated partition constraint for default partition would be violated by some row
  -- Attaching partitions should be successful when there are no overlapping rows
  ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (3, 10) TO (3, 20);
  -- check that leaf partitions are scanned when attaching a partitioned
***************
*** 3453,3459 ****
  CREATE TABLE part_5_a PARTITION OF part_5 FOR VALUES IN ('a');
  INSERT INTO part_5_a (a, b) VALUES (6, 'a');
  ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
! ERROR:  partition constraint is violated by some row
  -- delete the faulting row and also add a constraint to skip the scan
  DELETE FROM part_5_a WHERE a NOT IN (3);
  ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 5);
--- 3489,3495 ----
  CREATE TABLE part_5_a PARTITION OF part_5 FOR VALUES IN ('a');
  INSERT INTO part_5_a (a, b) VALUES (6, 'a');
  ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:partition constraint is violated by some row
  -- delete the faulting row and also add a constraint to skip the scan
  DELETE FROM part_5_a WHERE a NOT IN (3);
  ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 5);
***************
*** 3513,3519 ****
  
  ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
  INFO:  updated partition constraint for default partition "list_parted2_def" is implied by existing constraints
! ERROR:  partition constraint is violated by some row
  -- check that leaf partitions of default partition are scanned when
  -- attaching a partitioned table.
  ALTER TABLE part_5 DROP CONSTRAINT check_a;
--- 3549,3555 ----
  
  ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
  INFO:  updated partition constraint for default partition "list_parted2_def" is implied by existing constraints
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:partition constraint is violated by some row
  -- check that leaf partitions of default partition are scanned when
  -- attaching a partitioned table.
  ALTER TABLE part_5 DROP CONSTRAINT check_a;
***************
*** 3522,3528 ****
  INSERT INTO part5_def_p1 VALUES (5, 'y');
  CREATE TABLE part5_p1 (LIKE part_5);
  ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
! ERROR:  updated partition constraint for default partition would be violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM part5_def_p1 WHERE b = 'y';
  ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
--- 3558,3564 ----
  INSERT INTO part5_def_p1 VALUES (5, 'y');
  CREATE TABLE part5_p1 (LIKE part_5);
  ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:updated partition constraint for default partition would be violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM part5_def_p1 WHERE b = 'y';
  ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
***************
*** 3583,3589 ****
  CREATE TABLE hpart_2 (LIKE hash_parted);
  INSERT INTO hpart_2 VALUES (3, 0);
  ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
! ERROR:  partition constraint is violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM hpart_2;
  ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
--- 3619,3625 ----
  CREATE TABLE hpart_2 (LIKE hash_parted);
  INSERT INTO hpart_2 VALUES (3, 0);
  ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:partition constraint is violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM hpart_2;
  ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
***************
*** 3596,3602 ****
  CREATE TABLE hpart_5_a PARTITION OF hpart_5 FOR VALUES IN ('1', '2', '3');
  INSERT INTO hpart_5_a (a, b) VALUES (7, 1);
  ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
! ERROR:  partition constraint is violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM hpart_5_a;
  ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
--- 3632,3638 ----
  CREATE TABLE hpart_5_a PARTITION OF hpart_5 FOR VALUES IN ('1', '2', '3');
  INSERT INTO hpart_5_a (a, b) VALUES (7, 1);
  ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:partition constraint is violated by some row
  -- should be ok after deleting the bad row
  DELETE FROM hpart_5_a;
  ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
***************
*** 3675,3681 ****
  ERROR:  cannot drop inherited column "b"
  -- Nor rename, alter type
  ALTER TABLE part_2 RENAME COLUMN b to c;
! ERROR:  cannot rename inherited column "b"
  ALTER TABLE part_2 ALTER COLUMN b TYPE text;
  ERROR:  cannot alter inherited column "b"
  -- cannot add/drop NOT NULL or check constraints to *only* the parent, when
--- 3711,3717 ----
  ERROR:  cannot drop inherited column "b"
  -- Nor rename, alter type
  ALTER TABLE part_2 RENAME COLUMN b to c;
! ERROR:  node:datanode_2, backend_pid:384671, nodename:coord2,backend_pid:384618,message:cannot rename inherited column "b"
  ALTER TABLE part_2 ALTER COLUMN b TYPE text;
  ERROR:  cannot alter inherited column "b"
  -- cannot add/drop NOT NULL or check constraints to *only* the parent, when
***************
*** 3765,3771 ****
  DETAIL:  Postgres-XL requires attribute positions to match
  HINT:  Check for column ordering and dropped columns, if any
  insert into p1 (a, b) values (2, 3);
! ERROR:  no partition of relation "p1" found for row
  DETAIL:  Partition key of the failing row contains (b) = (3).
  -- check that partition validation scan correctly detects violating rows
  alter table p attach partition p1 for values from (1, 2) to (1, 10);
--- 3801,3807 ----
  DETAIL:  Postgres-XL requires attribute positions to match
  HINT:  Check for column ordering and dropped columns, if any
  insert into p1 (a, b) values (2, 3);
! ERROR:  node:datanode_2, backend_pid:384671, nodename:datanode_2,backend_pid:384671,message:no partition of relation "p1" found for row
  DETAIL:  Partition key of the failing row contains (b) = (3).
  -- check that partition validation scan correctly detects violating rows
  alter table p attach partition p1 for values from (1, 2) to (1, 10);
***************
*** 3790,3796 ****
  -- error because its constraint as the default partition would be violated
  -- by the row containing 1
  alter table defpart_attach_test attach partition defpart_attach_test_d default;
! ERROR:  partition constraint is violated by some row
  delete from defpart_attach_test_d where a = 1;
  alter table defpart_attach_test_d add check (a > 1);
  -- should be attached successfully and without needing to be scanned
--- 3826,3832 ----
  -- error because its constraint as the default partition would be violated
  -- by the row containing 1
  alter table defpart_attach_test attach partition defpart_attach_test_d default;
! ERROR:  node:datanode_1, backend_pid:384666, nodename:datanode_1,backend_pid:384666,message:partition constraint is violated by some row
  delete from defpart_attach_test_d where a = 1;
  alter table defpart_attach_test_d add check (a > 1);
  -- should be attached successfully and without needing to be scanned
***************
*** 3814,3820 ****
  drop function at_test_sql_partop;
  -- remote dml with dropped column
  create table dropped_col_remote_dml (a int, b int, c int) distribute by shard(a);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into dropped_col_remote_dml values(1,1,1);
  create or replace function dropped_col_remote_dml_func() returns trigger as
  $$
--- 3850,3855 ----
***************
*** 3833,3839 ****
  drop function dropped_col_remote_dml_func;
  -- add column with default values and check shardid
  create table t_default_shardid(a int, b int) distribute by shard(a);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into t_default_shardid values(1,1), (2,2), (3,3);
  select shardid, a, b from t_default_shardid order by 1;
   shardid | a | b 
--- 3868,3873 ----

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/sequence.out"	2025-07-31 16:07:15.002067866 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/sequence.out"	2025-07-31 16:40:04.531334212 +0800
***************
*** 77,83 ****
  INSERT INTO serialTest1 VALUES ('bar');
  INSERT INTO serialTest1 VALUES ('force', 100);
  INSERT INTO serialTest1 VALUES ('wrong', NULL);
! ERROR:  null value in column "f2" violates not-null constraint
  DETAIL:  Failing row contains (wrong, null).
  SELECT * FROM serialTest1 ORDER BY f1, f2;
    f1   | f2  
--- 77,83 ----
  INSERT INTO serialTest1 VALUES ('bar');
  INSERT INTO serialTest1 VALUES ('force', 100);
  INSERT INTO serialTest1 VALUES ('wrong', NULL);
! ERROR:  node:datanode_2, backend_pid:384359, nodename:datanode_2,backend_pid:384359,message:null value in column "f2" violates not-null constraint
  DETAIL:  Failing row contains (wrong, null).
  SELECT * FROM serialTest1 ORDER BY f1, f2;
    f1   | f2  
***************
*** 100,127 ****
  -- All these INSERTs should fail:
  INSERT INTO serialTest2 (f1, f3)
    VALUES ('bogus', -32769);
! ERROR:  smallint out of range
  INSERT INTO serialTest2 (f1, f4)
    VALUES ('bogus', -32769);
! ERROR:  smallint out of range
  INSERT INTO serialTest2 (f1, f3)
    VALUES ('bogus', 32768);
! ERROR:  smallint out of range
  INSERT INTO serialTest2 (f1, f4)
    VALUES ('bogus', 32768);
! ERROR:  smallint out of range
  INSERT INTO serialTest2 (f1, f5)
    VALUES ('bogus', -9223372036854775809);
! ERROR:  bigint out of range
  INSERT INTO serialTest2 (f1, f6)
    VALUES ('bogus', -9223372036854775809);
! ERROR:  bigint out of range
  INSERT INTO serialTest2 (f1, f5)
    VALUES ('bogus', 9223372036854775808);
! ERROR:  bigint out of range
  INSERT INTO serialTest2 (f1, f6)
    VALUES ('bogus', 9223372036854775808);
! ERROR:  bigint out of range
  SELECT * FROM serialTest2 ORDER BY f2 ASC;
        f1       |     f2      |   f3   |   f4   |          f5          |          f6          
  ---------------+-------------+--------+--------+----------------------+----------------------
--- 100,127 ----
  -- All these INSERTs should fail:
  INSERT INTO serialTest2 (f1, f3)
    VALUES ('bogus', -32769);
! ERROR:  node:datanode_2, backend_pid:384359, nodename:datanode_2,backend_pid:384359,message:smallint out of range
  INSERT INTO serialTest2 (f1, f4)
    VALUES ('bogus', -32769);
! ERROR:  node:datanode_2, backend_pid:384359, nodename:datanode_2,backend_pid:384359,message:smallint out of range
  INSERT INTO serialTest2 (f1, f3)
    VALUES ('bogus', 32768);
! ERROR:  node:datanode_2, backend_pid:384359, nodename:datanode_2,backend_pid:384359,message:smallint out of range
  INSERT INTO serialTest2 (f1, f4)
    VALUES ('bogus', 32768);
! ERROR:  node:datanode_2, backend_pid:384359, nodename:datanode_2,backend_pid:384359,message:smallint out of range
  INSERT INTO serialTest2 (f1, f5)
    VALUES ('bogus', -9223372036854775809);
! ERROR:  node:datanode_2, backend_pid:384359, nodename:datanode_2,backend_pid:384359,message:bigint out of range
  INSERT INTO serialTest2 (f1, f6)
    VALUES ('bogus', -9223372036854775809);
! ERROR:  node:datanode_2, backend_pid:384359, nodename:datanode_2,backend_pid:384359,message:bigint out of range
  INSERT INTO serialTest2 (f1, f5)
    VALUES ('bogus', 9223372036854775808);
! ERROR:  node:datanode_2, backend_pid:384359, nodename:datanode_2,backend_pid:384359,message:bigint out of range
  INSERT INTO serialTest2 (f1, f6)
    VALUES ('bogus', 9223372036854775808);
! ERROR:  node:datanode_2, backend_pid:384359, nodename:datanode_2,backend_pid:384359,message:bigint out of range
  SELECT * FROM serialTest2 ORDER BY f2 ASC;
        f1       |     f2      |   f3   |   f4   |          f5          |          f6          
  ---------------+-------------+--------+--------+----------------------+----------------------

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/rowtypes_1.out"	2025-07-31 16:07:14.999067914 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/rowtypes.out"	2025-07-31 16:39:55.793519509 +0800
***************
*** 305,311 ****
  reset enable_sort;
  -- Check row comparisons with IN
  select * from int8_tbl i8 where i8 in (row(123,456));  -- fail, type mismatch
! ERROR:  cannot compare dissimilar column types bigint and integer at record column 1
  explain (costs off, nodes off)
  select * from int8_tbl i8
  where i8 in (row(123,456)::int8_tbl, '(4567890123456789,123)');
--- 305,311 ----
  reset enable_sort;
  -- Check row comparisons with IN
  select * from int8_tbl i8 where i8 in (row(123,456));  -- fail, type mismatch
! ERROR:  node:datanode_1, backend_pid:383291, nodename:datanode_1,backend_pid:383291,message:cannot compare dissimilar column types bigint and integer at record column 1
  explain (costs off, nodes off)
  select * from int8_tbl i8
  where i8 in (row(123,456)::int8_tbl, '(4567890123456789,123)');
***************
*** 422,428 ****
  create function fcompos1(v compos) returns void as $$
  insert into compos values (v.*);
  $$ language sql;
! ERROR:  type compos does not exist
  create function fcompos2(v compos) returns void as $$
  select fcompos1(v);
  $$ language sql;
--- 422,428 ----
  create function fcompos1(v compos) returns void as $$
  insert into compos values (v.*);
  $$ language sql;
! ERROR:  node:coord2, backend_pid:384616, nodename:coord2,backend_pid:384616,message:type compos does not exist
  create function fcompos2(v compos) returns void as $$
  select fcompos1(v);
  $$ language sql;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/returning.out"	2025-07-31 16:07:14.998067930 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/returning.out"	2025-07-31 16:39:55.933516538 +0800
***************
*** 314,320 ****
      RETURNING foo.*, other;
  UPDATE joinview SET f1 = f1 + 1 WHERE f3 = 57 RETURNING *, other + 1;
  ERROR:  could not plan this distributed UPDATE/DELETE
! DETAIL:  correlated or complex UPDATE/DELETE is currently not supported in Postgres-XL.
  SELECT * FROM joinview ORDER BY f1;
   f1 |  f2  | f3 | f4  | other 
  ----+------+----+-----+-------
--- 314,320 ----
      RETURNING foo.*, other;
  UPDATE joinview SET f1 = f1 + 1 WHERE f3 = 57 RETURNING *, other + 1;
  ERROR:  could not plan this distributed UPDATE/DELETE
! DETAIL:  correlated or complex UPDATE/DELETE is currently not supported in OpenTenBase.
  SELECT * FROM joinview ORDER BY f1;
   f1 |  f2  | f3 | f4  | other 
  ----+------+----+-----+-------

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xml_1.out"	2025-07-31 16:07:15.011067723 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xml.out"	2025-07-31 16:39:56.132512315 +0800
***************
*** 914,923 ****
             FROM xmldata) x,
      LATERAL XMLTABLE(('/ROWS/ROW'::text) PASSING (x.data) COLUMNS id integer PATH ('@id'::text), _id FOR ORDINALITY, country_name text PATH ('COUNTRY_NAME'::text) NOT NULL, country_id text PATH ('COUNTRY_ID'::text), region_id integer PATH ('REGION_ID'::text), size double precision PATH ('SIZE'::text), unit text PATH ('SIZE/@unit'::text), premier_name text DEFAULT ('not specified'::text) PATH ('PREMIER_NAME'::text))
  EXPLAIN (COSTS OFF) SELECT * FROM xmltableview1;
!                         QUERY PLAN                         
! -----------------------------------------------------------
   Nested Loop
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
           ->  Seq Scan on xmldata
     ->  Table Function Scan on "xmltable"
  (4 rows)
--- 914,923 ----
             FROM xmldata) x,
      LATERAL XMLTABLE(('/ROWS/ROW'::text) PASSING (x.data) COLUMNS id integer PATH ('@id'::text), _id FOR ORDINALITY, country_name text PATH ('COUNTRY_NAME'::text) NOT NULL, country_id text PATH ('COUNTRY_ID'::text), region_id integer PATH ('REGION_ID'::text), size double precision PATH ('SIZE'::text), unit text PATH ('SIZE/@unit'::text), premier_name text DEFAULT ('not specified'::text) PATH ('PREMIER_NAME'::text))
  EXPLAIN (COSTS OFF) SELECT * FROM xmltableview1;
!                    QUERY PLAN                   
! ------------------------------------------------
   Nested Loop
!    ->  Remote Subquery Scan on all (datanode_1)
           ->  Seq Scan on xmldata
     ->  Table Function Scan on "xmltable"
  (4 rows)
***************
*** 927,933 ****
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   Nested Loop
     Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
           Output: xmldata.data
           ->  Seq Scan on public.xmldata
                 Output: xmldata.data
--- 927,933 ----
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   Nested Loop
     Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name
!    ->  Remote Subquery Scan on all (datanode_1)
           Output: xmldata.data
           ->  Seq Scan on public.xmldata
                 Output: xmldata.data
***************
*** 1071,1077 ****
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   Nested Loop
     Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
           Output: xmldata.data
           ->  Seq Scan on public.xmldata
                 Output: xmldata.data
--- 1071,1077 ----
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   Nested Loop
     Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name
!    ->  Remote Subquery Scan on all (datanode_1)
           Output: xmldata.data
           ->  Seq Scan on public.xmldata
                 Output: xmldata.data
***************
*** 1092,1098 ****
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   Nested Loop
     Output: "xmltable"."COUNTRY_NAME", "xmltable"."REGION_ID"
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
           Output: xmldata.data
           ->  Seq Scan on public.xmldata
                 Output: xmldata.data
--- 1092,1098 ----
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   Nested Loop
     Output: "xmltable"."COUNTRY_NAME", "xmltable"."REGION_ID"
!    ->  Remote Subquery Scan on all (datanode_1)
           Output: xmldata.data
           ->  Seq Scan on public.xmldata
                 Output: xmldata.data
***************
*** 1193,1199 ****
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   Nested Loop
     Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name
!    ->  Remote Subquery Scan on all (datanode_1,datanode_2)
           Output: xmldata.data
           ->  Seq Scan on public.xmldata
                 Output: xmldata.data
--- 1193,1199 ----
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   Nested Loop
     Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name
!    ->  Remote Subquery Scan on all (datanode_1)
           Output: xmldata.data
           ->  Seq Scan on public.xmldata
                 Output: xmldata.data

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/identity_1.out"	2025-07-31 16:07:14.985068136 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/identity.out"	2025-07-31 16:40:11.192193151 +0800
***************
*** 28,36 ****
  
  CREATE TABLE itest4 (a int, b text);
  ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- error, requires NOT NULL
- ERROR:  column "a" of relation "itest4" must be declared NOT NULL before identity can be added
  ALTER TABLE itest4 ALTER COLUMN a SET NOT NULL;
  ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- ok
  ALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL;  -- error, disallowed
  ERROR:  column "a" of relation "itest4" is an identity column
  ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- error, already set
--- 28,36 ----
  
  CREATE TABLE itest4 (a int, b text);
  ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- error, requires NOT NULL
  ALTER TABLE itest4 ALTER COLUMN a SET NOT NULL;
  ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- ok
+ ERROR:  column "a" of relation "itest4" is already an identity column
  ALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL;  -- error, disallowed
  ERROR:  column "a" of relation "itest4" is an identity column
  ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- error, already set
***************
*** 149,155 ****
  ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY IF EXISTS;  -- noop
  NOTICE:  column "a" of relation "itest4" is not an identity column, skipping
  INSERT INTO itest4 DEFAULT VALUES;  -- fails because NOT NULL is not dropped
! ERROR:  null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null, ).
  ALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL;
  INSERT INTO itest4 DEFAULT VALUES;
--- 149,155 ----
  ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY IF EXISTS;  -- noop
  NOTICE:  column "a" of relation "itest4" is not an identity column, skipping
  INSERT INTO itest4 DEFAULT VALUES;  -- fails because NOT NULL is not dropped
! ERROR:  node:datanode_1, backend_pid:383338, nodename:datanode_1,backend_pid:383338,message:null value in column "a" violates not-null constraint
  DETAIL:  Failing row contains (null, ).
  ALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL;
  INSERT INTO itest4 DEFAULT VALUES;
***************
*** 222,239 ****
  ALTER TABLE itest5 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
  ERROR:  column "a" of relation "itest5" already has a default value
  ALTER TABLE itest3 ALTER COLUMN a TYPE int;
  SELECT seqtypid::regtype FROM pg_sequence WHERE seqrelid = 'itest3_a_seq'::regclass;
   seqtypid 
  ----------
!  integer
  (1 row)
  
  \d itest3
!                            Table "public.itest3"
!  Column |  Type   | Collation | Nullable |             Default              
! --------+---------+-----------+----------+----------------------------------
!  a      | integer |           | not null | generated by default as identity
!  b      | text    |           |          | 
  
  ALTER TABLE itest3 ALTER COLUMN a TYPE text;  -- error
  ERROR:  identity column type must be smallint, integer, or bigint
--- 222,240 ----
  ALTER TABLE itest5 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
  ERROR:  column "a" of relation "itest5" already has a default value
  ALTER TABLE itest3 ALTER COLUMN a TYPE int;
+ ERROR:  cannot alter type of column named in distributed key
  SELECT seqtypid::regtype FROM pg_sequence WHERE seqrelid = 'itest3_a_seq'::regclass;
   seqtypid 
  ----------
!  smallint
  (1 row)
  
  \d itest3
!                             Table "public.itest3"
!  Column |   Type   | Collation | Nullable |             Default              
! --------+----------+-----------+----------+----------------------------------
!  a      | smallint |           | not null | generated by default as identity
!  b      | text     |           |          | 
  
  ALTER TABLE itest3 ALTER COLUMN a TYPE text;  -- error
  ERROR:  identity column type must be smallint, integer, or bigint
***************
*** 290,303 ****
  CREATE TABLE itest7e () INHERITS (itest7d);
  ALTER TABLE itest7d ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
  ALTER TABLE itest7d ADD COLUMN b int GENERATED ALWAYS AS IDENTITY;  -- error
! ERROR:  cannot recursively add identity column to table that has child tables
  SELECT table_name, column_name, is_nullable, is_identity, identity_generation FROM information_schema.columns WHERE table_name LIKE 'itest7%' ORDER BY 1, 2;
   table_name | column_name | is_nullable | is_identity | identity_generation 
  ------------+-------------+-------------+-------------+---------------------
   itest7     | a           | NO          | YES         | ALWAYS
   itest7a    | a           | NO          | NO          | 
   itest7a    | b           | YES         | NO          | 
!  itest7b    | a           | YES         | NO          | 
   itest7c    | a           | NO          | YES         | ALWAYS
   itest7d    | a           | NO          | YES         | ALWAYS
   itest7e    | a           | NO          | NO          | 
--- 291,304 ----
  CREATE TABLE itest7e () INHERITS (itest7d);
  ALTER TABLE itest7d ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
  ALTER TABLE itest7d ADD COLUMN b int GENERATED ALWAYS AS IDENTITY;  -- error
! ERROR:  identity colums are not supported on typed tables
  SELECT table_name, column_name, is_nullable, is_identity, identity_generation FROM information_schema.columns WHERE table_name LIKE 'itest7%' ORDER BY 1, 2;
   table_name | column_name | is_nullable | is_identity | identity_generation 
  ------------+-------------+-------------+-------------+---------------------
   itest7     | a           | NO          | YES         | ALWAYS
   itest7a    | a           | NO          | NO          | 
   itest7a    | b           | YES         | NO          | 
!  itest7b    | a           | NO          | NO          | 
   itest7c    | a           | NO          | YES         | ALWAYS
   itest7d    | a           | NO          | YES         | ALWAYS
   itest7e    | a           | NO          | NO          | 

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/partition_join_2.out"	2025-07-31 16:07:14.994067993 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/partition_join.out"	2025-07-31 16:40:15.537385011 +0800
***************
*** 70,83 ****
           ->  Hash Right Join
                 Hash Cond: (b = a)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: b
                       ->  Append
                             ->  Seq Scan on prt2_p1 t2
                             ->  Seq Scan on prt2_p2 t2_1
                             ->  Seq Scan on prt2_p3 t2_2
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: a
                             ->  Append
                                   ->  Seq Scan on prt1_p1 t1
                                         Filter: (b = 0)
--- 70,83 ----
           ->  Hash Right Join
                 Hash Cond: (b = a)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: b
                       ->  Append
                             ->  Seq Scan on prt2_p1 t2
                             ->  Seq Scan on prt2_p2 t2_1
                             ->  Seq Scan on prt2_p3 t2_2
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: a
                             ->  Append
                                   ->  Seq Scan on prt1_p1 t1
                                         Filter: (b = 0)
***************
*** 115,128 ****
           ->  Hash Right Join
                 Hash Cond: (a = b)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: a
                       ->  Append
                             ->  Seq Scan on prt1_p1 t1
                             ->  Seq Scan on prt1_p2 t1_1
                             ->  Seq Scan on prt1_p3 t1_2
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_2)
!                            Distribute results by H: b
                             ->  Append
                                   ->  Seq Scan on prt2_p1 t2
                                         Filter: (a = 0)
--- 115,128 ----
           ->  Hash Right Join
                 Hash Cond: (a = b)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: a
                       ->  Append
                             ->  Seq Scan on prt1_p1 t1
                             ->  Seq Scan on prt1_p2 t1_1
                             ->  Seq Scan on prt1_p3 t1_2
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_2)
!                            Distribute results by S: b
                             ->  Append
                                   ->  Seq Scan on prt2_p1 t2
                                         Filter: (a = 0)
***************
*** 157,163 ****
                 Hash Cond: (b = a)
                 Filter: (((50) = a) OR ((75) = b))
                 ->  Remote Subquery Scan on all (datanode_2)
!                      Distribute results by H: b
                       ->  Append
                             ->  Seq Scan on prt2_p1
                                   Filter: (a = 0)
--- 157,163 ----
                 Hash Cond: (b = a)
                 Filter: (((50) = a) OR ((75) = b))
                 ->  Remote Subquery Scan on all (datanode_2)
!                      Distribute results by S: b
                       ->  Append
                             ->  Seq Scan on prt2_p1
                                   Filter: (a = 0)
***************
*** 167,173 ****
                                   Filter: (a = 0)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: a
                             ->  Append
                                   ->  Seq Scan on prt1_p1
                                         Filter: (b = 0)
--- 167,173 ----
                                   Filter: (a = 0)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: a
                             ->  Append
                                   ->  Seq Scan on prt1_p1
                                         Filter: (b = 0)
***************
*** 224,230 ****
           ->  Hash Right Join
                 Hash Cond: (b = a)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: b
                       ->  Append
                             ->  Seq Scan on prt2_p2
                                   Filter: (b > 250)
--- 224,230 ----
           ->  Hash Right Join
                 Hash Cond: (b = a)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: b
                       ->  Append
                             ->  Seq Scan on prt2_p2
                                   Filter: (b > 250)
***************
*** 232,238 ****
                                   Filter: (b > 250)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: a
                             ->  Append
                                   ->  Seq Scan on prt1_p1
                                         Filter: ((a < 450) AND (b = 0))
--- 232,238 ----
                                   Filter: (b > 250)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: a
                             ->  Append
                                   ->  Seq Scan on prt1_p1
                                         Filter: ((a < 450) AND (b = 0))
***************
*** 265,271 ****
                 Hash Cond: (a = b)
                 Filter: ((b = 0) OR (a = 0))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: a
                       ->  Append
                             ->  Seq Scan on prt1_p1
                                   Filter: (a < 450)
--- 265,271 ----
                 Hash Cond: (a = b)
                 Filter: ((b = 0) OR (a = 0))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: a
                       ->  Append
                             ->  Seq Scan on prt1_p1
                                   Filter: (a < 450)
***************
*** 273,279 ****
                                   Filter: (a < 450)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: b
                             ->  Append
                                   ->  Seq Scan on prt2_p2
                                         Filter: (b > 250)
--- 273,279 ----
                                   Filter: (a < 450)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: b
                             ->  Append
                                   ->  Seq Scan on prt2_p2
                                         Filter: (b > 250)
***************
*** 376,382 ****
           Sort Key: a
           ->  Nested Loop Left Join
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: a
                       ->  Append
                             ->  Seq Scan on prt1_p1 t1
                                   Filter: (b = 0)
--- 376,382 ----
           Sort Key: a
           ->  Nested Loop Left Join
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: a
                       ->  Append
                             ->  Seq Scan on prt1_p1 t1
                                   Filter: (b = 0)
***************
*** 386,392 ****
                                   Filter: (b = 0)
                 ->  Materialize
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: a
                             ->  Hash Join
                                   Hash Cond: (t3.b = a)
                                   ->  Append
--- 386,392 ----
                                   Filter: (b = 0)
                 ->  Materialize
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: a
                             ->  Hash Join
                                   Hash Cond: (t3.b = a)
                                   ->  Append
***************
*** 436,449 ****
                 Hash Cond: ((c)::text = (c)::text)
                 Filter: ((b + COALESCE(b, 0)) = 0)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: c
                       ->  Append
                             ->  Seq Scan on prt1_p1 t1
                             ->  Seq Scan on prt1_p2 t1_1
                             ->  Seq Scan on prt1_p3 t1_2
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: c
                             ->  Hash Join
                                   Hash Cond: (b = t2.a)
                                   ->  Remote Subquery Scan on all (datanode_1,datanode_2)
--- 436,449 ----
                 Hash Cond: ((c)::text = (c)::text)
                 Filter: ((b + COALESCE(b, 0)) = 0)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: c
                       ->  Append
                             ->  Seq Scan on prt1_p1 t1
                             ->  Seq Scan on prt1_p2 t1_1
                             ->  Seq Scan on prt1_p3 t1_2
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: c
                             ->  Hash Join
                                   Hash Cond: (b = t2.a)
                                   ->  Remote Subquery Scan on all (datanode_1,datanode_2)
***************
*** 582,588 ****
           ->  Hash Right Join
                 Hash Cond: ((((a + b) / 2)) = a)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: ((a + b) / 2)
                       ->  Result
                             ->  Append
                                   ->  Seq Scan on prt1_e_p1 t3
--- 582,588 ----
           ->  Hash Right Join
                 Hash Cond: ((((a + b) / 2)) = a)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: ((a + b) / 2)
                       ->  Result
                             ->  Append
                                   ->  Seq Scan on prt1_e_p1 t3
***************
*** 592,605 ****
                       ->  Hash Right Join
                             Hash Cond: (b = a)
                             ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                  Distribute results by H: b
                                   ->  Append
                                         ->  Seq Scan on prt2_p1 t2
                                         ->  Seq Scan on prt2_p2 t2_1
                                         ->  Seq Scan on prt2_p3 t2_2
                             ->  Hash
                                   ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                        Distribute results by H: a
                                         ->  Append
                                               ->  Seq Scan on prt1_p1 t1
                                                     Filter: (b = 0)
--- 592,605 ----
                       ->  Hash Right Join
                             Hash Cond: (b = a)
                             ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                  Distribute results by S: b
                                   ->  Append
                                         ->  Seq Scan on prt2_p1 t2
                                         ->  Seq Scan on prt2_p2 t2_1
                                         ->  Seq Scan on prt2_p3 t2_2
                             ->  Hash
                                   ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                        Distribute results by S: a
                                         ->  Append
                                               ->  Seq Scan on prt1_p1 t1
                                                     Filter: (b = 0)
***************
*** 636,642 ****
           ->  Hash Right Join
                 Hash Cond: (a = (((a + b) / 2)))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: a
                       ->  Hash Right Join
                             Hash Cond: (b = t1.a)
                             ->  Remote Subquery Scan on all (datanode_1,datanode_2)
--- 636,642 ----
           ->  Hash Right Join
                 Hash Cond: (a = (((a + b) / 2)))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: a
                       ->  Hash Right Join
                             Hash Cond: (b = t1.a)
                             ->  Remote Subquery Scan on all (datanode_1,datanode_2)
***************
*** 651,657 ****
                                         ->  Seq Scan on prt1_p3 t1_2
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: ((a + b) / 2)
                             ->  Result
                                   ->  Append
                                         ->  Seq Scan on prt1_e_p1 t3
--- 651,657 ----
                                         ->  Seq Scan on prt1_p3 t1_2
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: ((a + b) / 2)
                             ->  Result
                                   ->  Append
                                         ->  Seq Scan on prt1_e_p1 t3
***************
*** 692,702 ****
                 Hash Cond: (a = (((a + b) / 2)))
                 Filter: ((a = (50)) OR (b = (75)) OR (((a + b) / 2) = (50)))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: a
                       ->  Hash Full Join
                             Hash Cond: (b = a)
                             ->  Remote Subquery Scan on all (datanode_2)
!                                  Distribute results by H: b
                                   ->  Append
                                         ->  Seq Scan on prt2_p1
                                               Filter: (a = 0)
--- 692,702 ----
                 Hash Cond: (a = (((a + b) / 2)))
                 Filter: ((a = (50)) OR (b = (75)) OR (((a + b) / 2) = (50)))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: a
                       ->  Hash Full Join
                             Hash Cond: (b = a)
                             ->  Remote Subquery Scan on all (datanode_2)
!                                  Distribute results by S: b
                                   ->  Append
                                         ->  Seq Scan on prt2_p1
                                               Filter: (a = 0)
***************
*** 706,712 ****
                                               Filter: (a = 0)
                             ->  Hash
                                   ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                        Distribute results by H: a
                                         ->  Append
                                               ->  Seq Scan on prt1_p1
                                                     Filter: (b = 0)
--- 706,712 ----
                                               Filter: (a = 0)
                             ->  Hash
                                   ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                                        Distribute results by S: a
                                         ->  Append
                                               ->  Seq Scan on prt1_p1
                                                     Filter: (b = 0)
***************
*** 716,722 ****
                                                     Filter: (b = 0)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: ((a + b) / 2)
                             ->  Result
                                   ->  Append
                                         ->  Seq Scan on prt1_e_p1
--- 716,722 ----
                                                     Filter: (b = 0)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: ((a + b) / 2)
                             ->  Result
                                   ->  Append
                                         ->  Seq Scan on prt1_e_p1
***************
*** 752,758 ****
                       Filter: (b = 0)
           ->  Materialize
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: b
                       ->  Hash Join
                             Hash Cond: (b = ((t2.a + t2.b) / 2))
                             ->  Remote Subquery Scan on all (datanode_2)
--- 752,758 ----
                       Filter: (b = 0)
           ->  Materialize
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: b
                       ->  Hash Join
                             Hash Cond: (b = ((t2.a + t2.b) / 2))
                             ->  Remote Subquery Scan on all (datanode_2)
***************
*** 796,802 ****
                       Filter: (b = 0)
           ->  Materialize
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: b
                       ->  Hash Semi Join
                             Hash Cond: (t1_3.b = ((a + b) / 2))
                             ->  Append
--- 796,802 ----
                       Filter: (b = 0)
           ->  Materialize
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: b
                       ->  Hash Semi Join
                             Hash Cond: (t1_3.b = ((a + b) / 2))
                             ->  Append
***************
*** 834,840 ****
     ->  Merge Semi Join
           Merge Cond: (a = b)
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: a
                 ->  Sort
                       Sort Key: t1.a
                       ->  Append
--- 834,840 ----
     ->  Merge Semi Join
           Merge Cond: (a = b)
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: a
                 ->  Sort
                       Sort Key: t1.a
                       ->  Append
***************
*** 845,851 ****
                             ->  Seq Scan on prt1_p3 t1_2
                                   Filter: (b = 0)
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: b
                 ->  Merge Semi Join
                       Merge Cond: (t1_3.b = (((a + b) / 2)))
                       ->  Sort
--- 845,851 ----
                             ->  Seq Scan on prt1_p3 t1_2
                                   Filter: (b = 0)
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: b
                 ->  Merge Semi Join
                       Merge Cond: (t1_3.b = (((a + b) / 2)))
                       ->  Sort
***************
*** 886,892 ****
           ->  Merge Right Join
                 Merge Cond: (a = (((a + b) / 2)))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: a
                       ->  Merge Left Join
                             Merge Cond: (t1.a = b)
                             ->  Sort
--- 886,892 ----
           ->  Merge Right Join
                 Merge Cond: (a = (((a + b) / 2)))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: a
                       ->  Merge Left Join
                             Merge Cond: (t1.a = b)
                             ->  Sort
***************
*** 905,911 ****
                                                     ->  Seq Scan on prt2_p3 t2_2
                 ->  Materialize
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: ((a + b) / 2)
                             ->  Sort
                                   Sort Key: (((t3.a + t3.b) / 2))
                                   ->  Result
--- 905,911 ----
                                                     ->  Seq Scan on prt2_p3 t2_2
                 ->  Materialize
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: ((a + b) / 2)
                             ->  Sort
                                   Sort Key: (((t3.a + t3.b) / 2))
                                   ->  Result
***************
*** 946,952 ****
           ->  Merge Right Join
                 Merge Cond: (b = a)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: b
                       ->  Sort
                             Sort Key: prt2_p2.b
                             ->  Append
--- 946,952 ----
           ->  Merge Right Join
                 Merge Cond: (b = a)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: b
                       ->  Sort
                             Sort Key: prt2_p2.b
                             ->  Append
***************
*** 956,962 ****
                                         Filter: (b > 250)
                 ->  Materialize
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: a
                             ->  Sort
                                   Sort Key: prt1_p1.a
                                   ->  Append
--- 956,962 ----
                                         Filter: (b > 250)
                 ->  Materialize
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: a
                             ->  Sort
                                   Sort Key: prt1_p1.a
                                   ->  Append
***************
*** 1007,1013 ****
           ->  Hash Full Join
                 Hash Cond: ((a = (((b + a) / 2))) AND (((a + b) / 2) = b))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: a
                       ->  Append
                             ->  Seq Scan on prt1_m_p1
                                   Filter: (c = 0)
--- 1007,1013 ----
           ->  Hash Full Join
                 Hash Cond: ((a = (((b + a) / 2))) AND (((a + b) / 2) = b))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: a
                       ->  Append
                             ->  Seq Scan on prt1_m_p1
                                   Filter: (c = 0)
***************
*** 1017,1023 ****
                                   Filter: (c = 0)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: ((b + a) / 2)
                             ->  Result
                                   ->  Append
                                         ->  Seq Scan on prt2_m_p1
--- 1017,1023 ----
                                   Filter: (c = 0)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: ((b + a) / 2)
                             ->  Result
                                   ->  Append
                                         ->  Seq Scan on prt2_m_p1
***************
*** 1084,1090 ****
           ->  Sort
                 Sort Key: c, c
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: c
                       ->  Partial HashAggregate
                             Group Key: c, c, t3.c
                             ->  Hash Join
--- 1084,1090 ----
           ->  Sort
                 Sort Key: c, c
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: c
                       ->  Partial HashAggregate
                             Group Key: c, c, t3.c
                             ->  Hash Join
***************
*** 1223,1229 ****
           ->  Sort
                 Sort Key: c, c
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: c
                       ->  Partial HashAggregate
                             Group Key: c, c, t3.c
                             ->  Hash Join
--- 1223,1229 ----
           ->  Sort
                 Sort Key: c, c
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: c
                       ->  Partial HashAggregate
                             Group Key: c, c, t3.c
                             ->  Hash Join
***************
*** 1337,1343 ****
           ->  Hash Right Join
                 Hash Cond: ((b = a) AND ((c)::text = (c)::text))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: b
                       ->  Append
                             ->  Seq Scan on prt2_l_p1 t2
                             ->  Seq Scan on prt2_l_p2_p1 t2_1
--- 1337,1343 ----
           ->  Hash Right Join
                 Hash Cond: ((b = a) AND ((c)::text = (c)::text))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: b
                       ->  Append
                             ->  Seq Scan on prt2_l_p1 t2
                             ->  Seq Scan on prt2_l_p2_p1 t2_1
***************
*** 1346,1352 ****
                             ->  Seq Scan on prt2_l_p3_p2 t2_4
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: a
                             ->  Append
                                   ->  Seq Scan on prt1_l_p1 t1
                                         Filter: (b = 0)
--- 1346,1352 ----
                             ->  Seq Scan on prt2_l_p3_p2 t2_4
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: a
                             ->  Append
                                   ->  Seq Scan on prt1_l_p1 t1
                                         Filter: (b = 0)
***************
*** 1386,1392 ****
           ->  Hash Right Join
                 Hash Cond: ((a = b) AND ((c)::text = (c)::text))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: a
                       ->  Append
                             ->  Seq Scan on prt1_l_p1 t1
                             ->  Seq Scan on prt1_l_p2_p1 t1_1
--- 1386,1392 ----
           ->  Hash Right Join
                 Hash Cond: ((a = b) AND ((c)::text = (c)::text))
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: a
                       ->  Append
                             ->  Seq Scan on prt1_l_p1 t1
                             ->  Seq Scan on prt1_l_p2_p1 t1_1
***************
*** 1395,1401 ****
                             ->  Seq Scan on prt1_l_p3_p2 t1_4
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_2)
!                            Distribute results by H: b
                             ->  Append
                                   ->  Seq Scan on prt2_l_p1 t2
                                         Filter: (a = 0)
--- 1395,1401 ----
                             ->  Seq Scan on prt1_l_p3_p2 t1_4
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_2)
!                            Distribute results by S: b
                             ->  Append
                                   ->  Seq Scan on prt2_l_p1 t2
                                         Filter: (a = 0)
***************
*** 1431,1437 ****
           ->  Hash Full Join
                 Hash Cond: ((b = a) AND ((c)::text = (c)::text))
                 ->  Remote Subquery Scan on all (datanode_2)
!                      Distribute results by H: b
                       ->  Append
                             ->  Seq Scan on prt2_l_p1
                                   Filter: (a = 0)
--- 1431,1437 ----
           ->  Hash Full Join
                 Hash Cond: ((b = a) AND ((c)::text = (c)::text))
                 ->  Remote Subquery Scan on all (datanode_2)
!                      Distribute results by S: b
                       ->  Append
                             ->  Seq Scan on prt2_l_p1
                                   Filter: (a = 0)
***************
*** 1443,1449 ****
                                   Filter: (a = 0)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: a
                             ->  Append
                                   ->  Seq Scan on prt1_l_p1
                                         Filter: (b = 0)
--- 1443,1449 ----
                                   Filter: (a = 0)
                 ->  Hash
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: a
                             ->  Append
                                   ->  Seq Scan on prt1_l_p1
                                         Filter: (b = 0)
***************
*** 1488,1494 ****
           Sort Key: a
           ->  Nested Loop Left Join
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: a
                       ->  Append
                             ->  Seq Scan on prt1_l_p1 t1
                                   Filter: (b = 0)
--- 1488,1494 ----
           Sort Key: a
           ->  Nested Loop Left Join
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: a
                       ->  Append
                             ->  Seq Scan on prt1_l_p1 t1
                                   Filter: (b = 0)
***************
*** 1500,1506 ****
                                   Filter: (b = 0)
                 ->  Materialize
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by H: a
                             ->  Hash Join
                                   Hash Cond: ((b = t2.a) AND ((c)::text = (t2.c)::text))
                                   ->  Remote Subquery Scan on all (datanode_1,datanode_2)
--- 1500,1506 ----
                                   Filter: (b = 0)
                 ->  Materialize
                       ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                            Distribute results by S: a
                             ->  Hash Join
                                   Hash Cond: ((b = t2.a) AND ((c)::text = (t2.c)::text))
                                   ->  Remote Subquery Scan on all (datanode_1,datanode_2)
***************
*** 1626,1632 ****
                             ->  Seq Scan on prt1_p3 t1_2
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: b
                       ->  Append
                             ->  Seq Scan on prt2_p1 t3
                             ->  Seq Scan on prt2_p2 t3_1
--- 1626,1632 ----
                             ->  Seq Scan on prt1_p3 t1_2
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: b
                       ->  Append
                             ->  Seq Scan on prt2_p1 t3
                             ->  Seq Scan on prt2_p2 t3_1
***************
*** 1664,1670 ****
     ->  Hash Join
           Hash Cond: ((((b + a) / 2)) = a)
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: ((b + a) / 2)
                 ->  Result
                       ->  Append
                             ->  Seq Scan on prt2_m_p1 t2
--- 1664,1670 ----
     ->  Hash Join
           Hash Cond: ((((b + a) / 2)) = a)
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: ((b + a) / 2)
                 ->  Result
                       ->  Append
                             ->  Seq Scan on prt2_m_p1 t2
***************
*** 1672,1678 ****
                             ->  Seq Scan on prt2_m_p3 t2_2
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: a
                       ->  Append
                             ->  Seq Scan on prt1_m_p1 t1
                             ->  Seq Scan on prt1_m_p2 t1_1
--- 1672,1678 ----
                             ->  Seq Scan on prt2_m_p3 t2_2
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: a
                       ->  Append
                             ->  Seq Scan on prt1_m_p1 t1
                             ->  Seq Scan on prt1_m_p2 t1_1
***************
*** 1730,1742 ****
     ->  Hash Right Join
           Hash Cond: (c = (c)::text)
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: c
                 ->  Append
                       ->  Seq Scan on prt2_n_p1 t2
                       ->  Seq Scan on prt2_n_p2 t2_1
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: c
                       ->  Append
                             ->  Seq Scan on prt1_n_p1 t1
                             ->  Seq Scan on prt1_n_p2 t1_1
--- 1730,1742 ----
     ->  Hash Right Join
           Hash Cond: (c = (c)::text)
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: c
                 ->  Append
                       ->  Seq Scan on prt2_n_p1 t2
                       ->  Seq Scan on prt2_n_p2 t2_1
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: c
                       ->  Append
                             ->  Seq Scan on prt1_n_p1 t1
                             ->  Seq Scan on prt1_n_p2 t1_1
***************
*** 1777,1790 ****
     ->  Hash Full Join
           Hash Cond: ((c)::text = (c)::text)
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by H: c
                 ->  Append
                       ->  Seq Scan on prt1_p1 t2
                       ->  Seq Scan on prt1_p2 t2_1
                       ->  Seq Scan on prt1_p3 t2_2
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: c
                       ->  Append
                             ->  Seq Scan on prt1_n_p1 t1
                             ->  Seq Scan on prt1_n_p2 t1_1
--- 1777,1790 ----
     ->  Hash Full Join
           Hash Cond: ((c)::text = (c)::text)
           ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                Distribute results by S: c
                 ->  Append
                       ->  Seq Scan on prt1_p1 t2
                       ->  Seq Scan on prt1_p2 t2_1
                       ->  Seq Scan on prt1_p3 t2_2
           ->  Hash
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: c
                       ->  Append
                             ->  Seq Scan on prt1_n_p1 t1
                             ->  Seq Scan on prt1_n_p2 t1_1

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/partition_prune.out"	2025-07-31 16:07:14.994067993 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/partition_prune.out"	2025-07-31 16:40:12.530164836 +0800
***************
*** 8,13 ****
--- 8,14 ----
  create table lp_bc partition of lp for values in ('b', 'c');
  create table lp_g partition of lp for values in ('g');
  create table lp_null partition of lp for values in (null);
+ INFO:  partition constraint for table "lp_default" is implied by existing constraints
  explain (costs off) select * from lp;
               QUERY PLAN             
  ------------------------------------
***************
*** 87,100 ****
  (13 rows)
  
  explain (costs off) select * from lp where a is null;
!             QUERY PLAN             
! -----------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Append
!          ->  Seq Scan on lp_null
!                Filter: (a IS NULL)
! (5 rows)
  
  explain (costs off) select * from lp where a = 'a' or a = 'c';
                             QUERY PLAN                           
--- 88,100 ----
  (13 rows)
  
  explain (costs off) select * from lp where a is null;
!             QUERY PLAN            
! ----------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Result
!          One-Time Filter: false
! (4 rows)
  
  explain (costs off) select * from lp where a = 'a' or a = 'c';
                             QUERY PLAN                           
***************
*** 204,209 ****
--- 204,210 ----
  create table rlp_default_10 partition of rlp_default for values in (10);
  create table rlp_default_30 partition of rlp_default for values in (30);
  create table rlp_default_null partition of rlp_default for values in (null);
+ INFO:  partition constraint for table "rlp_default_default" is implied by existing constraints
  create table rlp1 partition of rlp for values from (minvalue) to (1);
  create table rlp2 partition of rlp for values from (1) to (10);
  create table rlp3 (a int, b varchar) partition by list (b varchar_ops);
***************
*** 494,507 ****
  (11 rows)
  
  explain (costs off) select * from rlp where a is null;
!                 QUERY PLAN                
! ------------------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Append
!          ->  Seq Scan on rlp_default_null
!                Filter: (a IS NULL)
! (5 rows)
  
  explain (costs off) select * from rlp where a is not null;
                   QUERY PLAN                  
--- 495,507 ----
  (11 rows)
  
  explain (costs off) select * from rlp where a is null;
!             QUERY PLAN            
! ----------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Result
!          One-Time Filter: false
! (4 rows)
  
  explain (costs off) select * from rlp where a is not null;
                   QUERY PLAN                  
***************
*** 1147,1180 ****
  (5 rows)
  
  explain (costs off) select * from mc2p where a is null and b is null;
!                      QUERY PLAN                      
! -----------------------------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Append
!          ->  Seq Scan on mc2p_default
!                Filter: ((a IS NULL) AND (b IS NULL))
! (5 rows)
  
  explain (costs off) select * from mc2p where a is null and b = 1;
!                    QUERY PLAN                    
! -------------------------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Append
!          ->  Seq Scan on mc2p_default
!                Filter: ((a IS NULL) AND (b = 1))
! (5 rows)
  
  explain (costs off) select * from mc2p where a is null;
!               QUERY PLAN              
! --------------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Append
!          ->  Seq Scan on mc2p_default
!                Filter: (a IS NULL)
! (5 rows)
  
  explain (costs off) select * from mc2p where b is null;
                QUERY PLAN              
--- 1147,1177 ----
  (5 rows)
  
  explain (costs off) select * from mc2p where a is null and b is null;
!             QUERY PLAN            
! ----------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Result
!          One-Time Filter: false
! (4 rows)
  
  explain (costs off) select * from mc2p where a is null and b = 1;
!             QUERY PLAN            
! ----------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Result
!          One-Time Filter: false
! (4 rows)
  
  explain (costs off) select * from mc2p where a is null;
!             QUERY PLAN            
! ----------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Result
!          One-Time Filter: false
! (4 rows)
  
  explain (costs off) select * from mc2p where b is null;
                QUERY PLAN              
***************
*** 1379,1395 ****
  CREATE TABLE part_p2 PARTITION OF part DEFAULT PARTITION BY RANGE(a);
  CREATE TABLE part_p2_p1 PARTITION OF part_p2 DEFAULT;
  INSERT INTO part VALUES (-1,-1), (1,1), (2,NULL), (NULL,-2),(NULL,NULL);
  EXPLAIN (COSTS OFF) SELECT tableoid::regclass as part, a, b FROM part WHERE a IS NULL ORDER BY 1, 2, 3;
!                                    QUERY PLAN                                    
! ---------------------------------------------------------------------------------
!  Remote Subquery Scan on all (datanode_1,datanode_2)
!    ->  Sort
!          Sort Key: ((part_p2_p1.tableoid)::regclass), part_p2_p1.a, part_p2_p1.b
!          ->  Result
!                ->  Append
!                      ->  Seq Scan on part_p2_p1
!                            Filter: (a IS NULL)
! (7 rows)
  
  --
  -- some more cases
--- 1376,1391 ----
  CREATE TABLE part_p2 PARTITION OF part DEFAULT PARTITION BY RANGE(a);
  CREATE TABLE part_p2_p1 PARTITION OF part_p2 DEFAULT;
  INSERT INTO part VALUES (-1,-1), (1,1), (2,NULL), (NULL,-2),(NULL,NULL);
+ ERROR:  node:datanode_1, backend_pid:383338, nodename:datanode_1,backend_pid:383338,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, -2).
  EXPLAIN (COSTS OFF) SELECT tableoid::regclass as part, a, b FROM part WHERE a IS NULL ORDER BY 1, 2, 3;
!                        QUERY PLAN                        
! ---------------------------------------------------------
!  Sort
!    Sort Key: ((part.tableoid)::regclass), part.a, part.b
!    ->  Result
!          One-Time Filter: false
! (4 rows)
  
  --
  -- some more cases

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/partition_prune_hash.out"	2025-07-31 16:07:14.994067993 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/partition_prune_hash.out"	2025-07-31 16:40:08.914241375 +0800
***************
*** 9,29 ****
  create table hp1 partition of hp for values with (modulus 4, remainder 1);
  create table hp2 partition of hp for values with (modulus 4, remainder 2);
  insert into hp values (null, null);
  insert into hp values (1, null);
  insert into hp values (1, 'xxx');
  insert into hp values (null, 'xxx');
  insert into hp values (10, 'xxx');
  insert into hp values (10, 'yyy');
  select tableoid::regclass, * from hp order by 1;
   tableoid | a  |  b  
  ----------+----+-----
-  hp0      |    | 
   hp0      |  1 | 
   hp0      |  1 | xxx
   hp3      | 10 | yyy
-  hp1      |    | xxx
   hp2      | 10 | xxx
! (6 rows)
  
  -- partial keys won't prune, nor would non-equality conditions
  explain (costs off) select * from hp where a = 1;
--- 9,31 ----
  create table hp1 partition of hp for values with (modulus 4, remainder 1);
  create table hp2 partition of hp for values with (modulus 4, remainder 2);
  insert into hp values (null, null);
+ ERROR:  node:datanode_1, backend_pid:383340, nodename:datanode_1,backend_pid:383340,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, null).
  insert into hp values (1, null);
  insert into hp values (1, 'xxx');
  insert into hp values (null, 'xxx');
+ ERROR:  node:datanode_1, backend_pid:383340, nodename:datanode_1,backend_pid:383340,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, xxx).
  insert into hp values (10, 'xxx');
  insert into hp values (10, 'yyy');
  select tableoid::regclass, * from hp order by 1;
   tableoid | a  |  b  
  ----------+----+-----
   hp0      |  1 | 
   hp0      |  1 | xxx
   hp3      | 10 | yyy
   hp2      | 10 | xxx
! (4 rows)
  
  -- partial keys won't prune, nor would non-equality conditions
  explain (costs off) select * from hp where a = 1;
***************
*** 59,78 ****
  (11 rows)
  
  explain (costs off) select * from hp where a is null;
!             QUERY PLAN             
! -----------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Append
!          ->  Seq Scan on hp0
!                Filter: (a IS NULL)
!          ->  Seq Scan on hp1
!                Filter: (a IS NULL)
!          ->  Seq Scan on hp2
!                Filter: (a IS NULL)
!          ->  Seq Scan on hp3
!                Filter: (a IS NULL)
! (11 rows)
  
  explain (costs off) select * from hp where b is null;
              QUERY PLAN             
--- 61,73 ----
  (11 rows)
  
  explain (costs off) select * from hp where a is null;
!             QUERY PLAN            
! ----------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Result
!          One-Time Filter: false
! (4 rows)
  
  explain (costs off) select * from hp where b is null;
              QUERY PLAN             
***************
*** 124,137 ****
  
  -- pruning should work if non-null values are provided for all the keys
  explain (costs off) select * from hp where a is null and b is null;
!                      QUERY PLAN                      
! -----------------------------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Append
!          ->  Seq Scan on hp0
!                Filter: ((a IS NULL) AND (b IS NULL))
! (5 rows)
  
  explain (costs off) select * from hp where a = 1 and b is null;
                     QUERY PLAN                    
--- 119,131 ----
  
  -- pruning should work if non-null values are provided for all the keys
  explain (costs off) select * from hp where a is null and b is null;
!             QUERY PLAN            
! ----------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Result
!          One-Time Filter: false
! (4 rows)
  
  explain (costs off) select * from hp where a = 1 and b is null;
                     QUERY PLAN                    
***************
*** 154,167 ****
  (5 rows)
  
  explain (costs off) select * from hp where a is null and b = 'xxx';
!                         QUERY PLAN                         
! -----------------------------------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Append
!          ->  Seq Scan on hp1
!                Filter: ((a IS NULL) AND (b = 'xxx'::text))
! (5 rows)
  
  explain (costs off) select * from hp where a = 10 and b = 'xxx';
                         QUERY PLAN                       
--- 148,160 ----
  (5 rows)
  
  explain (costs off) select * from hp where a is null and b = 'xxx';
!             QUERY PLAN            
! ----------------------------------
   Remote Fast Query Execution
     Node/s: datanode_1, datanode_2
!    ->  Result
!          One-Time Filter: false
! (4 rows)
  
  explain (costs off) select * from hp where a = 10 and b = 'xxx';
                         QUERY PLAN                       

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/indexing.out"	2025-07-31 16:07:14.985068136 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/indexing.out"	2025-07-31 16:40:14.799116833 +0800
***************
*** 27,34 ****
  create table idxpart (a int, b int, c text) partition by range (a);
  create table idxpart1 partition of idxpart for values from (0) to (10);
  create index concurrently on idxpart (a);
! ERROR:  PGXC does not support concurrent INDEX yet
! DETAIL:  The feature is not currently supported
  drop table idxpart;
  -- Verify bugfix with index rewrite on ALTER TABLE / SET DATA TYPE
  -- https://postgr.es/m/CAKcux6mxNCGsgATwf5CGMF8g4WSupCXicCVMeKUTuWbyxHOMsQ@mail.gmail.com
--- 27,33 ----
  create table idxpart (a int, b int, c text) partition by range (a);
  create table idxpart1 partition of idxpart for values from (0) to (10);
  create index concurrently on idxpart (a);
! ERROR:  cannot create index on partitioned table "idxpart" concurrently
  drop table idxpart;
  -- Verify bugfix with index rewrite on ALTER TABLE / SET DATA TYPE
  -- https://postgr.es/m/CAKcux6mxNCGsgATwf5CGMF8g4WSupCXicCVMeKUTuWbyxHOMsQ@mail.gmail.com
***************
*** 48,54 ****
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
   c      | text    |           |          | 
  
--- 47,53 ----
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
   c      | text    |           |          | 
  
***************
*** 57,63 ****
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
   c      | text    |           |          | 
  Partition of: idxpart FOR VALUES FROM (0) TO (10)
--- 56,62 ----
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
   c      | text    |           |          | 
  Partition of: idxpart FOR VALUES FROM (0) TO (10)
***************
*** 90,96 ****
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
  Partition of: idxpart FOR VALUES FROM (0, 0) TO (10, 10)
  Indexes:
--- 89,95 ----
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
  Partition of: idxpart FOR VALUES FROM (0, 0) TO (10, 10)
  Indexes:
***************
*** 191,197 ****
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
  Partition of: idxpart FOR VALUES FROM (0) TO (1000)
  Indexes:
--- 190,196 ----
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
  Partition of: idxpart FOR VALUES FROM (0) TO (1000)
  Indexes:
***************
*** 220,226 ****
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
  Partition of: idxpart FOR VALUES FROM (0) TO (100)
  Indexes:
      "idxpart1_a_idx" btree (a)
--- 219,225 ----
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
  Partition of: idxpart FOR VALUES FROM (0) TO (100)
  Indexes:
      "idxpart1_a_idx" btree (a)
***************
*** 229,235 ****
                Table "public.idxpart2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
  Partition of: idxpart FOR VALUES FROM (100) TO (1000)
  Partition key: RANGE (a)
  Indexes:
--- 228,234 ----
                Table "public.idxpart2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
  Partition of: idxpart FOR VALUES FROM (100) TO (1000)
  Partition key: RANGE (a)
  Indexes:
***************
*** 240,246 ****
               Table "public.idxpart21"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
  Partition of: idxpart2 FOR VALUES FROM (100) TO (200)
  
  select indexrelid::regclass, indrelid::regclass, inhparent::regclass
--- 239,245 ----
               Table "public.idxpart21"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
  Partition of: idxpart2 FOR VALUES FROM (100) TO (200)
  
  select indexrelid::regclass, indrelid::regclass, inhparent::regclass
***************
*** 274,280 ****
                Table "public.idxpart2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
  Partition of: idxpart FOR VALUES FROM (100) TO (1000)
  Partition key: RANGE (a)
  Indexes:
--- 273,279 ----
                Table "public.idxpart2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
  Partition of: idxpart FOR VALUES FROM (100) TO (1000)
  Partition key: RANGE (a)
  Indexes:
***************
*** 288,294 ****
                Table "public.idxpart2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
  Partition of: idxpart FOR VALUES FROM (100) TO (1000)
  Partition key: RANGE (a)
  Indexes:
--- 287,293 ----
                Table "public.idxpart2"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
  Partition of: idxpart FOR VALUES FROM (100) TO (1000)
  Partition key: RANGE (a)
  Indexes:
***************
*** 307,313 ****
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
   c      | text    |           |          | 
  Indexes:
--- 306,312 ----
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
   c      | text    |           |          | 
  Indexes:
***************
*** 333,339 ****
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
   c      | text    |           |          | 
  Partition of: idxpart FOR VALUES FROM (0) TO (10)
--- 332,338 ----
                Table "public.idxpart1"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
   c      | text    |           |          | 
  Partition of: idxpart FOR VALUES FROM (0) TO (10)
***************
*** 685,691 ****
                 Table "public.idxpart"
    Column  |  Type   | Collation | Nullable | Default 
  ----------+---------+-----------+----------+---------
!  col_keep | integer |           |          | 
  Partition key: RANGE (col_keep)
  Indexes:
      "idxpart_col_keep_idx" btree (col_keep)
--- 684,690 ----
                 Table "public.idxpart"
    Column  |  Type   | Collation | Nullable | Default 
  ----------+---------+-----------+----------+---------
!  col_keep | integer |           | not null | 
  Partition key: RANGE (col_keep)
  Indexes:
      "idxpart_col_keep_idx" btree (col_keep)
***************
*** 695,701 ****
                 Table "public.idxpart1"
    Column  |  Type   | Collation | Nullable | Default 
  ----------+---------+-----------+----------+---------
!  col_keep | integer |           |          | 
  Partition of: idxpart FOR VALUES FROM (0) TO (1000)
  Indexes:
      "idxpart1_col_keep_idx" btree (col_keep)
--- 694,700 ----
                 Table "public.idxpart1"
    Column  |  Type   | Collation | Nullable | Default 
  ----------+---------+-----------+----------+---------
!  col_keep | integer |           | not null | 
  Partition of: idxpart FOR VALUES FROM (0) TO (1000)
  Indexes:
      "idxpart1_col_keep_idx" btree (col_keep)
***************
*** 728,734 ****
                 Table "public.idxpart"
    Column  |  Type   | Collation | Nullable | Default 
  ----------+---------+-----------+----------+---------
!  col_keep | integer |           |          | 
  Partition key: RANGE (col_keep)
  Indexes:
      "idxpart_col_keep_idx" btree (col_keep)
--- 727,733 ----
                 Table "public.idxpart"
    Column  |  Type   | Collation | Nullable | Default 
  ----------+---------+-----------+----------+---------
!  col_keep | integer |           | not null | 
  Partition key: RANGE (col_keep)
  Indexes:
      "idxpart_col_keep_idx" btree (col_keep)
***************
*** 738,744 ****
                 Table "public.idxpart1"
    Column  |  Type   | Collation | Nullable | Default 
  ----------+---------+-----------+----------+---------
!  col_keep | integer |           |          | 
  Partition of: idxpart FOR VALUES FROM (0) TO (1000)
  Indexes:
      "idxpart1_col_keep_idx" btree (col_keep)
--- 737,743 ----
                 Table "public.idxpart1"
    Column  |  Type   | Collation | Nullable | Default 
  ----------+---------+-----------+----------+---------
!  col_keep | integer |           | not null | 
  Partition of: idxpart FOR VALUES FROM (0) TO (1000)
  Indexes:
      "idxpart1_col_keep_idx" btree (col_keep)
***************
*** 844,850 ****
                Table "public.idxpart"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
   b      | integer |           |          | 
  Partition key: RANGE (a, b)
  Indexes:
--- 843,849 ----
                Table "public.idxpart"
   Column |  Type   | Collation | Nullable | Default 
  --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
   b      | integer |           |          | 
  Partition key: RANGE (a, b)
  Indexes:
***************
*** 1022,1036 ****
  alter table idxpart attach partition idxpart2 for values from (100000) to (1000000);
  insert into idxpart values (0, 'zero'), (42, 'life'), (2^16, 'sixteen');
  insert into idxpart select 2^g, format('two to power of %s', g) from generate_series(15, 17) g;
! ERROR:  duplicate key value violates unique constraint "idxpart1_a_idx"
  DETAIL:  Key (a)=(65536) already exists.
  insert into idxpart values (16, 'sixteen');
  insert into idxpart (b, a) values ('one', 142857), ('two', 285714);
  insert into idxpart select a * 2, b || b from idxpart where a between 2^16 and 2^19;
! ERROR:  duplicate key value violates unique constraint "idxpart2_a_idx"
  DETAIL:  Key (a)=(285714) already exists.
  insert into idxpart values (572814, 'five');
! ERROR:  duplicate key value violates unique constraint "idxpart2_a_idx"
  DETAIL:  Key (a)=(572814) already exists.
  insert into idxpart values (857142, 'six');
  select tableoid::regclass, * from idxpart order by a;
--- 1021,1035 ----
  alter table idxpart attach partition idxpart2 for values from (100000) to (1000000);
  insert into idxpart values (0, 'zero'), (42, 'life'), (2^16, 'sixteen');
  insert into idxpart select 2^g, format('two to power of %s', g) from generate_series(15, 17) g;
! ERROR:  node:datanode_1, backend_pid:383340, nodename:datanode_1,backend_pid:383340,message:duplicate key value violates unique constraint "idxpart1_a_idx"
  DETAIL:  Key (a)=(65536) already exists.
  insert into idxpart values (16, 'sixteen');
  insert into idxpart (b, a) values ('one', 142857), ('two', 285714);
  insert into idxpart select a * 2, b || b from idxpart where a between 2^16 and 2^19;
! ERROR:  node:datanode_2, backend_pid:385399, nodename:datanode_2,backend_pid:385399,message:duplicate key value violates unique constraint "idxpart2_a_idx"
  DETAIL:  Key (a)=(285714) already exists.
  insert into idxpart values (572814, 'five');
! ERROR:  node:datanode_1, backend_pid:385392, nodename:datanode_1,backend_pid:385392,message:duplicate key value violates unique constraint "idxpart2_a_idx"
  DETAIL:  Key (a)=(572814) already exists.
  insert into idxpart values (857142, 'six');
  select tableoid::regclass, * from idxpart order by a;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/event_trigger.out"	2025-07-31 16:07:14.982068184 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/event_trigger.out"	2025-07-31 16:40:16.184077936 +0800
***************
*** 122,131 ****
  ERROR:  event trigger "regress_event_trigger" does not exist
  -- should fail, name collision
  alter event trigger regress_event_trigger rename to regress_event_trigger2;
! ERROR:  event trigger "regress_event_trigger" does not exist
  -- OK
  alter event trigger regress_event_trigger rename to regress_event_trigger3;
! ERROR:  event trigger "regress_event_trigger" does not exist
  -- should fail, doesn't exist any more
  drop event trigger regress_event_trigger;
  ERROR:  event trigger "regress_event_trigger" does not exist
--- 122,131 ----
  ERROR:  event trigger "regress_event_trigger" does not exist
  -- should fail, name collision
  alter event trigger regress_event_trigger rename to regress_event_trigger2;
! ERROR:  node:datanode_2, backend_pid:384800, nodename:coord2,backend_pid:384821,message:event trigger "regress_event_trigger" does not exist
  -- OK
  alter event trigger regress_event_trigger rename to regress_event_trigger3;
! ERROR:  node:datanode_1, backend_pid:385392, nodename:coord2,backend_pid:384821,message:event trigger "regress_event_trigger" does not exist
  -- should fail, doesn't exist any more
  drop event trigger regress_event_trigger;
  ERROR:  event trigger "regress_event_trigger" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/stats_2.out"	2025-07-31 16:07:15.003067850 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/stats.out"	2025-07-31 16:40:48.871398198 +0800
***************
*** 190,196 ****
   WHERE st.relname='tenk2' AND cl.relname='tenk2';
   ?column? | ?column? 
  ----------+----------
!  f        | f
  (1 row)
  
  SELECT pr.snap_ts < pg_stat_get_snapshot_timestamp() as snapshot_newer
--- 190,196 ----
   WHERE st.relname='tenk2' AND cl.relname='tenk2';
   ?column? | ?column? 
  ----------+----------
!  f        | t
  (1 row)
  
  SELECT pr.snap_ts < pg_stat_get_snapshot_timestamp() as snapshot_newer

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_groupby_1.out"	2025-07-31 16:07:15.009067755 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_groupby.out"	2025-07-31 16:40:52.635319059 +0800
***************
*** 35,41 ****
                 Group Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial HashAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
--- 35,41 ----
                 Group Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial HashAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
***************
*** 53,59 ****
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_groupby_tab1.val2
--- 53,59 ----
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_groupby_tab1.val2
***************
*** 81,87 ****
           Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
           ->  Remote Subquery Scan on all
                 Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
                       Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
--- 81,87 ----
           Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
           ->  Remote Subquery Scan on all
                 Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
                       Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
***************
*** 90,103 ****
                             Hash Cond: (xc_groupby_tab1.val2 = xc_groupby_tab2.val2)
                             ->  Remote Subquery Scan on all
                                   Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
!                                  Distribute results by H: val2
                                   ->  Seq Scan on public.xc_groupby_tab1
                                         Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
                             ->  Hash
                                   Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
                                   ->  Remote Subquery Scan on all
                                         Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
!                                        Distribute results by H: val2
                                         ->  Seq Scan on public.xc_groupby_tab2
                                               Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
  (26 rows)
--- 90,103 ----
                             Hash Cond: (xc_groupby_tab1.val2 = xc_groupby_tab2.val2)
                             ->  Remote Subquery Scan on all
                                   Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
!                                  Distribute results by S: val2
                                   ->  Seq Scan on public.xc_groupby_tab1
                                         Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
                             ->  Hash
                                   Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
                                   ->  Remote Subquery Scan on all
                                         Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
!                                        Distribute results by S: val2
                                         ->  Seq Scan on public.xc_groupby_tab2
                                               Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
  (26 rows)
***************
*** 124,130 ****
                 Group Key: x
                 ->  Remote Subquery Scan on all
                       Output: x, PARTIAL sum(y)
!                      Distribute results by H: x
                       ->  Partial HashAggregate
                             Output: ((xc_groupby_tab1.val2 % 2)), PARTIAL sum((sum(xc_groupby_tab1.val)))
                             Group Key: (xc_groupby_tab1.val2 % 2)
--- 124,130 ----
                 Group Key: x
                 ->  Remote Subquery Scan on all
                       Output: x, PARTIAL sum(y)
!                      Distribute results by S: x
                       ->  Partial HashAggregate
                             Output: ((xc_groupby_tab1.val2 % 2)), PARTIAL sum((sum(xc_groupby_tab1.val)))
                             Group Key: (xc_groupby_tab1.val2 % 2)
***************
*** 133,139 ****
                                   Group Key: xc_groupby_tab1.val2
                                   ->  Remote Subquery Scan on all
                                         Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                        Distribute results by H: val2
                                         ->  Partial HashAggregate
                                               Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                               Group Key: xc_groupby_tab1.val2
--- 133,139 ----
                                   Group Key: xc_groupby_tab1.val2
                                   ->  Remote Subquery Scan on all
                                         Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                        Distribute results by S: val2
                                         ->  Partial HashAggregate
                                               Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                               Group Key: xc_groupby_tab1.val2
***************
*** 151,157 ****
           Group Key: x
           ->  Remote Subquery Scan on all
                 Output: x, PARTIAL sum(y)
!                Distribute results by H: x
                 ->  Partial HashAggregate
                       Output: ((xc_groupby_tab1.val2 % 2)), PARTIAL sum((sum(xc_groupby_tab1.val)))
                       Group Key: (xc_groupby_tab1.val2 % 2)
--- 151,157 ----
           Group Key: x
           ->  Remote Subquery Scan on all
                 Output: x, PARTIAL sum(y)
!                Distribute results by S: x
                 ->  Partial HashAggregate
                       Output: ((xc_groupby_tab1.val2 % 2)), PARTIAL sum((sum(xc_groupby_tab1.val)))
                       Group Key: (xc_groupby_tab1.val2 % 2)
***************
*** 160,166 ****
                             Group Key: xc_groupby_tab1.val2
                             ->  Remote Subquery Scan on all
                                   Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                  Distribute results by H: val2
                                   ->  Partial HashAggregate
                                         Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                         Group Key: xc_groupby_tab1.val2
--- 160,166 ----
                             Group Key: xc_groupby_tab1.val2
                             ->  Remote Subquery Scan on all
                                   Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                  Distribute results by S: val2
                                   ->  Partial HashAggregate
                                         Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                         Group Key: xc_groupby_tab1.val2
***************
*** 191,197 ****
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2
!                      Distribute results by H: val2
                       ->  Partial HashAggregate
                             Output: val2
                             Group Key: xc_groupby_tab1.val2
--- 191,197 ----
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2
!                      Distribute results by S: val2
                       ->  Partial HashAggregate
                             Output: val2
                             Group Key: xc_groupby_tab1.val2
***************
*** 209,215 ****
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2
                       Group Key: xc_groupby_tab1.val2
--- 209,215 ----
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2
                       Group Key: xc_groupby_tab1.val2
***************
*** 242,248 ****
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2)
!                      Distribute results by H: (val + val2)
                       ->  Partial HashAggregate
                             Output: ((val + val2))
                             Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
--- 242,248 ----
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2)
!                      Distribute results by S: (val + val2)
                       ->  Partial HashAggregate
                             Output: ((val + val2))
                             Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
***************
*** 260,266 ****
           Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
           ->  Remote Subquery Scan on all
                 Output: (val + val2)
!                Distribute results by H: (val + val2)
                 ->  Partial HashAggregate
                       Output: ((val + val2))
                       Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
--- 260,266 ----
           Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
           ->  Remote Subquery Scan on all
                 Output: (val + val2)
!                Distribute results by S: (val + val2)
                 ->  Partial HashAggregate
                       Output: ((val + val2))
                       Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
***************
*** 385,391 ****
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                      Distribute results by H: (val + val2)
                       ->  Partial HashAggregate
                             Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                             Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
--- 385,391 ----
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                      Distribute results by S: (val + val2)
                       ->  Partial HashAggregate
                             Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                             Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
***************
*** 410,416 ****
           Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
           ->  Remote Subquery Scan on all
                 Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                Distribute results by H: (val + val2)
                 ->  Partial HashAggregate
                       Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                       Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
--- 410,416 ----
           Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
           ->  Remote Subquery Scan on all
                 Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                Distribute results by S: (val + val2)
                 ->  Partial HashAggregate
                       Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                       Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
***************
*** 448,454 ****
                 Group Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial HashAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
--- 448,454 ----
                 Group Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial HashAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
***************
*** 466,472 ****
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_groupby_tab1.val2
--- 466,472 ----
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_groupby_tab1.val2
***************
*** 497,503 ****
                 Group Key: (2 * xc_groupby_tab1.val2)
                 ->  Remote Subquery Scan on all
                       Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: (2 * val2)
                       ->  Partial HashAggregate
                             Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: (2 * xc_groupby_tab1.val2)
--- 497,503 ----
                 Group Key: (2 * xc_groupby_tab1.val2)
                 ->  Remote Subquery Scan on all
                       Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: (2 * val2)
                       ->  Partial HashAggregate
                             Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: (2 * xc_groupby_tab1.val2)
***************
*** 515,521 ****
           Group Key: (2 * xc_groupby_tab1.val2)
           ->  Remote Subquery Scan on all
                 Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by H: (2 * val2)
                 ->  Partial HashAggregate
                       Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: (2 * xc_groupby_tab1.val2)
--- 515,521 ----
           Group Key: (2 * xc_groupby_tab1.val2)
           ->  Remote Subquery Scan on all
                 Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by S: (2 * val2)
                 ->  Partial HashAggregate
                       Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: (2 * xc_groupby_tab1.val2)
***************
*** 528,535 ****
--- 528,539 ----
  -- some tests involving nulls, characters, float type etc.
  create table xc_groupby_def(a int, b varchar(25)); 
  insert into xc_groupby_def VALUES (NULL, NULL);
+ ERROR:  node:datanode_1, backend_pid:384358, nodename:datanode_1,backend_pid:384358,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, null).
  insert into xc_groupby_def VALUES (1, NULL);
  insert into xc_groupby_def VALUES (NULL, 'One');
+ ERROR:  node:datanode_1, backend_pid:386082, nodename:datanode_1,backend_pid:386082,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, One).
  insert into xc_groupby_def VALUES (2, 'Two');
  insert into xc_groupby_def VALUES (2, 'Two');
  insert into xc_groupby_def VALUES (3, 'Three');
***************
*** 553,560 ****
    8 |     1
    9 |     1
   10 |     1
!     |     0
! (11 rows)
  
  explain (verbose true, costs false, nodes false) select a,count(a) from xc_groupby_def group by a order by a;
                       QUERY PLAN                      
--- 557,563 ----
    8 |     1
    9 |     1
   10 |     1
! (10 rows)
  
  explain (verbose true, costs false, nodes false) select a,count(a) from xc_groupby_def group by a order by a;
                       QUERY PLAN                      
***************
*** 585,592 ****
       8.0000000000000000
       9.0000000000000000
      10.0000000000000000
!                        
! (11 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by a order by 1;
                       QUERY PLAN                      
--- 588,594 ----
       8.0000000000000000
       9.0000000000000000
      10.0000000000000000
! (10 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by a order by 1;
                       QUERY PLAN                      
***************
*** 622,629 ****
   4.0000000000000000
   4.5000000000000000
   6.2000000000000000
!                    
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
--- 624,630 ----
   4.0000000000000000
   4.5000000000000000
   6.2000000000000000
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
***************
*** 639,645 ****
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_def.b
--- 640,646 ----
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_def.b
***************
*** 657,663 ****
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL avg(a)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL avg(a)
                       Group Key: xc_groupby_def.b
--- 658,664 ----
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL avg(a)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL avg(a)
                       Group Key: xc_groupby_def.b
***************
*** 671,678 ****
     8
    18
    31
!     
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select sum(a) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
--- 672,678 ----
     8
    18
    31
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select sum(a) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
***************
*** 688,694 ****
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(a)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(a)
                             Group Key: xc_groupby_def.b
--- 688,694 ----
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(a)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(a)
                             Group Key: xc_groupby_def.b
***************
*** 706,712 ****
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(a)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(a)
                       Group Key: xc_groupby_def.b
--- 706,712 ----
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(a)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(a)
                       Group Key: xc_groupby_def.b
***************
*** 717,727 ****
  select count(*) from xc_groupby_def group by b order by 1;
   count 
  -------
!      1
!      3
       4
       5
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
--- 717,726 ----
  select count(*) from xc_groupby_def group by b order by 1;
   count 
  -------
!      2
       4
       5
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
***************
*** 737,743 ****
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
--- 736,742 ----
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
***************
*** 755,761 ****
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL count(*)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL count(*)
                       Group Key: xc_groupby_def.b
--- 754,760 ----
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL count(*)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL count(*)
                       Group Key: xc_groupby_def.b
***************
*** 811,821 ****
  select * from (select b from xc_groupby_def group by b) q order by q.b;
     b   
  -------
-  One
   Three
   Two
   
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select * from (select b from xc_groupby_def group by b) q order by q.b;
                                   QUERY PLAN                                 
--- 810,819 ----
  select * from (select b from xc_groupby_def group by b) q order by q.b;
     b   
  -------
   Three
   Two
   
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select * from (select b from xc_groupby_def group by b) q order by q.b;
                                   QUERY PLAN                                 
***************
*** 831,837 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_def.b
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: xc_groupby_def.b
                             Group Key: xc_groupby_def.b
--- 829,835 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_def.b
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: xc_groupby_def.b
                             Group Key: xc_groupby_def.b
***************
*** 842,852 ****
  select * from (select b,count(b) from xc_groupby_def group by b) q order by q.b;
     b   | count 
  -------+-------
-  One   |     1
   Three |     5
   Two   |     4
         |     0
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select * from (select b,count(b) from xc_groupby_def group by b) q order by q.b;
                                       QUERY PLAN                                      
--- 840,849 ----
  select * from (select b,count(b) from xc_groupby_def group by b) q order by q.b;
     b   | count 
  -------+-------
   Three |     5
   Two   |     4
         |     0
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select * from (select b,count(b) from xc_groupby_def group by b) q order by q.b;
                                       QUERY PLAN                                      
***************
*** 862,868 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_def.b, PARTIAL count(xc_groupby_def.b)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: xc_groupby_def.b, PARTIAL count(xc_groupby_def.b)
                             Group Key: xc_groupby_def.b
--- 859,865 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_def.b, PARTIAL count(xc_groupby_def.b)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: xc_groupby_def.b, PARTIAL count(xc_groupby_def.b)
                             Group Key: xc_groupby_def.b
***************
*** 873,879 ****
  select count(*) from xc_groupby_def where b is null group by b order by 1;
   count 
  -------
!      3
  (1 row)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def where b is null group by b;
--- 870,876 ----
  select count(*) from xc_groupby_def where b is null group by b order by 1;
   count 
  -------
!      2
  (1 row)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def where b is null group by b;
***************
*** 889,895 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
--- 886,892 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
***************
*** 942,948 ****
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(b)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(b)
                             Group Key: xc_groupby_g.b
--- 939,945 ----
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(b)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(b)
                             Group Key: xc_groupby_g.b
***************
*** 960,966 ****
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(b)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(b)
                       Group Key: xc_groupby_g.b
--- 957,963 ----
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(b)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(b)
                       Group Key: xc_groupby_g.b
***************
*** 989,995 ****
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(c)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(c)
                             Group Key: xc_groupby_g.b
--- 986,992 ----
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(c)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(c)
                             Group Key: xc_groupby_g.b
***************
*** 1007,1013 ****
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(c)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(c)
                       Group Key: xc_groupby_g.b
--- 1004,1010 ----
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(c)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(c)
                       Group Key: xc_groupby_g.b
***************
*** 1036,1042 ****
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_g.b
--- 1033,1039 ----
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_g.b
***************
*** 1054,1060 ****
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL avg(a)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL avg(a)
                       Group Key: xc_groupby_g.b
--- 1051,1057 ----
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL avg(a)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL avg(a)
                       Group Key: xc_groupby_g.b
***************
*** 1083,1089 ****
                 Group Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(b)
!                      Distribute results by H: c
                       ->  Partial HashAggregate
                             Output: c, PARTIAL avg(b)
                             Group Key: xc_groupby_g.c
--- 1080,1086 ----
                 Group Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(b)
!                      Distribute results by S: c
                       ->  Partial HashAggregate
                             Output: c, PARTIAL avg(b)
                             Group Key: xc_groupby_g.c
***************
*** 1101,1107 ****
           Group Key: xc_groupby_g.c
           ->  Remote Subquery Scan on all
                 Output: c, PARTIAL avg(b)
!                Distribute results by H: c
                 ->  Partial HashAggregate
                       Output: c, PARTIAL avg(b)
                       Group Key: xc_groupby_g.c
--- 1098,1104 ----
           Group Key: xc_groupby_g.c
           ->  Remote Subquery Scan on all
                 Output: c, PARTIAL avg(b)
!                Distribute results by S: c
                 ->  Partial HashAggregate
                       Output: c, PARTIAL avg(b)
                       Group Key: xc_groupby_g.c
***************
*** 1130,1136 ****
                 Group Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(c)
!                      Distribute results by H: c
                       ->  Partial HashAggregate
                             Output: c, PARTIAL avg(c)
                             Group Key: xc_groupby_g.c
--- 1127,1133 ----
                 Group Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(c)
!                      Distribute results by S: c
                       ->  Partial HashAggregate
                             Output: c, PARTIAL avg(c)
                             Group Key: xc_groupby_g.c
***************
*** 2060,2066 ****
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
--- 2057,2063 ----
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
***************
*** 2094,2100 ****
                 Sort Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
                             Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
--- 2091,2097 ----
                 Sort Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
                             Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
***************
*** 2106,2119 ****
                                         Hash Cond: (xc_groupby_tab1.val2 = xc_groupby_tab2.val2)
                                         ->  Remote Subquery Scan on all
                                               Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
!                                              Distribute results by H: val2
                                               ->  Seq Scan on public.xc_groupby_tab1
                                                     Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
                                         ->  Hash
                                               Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
                                               ->  Remote Subquery Scan on all
                                                     Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
!                                                    Distribute results by H: val2
                                                     ->  Seq Scan on public.xc_groupby_tab2
                                                           Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
  (32 rows)
--- 2103,2116 ----
                                         Hash Cond: (xc_groupby_tab1.val2 = xc_groupby_tab2.val2)
                                         ->  Remote Subquery Scan on all
                                               Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
!                                              Distribute results by S: val2
                                               ->  Seq Scan on public.xc_groupby_tab1
                                                     Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
                                         ->  Hash
                                               Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
                                               ->  Remote Subquery Scan on all
                                                     Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
!                                                    Distribute results by S: val2
                                                     ->  Seq Scan on public.xc_groupby_tab2
                                                           Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
  (32 rows)
***************
*** 2139,2145 ****
                 Sort Key: q1.x
                 ->  Remote Subquery Scan on all
                       Output: q1.x, PARTIAL sum(q1.y)
!                      Distribute results by H: x
                       ->  Partial GroupAggregate
                             Output: q1.x, PARTIAL sum(q1.y)
                             Group Key: q1.x
--- 2136,2142 ----
                 Sort Key: q1.x
                 ->  Remote Subquery Scan on all
                       Output: q1.x, PARTIAL sum(q1.y)
!                      Distribute results by S: x
                       ->  Partial GroupAggregate
                             Output: q1.x, PARTIAL sum(q1.y)
                             Group Key: q1.x
***************
*** 2156,2162 ****
                                                     Sort Key: xc_groupby_tab1.val2
                                                     ->  Remote Subquery Scan on all
                                                           Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                                          Distribute results by H: val2
                                                           ->  Partial GroupAggregate
                                                                 Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                                                 Group Key: xc_groupby_tab1.val2
--- 2153,2159 ----
                                                     Sort Key: xc_groupby_tab1.val2
                                                     ->  Remote Subquery Scan on all
                                                           Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                                          Distribute results by S: val2
                                                           ->  Partial GroupAggregate
                                                                 Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                                                 Group Key: xc_groupby_tab1.val2
***************
*** 2189,2195 ****
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2
!                      Distribute results by H: val2
                       ->  Group
                             Output: val2
                             Group Key: xc_groupby_tab1.val2
--- 2186,2192 ----
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2
!                      Distribute results by S: val2
                       ->  Group
                             Output: val2
                             Group Key: xc_groupby_tab1.val2
***************
*** 2224,2230 ****
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2)
!                      Distribute results by H: (val + val2)
                       ->  Group
                             Output: ((val + val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
--- 2221,2227 ----
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2)
!                      Distribute results by S: (val + val2)
                       ->  Group
                             Output: ((val + val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
***************
*** 2319,2325 ****
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                      Distribute results by H: (val + val2)
                       ->  Group
                             Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
--- 2316,2322 ----
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                      Distribute results by S: (val + val2)
                       ->  Group
                             Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
***************
*** 2359,2365 ****
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
--- 2356,2362 ----
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
***************
*** 2392,2398 ****
                 Sort Key: ((2 * xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: (2 * val2)
                       ->  Partial GroupAggregate
                             Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: ((2 * xc_groupby_tab1.val2))
--- 2389,2395 ----
                 Sort Key: ((2 * xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: (2 * val2)
                       ->  Partial GroupAggregate
                             Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: ((2 * xc_groupby_tab1.val2))
***************
*** 2408,2415 ****
--- 2405,2416 ----
  -- some tests involving nulls, characters, float type etc.
  create table xc_groupby_def(a int, b varchar(25)); 
  insert into xc_groupby_def VALUES (NULL, NULL);
+ ERROR:  node:datanode_1, backend_pid:384358, nodename:datanode_1,backend_pid:384358,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, null).
  insert into xc_groupby_def VALUES (1, NULL);
  insert into xc_groupby_def VALUES (NULL, 'One');
+ ERROR:  node:datanode_1, backend_pid:384358, nodename:datanode_1,backend_pid:384358,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, One).
  insert into xc_groupby_def VALUES (2, 'Two');
  insert into xc_groupby_def VALUES (2, 'Two');
  insert into xc_groupby_def VALUES (3, 'Three');
***************
*** 2433,2440 ****
    8 |     1
    9 |     1
   10 |     1
!     |     0
! (11 rows)
  
  explain (verbose true, costs false, nodes false) select a,count(a) from xc_groupby_def group by a order by a;
                       QUERY PLAN                      
--- 2434,2440 ----
    8 |     1
    9 |     1
   10 |     1
! (10 rows)
  
  explain (verbose true, costs false, nodes false) select a,count(a) from xc_groupby_def group by a order by a;
                       QUERY PLAN                      
***************
*** 2465,2472 ****
       8.0000000000000000
       9.0000000000000000
      10.0000000000000000
!                        
! (11 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by a order by 1;
                          QUERY PLAN                         
--- 2465,2471 ----
       8.0000000000000000
       9.0000000000000000
      10.0000000000000000
! (10 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by a order by 1;
                          QUERY PLAN                         
***************
*** 2493,2500 ****
   4.0000000000000000
   4.5000000000000000
   6.2000000000000000
!                    
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by b;
                                QUERY PLAN                               
--- 2492,2498 ----
   4.0000000000000000
   4.5000000000000000
   6.2000000000000000
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by b;
                                QUERY PLAN                               
***************
*** 2509,2515 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_def.b
--- 2507,2513 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_def.b
***************
*** 2526,2533 ****
     8
    18
    31
!     
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select sum(a) from xc_groupby_def group by b;
                                QUERY PLAN                               
--- 2524,2530 ----
     8
    18
    31
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select sum(a) from xc_groupby_def group by b;
                                QUERY PLAN                               
***************
*** 2542,2548 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(a)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(a)
                             Group Key: xc_groupby_def.b
--- 2539,2545 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(a)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(a)
                             Group Key: xc_groupby_def.b
***************
*** 2556,2566 ****
  select count(*) from xc_groupby_def group by b order by 1;
   count 
  -------
!      1
!      3
       4
       5
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def group by b;
                                QUERY PLAN                               
--- 2553,2562 ----
  select count(*) from xc_groupby_def group by b order by 1;
   count 
  -------
!      2
       4
       5
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def group by b;
                                QUERY PLAN                               
***************
*** 2575,2581 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
--- 2571,2577 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
***************
*** 2620,2630 ****
  select b from xc_groupby_def group by b order by 1;
     b   
  -------
-  One
   Three
   Two
   
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select b from xc_groupby_def group by b;
                                QUERY PLAN                               
--- 2616,2625 ----
  select b from xc_groupby_def group by b order by 1;
     b   
  -------
   Three
   Two
   
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select b from xc_groupby_def group by b;
                                QUERY PLAN                               
***************
*** 2639,2645 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b
!                      Distribute results by H: b
                       ->  Group
                             Output: b
                             Group Key: xc_groupby_def.b
--- 2634,2640 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b
!                      Distribute results by S: b
                       ->  Group
                             Output: b
                             Group Key: xc_groupby_def.b
***************
*** 2653,2663 ****
  select b,count(b) from xc_groupby_def group by b order by 1;
     b   | count 
  -------+-------
-  One   |     1
   Three |     5
   Two   |     4
         |     0
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select b,count(b) from xc_groupby_def group by b;
                                QUERY PLAN                               
--- 2648,2657 ----
  select b,count(b) from xc_groupby_def group by b order by 1;
     b   | count 
  -------+-------
   Three |     5
   Two   |     4
         |     0
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select b,count(b) from xc_groupby_def group by b;
                                QUERY PLAN                               
***************
*** 2672,2678 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(b)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(b)
                             Group Key: xc_groupby_def.b
--- 2666,2672 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(b)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(b)
                             Group Key: xc_groupby_def.b
***************
*** 2686,2692 ****
  select count(*) from xc_groupby_def where b is null group by b order by 1;
   count 
  -------
!      3
  (1 row)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def where b is null group by b;
--- 2680,2686 ----
  select count(*) from xc_groupby_def where b is null group by b order by 1;
   count 
  -------
!      2
  (1 row)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def where b is null group by b;
***************
*** 2702,2708 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
--- 2696,2702 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
***************
*** 2760,2766 ****
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(b)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(b)
                             Group Key: xc_groupby_g.b
--- 2754,2760 ----
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(b)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(b)
                             Group Key: xc_groupby_g.b
***************
*** 2791,2797 ****
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(c)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(c)
                             Group Key: xc_groupby_g.b
--- 2785,2791 ----
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(c)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(c)
                             Group Key: xc_groupby_g.b
***************
*** 2822,2828 ****
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_g.b
--- 2816,2822 ----
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_g.b
***************
*** 2853,2859 ****
                 Sort Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(b)
!                      Distribute results by H: c
                       ->  Partial GroupAggregate
                             Output: c, PARTIAL avg(b)
                             Group Key: xc_groupby_g.c
--- 2847,2853 ----
                 Sort Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(b)
!                      Distribute results by S: c
                       ->  Partial GroupAggregate
                             Output: c, PARTIAL avg(b)
                             Group Key: xc_groupby_g.c
***************
*** 2884,2890 ****
                 Sort Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(c)
!                      Distribute results by H: c
                       ->  Partial GroupAggregate
                             Output: c, PARTIAL avg(c)
                             Group Key: xc_groupby_g.c
--- 2878,2884 ----
                 Sort Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(c)
!                      Distribute results by S: c
                       ->  Partial GroupAggregate
                             Output: c, PARTIAL avg(c)
                             Group Key: xc_groupby_g.c
***************
*** 3646,3652 ****
                 Group Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial HashAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
--- 3640,3646 ----
                 Group Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial HashAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
***************
*** 3664,3670 ****
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_groupby_tab1.val2
--- 3658,3664 ----
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_groupby_tab1.val2
***************
*** 3692,3698 ****
           Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
           ->  Remote Subquery Scan on all
                 Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
                       Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
--- 3686,3692 ----
           Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
           ->  Remote Subquery Scan on all
                 Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
                       Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
***************
*** 3701,3714 ****
                             Hash Cond: (xc_groupby_tab1.val2 = xc_groupby_tab2.val2)
                             ->  Remote Subquery Scan on all
                                   Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
!                                  Distribute results by H: val2
                                   ->  Seq Scan on public.xc_groupby_tab1
                                         Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
                             ->  Hash
                                   Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
                                   ->  Remote Subquery Scan on all
                                         Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
!                                        Distribute results by H: val2
                                         ->  Seq Scan on public.xc_groupby_tab2
                                               Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
  (26 rows)
--- 3695,3708 ----
                             Hash Cond: (xc_groupby_tab1.val2 = xc_groupby_tab2.val2)
                             ->  Remote Subquery Scan on all
                                   Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
!                                  Distribute results by S: val2
                                   ->  Seq Scan on public.xc_groupby_tab1
                                         Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
                             ->  Hash
                                   Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
                                   ->  Remote Subquery Scan on all
                                         Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
!                                        Distribute results by S: val2
                                         ->  Seq Scan on public.xc_groupby_tab2
                                               Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
  (26 rows)
***************
*** 3735,3741 ****
                 Group Key: x
                 ->  Remote Subquery Scan on all
                       Output: x, PARTIAL sum(y)
!                      Distribute results by H: x
                       ->  Partial HashAggregate
                             Output: ((xc_groupby_tab1.val2 % 2)), PARTIAL sum((sum(xc_groupby_tab1.val)))
                             Group Key: (xc_groupby_tab1.val2 % 2)
--- 3729,3735 ----
                 Group Key: x
                 ->  Remote Subquery Scan on all
                       Output: x, PARTIAL sum(y)
!                      Distribute results by S: x
                       ->  Partial HashAggregate
                             Output: ((xc_groupby_tab1.val2 % 2)), PARTIAL sum((sum(xc_groupby_tab1.val)))
                             Group Key: (xc_groupby_tab1.val2 % 2)
***************
*** 3744,3750 ****
                                   Group Key: xc_groupby_tab1.val2
                                   ->  Remote Subquery Scan on all
                                         Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                        Distribute results by H: val2
                                         ->  Partial HashAggregate
                                               Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                               Group Key: xc_groupby_tab1.val2
--- 3738,3744 ----
                                   Group Key: xc_groupby_tab1.val2
                                   ->  Remote Subquery Scan on all
                                         Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                        Distribute results by S: val2
                                         ->  Partial HashAggregate
                                               Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                               Group Key: xc_groupby_tab1.val2
***************
*** 3762,3768 ****
           Group Key: x
           ->  Remote Subquery Scan on all
                 Output: x, PARTIAL sum(y)
!                Distribute results by H: x
                 ->  Partial HashAggregate
                       Output: ((xc_groupby_tab1.val2 % 2)), PARTIAL sum((sum(xc_groupby_tab1.val)))
                       Group Key: (xc_groupby_tab1.val2 % 2)
--- 3756,3762 ----
           Group Key: x
           ->  Remote Subquery Scan on all
                 Output: x, PARTIAL sum(y)
!                Distribute results by S: x
                 ->  Partial HashAggregate
                       Output: ((xc_groupby_tab1.val2 % 2)), PARTIAL sum((sum(xc_groupby_tab1.val)))
                       Group Key: (xc_groupby_tab1.val2 % 2)
***************
*** 3771,3777 ****
                             Group Key: xc_groupby_tab1.val2
                             ->  Remote Subquery Scan on all
                                   Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                  Distribute results by H: val2
                                   ->  Partial HashAggregate
                                         Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                         Group Key: xc_groupby_tab1.val2
--- 3765,3771 ----
                             Group Key: xc_groupby_tab1.val2
                             ->  Remote Subquery Scan on all
                                   Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                  Distribute results by S: val2
                                   ->  Partial HashAggregate
                                         Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                         Group Key: xc_groupby_tab1.val2
***************
*** 3802,3808 ****
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2
!                      Distribute results by H: val2
                       ->  Partial HashAggregate
                             Output: val2
                             Group Key: xc_groupby_tab1.val2
--- 3796,3802 ----
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2
!                      Distribute results by S: val2
                       ->  Partial HashAggregate
                             Output: val2
                             Group Key: xc_groupby_tab1.val2
***************
*** 3820,3826 ****
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2
                       Group Key: xc_groupby_tab1.val2
--- 3814,3820 ----
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2
                       Group Key: xc_groupby_tab1.val2
***************
*** 3853,3859 ****
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2)
!                      Distribute results by H: (val + val2)
                       ->  Partial HashAggregate
                             Output: ((val + val2))
                             Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
--- 3847,3853 ----
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2)
!                      Distribute results by S: (val + val2)
                       ->  Partial HashAggregate
                             Output: ((val + val2))
                             Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
***************
*** 3871,3877 ****
           Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
           ->  Remote Subquery Scan on all
                 Output: (val + val2)
!                Distribute results by H: (val + val2)
                 ->  Partial HashAggregate
                       Output: ((val + val2))
                       Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
--- 3865,3871 ----
           Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
           ->  Remote Subquery Scan on all
                 Output: (val + val2)
!                Distribute results by S: (val + val2)
                 ->  Partial HashAggregate
                       Output: ((val + val2))
                       Group Key: (xc_groupby_tab1.val + xc_groupby_tab1.val2)
***************
*** 4002,4008 ****
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                      Distribute results by H: (val + val2)
                       ->  Partial HashAggregate
                             Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                             Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
--- 3996,4002 ----
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                      Distribute results by S: (val + val2)
                       ->  Partial HashAggregate
                             Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                             Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
***************
*** 4027,4033 ****
           Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
           ->  Remote Subquery Scan on all
                 Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                Distribute results by H: (val + val2)
                 ->  Partial HashAggregate
                       Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                       Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
--- 4021,4027 ----
           Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
           ->  Remote Subquery Scan on all
                 Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                Distribute results by S: (val + val2)
                 ->  Partial HashAggregate
                       Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                       Group Key: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
***************
*** 4065,4071 ****
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial HashAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
--- 4059,4065 ----
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial HashAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
***************
*** 4083,4089 ****
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_groupby_tab1.val2
--- 4077,4083 ----
           Group Key: xc_groupby_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_groupby_tab1.val2
***************
*** 4114,4120 ****
                 Sort Key: ((2 * xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: (2 * val2)
                       ->  Partial HashAggregate
                             Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: (2 * xc_groupby_tab1.val2)
--- 4108,4114 ----
                 Sort Key: ((2 * xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: (2 * val2)
                       ->  Partial HashAggregate
                             Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: (2 * xc_groupby_tab1.val2)
***************
*** 4132,4138 ****
           Group Key: (2 * xc_groupby_tab1.val2)
           ->  Remote Subquery Scan on all
                 Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by H: (2 * val2)
                 ->  Partial HashAggregate
                       Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: (2 * xc_groupby_tab1.val2)
--- 4126,4132 ----
           Group Key: (2 * xc_groupby_tab1.val2)
           ->  Remote Subquery Scan on all
                 Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by S: (2 * val2)
                 ->  Partial HashAggregate
                       Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: (2 * xc_groupby_tab1.val2)
***************
*** 4145,4152 ****
--- 4139,4150 ----
  -- some tests involving nulls, characters, float type etc.
  create table xc_groupby_def(a int, b varchar(25)); 
  insert into xc_groupby_def VALUES (NULL, NULL);
+ ERROR:  node:datanode_1, backend_pid:384358, nodename:datanode_1,backend_pid:384358,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, null).
  insert into xc_groupby_def VALUES (1, NULL);
  insert into xc_groupby_def VALUES (NULL, 'One');
+ ERROR:  node:datanode_1, backend_pid:384358, nodename:datanode_1,backend_pid:384358,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, One).
  insert into xc_groupby_def VALUES (2, 'Two');
  insert into xc_groupby_def VALUES (2, 'Two');
  insert into xc_groupby_def VALUES (3, 'Three');
***************
*** 4170,4177 ****
    8 |     1
    9 |     1
   10 |     1
!     |     0
! (11 rows)
  
  explain (verbose true, costs false, nodes false) select a,count(a) from xc_groupby_def group by a order by a;
                       QUERY PLAN                      
--- 4168,4174 ----
    8 |     1
    9 |     1
   10 |     1
! (10 rows)
  
  explain (verbose true, costs false, nodes false) select a,count(a) from xc_groupby_def group by a order by a;
                       QUERY PLAN                      
***************
*** 4202,4209 ****
       8.0000000000000000
       9.0000000000000000
      10.0000000000000000
!                        
! (11 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by a order by 1;
                       QUERY PLAN                      
--- 4199,4205 ----
       8.0000000000000000
       9.0000000000000000
      10.0000000000000000
! (10 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by a order by 1;
                       QUERY PLAN                      
***************
*** 4239,4246 ****
   4.0000000000000000
   4.5000000000000000
   6.2000000000000000
!                    
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
--- 4235,4241 ----
   4.0000000000000000
   4.5000000000000000
   6.2000000000000000
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
***************
*** 4256,4262 ****
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_def.b
--- 4251,4257 ----
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_def.b
***************
*** 4274,4280 ****
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL avg(a)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL avg(a)
                       Group Key: xc_groupby_def.b
--- 4269,4275 ----
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL avg(a)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL avg(a)
                       Group Key: xc_groupby_def.b
***************
*** 4288,4295 ****
     8
    18
    31
!     
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select sum(a) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
--- 4283,4289 ----
     8
    18
    31
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select sum(a) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
***************
*** 4305,4311 ****
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(a)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(a)
                             Group Key: xc_groupby_def.b
--- 4299,4305 ----
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(a)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(a)
                             Group Key: xc_groupby_def.b
***************
*** 4323,4329 ****
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(a)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(a)
                       Group Key: xc_groupby_def.b
--- 4317,4323 ----
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(a)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(a)
                       Group Key: xc_groupby_def.b
***************
*** 4334,4344 ****
  select count(*) from xc_groupby_def group by b order by 1;
   count 
  -------
!      1
!      3
       4
       5
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
--- 4328,4337 ----
  select count(*) from xc_groupby_def group by b order by 1;
   count 
  -------
!      2
       4
       5
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def group by b order by 1;
                             QUERY PLAN                            
***************
*** 4354,4360 ****
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
--- 4347,4353 ----
                 Group Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
***************
*** 4372,4378 ****
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL count(*)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL count(*)
                       Group Key: xc_groupby_def.b
--- 4365,4371 ----
           Group Key: xc_groupby_def.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL count(*)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL count(*)
                       Group Key: xc_groupby_def.b
***************
*** 4428,4438 ****
  select * from (select b from xc_groupby_def group by b) q order by q.b;
     b   
  -------
-  One
   Three
   Two
   
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select * from (select b from xc_groupby_def group by b) q order by q.b;
                                   QUERY PLAN                                 
--- 4421,4430 ----
  select * from (select b from xc_groupby_def group by b) q order by q.b;
     b   
  -------
   Three
   Two
   
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select * from (select b from xc_groupby_def group by b) q order by q.b;
                                   QUERY PLAN                                 
***************
*** 4448,4454 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_def.b
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: xc_groupby_def.b
                             Group Key: xc_groupby_def.b
--- 4440,4446 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_def.b
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: xc_groupby_def.b
                             Group Key: xc_groupby_def.b
***************
*** 4459,4469 ****
  select * from (select b,count(b) from xc_groupby_def group by b) q order by q.b;
     b   | count 
  -------+-------
-  One   |     1
   Three |     5
   Two   |     4
         |     0
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select * from (select b,count(b) from xc_groupby_def group by b) q order by q.b;
                                       QUERY PLAN                                      
--- 4451,4460 ----
  select * from (select b,count(b) from xc_groupby_def group by b) q order by q.b;
     b   | count 
  -------+-------
   Three |     5
   Two   |     4
         |     0
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select * from (select b,count(b) from xc_groupby_def group by b) q order by q.b;
                                       QUERY PLAN                                      
***************
*** 4479,4485 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_def.b, PARTIAL count(xc_groupby_def.b)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: xc_groupby_def.b, PARTIAL count(xc_groupby_def.b)
                             Group Key: xc_groupby_def.b
--- 4470,4476 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_def.b, PARTIAL count(xc_groupby_def.b)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: xc_groupby_def.b, PARTIAL count(xc_groupby_def.b)
                             Group Key: xc_groupby_def.b
***************
*** 4490,4496 ****
  select count(*) from xc_groupby_def where b is null group by b order by 1;
   count 
  -------
!      3
  (1 row)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def where b is null group by b;
--- 4481,4487 ----
  select count(*) from xc_groupby_def where b is null group by b order by 1;
   count 
  -------
!      2
  (1 row)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def where b is null group by b;
***************
*** 4506,4512 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
--- 4497,4503 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
***************
*** 4559,4565 ****
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(b)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(b)
                             Group Key: xc_groupby_g.b
--- 4550,4556 ----
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(b)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(b)
                             Group Key: xc_groupby_g.b
***************
*** 4577,4583 ****
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(b)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(b)
                       Group Key: xc_groupby_g.b
--- 4568,4574 ----
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(b)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(b)
                       Group Key: xc_groupby_g.b
***************
*** 4606,4612 ****
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(c)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(c)
                             Group Key: xc_groupby_g.b
--- 4597,4603 ----
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(c)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL sum(c)
                             Group Key: xc_groupby_g.b
***************
*** 4624,4630 ****
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(c)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(c)
                       Group Key: xc_groupby_g.b
--- 4615,4621 ----
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL sum(c)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL sum(c)
                       Group Key: xc_groupby_g.b
***************
*** 4653,4659 ****
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by H: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_g.b
--- 4644,4650 ----
                 Group Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by S: b
                       ->  Partial HashAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_g.b
***************
*** 4671,4677 ****
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL avg(a)
!                Distribute results by H: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL avg(a)
                       Group Key: xc_groupby_g.b
--- 4662,4668 ----
           Group Key: xc_groupby_g.b
           ->  Remote Subquery Scan on all
                 Output: b, PARTIAL avg(a)
!                Distribute results by S: b
                 ->  Partial HashAggregate
                       Output: b, PARTIAL avg(a)
                       Group Key: xc_groupby_g.b
***************
*** 4700,4706 ****
                 Group Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(b)
!                      Distribute results by H: c
                       ->  Partial HashAggregate
                             Output: c, PARTIAL avg(b)
                             Group Key: xc_groupby_g.c
--- 4691,4697 ----
                 Group Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(b)
!                      Distribute results by S: c
                       ->  Partial HashAggregate
                             Output: c, PARTIAL avg(b)
                             Group Key: xc_groupby_g.c
***************
*** 4718,4724 ****
           Group Key: xc_groupby_g.c
           ->  Remote Subquery Scan on all
                 Output: c, PARTIAL avg(b)
!                Distribute results by H: c
                 ->  Partial HashAggregate
                       Output: c, PARTIAL avg(b)
                       Group Key: xc_groupby_g.c
--- 4709,4715 ----
           Group Key: xc_groupby_g.c
           ->  Remote Subquery Scan on all
                 Output: c, PARTIAL avg(b)
!                Distribute results by S: c
                 ->  Partial HashAggregate
                       Output: c, PARTIAL avg(b)
                       Group Key: xc_groupby_g.c
***************
*** 4747,4753 ****
                 Group Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(c)
!                      Distribute results by H: c
                       ->  Partial HashAggregate
                             Output: c, PARTIAL avg(c)
                             Group Key: xc_groupby_g.c
--- 4738,4744 ----
                 Group Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(c)
!                      Distribute results by S: c
                       ->  Partial HashAggregate
                             Output: c, PARTIAL avg(c)
                             Group Key: xc_groupby_g.c
***************
*** 4765,4771 ****
           Group Key: xc_groupby_g.c
           ->  Remote Subquery Scan on all
                 Output: c, PARTIAL avg(c)
!                Distribute results by H: c
                 ->  Partial HashAggregate
                       Output: c, PARTIAL avg(c)
                       Group Key: xc_groupby_g.c
--- 4756,4762 ----
           Group Key: xc_groupby_g.c
           ->  Remote Subquery Scan on all
                 Output: c, PARTIAL avg(c)
!                Distribute results by S: c
                 ->  Partial HashAggregate
                       Output: c, PARTIAL avg(c)
                       Group Key: xc_groupby_g.c
***************
*** 5699,5705 ****
                       Sort Key: xc_groupby_tab1.val2
                       ->  Remote Subquery Scan on all
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                            Distribute results by H: val2
                             ->  Partial GroupAggregate
                                   Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                                   Group Key: xc_groupby_tab1.val2
--- 5690,5696 ----
                       Sort Key: xc_groupby_tab1.val2
                       ->  Remote Subquery Scan on all
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                            Distribute results by S: val2
                             ->  Partial GroupAggregate
                                   Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                                   Group Key: xc_groupby_tab1.val2
***************
*** 5723,5729 ****
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
--- 5714,5720 ----
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
***************
*** 5757,5763 ****
                 Sort Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
                             Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
--- 5748,5754 ----
                 Sort Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
                 ->  Remote Subquery Scan on all
                       Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: xc_groupby_tab1.val2, xc_groupby_tab2.val2, PARTIAL count(*), PARTIAL sum((xc_groupby_tab1.val * xc_groupby_tab2.val)), PARTIAL avg((xc_groupby_tab1.val * xc_groupby_tab2.val))
                             Group Key: xc_groupby_tab1.val2, xc_groupby_tab2.val2
***************
*** 5769,5782 ****
                                         Hash Cond: (xc_groupby_tab1.val2 = xc_groupby_tab2.val2)
                                         ->  Remote Subquery Scan on all
                                               Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
!                                              Distribute results by H: val2
                                               ->  Seq Scan on public.xc_groupby_tab1
                                                     Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
                                         ->  Hash
                                               Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
                                               ->  Remote Subquery Scan on all
                                                     Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
!                                                    Distribute results by H: val2
                                                     ->  Seq Scan on public.xc_groupby_tab2
                                                           Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
  (32 rows)
--- 5760,5773 ----
                                         Hash Cond: (xc_groupby_tab1.val2 = xc_groupby_tab2.val2)
                                         ->  Remote Subquery Scan on all
                                               Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
!                                              Distribute results by S: val2
                                               ->  Seq Scan on public.xc_groupby_tab1
                                                     Output: xc_groupby_tab1.val, xc_groupby_tab1.val2
                                         ->  Hash
                                               Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
                                               ->  Remote Subquery Scan on all
                                                     Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
!                                                    Distribute results by S: val2
                                                     ->  Seq Scan on public.xc_groupby_tab2
                                                           Output: xc_groupby_tab2.val, xc_groupby_tab2.val2
  (32 rows)
***************
*** 5802,5808 ****
                 Sort Key: q1.x
                 ->  Remote Subquery Scan on all
                       Output: q1.x, PARTIAL sum(q1.y)
!                      Distribute results by H: x
                       ->  Partial GroupAggregate
                             Output: q1.x, PARTIAL sum(q1.y)
                             Group Key: q1.x
--- 5793,5799 ----
                 Sort Key: q1.x
                 ->  Remote Subquery Scan on all
                       Output: q1.x, PARTIAL sum(q1.y)
!                      Distribute results by S: x
                       ->  Partial GroupAggregate
                             Output: q1.x, PARTIAL sum(q1.y)
                             Group Key: q1.x
***************
*** 5819,5825 ****
                                                     Sort Key: xc_groupby_tab1.val2
                                                     ->  Remote Subquery Scan on all
                                                           Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                                          Distribute results by H: val2
                                                           ->  Partial GroupAggregate
                                                                 Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                                                 Group Key: xc_groupby_tab1.val2
--- 5810,5816 ----
                                                     Sort Key: xc_groupby_tab1.val2
                                                     ->  Remote Subquery Scan on all
                                                           Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
!                                                          Distribute results by S: val2
                                                           ->  Partial GroupAggregate
                                                                 Output: xc_groupby_tab1.val2, PARTIAL sum(xc_groupby_tab1.val)
                                                                 Group Key: xc_groupby_tab1.val2
***************
*** 5853,5859 ****
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2
!                      Distribute results by H: val2
                       ->  Group
                             Output: val2
                             Group Key: xc_groupby_tab1.val2
--- 5844,5850 ----
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2
!                      Distribute results by S: val2
                       ->  Group
                             Output: val2
                             Group Key: xc_groupby_tab1.val2
***************
*** 5877,5883 ****
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2
!                      Distribute results by H: val2
                       ->  Group
                             Output: val2
                             Group Key: xc_groupby_tab1.val2
--- 5868,5874 ----
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2
!                      Distribute results by S: val2
                       ->  Group
                             Output: val2
                             Group Key: xc_groupby_tab1.val2
***************
*** 5913,5919 ****
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2)
!                      Distribute results by H: (val + val2)
                       ->  Group
                             Output: ((val + val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
--- 5904,5910 ----
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2)
!                      Distribute results by S: (val + val2)
                       ->  Group
                             Output: ((val + val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
***************
*** 5937,5943 ****
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2)
!                      Distribute results by H: (val + val2)
                       ->  Group
                             Output: ((val + val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
--- 5928,5934 ----
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2)
!                      Distribute results by S: (val + val2)
                       ->  Group
                             Output: ((val + val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab1.val2))
***************
*** 6083,6089 ****
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                      Distribute results by H: (val + val2)
                       ->  Group
                             Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
--- 6074,6080 ----
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                      Distribute results by S: (val + val2)
                       ->  Group
                             Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
***************
*** 6114,6120 ****
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                      Distribute results by H: (val + val2)
                       ->  Group
                             Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
--- 6105,6111 ----
                 Sort Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_groupby_tab1.val + xc_groupby_tab2.val2)
!                      Distribute results by S: (val + val2)
                       ->  Group
                             Output: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
                             Group Key: ((xc_groupby_tab1.val + xc_groupby_tab2.val2))
***************
*** 6158,6164 ****
                       Sort Key: xc_groupby_tab1.val2
                       ->  Remote Subquery Scan on all
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                            Distribute results by H: val2
                             ->  Partial GroupAggregate
                                   Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                                   Group Key: xc_groupby_tab1.val2
--- 6149,6155 ----
                       Sort Key: xc_groupby_tab1.val2
                       ->  Remote Subquery Scan on all
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                            Distribute results by S: val2
                             ->  Partial GroupAggregate
                                   Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                                   Group Key: xc_groupby_tab1.val2
***************
*** 6182,6188 ****
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
--- 6173,6179 ----
                 Sort Key: xc_groupby_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_groupby_tab1.val2
***************
*** 6216,6222 ****
                 Sort Key: ((2 * xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: (2 * val2)
                       ->  Partial GroupAggregate
                             Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: ((2 * xc_groupby_tab1.val2))
--- 6207,6213 ----
                 Sort Key: ((2 * xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: (2 * val2)
                       ->  Partial GroupAggregate
                             Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: ((2 * xc_groupby_tab1.val2))
***************
*** 6240,6246 ****
                 Sort Key: ((2 * xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: (2 * val2)
                       ->  Partial GroupAggregate
                             Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: ((2 * xc_groupby_tab1.val2))
--- 6231,6237 ----
                 Sort Key: ((2 * xc_groupby_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (2 * val2), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: (2 * val2)
                       ->  Partial GroupAggregate
                             Output: ((2 * val2)), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: ((2 * xc_groupby_tab1.val2))
***************
*** 6256,6263 ****
--- 6247,6258 ----
  -- some tests involving nulls, characters, float type etc.
  create table xc_groupby_def(a int, b varchar(25)); 
  insert into xc_groupby_def VALUES (NULL, NULL);
+ ERROR:  node:datanode_1, backend_pid:384358, nodename:datanode_1,backend_pid:384358,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, null).
  insert into xc_groupby_def VALUES (1, NULL);
  insert into xc_groupby_def VALUES (NULL, 'One');
+ ERROR:  node:datanode_1, backend_pid:384358, nodename:datanode_1,backend_pid:384358,message:null value in column "a" violates not-null constraint
+ DETAIL:  Failing row contains (null, One).
  insert into xc_groupby_def VALUES (2, 'Two');
  insert into xc_groupby_def VALUES (2, 'Two');
  insert into xc_groupby_def VALUES (3, 'Three');
***************
*** 6281,6288 ****
    8 |     1
    9 |     1
   10 |     1
!     |     0
! (11 rows)
  
  explain (verbose true, costs false, nodes false) select a,count(a) from xc_groupby_def group by a order by a;
                       QUERY PLAN                      
--- 6276,6282 ----
    8 |     1
    9 |     1
   10 |     1
! (10 rows)
  
  explain (verbose true, costs false, nodes false) select a,count(a) from xc_groupby_def group by a order by a;
                       QUERY PLAN                      
***************
*** 6313,6320 ****
       8.0000000000000000
       9.0000000000000000
      10.0000000000000000
!                        
! (11 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by a order by 1;
                          QUERY PLAN                         
--- 6307,6313 ----
       8.0000000000000000
       9.0000000000000000
      10.0000000000000000
! (10 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by a order by 1;
                          QUERY PLAN                         
***************
*** 6341,6348 ****
   4.0000000000000000
   4.5000000000000000
   6.2000000000000000
!                    
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by b;
                                QUERY PLAN                               
--- 6334,6340 ----
   4.0000000000000000
   4.5000000000000000
   6.2000000000000000
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select avg(a) from xc_groupby_def group by b;
                                QUERY PLAN                               
***************
*** 6357,6363 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_def.b
--- 6349,6355 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_def.b
***************
*** 6374,6381 ****
     8
    18
    31
!     
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select sum(a) from xc_groupby_def group by b;
                                QUERY PLAN                               
--- 6366,6372 ----
     8
    18
    31
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select sum(a) from xc_groupby_def group by b;
                                QUERY PLAN                               
***************
*** 6390,6396 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(a)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(a)
                             Group Key: xc_groupby_def.b
--- 6381,6387 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(a)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(a)
                             Group Key: xc_groupby_def.b
***************
*** 6404,6414 ****
  select count(*) from xc_groupby_def group by b order by 1;
   count 
  -------
!      1
!      3
       4
       5
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def group by b;
                                QUERY PLAN                               
--- 6395,6404 ----
  select count(*) from xc_groupby_def group by b order by 1;
   count 
  -------
!      2
       4
       5
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def group by b;
                                QUERY PLAN                               
***************
*** 6423,6429 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
--- 6413,6419 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
***************
*** 6468,6478 ****
  select b from xc_groupby_def group by b order by 1;
     b   
  -------
-  One
   Three
   Two
   
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select b from xc_groupby_def group by b;
                                QUERY PLAN                               
--- 6458,6467 ----
  select b from xc_groupby_def group by b order by 1;
     b   
  -------
   Three
   Two
   
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select b from xc_groupby_def group by b;
                                QUERY PLAN                               
***************
*** 6487,6493 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b
!                      Distribute results by H: b
                       ->  Group
                             Output: b
                             Group Key: xc_groupby_def.b
--- 6476,6482 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b
!                      Distribute results by S: b
                       ->  Group
                             Output: b
                             Group Key: xc_groupby_def.b
***************
*** 6501,6511 ****
  select b,count(b) from xc_groupby_def group by b order by 1;
     b   | count 
  -------+-------
-  One   |     1
   Three |     5
   Two   |     4
         |     0
! (4 rows)
  
  explain (verbose true, costs false, nodes false) select b,count(b) from xc_groupby_def group by b;
                                QUERY PLAN                               
--- 6490,6499 ----
  select b,count(b) from xc_groupby_def group by b order by 1;
     b   | count 
  -------+-------
   Three |     5
   Two   |     4
         |     0
! (3 rows)
  
  explain (verbose true, costs false, nodes false) select b,count(b) from xc_groupby_def group by b;
                                QUERY PLAN                               
***************
*** 6520,6526 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(b)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(b)
                             Group Key: xc_groupby_def.b
--- 6508,6514 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(b)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(b)
                             Group Key: xc_groupby_def.b
***************
*** 6534,6540 ****
  select count(*) from xc_groupby_def where b is null group by b order by 1;
   count 
  -------
!      3
  (1 row)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def where b is null group by b;
--- 6522,6528 ----
  select count(*) from xc_groupby_def where b is null group by b order by 1;
   count 
  -------
!      2
  (1 row)
  
  explain (verbose true, costs false, nodes false) select count(*) from xc_groupby_def where b is null group by b;
***************
*** 6550,6556 ****
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
--- 6538,6544 ----
                 Sort Key: xc_groupby_def.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL count(*)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL count(*)
                             Group Key: xc_groupby_def.b
***************
*** 6608,6614 ****
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(b)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(b)
                             Group Key: xc_groupby_g.b
--- 6596,6602 ----
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(b)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(b)
                             Group Key: xc_groupby_g.b
***************
*** 6639,6645 ****
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(c)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(c)
                             Group Key: xc_groupby_g.b
--- 6627,6633 ----
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL sum(c)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL sum(c)
                             Group Key: xc_groupby_g.b
***************
*** 6670,6676 ****
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by H: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_g.b
--- 6658,6664 ----
                 Sort Key: xc_groupby_g.b
                 ->  Remote Subquery Scan on all
                       Output: b, PARTIAL avg(a)
!                      Distribute results by S: b
                       ->  Partial GroupAggregate
                             Output: b, PARTIAL avg(a)
                             Group Key: xc_groupby_g.b
***************
*** 6701,6707 ****
                 Sort Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(b)
!                      Distribute results by H: c
                       ->  Partial GroupAggregate
                             Output: c, PARTIAL avg(b)
                             Group Key: xc_groupby_g.c
--- 6689,6695 ----
                 Sort Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(b)
!                      Distribute results by S: c
                       ->  Partial GroupAggregate
                             Output: c, PARTIAL avg(b)
                             Group Key: xc_groupby_g.c
***************
*** 6732,6738 ****
                 Sort Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(c)
!                      Distribute results by H: c
                       ->  Partial GroupAggregate
                             Output: c, PARTIAL avg(c)
                             Group Key: xc_groupby_g.c
--- 6720,6726 ----
                 Sort Key: xc_groupby_g.c
                 ->  Remote Subquery Scan on all
                       Output: c, PARTIAL avg(c)
!                      Distribute results by S: c
                       ->  Partial GroupAggregate
                             Output: c, PARTIAL avg(c)
                             Group Key: xc_groupby_g.c

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_distkey_2.out"	2025-07-31 16:07:15.008067771 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_distkey.out"	2025-07-31 16:40:49.476385474 +0800
***************
*** 1,7 ****
  -- XC Test cases to verify that all supported data types are working as distribution key
  -- Also verifies that the comaparison with a constant for equality is optimized.
  create table ch_tab(a char) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into ch_tab values('a');
  ERROR:  relation "ch_tab" does not exist
  LINE 1: insert into ch_tab values('a');
--- 1,7 ----
  -- XC Test cases to verify that all supported data types are working as distribution key
  -- Also verifies that the comaparison with a constant for equality is optimized.
  create table ch_tab(a char) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into ch_tab values('a');
  ERROR:  relation "ch_tab" does not exist
  LINE 1: insert into ch_tab values('a');
***************
*** 13,19 ****
  (1 row)
  
  create table nm_tab(a name) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into nm_tab values('abbas');
  ERROR:  relation "nm_tab" does not exist
  LINE 1: insert into nm_tab values('abbas');
--- 13,19 ----
  (1 row)
  
  create table nm_tab(a name) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into nm_tab values('abbas');
  ERROR:  relation "nm_tab" does not exist
  LINE 1: insert into nm_tab values('abbas');
***************
*** 25,31 ****
  (1 row)
  
  create table nu_tab(a numeric(10,5)) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into nu_tab values(123.456);
  ERROR:  relation "nu_tab" does not exist
  LINE 1: insert into nu_tab values(123.456);
--- 25,31 ----
  (1 row)
  
  create table nu_tab(a numeric(10,5)) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into nu_tab values(123.456);
  ERROR:  relation "nu_tab" does not exist
  LINE 1: insert into nu_tab values(123.456);
***************
*** 55,61 ****
  LINE 1: ...false, num_nodes true, nodes false) select * from nu_tab whe...
                                                               ^
  create table tx_tab(a text) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into tx_tab values('hello world');
  ERROR:  relation "tx_tab" does not exist
  LINE 1: insert into tx_tab values('hello world');
--- 55,61 ----
  LINE 1: ...false, num_nodes true, nodes false) select * from nu_tab whe...
                                                               ^
  create table tx_tab(a text) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into tx_tab values('hello world');
  ERROR:  relation "tx_tab" does not exist
  LINE 1: insert into tx_tab values('hello world');
***************
*** 93,99 ****
  LINE 1: ...false, num_nodes true, nodes false) select * from tx_tab whe...
                                                               ^
  create table vc_tab(a varchar(255)) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into vc_tab values('abcdefghijklmnopqrstuvwxyz');
  ERROR:  relation "vc_tab" does not exist
  LINE 1: insert into vc_tab values('abcdefghijklmnopqrstuvwxyz');
--- 93,99 ----
  LINE 1: ...false, num_nodes true, nodes false) select * from tx_tab whe...
                                                               ^
  create table vc_tab(a varchar(255)) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into vc_tab values('abcdefghijklmnopqrstuvwxyz');
  ERROR:  relation "vc_tab" does not exist
  LINE 1: insert into vc_tab values('abcdefghijklmnopqrstuvwxyz');
***************
*** 137,143 ****
  LINE 1: ...false, num_nodes true, nodes false) select * from vc_tab whe...
                                                               ^
  create table f8_tab(a float8) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into f8_tab values(123.456);
  ERROR:  relation "f8_tab" does not exist
  LINE 1: insert into f8_tab values(123.456);
--- 137,143 ----
  LINE 1: ...false, num_nodes true, nodes false) select * from vc_tab whe...
                                                               ^
  create table f8_tab(a float8) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into f8_tab values(123.456);
  ERROR:  relation "f8_tab" does not exist
  LINE 1: insert into f8_tab values(123.456);
***************
*** 167,173 ****
  LINE 1: select * from f8_tab where a = 10.987654::float8;
                        ^
  create table f4_tab(a float4) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into f4_tab values(123.456);
  ERROR:  relation "f4_tab" does not exist
  LINE 1: insert into f4_tab values(123.456);
--- 167,173 ----
  LINE 1: select * from f8_tab where a = 10.987654::float8;
                        ^
  create table f4_tab(a float4) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into f4_tab values(123.456);
  ERROR:  relation "f4_tab" does not exist
  LINE 1: insert into f4_tab values(123.456);
***************
*** 201,207 ****
  LINE 1: select * from f4_tab where a = 10.987654::float4;
                        ^
  create table i8_tab(a int8) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into i8_tab values(8446744073709551359);
  ERROR:  relation "i8_tab" does not exist
  LINE 1: insert into i8_tab values(8446744073709551359);
--- 201,207 ----
  LINE 1: select * from f4_tab where a = 10.987654::float4;
                        ^
  create table i8_tab(a int8) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into i8_tab values(8446744073709551359);
  ERROR:  relation "i8_tab" does not exist
  LINE 1: insert into i8_tab values(8446744073709551359);
***************
*** 235,263 ****
  LINE 1: select * from i8_tab where a = 78902;
                        ^
  create table i2_tab(a int2) distribute by modulo(a);
  insert into i2_tab values(123);
  insert into i2_tab values(456);
  select * from i2_tab order by a;
!   a  
! -----
!  123
!  456
! (2 rows)
! 
  select * from i2_tab where a = 123;
!   a  
! -----
!  123
! (1 row)
! 
  select * from i2_tab where a = 456;
!   a  
! -----
!  456
! (1 row)
! 
  create table oid_tab(a oid) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into oid_tab values(23445);
  ERROR:  relation "oid_tab" does not exist
  LINE 1: insert into oid_tab values(23445);
--- 235,263 ----
  LINE 1: select * from i8_tab where a = 78902;
                        ^
  create table i2_tab(a int2) distribute by modulo(a);
+ ERROR:  Cannot support distribute type: Hash
  insert into i2_tab values(123);
+ ERROR:  relation "i2_tab" does not exist
+ LINE 1: insert into i2_tab values(123);
+                     ^
  insert into i2_tab values(456);
+ ERROR:  relation "i2_tab" does not exist
+ LINE 1: insert into i2_tab values(456);
+                     ^
  select * from i2_tab order by a;
! ERROR:  relation "i2_tab" does not exist
! LINE 1: select * from i2_tab order by a;
!                       ^
  select * from i2_tab where a = 123;
! ERROR:  relation "i2_tab" does not exist
! LINE 1: select * from i2_tab where a = 123;
!                       ^
  select * from i2_tab where a = 456;
! ERROR:  relation "i2_tab" does not exist
! LINE 1: select * from i2_tab where a = 456;
!                       ^
  create table oid_tab(a oid) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into oid_tab values(23445);
  ERROR:  relation "oid_tab" does not exist
  LINE 1: insert into oid_tab values(23445);
***************
*** 279,357 ****
  LINE 1: select * from oid_tab where a = 45662;
                        ^
  create table i4_tab(a int4) distribute by modulo(a);
  insert into i4_tab values(65530);
  insert into i4_tab values(2147483647);
  select * from i4_tab order by a;
!      a      
! ------------
!       65530
!  2147483647
! (2 rows)
! 
  select * from i4_tab where a = 65530;
!    a   
! -------
!  65530
! (1 row)
! 
  select * from i4_tab where a = 2147483647;
!      a      
! ------------
!  2147483647
! (1 row)
! 
  select * from i4_tab where 65530 = a;
!    a   
! -------
!  65530
! (1 row)
! 
  select * from i4_tab where 2147483647 = a;
!      a      
! ------------
!  2147483647
! (1 row)
! 
  explain (costs false, num_nodes true, nodes false) select * from i4_tab where 65530 = a;
!          QUERY PLAN          
! -----------------------------
!  Remote Subquery Scan on all
!    ->  Seq Scan on i4_tab
!          Filter: (65530 = a)
! (3 rows)
! 
  explain (costs false, num_nodes true, nodes false) select * from i4_tab where a = 2147483647;
!             QUERY PLAN            
! ----------------------------------
!  Remote Subquery Scan on all
!    ->  Seq Scan on i4_tab
!          Filter: (a = 2147483647)
! (3 rows)
! 
  create table bo_tab(a bool) distribute by modulo(a);
  insert into bo_tab values(true);
  insert into bo_tab values(false);
  select * from bo_tab order by a;
!  a 
! ---
!  f
!  t
! (2 rows)
! 
  select * from bo_tab where a = true;
!  a 
! ---
!  t
! (1 row)
! 
  select * from bo_tab where a = false;
!  a 
! ---
!  f
! (1 row)
! 
  create table bpc_tab(a char(35)) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into bpc_tab values('Hello World');
  ERROR:  relation "bpc_tab" does not exist
  LINE 1: insert into bpc_tab values('Hello World');
--- 279,345 ----
  LINE 1: select * from oid_tab where a = 45662;
                        ^
  create table i4_tab(a int4) distribute by modulo(a);
+ ERROR:  Cannot support distribute type: Hash
  insert into i4_tab values(65530);
+ ERROR:  relation "i4_tab" does not exist
+ LINE 1: insert into i4_tab values(65530);
+                     ^
  insert into i4_tab values(2147483647);
+ ERROR:  relation "i4_tab" does not exist
+ LINE 1: insert into i4_tab values(2147483647);
+                     ^
  select * from i4_tab order by a;
! ERROR:  relation "i4_tab" does not exist
! LINE 1: select * from i4_tab order by a;
!                       ^
  select * from i4_tab where a = 65530;
! ERROR:  relation "i4_tab" does not exist
! LINE 1: select * from i4_tab where a = 65530;
!                       ^
  select * from i4_tab where a = 2147483647;
! ERROR:  relation "i4_tab" does not exist
! LINE 1: select * from i4_tab where a = 2147483647;
!                       ^
  select * from i4_tab where 65530 = a;
! ERROR:  relation "i4_tab" does not exist
! LINE 1: select * from i4_tab where 65530 = a;
!                       ^
  select * from i4_tab where 2147483647 = a;
! ERROR:  relation "i4_tab" does not exist
! LINE 1: select * from i4_tab where 2147483647 = a;
!                       ^
  explain (costs false, num_nodes true, nodes false) select * from i4_tab where 65530 = a;
! ERROR:  relation "i4_tab" does not exist
! LINE 1: ...false, num_nodes true, nodes false) select * from i4_tab whe...
!                                                              ^
  explain (costs false, num_nodes true, nodes false) select * from i4_tab where a = 2147483647;
! ERROR:  relation "i4_tab" does not exist
! LINE 1: ...false, num_nodes true, nodes false) select * from i4_tab whe...
!                                                              ^
  create table bo_tab(a bool) distribute by modulo(a);
+ ERROR:  Cannot support distribute type: Hash
  insert into bo_tab values(true);
+ ERROR:  relation "bo_tab" does not exist
+ LINE 1: insert into bo_tab values(true);
+                     ^
  insert into bo_tab values(false);
+ ERROR:  relation "bo_tab" does not exist
+ LINE 1: insert into bo_tab values(false);
+                     ^
  select * from bo_tab order by a;
! ERROR:  relation "bo_tab" does not exist
! LINE 1: select * from bo_tab order by a;
!                       ^
  select * from bo_tab where a = true;
! ERROR:  relation "bo_tab" does not exist
! LINE 1: select * from bo_tab where a = true;
!                       ^
  select * from bo_tab where a = false;
! ERROR:  relation "bo_tab" does not exist
! LINE 1: select * from bo_tab where a = false;
!                       ^
  create table bpc_tab(a char(35)) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into bpc_tab values('Hello World');
  ERROR:  relation "bpc_tab" does not exist
  LINE 1: insert into bpc_tab values('Hello World');
***************
*** 373,379 ****
  LINE 1: select * from bpc_tab where a = 'The quick brown fox';
                        ^
  create table byta_tab(a bytea) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into byta_tab values(E'\\000\\001\\002\\003\\004\\005\\006\\007\\010');
  ERROR:  relation "byta_tab" does not exist
  LINE 1: insert into byta_tab values(E'\\000\\001\\002\\003\\004\\005...
--- 361,367 ----
  LINE 1: select * from bpc_tab where a = 'The quick brown fox';
                        ^
  create table byta_tab(a bytea) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into byta_tab values(E'\\000\\001\\002\\003\\004\\005\\006\\007\\010');
  ERROR:  relation "byta_tab" does not exist
  LINE 1: insert into byta_tab values(E'\\000\\001\\002\\003\\004\\005...
***************
*** 395,401 ****
  LINE 1: select * from byta_tab where a = E'\\010\\011\\012\\013\\014...
                        ^
  create table tim_tab(a time) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into tim_tab values('00:01:02.03');
  ERROR:  relation "tim_tab" does not exist
  LINE 1: insert into tim_tab values('00:01:02.03');
--- 383,389 ----
  LINE 1: select * from byta_tab where a = E'\\010\\011\\012\\013\\014...
                        ^
  create table tim_tab(a time) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into tim_tab values('00:01:02.03');
  ERROR:  relation "tim_tab" does not exist
  LINE 1: insert into tim_tab values('00:01:02.03');
***************
*** 417,423 ****
  LINE 1: delete from tim_tab where a = '23:59:59.99';
                      ^
  create table timtz_tab(a time with time zone) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into timtz_tab values('00:01:02.03 PST');
  ERROR:  relation "timtz_tab" does not exist
  LINE 1: insert into timtz_tab values('00:01:02.03 PST');
--- 405,411 ----
  LINE 1: delete from tim_tab where a = '23:59:59.99';
                      ^
  create table timtz_tab(a time with time zone) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into timtz_tab values('00:01:02.03 PST');
  ERROR:  relation "timtz_tab" does not exist
  LINE 1: insert into timtz_tab values('00:01:02.03 PST');
***************
*** 439,445 ****
  LINE 1: select * from timtz_tab where a = '23:59:59.99 PST';
                        ^
  create table ts_tab(a timestamp) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into ts_tab values('May 10, 2011 00:01:02.03');
  ERROR:  relation "ts_tab" does not exist
  LINE 1: insert into ts_tab values('May 10, 2011 00:01:02.03');
--- 427,433 ----
  LINE 1: select * from timtz_tab where a = '23:59:59.99 PST';
                        ^
  create table ts_tab(a timestamp) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into ts_tab values('May 10, 2011 00:01:02.03');
  ERROR:  relation "ts_tab" does not exist
  LINE 1: insert into ts_tab values('May 10, 2011 00:01:02.03');
***************
*** 461,467 ****
  LINE 1: select * from ts_tab where a = 'August 14, 2001 23:59:59.99'...
                        ^
  create table in_tab(a interval) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into in_tab values('1 day 12 hours 59 min 10 sec');
  ERROR:  relation "in_tab" does not exist
  LINE 1: insert into in_tab values('1 day 12 hours 59 min 10 sec');
--- 449,455 ----
  LINE 1: select * from ts_tab where a = 'August 14, 2001 23:59:59.99'...
                        ^
  create table in_tab(a interval) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into in_tab values('1 day 12 hours 59 min 10 sec');
  ERROR:  relation "in_tab" does not exist
  LINE 1: insert into in_tab values('1 day 12 hours 59 min 10 sec');
***************
*** 483,489 ****
  LINE 1: select * from in_tab where a = '0 day 4 hours 32 min 23 sec'...
                        ^
  create table cash_tab(a money) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into cash_tab values('231.54');
  ERROR:  relation "cash_tab" does not exist
  LINE 1: insert into cash_tab values('231.54');
--- 471,477 ----
  LINE 1: select * from in_tab where a = '0 day 4 hours 32 min 23 sec'...
                        ^
  create table cash_tab(a money) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into cash_tab values('231.54');
  ERROR:  relation "cash_tab" does not exist
  LINE 1: insert into cash_tab values('231.54');
***************
*** 505,577 ****
  LINE 1: select * from cash_tab where a = '14011.50';
                        ^
  create table atim_tab(a abstime) distribute by modulo(a);
  insert into atim_tab values(abstime('May 10, 2011 00:01:02.03'));
  insert into atim_tab values(abstime('Jun 23, 2001 23:59:59.99'));
  select * from atim_tab order by a;
!               a               
! ------------------------------
!  Sat Jun 23 23:59:59 2001 PDT
!  Tue May 10 00:01:02 2011 PDT
! (2 rows)
! 
  select * from atim_tab where a = abstime('May 10, 2011 00:01:02.03');
!               a               
! ------------------------------
!  Tue May 10 00:01:02 2011 PDT
! (1 row)
! 
  select * from atim_tab where a = abstime('Jun 23, 2001 23:59:59.99');
!               a               
! ------------------------------
!  Sat Jun 23 23:59:59 2001 PDT
! (1 row)
! 
  create table rtim_tab(a reltime) distribute by modulo(a);
  insert into rtim_tab values(reltime('1 day 12 hours 59 min 10 sec'));
  insert into rtim_tab values(reltime('0 day 5 hours 32 min 23 sec'));
  select * from rtim_tab order by a;
!                 a                 
! ----------------------------------
!  @ 5 hours 32 mins 23 secs
!  @ 1 day 12 hours 59 mins 10 secs
! (2 rows)
! 
  select * from rtim_tab where a = reltime('1 day 12 hours 59 min 10 sec');
!                 a                 
! ----------------------------------
!  @ 1 day 12 hours 59 mins 10 secs
! (1 row)
! 
  select * from rtim_tab where a = reltime('0 day 5 hours 32 min 23 sec');
!              a             
! ---------------------------
!  @ 5 hours 32 mins 23 secs
! (1 row)
! 
  create table date_tab(a date) distribute by modulo(a);
  insert into date_tab values('May 10, 2011');
  insert into date_tab values('August 23, 2001');
  select * from date_tab order by a;
!      a      
! ------------
!  08-23-2001
!  05-10-2011
! (2 rows)
! 
  select * from date_tab where a = 'May 10, 2011';
!      a      
! ------------
!  2011-05-10
! (1 row)
! 
  select * from date_tab where a = 'August 23, 2001';
!      a      
! ------------
!  2001-08-23
! (1 row)
! 
  create table tstz_tab(a timestamp with time zone) distribute by modulo(a);
! ERROR:  Column a is not modulo distributable data type
  insert into tstz_tab values('May 10, 2011 00:01:02.03 PST');
  ERROR:  relation "tstz_tab" does not exist
  LINE 1: insert into tstz_tab values('May 10, 2011 00:01:02.03 PST');
--- 493,565 ----
  LINE 1: select * from cash_tab where a = '14011.50';
                        ^
  create table atim_tab(a abstime) distribute by modulo(a);
+ ERROR:  Cannot support distribute type: Hash
  insert into atim_tab values(abstime('May 10, 2011 00:01:02.03'));
+ ERROR:  relation "atim_tab" does not exist
+ LINE 1: insert into atim_tab values(abstime('May 10, 2011 00:01:02.0...
+                     ^
  insert into atim_tab values(abstime('Jun 23, 2001 23:59:59.99'));
+ ERROR:  relation "atim_tab" does not exist
+ LINE 1: insert into atim_tab values(abstime('Jun 23, 2001 23:59:59.9...
+                     ^
  select * from atim_tab order by a;
! ERROR:  relation "atim_tab" does not exist
! LINE 1: select * from atim_tab order by a;
!                       ^
  select * from atim_tab where a = abstime('May 10, 2011 00:01:02.03');
! ERROR:  relation "atim_tab" does not exist
! LINE 1: select * from atim_tab where a = abstime('May 10, 2011 00:01...
!                       ^
  select * from atim_tab where a = abstime('Jun 23, 2001 23:59:59.99');
! ERROR:  relation "atim_tab" does not exist
! LINE 1: select * from atim_tab where a = abstime('Jun 23, 2001 23:59...
!                       ^
  create table rtim_tab(a reltime) distribute by modulo(a);
+ ERROR:  Cannot support distribute type: Hash
  insert into rtim_tab values(reltime('1 day 12 hours 59 min 10 sec'));
+ ERROR:  relation "rtim_tab" does not exist
+ LINE 1: insert into rtim_tab values(reltime('1 day 12 hours 59 min 1...
+                     ^
  insert into rtim_tab values(reltime('0 day 5 hours 32 min 23 sec'));
+ ERROR:  relation "rtim_tab" does not exist
+ LINE 1: insert into rtim_tab values(reltime('0 day 5 hours 32 min 23...
+                     ^
  select * from rtim_tab order by a;
! ERROR:  relation "rtim_tab" does not exist
! LINE 1: select * from rtim_tab order by a;
!                       ^
  select * from rtim_tab where a = reltime('1 day 12 hours 59 min 10 sec');
! ERROR:  relation "rtim_tab" does not exist
! LINE 1: select * from rtim_tab where a = reltime('1 day 12 hours 59 ...
!                       ^
  select * from rtim_tab where a = reltime('0 day 5 hours 32 min 23 sec');
! ERROR:  relation "rtim_tab" does not exist
! LINE 1: select * from rtim_tab where a = reltime('0 day 5 hours 32 m...
!                       ^
  create table date_tab(a date) distribute by modulo(a);
+ ERROR:  Cannot support distribute type: Hash
  insert into date_tab values('May 10, 2011');
+ ERROR:  relation "date_tab" does not exist
+ LINE 1: insert into date_tab values('May 10, 2011');
+                     ^
  insert into date_tab values('August 23, 2001');
+ ERROR:  relation "date_tab" does not exist
+ LINE 1: insert into date_tab values('August 23, 2001');
+                     ^
  select * from date_tab order by a;
! ERROR:  relation "date_tab" does not exist
! LINE 1: select * from date_tab order by a;
!                       ^
  select * from date_tab where a = 'May 10, 2011';
! ERROR:  relation "date_tab" does not exist
! LINE 1: select * from date_tab where a = 'May 10, 2011';
!                       ^
  select * from date_tab where a = 'August 23, 2001';
! ERROR:  relation "date_tab" does not exist
! LINE 1: select * from date_tab where a = 'August 23, 2001';
!                       ^
  create table tstz_tab(a timestamp with time zone) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  insert into tstz_tab values('May 10, 2011 00:01:02.03 PST');
  ERROR:  relation "tstz_tab" does not exist
  LINE 1: insert into tstz_tab values('May 10, 2011 00:01:02.03 PST');
***************
*** 593,626 ****
  LINE 1: select * from tstz_tab where a = 'Jun 23, 2001 23:59:59.99 P...
                        ^
  create table tstz_tab_h(a timestamp with time zone) distribute by hash(a);
  insert into tstz_tab_h values('May 10, 2011 00:01:02.03 PST');
  insert into tstz_tab_h values('Jun 23, 2001 23:59:59.99 PST');
  select * from tstz_tab_h order by a;
!                 a                
! ---------------------------------
!  Sun Jun 24 00:59:59.99 2001 PDT
!  Tue May 10 01:01:02.03 2011 PDT
! (2 rows)
! 
  select * from tstz_tab_h where a = 'May 10, 2011 00:01:02.03 PST';
!                 a                
! ---------------------------------
!  Tue May 10 01:01:02.03 2011 PDT
! (1 row)
! 
  select * from tstz_tab_h where a = 'Jun 23, 2001 23:59:59.99 PST';
!                 a                
! ---------------------------------
!  Sun Jun 24 00:59:59.99 2001 PDT
! (1 row)
! 
  create table my_rr_tab(a integer, b varchar(100)) distribute by roundrobin;
  insert into my_rr_tab values(1 , 'One');
  insert into my_rr_tab values(2, 'Two');
  select * from my_rr_tab order by a;
!  a |  b  
! ---+-----
!  1 | One
!  2 | Two
! (2 rows)
! 
--- 581,618 ----
  LINE 1: select * from tstz_tab where a = 'Jun 23, 2001 23:59:59.99 P...
                        ^
  create table tstz_tab_h(a timestamp with time zone) distribute by hash(a);
+ ERROR:  Cannot support distribute type: Hash
  insert into tstz_tab_h values('May 10, 2011 00:01:02.03 PST');
+ ERROR:  relation "tstz_tab_h" does not exist
+ LINE 1: insert into tstz_tab_h values('May 10, 2011 00:01:02.03 PST'...
+                     ^
  insert into tstz_tab_h values('Jun 23, 2001 23:59:59.99 PST');
+ ERROR:  relation "tstz_tab_h" does not exist
+ LINE 1: insert into tstz_tab_h values('Jun 23, 2001 23:59:59.99 PST'...
+                     ^
  select * from tstz_tab_h order by a;
! ERROR:  relation "tstz_tab_h" does not exist
! LINE 1: select * from tstz_tab_h order by a;
!                       ^
  select * from tstz_tab_h where a = 'May 10, 2011 00:01:02.03 PST';
! ERROR:  relation "tstz_tab_h" does not exist
! LINE 1: select * from tstz_tab_h where a = 'May 10, 2011 00:01:02.03...
!                       ^
  select * from tstz_tab_h where a = 'Jun 23, 2001 23:59:59.99 PST';
! ERROR:  relation "tstz_tab_h" does not exist
! LINE 1: select * from tstz_tab_h where a = 'Jun 23, 2001 23:59:59.99...
!                       ^
  create table my_rr_tab(a integer, b varchar(100)) distribute by roundrobin;
+ ERROR:  Cannot support distribute type: RoundRobin
  insert into my_rr_tab values(1 , 'One');
+ ERROR:  relation "my_rr_tab" does not exist
+ LINE 1: insert into my_rr_tab values(1 , 'One');
+                     ^
  insert into my_rr_tab values(2, 'Two');
+ ERROR:  relation "my_rr_tab" does not exist
+ LINE 1: insert into my_rr_tab values(2, 'Two');
+                     ^
  select * from my_rr_tab order by a;
! ERROR:  relation "my_rr_tab" does not exist
! LINE 1: select * from my_rr_tab order by a;
!                       ^

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_having_1.out"	2025-07-31 16:07:15.010067739 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_having.out"	2025-07-31 16:40:51.283347479 +0800
***************
*** 30,36 ****
           Group Key: xc_having_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_having_tab1.val2
--- 30,36 ----
           Group Key: xc_having_tab1.val2
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_having_tab1.val2
***************
*** 57,63 ****
           Filter: (avg(xc_having_tab1.val) > 3.75)
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_having_tab1.val2
--- 57,63 ----
           Filter: (avg(xc_having_tab1.val) > 3.75)
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_having_tab1.val2
***************
*** 87,93 ****
                 Filter: ((avg(xc_having_tab1.val) > 3.75) OR (xc_having_tab1.val2 > 2))
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial HashAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_having_tab1.val2
--- 87,93 ----
                 Filter: ((avg(xc_having_tab1.val) > 3.75) OR (xc_having_tab1.val2 > 2))
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial HashAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_having_tab1.val2
***************
*** 106,112 ****
           Filter: ((avg(xc_having_tab1.val) > 3.75) OR (xc_having_tab1.val2 > 2))
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_having_tab1.val2
--- 106,112 ----
           Filter: ((avg(xc_having_tab1.val) > 3.75) OR (xc_having_tab1.val2 > 2))
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_having_tab1.val2
***************
*** 130,136 ****
           Filter: (avg(xc_having_tab1.val) > 3.75)
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_having_tab1.val2
--- 130,136 ----
           Filter: (avg(xc_having_tab1.val) > 3.75)
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                       Group Key: xc_having_tab1.val2
***************
*** 160,173 ****
                 Join Filter: ((xc_having_tab1.val2 + xc_having_tab2.val2) > 2)
                 ->  Remote Subquery Scan on all
                       Output: xc_having_tab1.val, xc_having_tab1.val2
!                      Distribute results by H: val2
                       ->  Seq Scan on public.xc_having_tab1
                             Output: xc_having_tab1.val, xc_having_tab1.val2
                 ->  Hash
                       Output: xc_having_tab2.val, xc_having_tab2.val2
                       ->  Remote Subquery Scan on all
                             Output: xc_having_tab2.val, xc_having_tab2.val2
!                            Distribute results by H: val2
                             ->  Seq Scan on public.xc_having_tab2
                                   Output: xc_having_tab2.val, xc_having_tab2.val2
  (21 rows)
--- 160,173 ----
                 Join Filter: ((xc_having_tab1.val2 + xc_having_tab2.val2) > 2)
                 ->  Remote Subquery Scan on all
                       Output: xc_having_tab1.val, xc_having_tab1.val2
!                      Distribute results by S: val2
                       ->  Seq Scan on public.xc_having_tab1
                             Output: xc_having_tab1.val, xc_having_tab1.val2
                 ->  Hash
                       Output: xc_having_tab2.val, xc_having_tab2.val2
                       ->  Remote Subquery Scan on all
                             Output: xc_having_tab2.val, xc_having_tab2.val2
!                            Distribute results by S: val2
                             ->  Seq Scan on public.xc_having_tab2
                                   Output: xc_having_tab2.val, xc_having_tab2.val2
  (21 rows)
***************
*** 190,196 ****
           Filter: (sum(xc_having_tab1.val) > 8)
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL sum(val)
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL sum(val)
                       Group Key: xc_having_tab1.val2
--- 190,196 ----
           Filter: (sum(xc_having_tab1.val) > 8)
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL sum(val)
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL sum(val)
                       Group Key: xc_having_tab1.val2
***************
*** 221,227 ****
                 Sort Key: ((xc_having_tab1.val + xc_having_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_having_tab1.val + xc_having_tab1.val2), PARTIAL sum(xc_having_tab1.val)
!                      Distribute results by H: (val + val2)
                       ->  Partial HashAggregate
                             Output: ((xc_having_tab1.val + xc_having_tab1.val2)), PARTIAL sum(xc_having_tab1.val)
                             Group Key: (xc_having_tab1.val + xc_having_tab1.val2)
--- 221,227 ----
                 Sort Key: ((xc_having_tab1.val + xc_having_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (xc_having_tab1.val + xc_having_tab1.val2), PARTIAL sum(xc_having_tab1.val)
!                      Distribute results by S: (val + val2)
                       ->  Partial HashAggregate
                             Output: ((xc_having_tab1.val + xc_having_tab1.val2)), PARTIAL sum(xc_having_tab1.val)
                             Group Key: (xc_having_tab1.val + xc_having_tab1.val2)
***************
*** 247,253 ****
           Filter: (min(xc_having_tab1.val) < xc_having_tab1.val2)
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val), PARTIAL min(val)
!                Distribute results by H: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val), PARTIAL min(val)
                       Group Key: xc_having_tab1.val2
--- 247,253 ----
           Filter: (min(xc_having_tab1.val) < xc_having_tab1.val2)
           ->  Remote Subquery Scan on all
                 Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val), PARTIAL min(val)
!                Distribute results by S: val2
                 ->  Partial HashAggregate
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val), PARTIAL min(val)
                       Group Key: xc_having_tab1.val2
***************
*** 483,489 ****
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_having_tab1.val2
--- 483,489 ----
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_having_tab1.val2
***************
*** 516,522 ****
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_having_tab1.val2
--- 516,522 ----
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_having_tab1.val2
***************
*** 548,554 ****
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_having_tab1.val2
--- 548,554 ----
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_having_tab1.val2
***************
*** 578,584 ****
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_having_tab1.val2
--- 578,584 ----
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val)
                             Group Key: xc_having_tab1.val2
***************
*** 614,627 ****
                       Join Filter: ((xc_having_tab1.val2 + xc_having_tab2.val2) > 2)
                       ->  Remote Subquery Scan on all
                             Output: xc_having_tab1.val, xc_having_tab1.val2
!                            Distribute results by H: val2
                             ->  Seq Scan on public.xc_having_tab1
                                   Output: xc_having_tab1.val, xc_having_tab1.val2
                       ->  Hash
                             Output: xc_having_tab2.val, xc_having_tab2.val2
                             ->  Remote Subquery Scan on all
                                   Output: xc_having_tab2.val, xc_having_tab2.val2
!                                  Distribute results by H: val2
                                   ->  Seq Scan on public.xc_having_tab2
                                         Output: xc_having_tab2.val, xc_having_tab2.val2
  (24 rows)
--- 614,627 ----
                       Join Filter: ((xc_having_tab1.val2 + xc_having_tab2.val2) > 2)
                       ->  Remote Subquery Scan on all
                             Output: xc_having_tab1.val, xc_having_tab1.val2
!                            Distribute results by S: val2
                             ->  Seq Scan on public.xc_having_tab1
                                   Output: xc_having_tab1.val, xc_having_tab1.val2
                       ->  Hash
                             Output: xc_having_tab2.val, xc_having_tab2.val2
                             ->  Remote Subquery Scan on all
                                   Output: xc_having_tab2.val, xc_having_tab2.val2
!                                  Distribute results by S: val2
                                   ->  Seq Scan on public.xc_having_tab2
                                         Output: xc_having_tab2.val, xc_having_tab2.val2
  (24 rows)
***************
*** 647,653 ****
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL sum(val)
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL sum(val)
                             Group Key: xc_having_tab1.val2
--- 647,653 ----
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL sum(val)
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL sum(val)
                             Group Key: xc_having_tab1.val2
***************
*** 680,686 ****
                 Sort Key: ((xc_having_tab1.val + xc_having_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2), PARTIAL sum(val)
!                      Distribute results by H: (val + val2)
                       ->  Partial GroupAggregate
                             Output: ((val + val2)), PARTIAL sum(val)
                             Group Key: ((xc_having_tab1.val + xc_having_tab1.val2))
--- 680,686 ----
                 Sort Key: ((xc_having_tab1.val + xc_having_tab1.val2))
                 ->  Remote Subquery Scan on all
                       Output: (val + val2), PARTIAL sum(val)
!                      Distribute results by S: (val + val2)
                       ->  Partial GroupAggregate
                             Output: ((val + val2)), PARTIAL sum(val)
                             Group Key: ((xc_having_tab1.val + xc_having_tab1.val2))
***************
*** 712,718 ****
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val), PARTIAL min(val)
!                      Distribute results by H: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val), PARTIAL min(val)
                             Group Key: xc_having_tab1.val2
--- 712,718 ----
                 Sort Key: xc_having_tab1.val2
                 ->  Remote Subquery Scan on all
                       Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val), PARTIAL min(val)
!                      Distribute results by S: val2
                       ->  Partial GroupAggregate
                             Output: val2, PARTIAL count(*), PARTIAL sum(val), PARTIAL avg(val), PARTIAL min(val)
                             Group Key: xc_having_tab1.val2

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_temp.out"	2025-07-31 16:07:15.010067739 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_temp.out"	2025-07-31 16:40:50.142371469 +0800
***************
*** 4,134 ****
  -- Create TEMPORARY and normal tables
  CREATE TABLE table_rep (a int, b_rep char(1)) DISTRIBUTE BY REPLICATION;
  CREATE TABLE table_hash (a int, b_hash char(1)) DISTRIBUTE BY HASH(a);
  CREATE TABLE table_rb (a int, b_rb char(1)) DISTRIBUTE BY ROUNDROBIN;
  CREATE TEMP TABLE temptable_rep (a int, b_tprep char(1)) DISTRIBUTE BY REPLICATION;
  CREATE TEMP TABLE temptable_hash (a int, b_tphash char(1)) DISTRIBUTE BY HASH(a);
  CREATE TEMP TABLE temptable_rb (a int, b_tprb char(1)) DISTRIBUTE BY ROUNDROBIN;
  INSERT INTO table_rep VALUES (1, 'a');
  INSERT INTO table_rep VALUES (2, 'b');
  INSERT INTO table_rep VALUES (3, 'c');
  INSERT INTO table_rep VALUES (4, NULL);
  INSERT INTO table_rep VALUES (NULL, 'e');
  INSERT INTO table_hash VALUES (1, 'a');
  INSERT INTO table_hash VALUES (2, 'b');
  INSERT INTO table_hash VALUES (3, 'c');
  INSERT INTO table_hash VALUES (4, NULL);
  INSERT INTO table_hash VALUES (NULL, 'e');
  INSERT INTO table_rb VALUES (1, 'a');
  INSERT INTO table_rb VALUES (2, 'b');
  INSERT INTO table_rb VALUES (3, 'c');
  INSERT INTO table_rb VALUES (4, NULL);
  INSERT INTO table_rb VALUES (NULL, 'e');
  INSERT INTO temptable_rep VALUES (1, 'A');
  INSERT INTO temptable_rep VALUES (2, NULL);
  INSERT INTO temptable_rep VALUES (3, 'C');
  INSERT INTO temptable_rep VALUES (4, 'D');
  INSERT INTO temptable_rep VALUES (NULL, 'E');
  INSERT INTO temptable_hash VALUES (1, 'A');
  INSERT INTO temptable_hash VALUES (2, 'B');
  INSERT INTO temptable_hash VALUES (3, NULL);
  INSERT INTO temptable_hash VALUES (4, 'D');
  INSERT INTO temptable_hash VALUES (NULL, 'E');
  INSERT INTO temptable_rb VALUES (1, 'A');
  INSERT INTO temptable_rb VALUES (2, 'B');
  INSERT INTO temptable_rb VALUES (3, 'C');
  INSERT INTO temptable_rb VALUES (4, NULL);
  INSERT INTO temptable_rb VALUES (NULL, 'E');
  -- Check global joins on each table combination
  SELECT * FROM table_hash, temptable_hash ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tphash 
! ---+--------+---+----------
!  1 | a      | 1 | A
!  1 | a      | 2 | B
!  1 | a      | 3 | 
!  1 | a      | 4 | D
!  1 | a      |   | E
!  2 | b      | 1 | A
!  2 | b      | 2 | B
!  2 | b      | 3 | 
!  2 | b      | 4 | D
!  2 | b      |   | E
!  3 | c      | 1 | A
!  3 | c      | 2 | B
!  3 | c      | 3 | 
!  3 | c      | 4 | D
!  3 | c      |   | E
!  4 |        | 1 | A
!  4 |        | 2 | B
!  4 |        | 3 | 
!  4 |        | 4 | D
!  4 |        |   | E
!    | e      | 1 | A
!    | e      | 2 | B
!    | e      | 3 | 
!    | e      | 4 | D
!    | e      |   | E
! (25 rows)
! 
  SELECT * FROM table_hash, temptable_rep ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tprep 
! ---+--------+---+---------
!  1 | a      | 1 | A
!  1 | a      | 2 | 
!  1 | a      | 3 | C
!  1 | a      | 4 | D
!  1 | a      |   | E
!  2 | b      | 1 | A
!  2 | b      | 2 | 
!  2 | b      | 3 | C
!  2 | b      | 4 | D
!  2 | b      |   | E
!  3 | c      | 1 | A
!  3 | c      | 2 | 
!  3 | c      | 3 | C
!  3 | c      | 4 | D
!  3 | c      |   | E
!  4 |        | 1 | A
!  4 |        | 2 | 
!  4 |        | 3 | C
!  4 |        | 4 | D
!  4 |        |   | E
!    | e      | 1 | A
!    | e      | 2 | 
!    | e      | 3 | C
!    | e      | 4 | D
!    | e      |   | E
! (25 rows)
! 
  SELECT * FROM table_hash, temptable_rb ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tprb 
! ---+--------+---+--------
!  1 | a      | 1 | A
!  1 | a      | 2 | B
!  1 | a      | 3 | C
!  1 | a      | 4 | 
!  1 | a      |   | E
!  2 | b      | 1 | A
!  2 | b      | 2 | B
!  2 | b      | 3 | C
!  2 | b      | 4 | 
!  2 | b      |   | E
!  3 | c      | 1 | A
!  3 | c      | 2 | B
!  3 | c      | 3 | C
!  3 | c      | 4 | 
!  3 | c      |   | E
!  4 |        | 1 | A
!  4 |        | 2 | B
!  4 |        | 3 | C
!  4 |        | 4 | 
!  4 |        |   | E
!    | e      | 1 | A
!    | e      | 2 | B
!    | e      | 3 | C
!    | e      | 4 | 
!    | e      |   | E
! (25 rows)
! 
  SELECT * FROM table_rep, temptable_rep ORDER BY 1,2,3,4;
   a | b_rep | a | b_tprep 
  ---+-------+---+---------
--- 4,120 ----
  -- Create TEMPORARY and normal tables
  CREATE TABLE table_rep (a int, b_rep char(1)) DISTRIBUTE BY REPLICATION;
  CREATE TABLE table_hash (a int, b_hash char(1)) DISTRIBUTE BY HASH(a);
+ ERROR:  Cannot support distribute type: Hash
  CREATE TABLE table_rb (a int, b_rb char(1)) DISTRIBUTE BY ROUNDROBIN;
+ ERROR:  Cannot support distribute type: RoundRobin
  CREATE TEMP TABLE temptable_rep (a int, b_tprep char(1)) DISTRIBUTE BY REPLICATION;
  CREATE TEMP TABLE temptable_hash (a int, b_tphash char(1)) DISTRIBUTE BY HASH(a);
+ ERROR:  Cannot support distribute type: Hash
  CREATE TEMP TABLE temptable_rb (a int, b_tprb char(1)) DISTRIBUTE BY ROUNDROBIN;
+ ERROR:  Cannot support distribute type: RoundRobin
  INSERT INTO table_rep VALUES (1, 'a');
  INSERT INTO table_rep VALUES (2, 'b');
  INSERT INTO table_rep VALUES (3, 'c');
  INSERT INTO table_rep VALUES (4, NULL);
  INSERT INTO table_rep VALUES (NULL, 'e');
  INSERT INTO table_hash VALUES (1, 'a');
+ ERROR:  relation "table_hash" does not exist
+ LINE 1: INSERT INTO table_hash VALUES (1, 'a');
+                     ^
  INSERT INTO table_hash VALUES (2, 'b');
+ ERROR:  relation "table_hash" does not exist
+ LINE 1: INSERT INTO table_hash VALUES (2, 'b');
+                     ^
  INSERT INTO table_hash VALUES (3, 'c');
+ ERROR:  relation "table_hash" does not exist
+ LINE 1: INSERT INTO table_hash VALUES (3, 'c');
+                     ^
  INSERT INTO table_hash VALUES (4, NULL);
+ ERROR:  relation "table_hash" does not exist
+ LINE 1: INSERT INTO table_hash VALUES (4, NULL);
+                     ^
  INSERT INTO table_hash VALUES (NULL, 'e');
+ ERROR:  relation "table_hash" does not exist
+ LINE 1: INSERT INTO table_hash VALUES (NULL, 'e');
+                     ^
  INSERT INTO table_rb VALUES (1, 'a');
+ ERROR:  relation "table_rb" does not exist
+ LINE 1: INSERT INTO table_rb VALUES (1, 'a');
+                     ^
  INSERT INTO table_rb VALUES (2, 'b');
+ ERROR:  relation "table_rb" does not exist
+ LINE 1: INSERT INTO table_rb VALUES (2, 'b');
+                     ^
  INSERT INTO table_rb VALUES (3, 'c');
+ ERROR:  relation "table_rb" does not exist
+ LINE 1: INSERT INTO table_rb VALUES (3, 'c');
+                     ^
  INSERT INTO table_rb VALUES (4, NULL);
+ ERROR:  relation "table_rb" does not exist
+ LINE 1: INSERT INTO table_rb VALUES (4, NULL);
+                     ^
  INSERT INTO table_rb VALUES (NULL, 'e');
+ ERROR:  relation "table_rb" does not exist
+ LINE 1: INSERT INTO table_rb VALUES (NULL, 'e');
+                     ^
  INSERT INTO temptable_rep VALUES (1, 'A');
  INSERT INTO temptable_rep VALUES (2, NULL);
  INSERT INTO temptable_rep VALUES (3, 'C');
  INSERT INTO temptable_rep VALUES (4, 'D');
  INSERT INTO temptable_rep VALUES (NULL, 'E');
  INSERT INTO temptable_hash VALUES (1, 'A');
+ ERROR:  relation "temptable_hash" does not exist
+ LINE 1: INSERT INTO temptable_hash VALUES (1, 'A');
+                     ^
  INSERT INTO temptable_hash VALUES (2, 'B');
+ ERROR:  relation "temptable_hash" does not exist
+ LINE 1: INSERT INTO temptable_hash VALUES (2, 'B');
+                     ^
  INSERT INTO temptable_hash VALUES (3, NULL);
+ ERROR:  relation "temptable_hash" does not exist
+ LINE 1: INSERT INTO temptable_hash VALUES (3, NULL);
+                     ^
  INSERT INTO temptable_hash VALUES (4, 'D');
+ ERROR:  relation "temptable_hash" does not exist
+ LINE 1: INSERT INTO temptable_hash VALUES (4, 'D');
+                     ^
  INSERT INTO temptable_hash VALUES (NULL, 'E');
+ ERROR:  relation "temptable_hash" does not exist
+ LINE 1: INSERT INTO temptable_hash VALUES (NULL, 'E');
+                     ^
  INSERT INTO temptable_rb VALUES (1, 'A');
+ ERROR:  relation "temptable_rb" does not exist
+ LINE 1: INSERT INTO temptable_rb VALUES (1, 'A');
+                     ^
  INSERT INTO temptable_rb VALUES (2, 'B');
+ ERROR:  relation "temptable_rb" does not exist
+ LINE 1: INSERT INTO temptable_rb VALUES (2, 'B');
+                     ^
  INSERT INTO temptable_rb VALUES (3, 'C');
+ ERROR:  relation "temptable_rb" does not exist
+ LINE 1: INSERT INTO temptable_rb VALUES (3, 'C');
+                     ^
  INSERT INTO temptable_rb VALUES (4, NULL);
+ ERROR:  relation "temptable_rb" does not exist
+ LINE 1: INSERT INTO temptable_rb VALUES (4, NULL);
+                     ^
  INSERT INTO temptable_rb VALUES (NULL, 'E');
+ ERROR:  relation "temptable_rb" does not exist
+ LINE 1: INSERT INTO temptable_rb VALUES (NULL, 'E');
+                     ^
  -- Check global joins on each table combination
  SELECT * FROM table_hash, temptable_hash ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash, temptable_hash ORDER BY 1,2,3,4;
!                       ^
  SELECT * FROM table_hash, temptable_rep ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash, temptable_rep ORDER BY 1,2,3,4;
!                       ^
  SELECT * FROM table_hash, temptable_rb ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash, temptable_rb ORDER BY 1,2,3,4;
!                       ^
  SELECT * FROM table_rep, temptable_rep ORDER BY 1,2,3,4;
   a | b_rep | a | b_tprep 
  ---+-------+---+---------
***************
*** 160,252 ****
  (25 rows)
  
  SELECT * FROM table_rep, temptable_rb ORDER BY 1,2,3,4;
!  a | b_rep | a | b_tprb 
! ---+-------+---+--------
!  1 | a     | 1 | A
!  1 | a     | 2 | B
!  1 | a     | 3 | C
!  1 | a     | 4 | 
!  1 | a     |   | E
!  2 | b     | 1 | A
!  2 | b     | 2 | B
!  2 | b     | 3 | C
!  2 | b     | 4 | 
!  2 | b     |   | E
!  3 | c     | 1 | A
!  3 | c     | 2 | B
!  3 | c     | 3 | C
!  3 | c     | 4 | 
!  3 | c     |   | E
!  4 |       | 1 | A
!  4 |       | 2 | B
!  4 |       | 3 | C
!  4 |       | 4 | 
!  4 |       |   | E
!    | e     | 1 | A
!    | e     | 2 | B
!    | e     | 3 | C
!    | e     | 4 | 
!    | e     |   | E
! (25 rows)
! 
  SELECT * FROM table_rb, temptable_rb ORDER BY 1,2,3,4;
!  a | b_rb | a | b_tprb 
! ---+------+---+--------
!  1 | a    | 1 | A
!  1 | a    | 2 | B
!  1 | a    | 3 | C
!  1 | a    | 4 | 
!  1 | a    |   | E
!  2 | b    | 1 | A
!  2 | b    | 2 | B
!  2 | b    | 3 | C
!  2 | b    | 4 | 
!  2 | b    |   | E
!  3 | c    | 1 | A
!  3 | c    | 2 | B
!  3 | c    | 3 | C
!  3 | c    | 4 | 
!  3 | c    |   | E
!  4 |      | 1 | A
!  4 |      | 2 | B
!  4 |      | 3 | C
!  4 |      | 4 | 
!  4 |      |   | E
!    | e    | 1 | A
!    | e    | 2 | B
!    | e    | 3 | C
!    | e    | 4 | 
!    | e    |   | E
! (25 rows)
! 
  -- Equi-joins
  SELECT * FROM table_hash, temptable_hash WHERE table_hash.a = temptable_hash.a ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tphash 
! ---+--------+---+----------
!  1 | a      | 1 | A
!  2 | b      | 2 | B
!  3 | c      | 3 | 
!  4 |        | 4 | D
! (4 rows)
! 
  SELECT * FROM table_hash, temptable_rep WHERE table_hash.a = temptable_rep.a ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tprep 
! ---+--------+---+---------
!  1 | a      | 1 | A
!  2 | b      | 2 | 
!  3 | c      | 3 | C
!  4 |        | 4 | D
! (4 rows)
! 
  SELECT * FROM table_hash, temptable_rb WHERE table_hash.a = temptable_rb.a ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tprb 
! ---+--------+---+--------
!  1 | a      | 1 | A
!  2 | b      | 2 | B
!  3 | c      | 3 | C
!  4 |        | 4 | 
! (4 rows)
! 
  SELECT * FROM table_rep, temptable_rep WHERE table_rep.a = temptable_rep.a ORDER BY 1,2,3,4;
   a | b_rep | a | b_tprep 
  ---+-------+---+---------
--- 146,171 ----
  (25 rows)
  
  SELECT * FROM table_rep, temptable_rb ORDER BY 1,2,3,4;
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep, temptable_rb ORDER BY 1,2,3,4;
!                                  ^
  SELECT * FROM table_rb, temptable_rb ORDER BY 1,2,3,4;
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb, temptable_rb ORDER BY 1,2,3,4;
!                       ^
  -- Equi-joins
  SELECT * FROM table_hash, temptable_hash WHERE table_hash.a = temptable_hash.a ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash, temptable_hash WHERE table_hash.a ...
!                       ^
  SELECT * FROM table_hash, temptable_rep WHERE table_hash.a = temptable_rep.a ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash, temptable_rep WHERE table_hash.a =...
!                       ^
  SELECT * FROM table_hash, temptable_rb WHERE table_hash.a = temptable_rb.a ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash, temptable_rb WHERE table_hash.a = ...
!                       ^
  SELECT * FROM table_rep, temptable_rep WHERE table_rep.a = temptable_rep.a ORDER BY 1,2,3,4;
   a | b_rep | a | b_tprep 
  ---+-------+---+---------
***************
*** 257,325 ****
  (4 rows)
  
  SELECT * FROM table_rep, temptable_rb WHERE table_rep.a = temptable_rb.a ORDER BY 1,2,3,4;
!  a | b_rep | a | b_tprb 
! ---+-------+---+--------
!  1 | a     | 1 | A
!  2 | b     | 2 | B
!  3 | c     | 3 | C
!  4 |       | 4 | 
! (4 rows)
! 
  SELECT * FROM table_rb, temptable_rb WHERE table_rb.a = temptable_rb.a ORDER BY 1,2,3,4;
!  a | b_rb | a | b_tprb 
! ---+------+---+--------
!  1 | a    | 1 | A
!  2 | b    | 2 | B
!  3 | c    | 3 | C
!  4 |      | 4 | 
! (4 rows)
! 
  -- Non equi-joins
  SELECT * FROM table_hash JOIN temptable_hash ON (table_hash.a <= temptable_hash.a) ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tphash 
! ---+--------+---+----------
!  1 | a      | 1 | A
!  1 | a      | 2 | B
!  1 | a      | 3 | 
!  1 | a      | 4 | D
!  2 | b      | 2 | B
!  2 | b      | 3 | 
!  2 | b      | 4 | D
!  3 | c      | 3 | 
!  3 | c      | 4 | D
!  4 |        | 4 | D
! (10 rows)
! 
  SELECT * FROM table_hash JOIN temptable_rep ON (table_hash.a <= temptable_rep.a) ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tprep 
! ---+--------+---+---------
!  1 | a      | 1 | A
!  1 | a      | 2 | 
!  1 | a      | 3 | C
!  1 | a      | 4 | D
!  2 | b      | 2 | 
!  2 | b      | 3 | C
!  2 | b      | 4 | D
!  3 | c      | 3 | C
!  3 | c      | 4 | D
!  4 |        | 4 | D
! (10 rows)
! 
  SELECT * FROM table_hash JOIN temptable_rb ON (table_hash.a <= temptable_rb.a) ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tprb 
! ---+--------+---+--------
!  1 | a      | 1 | A
!  1 | a      | 2 | B
!  1 | a      | 3 | C
!  1 | a      | 4 | 
!  2 | b      | 2 | B
!  2 | b      | 3 | C
!  2 | b      | 4 | 
!  3 | c      | 3 | C
!  3 | c      | 4 | 
!  4 |        | 4 | 
! (10 rows)
! 
  SELECT * FROM table_rep JOIN temptable_rep ON (table_rep.a <= temptable_rep.a) ORDER BY 1,2,3,4;
   a | b_rep | a | b_tprep 
  ---+-------+---+---------
--- 176,201 ----
  (4 rows)
  
  SELECT * FROM table_rep, temptable_rb WHERE table_rep.a = temptable_rb.a ORDER BY 1,2,3,4;
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep, temptable_rb WHERE table_rep.a = te...
!                                  ^
  SELECT * FROM table_rb, temptable_rb WHERE table_rb.a = temptable_rb.a ORDER BY 1,2,3,4;
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb, temptable_rb WHERE table_rb.a = temp...
!                       ^
  -- Non equi-joins
  SELECT * FROM table_hash JOIN temptable_hash ON (table_hash.a <= temptable_hash.a) ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash JOIN temptable_hash ON (table_hash....
!                       ^
  SELECT * FROM table_hash JOIN temptable_rep ON (table_hash.a <= temptable_rep.a) ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash JOIN temptable_rep ON (table_hash.a...
!                       ^
  SELECT * FROM table_hash JOIN temptable_rb ON (table_hash.a <= temptable_rb.a) ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash JOIN temptable_rb ON (table_hash.a ...
!                       ^
  SELECT * FROM table_rep JOIN temptable_rep ON (table_rep.a <= temptable_rep.a) ORDER BY 1,2,3,4;
   a | b_rep | a | b_tprep 
  ---+-------+---+---------
***************
*** 336,704 ****
  (10 rows)
  
  SELECT * FROM table_rep JOIN temptable_rb ON (table_rep.a <= temptable_rb.a) ORDER BY 1,2,3,4;
!  a | b_rep | a | b_tprb 
! ---+-------+---+--------
!  1 | a     | 1 | A
!  1 | a     | 2 | B
!  1 | a     | 3 | C
!  1 | a     | 4 | 
!  2 | b     | 2 | B
!  2 | b     | 3 | C
!  2 | b     | 4 | 
!  3 | c     | 3 | C
!  3 | c     | 4 | 
!  4 |       | 4 | 
! (10 rows)
! 
  SELECT * FROM table_rb JOIN temptable_rb ON (table_rb.a <= temptable_rb.a) ORDER BY 1,2,3,4;
!  a | b_rb | a | b_tprb 
! ---+------+---+--------
!  1 | a    | 1 | A
!  1 | a    | 2 | B
!  1 | a    | 3 | C
!  1 | a    | 4 | 
!  2 | b    | 2 | B
!  2 | b    | 3 | C
!  2 | b    | 4 | 
!  3 | c    | 3 | C
!  3 | c    | 4 | 
!  4 |      | 4 | 
! (10 rows)
! 
  -- More complicated joins
  -- Hash and temp Hash
  SELECT * FROM table_hash NATURAL JOIN temptable_hash ORDER BY 1,2,3;
!  a | b_hash | b_tphash 
! ---+--------+----------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | 
!  4 |        | D
! (4 rows)
! 
  SELECT * FROM table_hash CROSS JOIN temptable_hash ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tphash 
! ---+--------+---+----------
!  1 | a      | 1 | A
!  1 | a      | 2 | B
!  1 | a      | 3 | 
!  1 | a      | 4 | D
!  1 | a      |   | E
!  2 | b      | 1 | A
!  2 | b      | 2 | B
!  2 | b      | 3 | 
!  2 | b      | 4 | D
!  2 | b      |   | E
!  3 | c      | 1 | A
!  3 | c      | 2 | B
!  3 | c      | 3 | 
!  3 | c      | 4 | D
!  3 | c      |   | E
!  4 |        | 1 | A
!  4 |        | 2 | B
!  4 |        | 3 | 
!  4 |        | 4 | D
!  4 |        |   | E
!    | e      | 1 | A
!    | e      | 2 | B
!    | e      | 3 | 
!    | e      | 4 | D
!    | e      |   | E
! (25 rows)
! 
  SELECT * FROM table_hash INNER JOIN temptable_hash USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tphash 
! ---+--------+----------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | 
!  4 |        | D
! (4 rows)
! 
  SELECT * FROM table_hash LEFT OUTER JOIN temptable_hash USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tphash 
! ---+--------+----------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | 
!  4 |        | D
!    | e      | 
! (5 rows)
! 
  SELECT * FROM table_hash RIGHT OUTER JOIN temptable_hash USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tphash 
! ---+--------+----------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | 
!  4 |        | D
!    |        | E
! (5 rows)
! 
  SELECT * FROM table_hash FULL OUTER JOIN temptable_hash USING (a) ORDER BY 1,2,3; --Fails for the time being
!  a | b_hash | b_tphash 
! ---+--------+----------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | 
!  4 |        | D
!    | e      | 
!    |        | E
! (6 rows)
! 
  SELECT * FROM table_hash LEFT JOIN temptable_hash USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tphash 
! ---+--------+----------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | 
!  4 |        | D
!    | e      | 
! (5 rows)
! 
  SELECT * FROM table_hash RIGHT JOIN temptable_hash USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tphash 
! ---+--------+----------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | 
!  4 |        | D
!    |        | E
! (5 rows)
! 
  SELECT * FROM table_hash FULL JOIN temptable_hash USING (a) ORDER BY 1,2,3; --Fails for the time being
!  a | b_hash | b_tphash 
! ---+--------+----------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | 
!  4 |        | D
!    | e      | 
!    |        | E
! (6 rows)
! 
  -- Hash and temp Replication
  SELECT * FROM table_hash NATURAL JOIN temptable_rep ORDER BY 1,2,3;
!  a | b_hash | b_tprep 
! ---+--------+---------
!  1 | a      | A
!  2 | b      | 
!  3 | c      | C
!  4 |        | D
! (4 rows)
! 
  SELECT * FROM table_hash CROSS JOIN temptable_rep ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tprep 
! ---+--------+---+---------
!  1 | a      | 1 | A
!  1 | a      | 2 | 
!  1 | a      | 3 | C
!  1 | a      | 4 | D
!  1 | a      |   | E
!  2 | b      | 1 | A
!  2 | b      | 2 | 
!  2 | b      | 3 | C
!  2 | b      | 4 | D
!  2 | b      |   | E
!  3 | c      | 1 | A
!  3 | c      | 2 | 
!  3 | c      | 3 | C
!  3 | c      | 4 | D
!  3 | c      |   | E
!  4 |        | 1 | A
!  4 |        | 2 | 
!  4 |        | 3 | C
!  4 |        | 4 | D
!  4 |        |   | E
!    | e      | 1 | A
!    | e      | 2 | 
!    | e      | 3 | C
!    | e      | 4 | D
!    | e      |   | E
! (25 rows)
! 
  SELECT * FROM table_hash INNER JOIN temptable_rep USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tprep 
! ---+--------+---------
!  1 | a      | A
!  2 | b      | 
!  3 | c      | C
!  4 |        | D
! (4 rows)
! 
  SELECT * FROM table_hash LEFT OUTER JOIN temptable_rep USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tprep 
! ---+--------+---------
!  1 | a      | A
!  2 | b      | 
!  3 | c      | C
!  4 |        | D
!    | e      | 
! (5 rows)
! 
  SELECT * FROM table_hash RIGHT OUTER JOIN temptable_rep USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tprep 
! ---+--------+---------
!  1 | a      | A
!  2 | b      | 
!  3 | c      | C
!  4 |        | D
!    |        | E
! (5 rows)
! 
  SELECT * FROM table_hash FULL OUTER JOIN temptable_rep USING (a) ORDER BY 1,2,3; --Fails for the time being                                                                                                   
!  a | b_hash | b_tprep 
! ---+--------+---------
!  1 | a      | A
!  2 | b      | 
!  3 | c      | C
!  4 |        | D
!    | e      | 
!    |        | E
! (6 rows)
! 
  SELECT * FROM table_hash LEFT JOIN temptable_rep USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tprep 
! ---+--------+---------
!  1 | a      | A
!  2 | b      | 
!  3 | c      | C
!  4 |        | D
!    | e      | 
! (5 rows)
! 
  SELECT * FROM table_hash RIGHT JOIN temptable_rep USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tprep 
! ---+--------+---------
!  1 | a      | A
!  2 | b      | 
!  3 | c      | C
!  4 |        | D
!    |        | E
! (5 rows)
! 
  SELECT * FROM table_hash FULL JOIN temptable_rep USING (a) ORDER BY 1,2,3; --Fails for the time being
!  a | b_hash | b_tprep 
! ---+--------+---------
!  1 | a      | A
!  2 | b      | 
!  3 | c      | C
!  4 |        | D
!    | e      | 
!    |        | E
! (6 rows)
! 
  -- Hash and temp Round Robin
  SELECT * FROM table_hash NATURAL JOIN temptable_rb ORDER BY 1,2,3;
!  a | b_hash | b_tprb 
! ---+--------+--------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | C
!  4 |        | 
! (4 rows)
! 
  SELECT * FROM table_hash CROSS JOIN temptable_rb ORDER BY 1,2,3,4;
!  a | b_hash | a | b_tprb 
! ---+--------+---+--------
!  1 | a      | 1 | A
!  1 | a      | 2 | B
!  1 | a      | 3 | C
!  1 | a      | 4 | 
!  1 | a      |   | E
!  2 | b      | 1 | A
!  2 | b      | 2 | B
!  2 | b      | 3 | C
!  2 | b      | 4 | 
!  2 | b      |   | E
!  3 | c      | 1 | A
!  3 | c      | 2 | B
!  3 | c      | 3 | C
!  3 | c      | 4 | 
!  3 | c      |   | E
!  4 |        | 1 | A
!  4 |        | 2 | B
!  4 |        | 3 | C
!  4 |        | 4 | 
!  4 |        |   | E
!    | e      | 1 | A
!    | e      | 2 | B
!    | e      | 3 | C
!    | e      | 4 | 
!    | e      |   | E
! (25 rows)
! 
  SELECT * FROM table_hash INNER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tprb 
! ---+--------+--------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | C
!  4 |        | 
! (4 rows)
! 
  SELECT * FROM table_hash LEFT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tprb 
! ---+--------+--------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | C
!  4 |        | 
!    | e      | 
! (5 rows)
! 
  SELECT * FROM table_hash RIGHT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tprb 
! ---+--------+--------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | C
!  4 |        | 
!    |        | E
! (5 rows)
! 
  SELECT * FROM table_hash FULL OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being                                                                                                   
!  a | b_hash | b_tprb 
! ---+--------+--------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | C
!  4 |        | 
!    | e      | 
!    |        | E
! (6 rows)
! 
  SELECT * FROM table_hash LEFT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tprb 
! ---+--------+--------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | C
!  4 |        | 
!    | e      | 
! (5 rows)
! 
  SELECT * FROM table_hash RIGHT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_hash | b_tprb 
! ---+--------+--------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | C
!  4 |        | 
!    |        | E
! (5 rows)
! 
  SELECT * FROM table_hash FULL JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being
!  a | b_hash | b_tprb 
! ---+--------+--------
!  1 | a      | A
!  2 | b      | B
!  3 | c      | C
!  4 |        | 
!    | e      | 
!    |        | E
! (6 rows)
! 
  -- Replication and temp Replication
  SELECT * FROM table_rep NATURAL JOIN temptable_rep ORDER BY 1,2,3;
   a | b_rep | b_tprep 
--- 212,336 ----
  (10 rows)
  
  SELECT * FROM table_rep JOIN temptable_rb ON (table_rep.a <= temptable_rb.a) ORDER BY 1,2,3,4;
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep JOIN temptable_rb ON (table_rep.a <=...
!                                      ^
  SELECT * FROM table_rb JOIN temptable_rb ON (table_rb.a <= temptable_rb.a) ORDER BY 1,2,3,4;
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb JOIN temptable_rb ON (table_rb.a <= t...
!                       ^
  -- More complicated joins
  -- Hash and temp Hash
  SELECT * FROM table_hash NATURAL JOIN temptable_hash ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash NATURAL JOIN temptable_hash ORDER B...
!                       ^
  SELECT * FROM table_hash CROSS JOIN temptable_hash ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash CROSS JOIN temptable_hash ORDER BY ...
!                       ^
  SELECT * FROM table_hash INNER JOIN temptable_hash USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash INNER JOIN temptable_hash USING (a)...
!                       ^
  SELECT * FROM table_hash LEFT OUTER JOIN temptable_hash USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash LEFT OUTER JOIN temptable_hash USIN...
!                       ^
  SELECT * FROM table_hash RIGHT OUTER JOIN temptable_hash USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash RIGHT OUTER JOIN temptable_hash USI...
!                       ^
  SELECT * FROM table_hash FULL OUTER JOIN temptable_hash USING (a) ORDER BY 1,2,3; --Fails for the time being
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash FULL OUTER JOIN temptable_hash USIN...
!                       ^
  SELECT * FROM table_hash LEFT JOIN temptable_hash USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash LEFT JOIN temptable_hash USING (a) ...
!                       ^
  SELECT * FROM table_hash RIGHT JOIN temptable_hash USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash RIGHT JOIN temptable_hash USING (a)...
!                       ^
  SELECT * FROM table_hash FULL JOIN temptable_hash USING (a) ORDER BY 1,2,3; --Fails for the time being
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash FULL JOIN temptable_hash USING (a) ...
!                       ^
  -- Hash and temp Replication
  SELECT * FROM table_hash NATURAL JOIN temptable_rep ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash NATURAL JOIN temptable_rep ORDER BY...
!                       ^
  SELECT * FROM table_hash CROSS JOIN temptable_rep ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash CROSS JOIN temptable_rep ORDER BY 1...
!                       ^
  SELECT * FROM table_hash INNER JOIN temptable_rep USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash INNER JOIN temptable_rep USING (a) ...
!                       ^
  SELECT * FROM table_hash LEFT OUTER JOIN temptable_rep USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash LEFT OUTER JOIN temptable_rep USING...
!                       ^
  SELECT * FROM table_hash RIGHT OUTER JOIN temptable_rep USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash RIGHT OUTER JOIN temptable_rep USIN...
!                       ^
  SELECT * FROM table_hash FULL OUTER JOIN temptable_rep USING (a) ORDER BY 1,2,3; --Fails for the time being                                                                                                   
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash FULL OUTER JOIN temptable_rep USING...
!                       ^
  SELECT * FROM table_hash LEFT JOIN temptable_rep USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash LEFT JOIN temptable_rep USING (a) O...
!                       ^
  SELECT * FROM table_hash RIGHT JOIN temptable_rep USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash RIGHT JOIN temptable_rep USING (a) ...
!                       ^
  SELECT * FROM table_hash FULL JOIN temptable_rep USING (a) ORDER BY 1,2,3; --Fails for the time being
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash FULL JOIN temptable_rep USING (a) O...
!                       ^
  -- Hash and temp Round Robin
  SELECT * FROM table_hash NATURAL JOIN temptable_rb ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash NATURAL JOIN temptable_rb ORDER BY ...
!                       ^
  SELECT * FROM table_hash CROSS JOIN temptable_rb ORDER BY 1,2,3,4;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash CROSS JOIN temptable_rb ORDER BY 1,...
!                       ^
  SELECT * FROM table_hash INNER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash INNER JOIN temptable_rb USING (a) O...
!                       ^
  SELECT * FROM table_hash LEFT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash LEFT OUTER JOIN temptable_rb USING ...
!                       ^
  SELECT * FROM table_hash RIGHT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash RIGHT OUTER JOIN temptable_rb USING...
!                       ^
  SELECT * FROM table_hash FULL OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being                                                                                                   
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash FULL OUTER JOIN temptable_rb USING ...
!                       ^
  SELECT * FROM table_hash LEFT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash LEFT JOIN temptable_rb USING (a) OR...
!                       ^
  SELECT * FROM table_hash RIGHT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash RIGHT JOIN temptable_rb USING (a) O...
!                       ^
  SELECT * FROM table_hash FULL JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being
! ERROR:  relation "table_hash" does not exist
! LINE 1: SELECT * FROM table_hash FULL JOIN temptable_rb USING (a) OR...
!                       ^
  -- Replication and temp Replication
  SELECT * FROM table_rep NATURAL JOIN temptable_rep ORDER BY 1,2,3;
   a | b_rep | b_tprep 
***************
*** 812,1047 ****
  
  -- Replication and temp Round Robin
  SELECT * FROM table_rep NATURAL JOIN temptable_rb ORDER BY 1,2,3;
!  a | b_rep | b_tprb 
! ---+-------+--------
!  1 | a     | A
!  2 | b     | B
!  3 | c     | C
!  4 |       | 
! (4 rows)
! 
  SELECT * FROM table_rep CROSS JOIN temptable_rb ORDER BY 1,2,3,4;
!  a | b_rep | a | b_tprb 
! ---+-------+---+--------
!  1 | a     | 1 | A
!  1 | a     | 2 | B
!  1 | a     | 3 | C
!  1 | a     | 4 | 
!  1 | a     |   | E
!  2 | b     | 1 | A
!  2 | b     | 2 | B
!  2 | b     | 3 | C
!  2 | b     | 4 | 
!  2 | b     |   | E
!  3 | c     | 1 | A
!  3 | c     | 2 | B
!  3 | c     | 3 | C
!  3 | c     | 4 | 
!  3 | c     |   | E
!  4 |       | 1 | A
!  4 |       | 2 | B
!  4 |       | 3 | C
!  4 |       | 4 | 
!  4 |       |   | E
!    | e     | 1 | A
!    | e     | 2 | B
!    | e     | 3 | C
!    | e     | 4 | 
!    | e     |   | E
! (25 rows)
! 
  SELECT * FROM table_rep INNER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_rep | b_tprb 
! ---+-------+--------
!  1 | a     | A
!  2 | b     | B
!  3 | c     | C
!  4 |       | 
! (4 rows)
! 
  SELECT * FROM table_rep LEFT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_rep | b_tprb 
! ---+-------+--------
!  1 | a     | A
!  2 | b     | B
!  3 | c     | C
!  4 |       | 
!    | e     | 
! (5 rows)
! 
  SELECT * FROM table_rep RIGHT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_rep | b_tprb 
! ---+-------+--------
!  1 | a     | A
!  2 | b     | B
!  3 | c     | C
!  4 |       | 
!    |       | E
! (5 rows)
! 
  SELECT * FROM table_rep FULL OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being                                                                                                   
!  a | b_rep | b_tprb 
! ---+-------+--------
!  1 | a     | A
!  2 | b     | B
!  3 | c     | C
!  4 |       | 
!    | e     | 
!    |       | E
! (6 rows)
! 
  SELECT * FROM table_rep LEFT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_rep | b_tprb 
! ---+-------+--------
!  1 | a     | A
!  2 | b     | B
!  3 | c     | C
!  4 |       | 
!    | e     | 
! (5 rows)
! 
  SELECT * FROM table_rep RIGHT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_rep | b_tprb 
! ---+-------+--------
!  1 | a     | A
!  2 | b     | B
!  3 | c     | C
!  4 |       | 
!    |       | E
! (5 rows)
! 
  SELECT * FROM table_rep FULL JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being
!  a | b_rep | b_tprb 
! ---+-------+--------
!  1 | a     | A
!  2 | b     | B
!  3 | c     | C
!  4 |       | 
!    | e     | 
!    |       | E
! (6 rows)
! 
  -- Round Robin and temp Round Robin
  SELECT * FROM table_rb NATURAL JOIN temptable_rb ORDER BY 1,2,3;
!  a | b_rb | b_tprb 
! ---+------+--------
!  1 | a    | A
!  2 | b    | B
!  3 | c    | C
!  4 |      | 
! (4 rows)
! 
  SELECT * FROM table_rb CROSS JOIN temptable_rb ORDER BY 1,2,3,4;
!  a | b_rb | a | b_tprb 
! ---+------+---+--------
!  1 | a    | 1 | A
!  1 | a    | 2 | B
!  1 | a    | 3 | C
!  1 | a    | 4 | 
!  1 | a    |   | E
!  2 | b    | 1 | A
!  2 | b    | 2 | B
!  2 | b    | 3 | C
!  2 | b    | 4 | 
!  2 | b    |   | E
!  3 | c    | 1 | A
!  3 | c    | 2 | B
!  3 | c    | 3 | C
!  3 | c    | 4 | 
!  3 | c    |   | E
!  4 |      | 1 | A
!  4 |      | 2 | B
!  4 |      | 3 | C
!  4 |      | 4 | 
!  4 |      |   | E
!    | e    | 1 | A
!    | e    | 2 | B
!    | e    | 3 | C
!    | e    | 4 | 
!    | e    |   | E
! (25 rows)
! 
  SELECT * FROM table_rb INNER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_rb | b_tprb 
! ---+------+--------
!  1 | a    | A
!  2 | b    | B
!  3 | c    | C
!  4 |      | 
! (4 rows)
! 
  SELECT * FROM table_rb LEFT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_rb | b_tprb 
! ---+------+--------
!  1 | a    | A
!  2 | b    | B
!  3 | c    | C
!  4 |      | 
!    | e    | 
! (5 rows)
! 
  SELECT * FROM table_rb RIGHT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_rb | b_tprb 
! ---+------+--------
!  1 | a    | A
!  2 | b    | B
!  3 | c    | C
!  4 |      | 
!    |      | E
! (5 rows)
! 
  SELECT * FROM table_rb FULL OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being                                                                                                   
!  a | b_rb | b_tprb 
! ---+------+--------
!  1 | a    | A
!  2 | b    | B
!  3 | c    | C
!  4 |      | 
!    | e    | 
!    |      | E
! (6 rows)
! 
  SELECT * FROM table_rb LEFT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_rb | b_tprb 
! ---+------+--------
!  1 | a    | A
!  2 | b    | B
!  3 | c    | C
!  4 |      | 
!    | e    | 
! (5 rows)
! 
  SELECT * FROM table_rb RIGHT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
!  a | b_rb | b_tprb 
! ---+------+--------
!  1 | a    | A
!  2 | b    | B
!  3 | c    | C
!  4 |      | 
!    |      | E
! (5 rows)
! 
  SELECT * FROM table_rb FULL JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being
!  a | b_rb | b_tprb 
! ---+------+--------
!  1 | a    | A
!  2 | b    | B
!  3 | c    | C
!  4 |      | 
!    | e    | 
!    |      | E
! (6 rows)
! 
  -- Check that DROP with TEMP and non-TEMP tables fails correctly
  DROP TABLE temptable_rep,table_rep;
  ERROR:  DROP not supported for TEMP and non-TEMP objects
  DETAIL:  You should separate TEMP and non-TEMP objects
  -- Clean up everything
  DROP TABLE table_rep,table_hash,table_rb;
  -- Check of inheritance between temp and non-temp tables
  CREATE TEMP TABLE table_parent (a int);
  CREATE TABLE table_child (like table_parent, b int);
! ERROR:  relation "table_parent" does not exist
  DROP TABLE table_child;
  ERROR:  table "table_child" does not exist
  -- Access temp sequence in redistribution.
--- 444,532 ----
  
  -- Replication and temp Round Robin
  SELECT * FROM table_rep NATURAL JOIN temptable_rb ORDER BY 1,2,3;
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep NATURAL JOIN temptable_rb ORDER BY 1...
!                                              ^
  SELECT * FROM table_rep CROSS JOIN temptable_rb ORDER BY 1,2,3,4;
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep CROSS JOIN temptable_rb ORDER BY 1,2...
!                                            ^
  SELECT * FROM table_rep INNER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep INNER JOIN temptable_rb USING (a) OR...
!                                            ^
  SELECT * FROM table_rep LEFT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep LEFT OUTER JOIN temptable_rb USING (...
!                                                 ^
  SELECT * FROM table_rep RIGHT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep RIGHT OUTER JOIN temptable_rb USING ...
!                                                  ^
  SELECT * FROM table_rep FULL OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being                                                                                                   
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep FULL OUTER JOIN temptable_rb USING (...
!                                                 ^
  SELECT * FROM table_rep LEFT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep LEFT JOIN temptable_rb USING (a) ORD...
!                                           ^
  SELECT * FROM table_rep RIGHT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep RIGHT JOIN temptable_rb USING (a) OR...
!                                            ^
  SELECT * FROM table_rep FULL JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being
! ERROR:  relation "temptable_rb" does not exist
! LINE 1: SELECT * FROM table_rep FULL JOIN temptable_rb USING (a) ORD...
!                                           ^
  -- Round Robin and temp Round Robin
  SELECT * FROM table_rb NATURAL JOIN temptable_rb ORDER BY 1,2,3;
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb NATURAL JOIN temptable_rb ORDER BY 1,...
!                       ^
  SELECT * FROM table_rb CROSS JOIN temptable_rb ORDER BY 1,2,3,4;
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb CROSS JOIN temptable_rb ORDER BY 1,2,...
!                       ^
  SELECT * FROM table_rb INNER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb INNER JOIN temptable_rb USING (a) ORD...
!                       ^
  SELECT * FROM table_rb LEFT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb LEFT OUTER JOIN temptable_rb USING (a...
!                       ^
  SELECT * FROM table_rb RIGHT OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb RIGHT OUTER JOIN temptable_rb USING (...
!                       ^
  SELECT * FROM table_rb FULL OUTER JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being                                                                                                   
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb FULL OUTER JOIN temptable_rb USING (a...
!                       ^
  SELECT * FROM table_rb LEFT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb LEFT JOIN temptable_rb USING (a) ORDE...
!                       ^
  SELECT * FROM table_rb RIGHT JOIN temptable_rb USING (a) ORDER BY 1,2,3;
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb RIGHT JOIN temptable_rb USING (a) ORD...
!                       ^
  SELECT * FROM table_rb FULL JOIN temptable_rb USING (a) ORDER BY 1,2,3; --Fails for the time being
! ERROR:  relation "table_rb" does not exist
! LINE 1: SELECT * FROM table_rb FULL JOIN temptable_rb USING (a) ORDE...
!                       ^
  -- Check that DROP with TEMP and non-TEMP tables fails correctly
  DROP TABLE temptable_rep,table_rep;
  ERROR:  DROP not supported for TEMP and non-TEMP objects
  DETAIL:  You should separate TEMP and non-TEMP objects
  -- Clean up everything
  DROP TABLE table_rep,table_hash,table_rb;
+ ERROR:  table "table_hash" does not exist
  -- Check of inheritance between temp and non-temp tables
  CREATE TEMP TABLE table_parent (a int);
  CREATE TABLE table_child (like table_parent, b int);
! ERROR:  node:coord2, backend_pid:383274, nodename:coord2,backend_pid:383274,message:relation "table_parent" does not exist
  DROP TABLE table_child;
  ERROR:  table "table_child" does not exist
  -- Access temp sequence in redistribution.

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_remote.out"	2025-07-31 16:07:15.010067739 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_remote.out"	2025-07-31 16:40:51.511342686 +0800
***************
*** 9,28 ****
--- 9,48 ----
  -- Test for remote DML on different tables
  CREATE TABLE rel_rep (a int, b int) DISTRIBUTE BY REPLICATION;
  CREATE TABLE rel_hash (a int, b int) DISTRIBUTE BY HASH (a);
+ ERROR:  Cannot support distribute type: Hash
  CREATE TABLE rel_rr (a int, b int) DISTRIBUTE BY ROUNDROBIN;
+ ERROR:  Cannot support distribute type: RoundRobin
  CREATE SEQUENCE seqtest START 10;
  CREATE SEQUENCE seqtest2 START 100;
  -- INSERT cases
  INSERT INTO rel_rep VALUES (1,1);
  INSERT INTO rel_hash VALUES (1,1);
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: INSERT INTO rel_hash VALUES (1,1);
+                     ^
  INSERT INTO rel_rr VALUES (1,1);
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: INSERT INTO rel_rr VALUES (1,1);
+                     ^
  -- Multiple entries with non-shippable expressions
  INSERT INTO rel_rep VALUES (nextval('seqtest'), nextval('seqtest')), (1, nextval('seqtest'));
  INSERT INTO rel_rep VALUES (nextval('seqtest'), 1), (nextval('seqtest'), nextval('seqtest2'));
  INSERT INTO rel_hash VALUES (nextval('seqtest'), nextval('seqtest')), (1, nextval('seqtest'));
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: INSERT INTO rel_hash VALUES (nextval('seqtest'), nextval('se...
+                     ^
  INSERT INTO rel_hash VALUES (nextval('seqtest'), 1), (nextval('seqtest'), nextval('seqtest2'));
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: INSERT INTO rel_hash VALUES (nextval('seqtest'), 1), (nextva...
+                     ^
  INSERT INTO rel_rr VALUES (nextval('seqtest'), nextval('seqtest')), (1, nextval('seqtest'));
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: INSERT INTO rel_rr VALUES (nextval('seqtest'), nextval('seqt...
+                     ^
  INSERT INTO rel_rr VALUES (nextval('seqtest'), 1), (nextval('seqtest'), nextval('seqtest2'));
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: INSERT INTO rel_rr VALUES (nextval('seqtest'), 1), (nextval(...
+                     ^
  -- Global check
  SELECT a, b FROM rel_rep ORDER BY 1,2;
   a  |  b  
***************
*** 35,82 ****
  (5 rows)
  
  SELECT a, b FROM rel_hash ORDER BY 1,2;
!  a  |  b  
! ----+-----
!   1 |   1
!   1 |  17
!  15 |  16
!  18 |   1
!  19 | 101
! (5 rows)
! 
  SELECT a, b FROM rel_rr ORDER BY 1,2;
!  a  |  b  
! ----+-----
!   1 |   1
!   1 |  22
!  20 |  21
!  23 |   1
!  24 | 102
! (5 rows)
! 
  -- Some SELECT queries with some quals
  -- Coordinator quals first
  SELECT a, b FROM rel_rep WHERE a <= currval('seqtest') - 15 ORDER BY 1,2;
!  a | b  
! ---+----
!  1 |  1
!  1 | 12
! (2 rows)
  
  SELECT a, b FROM rel_hash WHERE a <= currval('seqtest') - 15 ORDER BY 1,2;
!  a | b  
! ---+----
!  1 |  1
!  1 | 17
! (2 rows)
! 
  SELECT a, b FROM rel_rr WHERE a <= currval('seqtest') - 15 ORDER BY 1,2;
!  a | b  
! ---+----
!  1 |  1
!  1 | 22
! (2 rows)
! 
  -- Non Coordinator quals
  SELECT a, b FROM rel_rep WHERE a <= func_immutable(5) ORDER BY 1,2;
   a | b  
--- 55,82 ----
  (5 rows)
  
  SELECT a, b FROM rel_hash ORDER BY 1,2;
! ERROR:  relation "rel_hash" does not exist
! LINE 1: SELECT a, b FROM rel_hash ORDER BY 1,2;
!                          ^
  SELECT a, b FROM rel_rr ORDER BY 1,2;
! ERROR:  relation "rel_rr" does not exist
! LINE 1: SELECT a, b FROM rel_rr ORDER BY 1,2;
!                          ^
  -- Some SELECT queries with some quals
  -- Coordinator quals first
  SELECT a, b FROM rel_rep WHERE a <= currval('seqtest') - 15 ORDER BY 1,2;
!  a | b 
! ---+---
! (0 rows)
  
  SELECT a, b FROM rel_hash WHERE a <= currval('seqtest') - 15 ORDER BY 1,2;
! ERROR:  relation "rel_hash" does not exist
! LINE 1: SELECT a, b FROM rel_hash WHERE a <= currval('seqtest') - 15...
!                          ^
  SELECT a, b FROM rel_rr WHERE a <= currval('seqtest') - 15 ORDER BY 1,2;
! ERROR:  relation "rel_rr" does not exist
! LINE 1: SELECT a, b FROM rel_rr WHERE a <= currval('seqtest') - 15 O...
!                          ^
  -- Non Coordinator quals
  SELECT a, b FROM rel_rep WHERE a <= func_immutable(5) ORDER BY 1,2;
   a | b  
***************
*** 86,104 ****
  (2 rows)
  
  SELECT a, b FROM rel_hash WHERE a <= func_immutable(5) ORDER BY 1,2;
!  a | b  
! ---+----
!  1 |  1
!  1 | 17
! (2 rows)
! 
  SELECT a, b FROM rel_rr WHERE a <= func_immutable(5) ORDER BY 1,2;
!  a | b  
! ---+----
!  1 |  1
!  1 | 22
! (2 rows)
! 
  SELECT a, b FROM rel_rep WHERE a <= func_stable(5) ORDER BY 1,2;
   a | b  
  ---+----
--- 86,98 ----
  (2 rows)
  
  SELECT a, b FROM rel_hash WHERE a <= func_immutable(5) ORDER BY 1,2;
! ERROR:  relation "rel_hash" does not exist
! LINE 1: SELECT a, b FROM rel_hash WHERE a <= func_immutable(5) ORDER...
!                          ^
  SELECT a, b FROM rel_rr WHERE a <= func_immutable(5) ORDER BY 1,2;
! ERROR:  relation "rel_rr" does not exist
! LINE 1: SELECT a, b FROM rel_rr WHERE a <= func_immutable(5) ORDER B...
!                          ^
  SELECT a, b FROM rel_rep WHERE a <= func_stable(5) ORDER BY 1,2;
   a | b  
  ---+----
***************
*** 107,125 ****
  (2 rows)
  
  SELECT a, b FROM rel_hash WHERE a <= func_stable(5) ORDER BY 1,2;
!  a | b  
! ---+----
!  1 |  1
!  1 | 17
! (2 rows)
! 
  SELECT a, b FROM rel_rr WHERE a <= func_stable(5) ORDER BY 1,2;
!  a | b  
! ---+----
!  1 |  1
!  1 | 22
! (2 rows)
! 
  SELECT a, b FROM rel_rep WHERE a <= func_volatile(5) ORDER BY 1,2;
   a | b  
  ---+----
--- 101,113 ----
  (2 rows)
  
  SELECT a, b FROM rel_hash WHERE a <= func_stable(5) ORDER BY 1,2;
! ERROR:  relation "rel_hash" does not exist
! LINE 1: SELECT a, b FROM rel_hash WHERE a <= func_stable(5) ORDER BY...
!                          ^
  SELECT a, b FROM rel_rr WHERE a <= func_stable(5) ORDER BY 1,2;
! ERROR:  relation "rel_rr" does not exist
! LINE 1: SELECT a, b FROM rel_rr WHERE a <= func_stable(5) ORDER BY 1...
!                          ^
  SELECT a, b FROM rel_rep WHERE a <= func_volatile(5) ORDER BY 1,2;
   a | b  
  ---+----
***************
*** 128,152 ****
  (2 rows)
  
  SELECT a, b FROM rel_hash WHERE a <= func_volatile(5) ORDER BY 1,2;
!  a | b  
! ---+----
!  1 |  1
!  1 | 17
! (2 rows)
! 
  SELECT a, b FROM rel_rr WHERE a <= func_volatile(5) ORDER BY 1,2;
!  a | b  
! ---+----
!  1 |  1
!  1 | 22
! (2 rows)
! 
  -- Clean up everything
  DROP SEQUENCE seqtest;
  DROP SEQUENCE seqtest2;
  DROP TABLE rel_rep;
  DROP TABLE rel_hash;
  DROP TABLE rel_rr;
  -- UPDATE cases for replicated table
  -- Plain case, change it completely
  CREATE TABLE rel_rep (a int, b timestamp DEFAULT NULL, c boolean DEFAULT NULL) DISTRIBUTE BY REPLICATION;
--- 116,136 ----
  (2 rows)
  
  SELECT a, b FROM rel_hash WHERE a <= func_volatile(5) ORDER BY 1,2;
! ERROR:  relation "rel_hash" does not exist
! LINE 1: SELECT a, b FROM rel_hash WHERE a <= func_volatile(5) ORDER ...
!                          ^
  SELECT a, b FROM rel_rr WHERE a <= func_volatile(5) ORDER BY 1,2;
! ERROR:  relation "rel_rr" does not exist
! LINE 1: SELECT a, b FROM rel_rr WHERE a <= func_volatile(5) ORDER BY...
!                          ^
  -- Clean up everything
  DROP SEQUENCE seqtest;
  DROP SEQUENCE seqtest2;
  DROP TABLE rel_rep;
  DROP TABLE rel_hash;
+ ERROR:  table "rel_hash" does not exist
  DROP TABLE rel_rr;
+ ERROR:  table "rel_rr" does not exist
  -- UPDATE cases for replicated table
  -- Plain case, change it completely
  CREATE TABLE rel_rep (a int, b timestamp DEFAULT NULL, c boolean DEFAULT NULL) DISTRIBUTE BY REPLICATION;
***************
*** 194,200 ****
  UPDATE rel_rep SET c = false;
  -- Coordinator quals
  UPDATE rel_rep SET b = now(), c = true WHERE a < currval('seqtest3') - 3 AND b < now();
! ERROR:  currval of sequence "seqtest3" is not yet defined in this session
  SELECT a FROM rel_rep  WHERE c = true ORDER BY 1;
   a 
  ---
--- 178,184 ----
  UPDATE rel_rep SET c = false;
  -- Coordinator quals
  UPDATE rel_rep SET b = now(), c = true WHERE a < currval('seqtest3') - 3 AND b < now();
! ERROR:  node:datanode_2, backend_pid:386116, nodename:datanode_1,backend_pid:384790,message:currval of sequence "seqtest3" is not yet defined in this session
  SELECT a FROM rel_rep  WHERE c = true ORDER BY 1;
   a 
  ---
***************
*** 204,250 ****
  -- UPDATE cases for roundrobin table
  -- Plain cases change it completely
  CREATE TABLE rel_rr (a int, b timestamp DEFAULT NULL, c boolean DEFAULT NULL) DISTRIBUTE BY ROUNDROBIN;
  CREATE SEQUENCE seqtest4 START 1;
  INSERT INTO rel_rr VALUES (1),(2),(3),(4),(5);
  UPDATE rel_rr SET a = nextval('seqtest4'), b = now(), c = false;
  SELECT a FROM rel_rr ORDER BY 1;
!  a 
! ---
!  1
!  2
!  3
!  4
!  5
! (5 rows)
! 
  -- Non-Coordinator quals
  UPDATE rel_rr SET b = now(), c = true WHERE a < func_volatile(2);
  SELECT a FROM rel_rr WHERE c = true ORDER BY 1;
!  a 
! ---
!  1
! (1 row)
! 
  UPDATE rel_rr SET c = false;
  UPDATE rel_rr SET b = now(), c = true WHERE a < func_stable(3);
  SELECT a FROM rel_rr WHERE c = true ORDER BY 1;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
  UPDATE rel_rr SET c = false WHERE c = true;
  UPDATE rel_rr SET b = now(), c = true WHERE a < func_immutable(4);
  SELECT a FROM rel_rr WHERE c = true ORDER BY 1;
!  a 
! ---
!  1
!  2
!  3
! (3 rows)
! 
  UPDATE rel_rr SET c = false;
  -- Coordinator qual
  --UPDATE rel_rr SET b = now(), c = true WHERE a < currval('seqtest4') - 3 AND b < now();
  --SELECT a FROM rel_rr WHERE c = true ORDER BY 1;
--- 188,244 ----
  -- UPDATE cases for roundrobin table
  -- Plain cases change it completely
  CREATE TABLE rel_rr (a int, b timestamp DEFAULT NULL, c boolean DEFAULT NULL) DISTRIBUTE BY ROUNDROBIN;
+ ERROR:  Cannot support distribute type: RoundRobin
  CREATE SEQUENCE seqtest4 START 1;
  INSERT INTO rel_rr VALUES (1),(2),(3),(4),(5);
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: INSERT INTO rel_rr VALUES (1),(2),(3),(4),(5);
+                     ^
  UPDATE rel_rr SET a = nextval('seqtest4'), b = now(), c = false;
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: UPDATE rel_rr SET a = nextval('seqtest4'), b = now(), c = fa...
+                ^
  SELECT a FROM rel_rr ORDER BY 1;
! ERROR:  relation "rel_rr" does not exist
! LINE 1: SELECT a FROM rel_rr ORDER BY 1;
!                       ^
  -- Non-Coordinator quals
  UPDATE rel_rr SET b = now(), c = true WHERE a < func_volatile(2);
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: UPDATE rel_rr SET b = now(), c = true WHERE a < func_volatil...
+                ^
  SELECT a FROM rel_rr WHERE c = true ORDER BY 1;
! ERROR:  relation "rel_rr" does not exist
! LINE 1: SELECT a FROM rel_rr WHERE c = true ORDER BY 1;
!                       ^
  UPDATE rel_rr SET c = false;
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: UPDATE rel_rr SET c = false;
+                ^
  UPDATE rel_rr SET b = now(), c = true WHERE a < func_stable(3);
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: UPDATE rel_rr SET b = now(), c = true WHERE a < func_stable(...
+                ^
  SELECT a FROM rel_rr WHERE c = true ORDER BY 1;
! ERROR:  relation "rel_rr" does not exist
! LINE 1: SELECT a FROM rel_rr WHERE c = true ORDER BY 1;
!                       ^
  UPDATE rel_rr SET c = false WHERE c = true;
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: UPDATE rel_rr SET c = false WHERE c = true;
+                ^
  UPDATE rel_rr SET b = now(), c = true WHERE a < func_immutable(4);
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: UPDATE rel_rr SET b = now(), c = true WHERE a < func_immutab...
+                ^
  SELECT a FROM rel_rr WHERE c = true ORDER BY 1;
! ERROR:  relation "rel_rr" does not exist
! LINE 1: SELECT a FROM rel_rr WHERE c = true ORDER BY 1;
!                       ^
  UPDATE rel_rr SET c = false;
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: UPDATE rel_rr SET c = false;
+                ^
  -- Coordinator qual
  --UPDATE rel_rr SET b = now(), c = true WHERE a < currval('seqtest4') - 3 AND b < now();
  --SELECT a FROM rel_rr WHERE c = true ORDER BY 1;
***************
*** 252,332 ****
  -- UPDATE cases for hash table
  -- Hash tables cannot be updated on distribution keys so insert fresh rows
  CREATE TABLE rel_hash (a int, b timestamp DEFAULT now(), c boolean DEFAULT false) DISTRIBUTE BY HASH(a);
  CREATE SEQUENCE seqtest5 START 1;
  INSERT INTO rel_hash VALUES (nextval('seqtest5'));
  INSERT INTO rel_hash VALUES (nextval('seqtest5'));
  INSERT INTO rel_hash VALUES (nextval('seqtest5'));
  INSERT INTO rel_hash VALUES (nextval('seqtest5'));
  INSERT INTO rel_hash VALUES (nextval('seqtest5'));
  SELECT a FROM rel_hash ORDER BY 1;
!  a 
! ---
!  1
!  2
!  3
!  4
!  5
! (5 rows)
! 
  UPDATE rel_hash SET b = now(), c = true;
  SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
!  a 
! ---
!  1
!  2
!  3
!  4
!  5
! (5 rows)
! 
  UPDATE rel_hash SET c = false;
  -- Non-Coordinator quals
  UPDATE rel_hash SET b = now(), c = true WHERE a < func_volatile(2);
  SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
!  a 
! ---
!  1
! (1 row)
! 
  UPDATE rel_hash SET c = false;
  UPDATE rel_hash SET b = now(), c = true WHERE a < func_stable(3);
  SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
  UPDATE rel_hash SET c = false;
  UPDATE rel_hash SET b = now(), c = true WHERE a < func_immutable(4);
  SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
!  a 
! ---
!  1
!  2
!  3
! (3 rows)
! 
  UPDATE rel_hash SET c = false;
  -- Coordinator quals
  UPDATE rel_hash SET b = now(), c = true WHERE a < currval('seqtest5') - 3 AND b < now();
  SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
!  a 
! ---
!  1
! (1 row)
! 
  DROP SEQUENCE seqtest5;
  -- DELETE cases
  -- Coordinator quals
  CREATE SEQUENCE seqtest7 START 1;
  DELETE FROM rel_rep WHERE a < nextval('seqtest7') + 1;
  DELETE FROM rel_rr WHERE a < nextval('seqtest7') - 3;
  DELETE FROM rel_hash WHERE a < nextval('seqtest7') - 3;
  -- Plain cases
  DELETE FROM rel_rep;
  DELETE FROM rel_rr;
  DELETE FROM rel_hash;
  DROP SEQUENCE seqtest7;
  -- Few more cases to test the specific scenario of quals incorrecly applied
  -- to wrong element of target list (sourceforge bug 3515461)
--- 246,359 ----
  -- UPDATE cases for hash table
  -- Hash tables cannot be updated on distribution keys so insert fresh rows
  CREATE TABLE rel_hash (a int, b timestamp DEFAULT now(), c boolean DEFAULT false) DISTRIBUTE BY HASH(a);
+ ERROR:  Cannot support distribute type: Hash
  CREATE SEQUENCE seqtest5 START 1;
  INSERT INTO rel_hash VALUES (nextval('seqtest5'));
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: INSERT INTO rel_hash VALUES (nextval('seqtest5'));
+                     ^
  INSERT INTO rel_hash VALUES (nextval('seqtest5'));
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: INSERT INTO rel_hash VALUES (nextval('seqtest5'));
+                     ^
  INSERT INTO rel_hash VALUES (nextval('seqtest5'));
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: INSERT INTO rel_hash VALUES (nextval('seqtest5'));
+                     ^
  INSERT INTO rel_hash VALUES (nextval('seqtest5'));
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: INSERT INTO rel_hash VALUES (nextval('seqtest5'));
+                     ^
  INSERT INTO rel_hash VALUES (nextval('seqtest5'));
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: INSERT INTO rel_hash VALUES (nextval('seqtest5'));
+                     ^
  SELECT a FROM rel_hash ORDER BY 1;
! ERROR:  relation "rel_hash" does not exist
! LINE 1: SELECT a FROM rel_hash ORDER BY 1;
!                       ^
  UPDATE rel_hash SET b = now(), c = true;
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: UPDATE rel_hash SET b = now(), c = true;
+                ^
  SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
! ERROR:  relation "rel_hash" does not exist
! LINE 1: SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
!                       ^
  UPDATE rel_hash SET c = false;
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: UPDATE rel_hash SET c = false;
+                ^
  -- Non-Coordinator quals
  UPDATE rel_hash SET b = now(), c = true WHERE a < func_volatile(2);
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: UPDATE rel_hash SET b = now(), c = true WHERE a < func_volat...
+                ^
  SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
! ERROR:  relation "rel_hash" does not exist
! LINE 1: SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
!                       ^
  UPDATE rel_hash SET c = false;
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: UPDATE rel_hash SET c = false;
+                ^
  UPDATE rel_hash SET b = now(), c = true WHERE a < func_stable(3);
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: UPDATE rel_hash SET b = now(), c = true WHERE a < func_stabl...
+                ^
  SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
! ERROR:  relation "rel_hash" does not exist
! LINE 1: SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
!                       ^
  UPDATE rel_hash SET c = false;
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: UPDATE rel_hash SET c = false;
+                ^
  UPDATE rel_hash SET b = now(), c = true WHERE a < func_immutable(4);
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: UPDATE rel_hash SET b = now(), c = true WHERE a < func_immut...
+                ^
  SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
! ERROR:  relation "rel_hash" does not exist
! LINE 1: SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
!                       ^
  UPDATE rel_hash SET c = false;
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: UPDATE rel_hash SET c = false;
+                ^
  -- Coordinator quals
  UPDATE rel_hash SET b = now(), c = true WHERE a < currval('seqtest5') - 3 AND b < now();
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: UPDATE rel_hash SET b = now(), c = true WHERE a < currval('s...
+                ^
  SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
! ERROR:  relation "rel_hash" does not exist
! LINE 1: SELECT a FROM rel_hash WHERE c = true ORDER BY 1;
!                       ^
  DROP SEQUENCE seqtest5;
  -- DELETE cases
  -- Coordinator quals
  CREATE SEQUENCE seqtest7 START 1;
  DELETE FROM rel_rep WHERE a < nextval('seqtest7') + 1;
+ ERROR:  Write to replicated table returned different results from the Datanodes
  DELETE FROM rel_rr WHERE a < nextval('seqtest7') - 3;
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: DELETE FROM rel_rr WHERE a < nextval('seqtest7') - 3;
+                     ^
  DELETE FROM rel_hash WHERE a < nextval('seqtest7') - 3;
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: DELETE FROM rel_hash WHERE a < nextval('seqtest7') - 3;
+                     ^
  -- Plain cases
  DELETE FROM rel_rep;
  DELETE FROM rel_rr;
+ ERROR:  relation "rel_rr" does not exist
+ LINE 1: DELETE FROM rel_rr;
+                     ^
  DELETE FROM rel_hash;
+ ERROR:  relation "rel_hash" does not exist
+ LINE 1: DELETE FROM rel_hash;
+                     ^
  DROP SEQUENCE seqtest7;
  -- Few more cases to test the specific scenario of quals incorrecly applied
  -- to wrong element of target list (sourceforge bug 3515461)
***************
*** 625,630 ****
--- 652,658 ----
  
  -- Clean up
  DROP TABLE rel_rep, rel_hash, rel_rr;
+ ERROR:  table "rel_hash" does not exist
  DROP FUNCTION func_stable (int);
  DROP FUNCTION func_volatile (int);
  DROP FUNCTION func_immutable (int);

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_FQS.out"	2025-07-31 16:07:15.007067787 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_FQS.out"	2025-07-31 16:40:50.693359884 +0800
***************
*** 41,1315 ****
  -- a single table
  -- Testset 1 for distributed table (by roundrobin)
  select create_table_nodes('tab1_rr(val int, val2 int)', '{1, 2, 3}'::int[], 'roundrobin', NULL);
!  create_table_nodes 
! --------------------
!  
! (1 row)
! 
  insert into tab1_rr values (1, 2);
  insert into tab1_rr values (2, 4);
  insert into tab1_rr values (5, 3);
  insert into tab1_rr values (7, 8);
  insert into tab1_rr values (9, 2);
  explain (verbose on, nodes off, num_nodes on, costs off) insert into tab1_rr values (9, 2);
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: 9, 2
!    Remote query: INSERT INTO tab1_rr (val, val2) VALUES (9, 2)
!    ->  Insert on public.tab1_rr
!          ->  Result
!                Output: 9, 2
! (6 rows)
! 
  -- simple select
  -- should get FQSed
  select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_rr where val2 = 4;
!  val | ?column? |           case            
! -----+----------+---------------------------
!    2 |        6 | val and val2 are not same
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_rr where val2 = 4;
!                                                                                     QUERY PLAN                                                                                    
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_rr.val, (tab1_rr.val2 + 2), CASE tab1_rr.val WHEN tab1_rr.val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
!    Remote query: SELECT val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END AS "case" FROM tab1_rr WHERE (val2 = 4)
!    ->  Seq Scan on public.tab1_rr
!          Output: val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
!          Filter: (tab1_rr.val2 = 4)
! (6 rows)
! 
  -- should not get FQSed because of aggregates
  select sum(val), avg(val), count(*) from tab1_rr;
!  sum |        avg         | count 
! -----+--------------------+-------
!   24 | 4.8000000000000000 |     5
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select sum(val), avg(val), count(*) from tab1_rr;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Finalize Aggregate
!    Output: sum(val), avg(val), count(*)
!    ->  Remote Subquery Scan on all
!          Output: PARTIAL sum(val), PARTIAL avg(val), PARTIAL count(*)
!          ->  Partial Aggregate
!                Output: PARTIAL sum(val), PARTIAL avg(val), PARTIAL count(*)
!                ->  Seq Scan on public.tab1_rr
!                      Output: val, val2
! (8 rows)
! 
  -- should not get FQSed because of window functions
  select first_value(val) over (partition by val2 order by val) from tab1_rr;
!  first_value 
! -------------
!            1
!            1
!            5
!            2
!            7
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select first_value(val) over (partition by val2 order by val) from tab1_rr;
!                     QUERY PLAN                     
! ---------------------------------------------------
!  WindowAgg
!    Output: first_value(val) OVER (?), val, val2
!    ->  Remote Subquery Scan on all
!          Output: val, val2
!          Sort Key: tab1_rr.val2, tab1_rr.val
!          ->  Sort
!                Output: val, val2
!                Sort Key: tab1_rr.val2, tab1_rr.val
!                ->  Seq Scan on public.tab1_rr
!                      Output: val, val2
! (10 rows)
! 
  -- should not get FQSed because of LIMIT clause
  select * from tab1_rr where val2 = 3 limit 1;
!  val | val2 
! -----+------
!    5 |    3
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val2 = 3 limit 1;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Limit
!    Output: val, val2
!    ->  Remote Subquery Scan on all
!          Output: val, val2
!          ->  Limit
!                Output: val, val2
!                ->  Seq Scan on public.tab1_rr
!                      Output: val, val2
!                      Filter: (tab1_rr.val2 = 3)
! (9 rows)
! 
  -- should not FQSed because of OFFSET clause
  select * from tab1_rr where val2 = 4 offset 1;
!  val | val2 
! -----+------
! (0 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val2 = 4 offset 1;
!                 QUERY PLAN                
! ------------------------------------------
!  Limit
!    Output: val, val2
!    ->  Remote Subquery Scan on all
!          Output: val, val2
!          ->  Seq Scan on public.tab1_rr
!                Output: val, val2
!                Filter: (tab1_rr.val2 = 4)
! (7 rows)
! 
  -- should not get FQSed because of SORT clause
  select * from tab1_rr order by val;
!  val | val2 
! -----+------
!    1 |    2
!    2 |    4
!    5 |    3
!    7 |    8
!    9 |    2
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_rr order by val;
!                QUERY PLAN               
! ----------------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    Sort Key: tab1_rr.val
!    ->  Sort
!          Output: val, val2
!          Sort Key: tab1_rr.val
!          ->  Seq Scan on public.tab1_rr
!                Output: val, val2
! (8 rows)
! 
  -- should not get FQSed because of DISTINCT clause
  select distinct val, val2 from tab1_rr where val2 = 8;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select distinct val, val2 from tab1_rr where val2 = 8;
!                    QUERY PLAN                   
! ------------------------------------------------
!  Unique
!    Output: val, val2
!    ->  Remote Subquery Scan on all
!          Output: val, val2
!          Sort Key: tab1_rr.val
!          ->  Sort
!                Output: val, val2
!                Sort Key: tab1_rr.val
!                ->  Seq Scan on public.tab1_rr
!                      Output: val, val2
!                      Filter: (tab1_rr.val2 = 8)
! (11 rows)
! 
  -- should not get FQSed because of GROUP clause
  select val, val2 from tab1_rr where val2 = 8 group by val, val2;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select val, val2 from tab1_rr where val2 = 8 group by val, val2;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    ->  Group
!          Output: val, val2
!          Group Key: tab1_rr.val, tab1_rr.val2
!          ->  Sort
!                Output: val, val2
!                Sort Key: tab1_rr.val
!                ->  Remote Subquery Scan on all
!                      Output: val, val2
!                      Distribute results by H: val
!                      ->  Group
!                            Output: val, val2
!                            Group Key: tab1_rr.val, tab1_rr.val2
!                            ->  Sort
!                                  Output: val, val2
!                                  Sort Key: tab1_rr.val
!                                  ->  Seq Scan on public.tab1_rr
!                                        Output: val, val2
!                                        Filter: (tab1_rr.val2 = 8)
! (20 rows)
! 
  -- should not get FQSed because of HAVING clause
  select sum(val) from tab1_rr where val2 = 2 group by val2 having sum(val) > 1;
!  sum 
! -----
!   10
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select sum(val) from tab1_rr where val2 = 2 group by val2 having sum(val) > 1;
!                       QUERY PLAN                      
! ------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: sum(val), val2
!    ->  Finalize GroupAggregate
!          Output: sum(val), val2
!          Group Key: tab1_rr.val2
!          Filter: (sum(tab1_rr.val) > 1)
!          ->  Remote Subquery Scan on all
!                Output: val2, PARTIAL sum(val)
!                Distribute results by H: val2
!                ->  Partial GroupAggregate
!                      Output: val2, PARTIAL sum(val)
!                      Group Key: tab1_rr.val2
!                      ->  Seq Scan on public.tab1_rr
!                            Output: val, val2
!                            Filter: (tab1_rr.val2 = 2)
! (15 rows)
! 
  -- tests for node reduction by application of quals, for roundrobin node
  -- reduction is not applicable. Having query not FQSed because of existence of ORDER BY,
  -- implies that nodes did not get reduced.
  select * from tab1_rr where val = 7;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 7;
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_rr.val, tab1_rr.val2
!    Remote query: SELECT val, val2 FROM tab1_rr WHERE (val = 7)
!    ->  Seq Scan on public.tab1_rr
!          Output: val, val2
!          Filter: (tab1_rr.val = 7)
! (6 rows)
! 
  select * from tab1_rr where val = 7 or val = 2 order by val;
!  val | val2 
! -----+------
!    2 |    4
!    7 |    8
! (2 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 7 or val = 2 order by val;
!                            QUERY PLAN                           
! ----------------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    Sort Key: tab1_rr.val
!    ->  Sort
!          Output: val, val2
!          Sort Key: tab1_rr.val
!          ->  Seq Scan on public.tab1_rr
!                Output: val, val2
!                Filter: ((tab1_rr.val = 7) OR (tab1_rr.val = 2))
! (9 rows)
! 
  select * from tab1_rr where val = 7 and val2 = 8;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 7 and val2 = 8 order by val;
!                          QUERY PLAN                         
! ------------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    ->  Seq Scan on public.tab1_rr
!          Output: val, val2
!          Filter: ((tab1_rr.val = 7) AND (tab1_rr.val2 = 8))
! (5 rows)
! 
  select * from tab1_rr where val = 3 + 4 and val2 = 8 order by val;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 3 + 4 order by val;
!             QUERY PLAN             
! -----------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    ->  Seq Scan on public.tab1_rr
!          Output: val, val2
!          Filter: (tab1_rr.val = 7)
! (5 rows)
! 
  select * from tab1_rr where val = char_length('len')+4 order by val;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val = char_length('len')+4 order by val;
!             QUERY PLAN             
! -----------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    ->  Seq Scan on public.tab1_rr
!          Output: val, val2
!          Filter: (tab1_rr.val = 7)
! (5 rows)
! 
  -- insert some more values 
  insert into tab1_rr values (7, 2); 
  select avg(val) from tab1_rr where val = 7;
!         avg         
! --------------------
!  7.0000000000000000
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select avg(val) from tab1_rr where val = 7;
!                   QUERY PLAN                   
! -----------------------------------------------
!  Finalize Aggregate
!    Output: avg(val)
!    ->  Remote Subquery Scan on all
!          Output: PARTIAL avg(val)
!          ->  Partial Aggregate
!                Output: PARTIAL avg(val)
!                ->  Seq Scan on public.tab1_rr
!                      Output: val, val2
!                      Filter: (tab1_rr.val = 7)
! (9 rows)
! 
  select val, val2 from tab1_rr where val = 7 order by val2;
!  val | val2 
! -----+------
!    7 |    2
!    7 |    8
! (2 rows)
! 
  explain (verbose on, nodes off, costs off) select val, val2 from tab1_rr where val = 7 order by val2;
!                QUERY PLAN                
! -----------------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    Sort Key: tab1_rr.val2
!    ->  Sort
!          Output: val, val2
!          Sort Key: tab1_rr.val2
!          ->  Seq Scan on public.tab1_rr
!                Output: val, val2
!                Filter: (tab1_rr.val = 7)
! (9 rows)
! 
  select distinct val2 from tab1_rr where val = 7 order by val2;
!  val2 
! ------
!     2
!     8
! (2 rows)
! 
  explain (verbose on, nodes off, costs off) select distinct val2 from tab1_rr where val = 7 order by val2;
!                   QUERY PLAN                   
! -----------------------------------------------
!  Unique
!    Output: val2
!    ->  Remote Subquery Scan on all
!          Output: val2
!          Sort Key: tab1_rr.val2
!          ->  Sort
!                Output: val2
!                Sort Key: tab1_rr.val2
!                ->  Seq Scan on public.tab1_rr
!                      Output: val2
!                      Filter: (tab1_rr.val = 7)
! (11 rows)
! 
  -- DMLs
  update tab1_rr set val2 = 1000 where val = 7; 
  explain (verbose on, nodes off, costs off) update tab1_rr set val2 = 1000 where val = 7; 
!                                    QUERY PLAN                                   
! --------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_rr.val, 1000, tab1_rr.xc_node_id, tab1_rr.ctid, tab1_rr.shardid
!    Remote query: UPDATE tab1_rr SET val2 = 1000 WHERE (val = 7)
!    ->  Update on public.tab1_rr
!          ->  Seq Scan on public.tab1_rr
!                Output: val, 1000, ctid, shardid
!                Filter: (tab1_rr.val = 7)
! (7 rows)
! 
  select * from tab1_rr where val = 7;
!  val | val2 
! -----+------
!    7 | 1000
!    7 | 1000
! (2 rows)
! 
  delete from tab1_rr where val = 7; 
  explain (verbose on, costs off) delete from tab1_rr where val = 7; 
!                          QUERY PLAN                          
! -------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_rr.xc_node_id, tab1_rr.ctid, tab1_rr.shardid
!    Node/s: datanode_1, datanode_2
!    Remote query: DELETE FROM tab1_rr WHERE (val = 7)
!    ->  Delete on public.tab1_rr
!          ->  Seq Scan on public.tab1_rr
!                Output: ctid, shardid
!                Filter: (tab1_rr.val = 7)
! (8 rows)
! 
  select * from tab1_rr where val = 7;
!  val | val2 
! -----+------
! (0 rows)
! 
  -- Testset 2 for distributed tables (by hash)
  select cr_table('tab1_hash(val int, val2 int)', '{1, 2, 3}'::int[], 'hash(val)');
!  cr_table 
! ----------
!  
! (1 row)
! 
  insert into tab1_hash values (1, 2);
  insert into tab1_hash values (2, 4);
  insert into tab1_hash values (5, 3);
  insert into tab1_hash values (7, 8);
  insert into tab1_hash values (9, 2);
  explain (verbose on, costs off) insert into tab1_hash values (9, 2);
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: 9, 2
!    Node expr: 9
!    Remote query: INSERT INTO tab1_hash (val, val2) VALUES (9, 2)
!    ->  Insert on public.tab1_hash
!          ->  Result
!                Output: 9, 2
! (7 rows)
! 
  -- simple select
  -- should get FQSed
  select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_hash where val2 = 4;
!  val | ?column? |           case            
! -----+----------+---------------------------
!    2 |        6 | val and val2 are not same
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_hash where val2 = 2;
!                                                                                      QUERY PLAN                                                                                     
! ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_hash.val, (tab1_hash.val2 + 2), CASE tab1_hash.val WHEN tab1_hash.val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
!    Remote query: SELECT val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END AS "case" FROM tab1_hash WHERE (val2 = 2)
!    ->  Seq Scan on public.tab1_hash
!          Output: val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
!          Filter: (tab1_hash.val2 = 2)
! (6 rows)
! 
  -- should not get FQSed because of aggregates
  select sum(val), avg(val), count(*) from tab1_hash;
!  sum |        avg         | count 
! -----+--------------------+-------
!   24 | 4.8000000000000000 |     5
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select sum(val), avg(val), count(*) from tab1_hash;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Finalize Aggregate
!    Output: sum(val), avg(val), count(*)
!    ->  Remote Subquery Scan on all
!          Output: PARTIAL sum(val), PARTIAL avg(val), PARTIAL count(*)
!          ->  Partial Aggregate
!                Output: PARTIAL sum(val), PARTIAL avg(val), PARTIAL count(*)
!                ->  Seq Scan on public.tab1_hash
!                      Output: val, val2
! (8 rows)
! 
  -- should not get FQSed because of window functions
  select first_value(val) over (partition by val2 order by val) from tab1_hash;
!  first_value 
! -------------
!            1
!            1
!            5
!            2
!            7
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select first_value(val) over (partition by val2 order by val) from tab1_hash;
!                       QUERY PLAN                       
! -------------------------------------------------------
!  WindowAgg
!    Output: first_value(val) OVER (?), val, val2
!    ->  Remote Subquery Scan on all
!          Output: val, val2
!          Sort Key: tab1_hash.val2, tab1_hash.val
!          ->  Sort
!                Output: val, val2
!                Sort Key: tab1_hash.val2, tab1_hash.val
!                ->  Seq Scan on public.tab1_hash
!                      Output: val, val2
! (10 rows)
! 
  -- should not get FQSed because of LIMIT clause
  select * from tab1_hash where val2 = 3 limit 1;
!  val | val2 
! -----+------
!    5 |    3
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_hash where val2 = 3 limit 1;
!                     QUERY PLAN                    
! --------------------------------------------------
!  Limit
!    Output: val, val2
!    ->  Remote Subquery Scan on all
!          Output: val, val2
!          ->  Limit
!                Output: val, val2
!                ->  Seq Scan on public.tab1_hash
!                      Output: val, val2
!                      Filter: (tab1_hash.val2 = 3)
! (9 rows)
! 
  -- should not FQSed because of OFFSET clause
  select * from tab1_hash where val2 = 4 offset 1;
!  val | val2 
! -----+------
! (0 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_hash where val2 = 4 offset 1;
!                  QUERY PLAN                 
! --------------------------------------------
!  Limit
!    Output: val, val2
!    ->  Remote Subquery Scan on all
!          Output: val, val2
!          ->  Seq Scan on public.tab1_hash
!                Output: val, val2
!                Filter: (tab1_hash.val2 = 4)
! (7 rows)
! 
  -- should not get FQSed because of SORT clause
  select * from tab1_hash order by val;
!  val | val2 
! -----+------
!    1 |    2
!    2 |    4
!    5 |    3
!    7 |    8
!    9 |    2
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_hash order by val;
!                 QUERY PLAN                
! ------------------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    Sort Key: tab1_hash.val
!    ->  Sort
!          Output: val, val2
!          Sort Key: tab1_hash.val
!          ->  Seq Scan on public.tab1_hash
!                Output: val, val2
! (8 rows)
! 
  -- should get FQSed because DISTINCT clause contains distkey
  select distinct val, val2 from tab1_hash where val2 = 8;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select distinct val, val2 from tab1_hash where val2 = 8;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_hash.val, tab1_hash.val2
!    Remote query: SELECT DISTINCT val, val2 FROM tab1_hash WHERE (val2 = 8)
!    ->  Unique
!          Output: val, val2
!          ->  Sort
!                Output: val, val2
!                Sort Key: tab1_hash.val
!                ->  Seq Scan on public.tab1_hash
!                      Output: val, val2
!                      Filter: (tab1_hash.val2 = 8)
! (11 rows)
! 
  -- should get FQSed because GROUP BY clause uses distkey
  select val, val2 from tab1_hash where val2 = 8 group by val, val2;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select val, val2 from tab1_hash where val2 = 8 group by val, val2;
!                                      QUERY PLAN                                      
! -------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_hash.val, tab1_hash.val2
!    Remote query: SELECT val, val2 FROM tab1_hash WHERE (val2 = 8) GROUP BY val, val2
!    ->  Group
!          Output: val, val2
!          Group Key: tab1_hash.val, tab1_hash.val2
!          ->  Sort
!                Output: val, val2
!                Sort Key: tab1_hash.val
!                ->  Seq Scan on public.tab1_hash
!                      Output: val, val2
!                      Filter: (tab1_hash.val2 = 8)
! (12 rows)
! 
  -- should not get FQSed because of HAVING clause
  select sum(val) from tab1_hash where val2 = 2 group by val2 having sum(val) > 1;
!  sum 
! -----
!   10
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select sum(val) from tab1_hash where val2 = 2 group by val2 having sum(val) > 1;
!                        QUERY PLAN                       
! --------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: sum(val), val2
!    ->  Finalize GroupAggregate
!          Output: sum(val), val2
!          Group Key: tab1_hash.val2
!          Filter: (sum(tab1_hash.val) > 1)
!          ->  Remote Subquery Scan on all
!                Output: val2, PARTIAL sum(val)
!                Distribute results by H: val2
!                ->  Partial GroupAggregate
!                      Output: val2, PARTIAL sum(val)
!                      Group Key: tab1_hash.val2
!                      ->  Seq Scan on public.tab1_hash
!                            Output: val, val2
!                            Filter: (tab1_hash.val2 = 2)
! (15 rows)
! 
  -- tests for node reduction by application of quals. Having query FQSed because of
  -- existence of ORDER BY, implies that nodes got reduced.
  select * from tab1_hash where val = 7;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = 7;
!                             QUERY PLAN                            
! ------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: tab1_hash.val, tab1_hash.val2
!    Remote query: SELECT val, val2 FROM tab1_hash WHERE (val = 7)
!    ->  Seq Scan on public.tab1_hash
!          Output: val, val2
!          Filter: (tab1_hash.val = 7)
! (6 rows)
! 
  select * from tab1_hash where val = 7 or val = 2 order by val;
!  val | val2 
! -----+------
!    2 |    4
!    7 |    8
! (2 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_hash where val = 7 or val = 2 order by val;
!                              QUERY PLAN                             
! --------------------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    Sort Key: tab1_hash.val
!    ->  Sort
!          Output: val, val2
!          Sort Key: tab1_hash.val
!          ->  Seq Scan on public.tab1_hash
!                Output: val, val2
!                Filter: ((tab1_hash.val = 7) OR (tab1_hash.val = 2))
! (9 rows)
! 
  select * from tab1_hash where val = 7 and val2 = 8;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = 7 and val2 = 8;
!                                     QUERY PLAN                                    
! ----------------------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: tab1_hash.val, tab1_hash.val2
!    Remote query: SELECT val, val2 FROM tab1_hash WHERE ((val = 7) AND (val2 = 8))
!    ->  Seq Scan on public.tab1_hash
!          Output: val, val2
!          Filter: ((tab1_hash.val = 7) AND (tab1_hash.val2 = 8))
! (6 rows)
! 
  select * from tab1_hash where val = 3 + 4 and val2 = 8;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = 3 + 4;
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: tab1_hash.val, tab1_hash.val2
!    Remote query: SELECT val, val2 FROM tab1_hash WHERE (val = (3 + 4))
!    ->  Seq Scan on public.tab1_hash
!          Output: val, val2
!          Filter: (tab1_hash.val = 7)
! (6 rows)
! 
  select * from tab1_hash where val = char_length('len')+4;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = char_length('len')+4;
!                                           QUERY PLAN                                          
! ----------------------------------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: tab1_hash.val, tab1_hash.val2
!    Remote query: SELECT val, val2 FROM tab1_hash WHERE (val = (char_length('len'::text) + 4))
!    ->  Seq Scan on public.tab1_hash
!          Output: val, val2
!          Filter: (tab1_hash.val = 7)
! (6 rows)
! 
  -- insert some more values 
  insert into tab1_hash values (7, 2); 
  select avg(val) from tab1_hash where val = 7;
!         avg         
! --------------------
!  7.0000000000000000
! (1 row)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select avg(val) from tab1_hash where val = 7;
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: avg(tab1_hash.val)
!    Remote query: SELECT avg(val) AS avg FROM tab1_hash WHERE (val = 7)
!    ->  Aggregate
!          Output: avg(val)
!          ->  Seq Scan on public.tab1_hash
!                Output: val, val2
!                Filter: (tab1_hash.val = 7)
! (8 rows)
! 
  select val, val2 from tab1_hash where val = 7 order by val2;
!  val | val2 
! -----+------
!    7 |    2
!    7 |    8
! (2 rows)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select val, val2 from tab1_hash where val = 7 order by val2;
!                                   QUERY PLAN                                   
! -------------------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: tab1_hash.val, tab1_hash.val2
!    Remote query: SELECT val, val2 FROM tab1_hash WHERE (val = 7) ORDER BY val2
!    ->  Sort
!          Output: val, val2
!          Sort Key: tab1_hash.val2
!          ->  Seq Scan on public.tab1_hash
!                Output: val, val2
!                Filter: (tab1_hash.val = 7)
! (9 rows)
! 
  select distinct val2 from tab1_hash where val = 7 order by val2;
!  val2 
! ------
!     2
!     8
! (2 rows)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select distinct val2 from tab1_hash where val = 7 order by val2;
!                                     QUERY PLAN                                     
! -----------------------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: tab1_hash.val2
!    Remote query: SELECT DISTINCT val2 FROM tab1_hash WHERE (val = 7) ORDER BY val2
!    ->  Unique
!          Output: val2
!          ->  Sort
!                Output: val2
!                Sort Key: tab1_hash.val2
!                ->  Seq Scan on public.tab1_hash
!                      Output: val2
!                      Filter: (tab1_hash.val = 7)
! (11 rows)
! 
  -- DMLs
  update tab1_hash set val2 = 1000 where val = 7; 
  explain (verbose on, nodes off, costs off) update tab1_hash set val2 = 1000 where val = 7; 
!                                        QUERY PLAN                                       
! ----------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_hash.val, 1000, tab1_hash.xc_node_id, tab1_hash.ctid, tab1_hash.shardid
!    Remote query: UPDATE tab1_hash SET val2 = 1000 WHERE (val = 7)
!    ->  Update on public.tab1_hash
!          ->  Seq Scan on public.tab1_hash
!                Output: val, 1000, ctid, shardid
!                Filter: (tab1_hash.val = 7)
! (7 rows)
! 
  select * from tab1_hash where val = 7;
!  val | val2 
! -----+------
!    7 | 1000
!    7 | 1000
! (2 rows)
! 
  delete from tab1_hash where val = 7; 
  explain (verbose on, costs off) delete from tab1_hash where val = 7; 
!                                     QUERY PLAN                                    
! ----------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_hash.xc_node_id, tab1_hash.ctid, tab1_hash.shardid, tab1_hash.val
!    Node/s: datanode_2
!    Remote query: DELETE FROM tab1_hash WHERE (val = 7)
!    ->  Delete on public.tab1_hash
!          ->  Seq Scan on public.tab1_hash
!                Output: ctid, shardid
!                Filter: (tab1_hash.val = 7)
! (8 rows)
! 
  select * from tab1_hash where val = 7;
!  val | val2 
! -----+------
! (0 rows)
! 
  -- Testset 3 for distributed tables (by modulo)
  select cr_table('tab1_modulo(val int, val2 int)', '{1, 2, 3}'::int[], 'modulo(val)');
!  cr_table 
! ----------
!  
! (1 row)
! 
  insert into tab1_modulo values (1, 2);
  insert into tab1_modulo values (2, 4);
  insert into tab1_modulo values (5, 3);
  insert into tab1_modulo values (7, 8);
  insert into tab1_modulo values (9, 2);
  explain (verbose on, costs off) insert into tab1_modulo values (9, 2);
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: 9, 2
!    Node expr: 9
!    Remote query: INSERT INTO tab1_modulo (val, val2) VALUES (9, 2)
!    ->  Insert on public.tab1_modulo
!          ->  Result
!                Output: 9, 2
! (7 rows)
! 
  -- simple select
  -- should get FQSed
  select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_modulo where val2 = 4;
!  val | ?column? |           case            
! -----+----------+---------------------------
!    2 |        6 | val and val2 are not same
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_modulo where val2 = 4;
!                                                                                       QUERY PLAN                                                                                      
! --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_modulo.val, (tab1_modulo.val2 + 2), CASE tab1_modulo.val WHEN tab1_modulo.val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
!    Remote query: SELECT val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END AS "case" FROM tab1_modulo WHERE (val2 = 4)
!    ->  Seq Scan on public.tab1_modulo
!          Output: val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END
!          Filter: (tab1_modulo.val2 = 4)
! (6 rows)
! 
  -- should not get FQSed because of aggregates
  select sum(val), avg(val), count(*) from tab1_modulo;
!  sum |        avg         | count 
! -----+--------------------+-------
!   24 | 4.8000000000000000 |     5
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select sum(val), avg(val), count(*) from tab1_modulo;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Finalize Aggregate
!    Output: sum(val), avg(val), count(*)
!    ->  Remote Subquery Scan on all
!          Output: PARTIAL sum(val), PARTIAL avg(val), PARTIAL count(*)
!          ->  Partial Aggregate
!                Output: PARTIAL sum(val), PARTIAL avg(val), PARTIAL count(*)
!                ->  Seq Scan on public.tab1_modulo
!                      Output: val, val2
! (8 rows)
! 
  -- should not get FQSed because of window functions
  select first_value(val) over (partition by val2 order by val) from tab1_modulo;
!  first_value 
! -------------
!            1
!            1
!            5
!            2
!            7
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select first_value(val) over (partition by val2 order by val) from tab1_modulo;
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  WindowAgg
!    Output: first_value(val) OVER (?), val, val2
!    ->  Remote Subquery Scan on all
!          Output: val, val2
!          Sort Key: tab1_modulo.val2, tab1_modulo.val
!          ->  Sort
!                Output: val, val2
!                Sort Key: tab1_modulo.val2, tab1_modulo.val
!                ->  Seq Scan on public.tab1_modulo
!                      Output: val, val2
! (10 rows)
! 
  -- should not get FQSed because of LIMIT clause
  select * from tab1_modulo where val2 = 3 limit 1;
!  val | val2 
! -----+------
!    5 |    3
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_modulo where val2 = 3 limit 1;
!                      QUERY PLAN                     
! ----------------------------------------------------
!  Limit
!    Output: val, val2
!    ->  Remote Subquery Scan on all
!          Output: val, val2
!          ->  Limit
!                Output: val, val2
!                ->  Seq Scan on public.tab1_modulo
!                      Output: val, val2
!                      Filter: (tab1_modulo.val2 = 3)
! (9 rows)
! 
  -- should not FQSed because of OFFSET clause
  select * from tab1_modulo where val2 = 4 offset 1;
!  val | val2 
! -----+------
! (0 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_modulo where val2 = 4 offset 1;
!                   QUERY PLAN                  
! ----------------------------------------------
!  Limit
!    Output: val, val2
!    ->  Remote Subquery Scan on all
!          Output: val, val2
!          ->  Seq Scan on public.tab1_modulo
!                Output: val, val2
!                Filter: (tab1_modulo.val2 = 4)
! (7 rows)
! 
  -- should not get FQSed because of SORT clause
  select * from tab1_modulo order by val;
!  val | val2 
! -----+------
!    1 |    2
!    2 |    4
!    5 |    3
!    7 |    8
!    9 |    2
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_modulo order by val;
!                  QUERY PLAN                 
! --------------------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    Sort Key: tab1_modulo.val
!    ->  Sort
!          Output: val, val2
!          Sort Key: tab1_modulo.val
!          ->  Seq Scan on public.tab1_modulo
!                Output: val, val2
! (8 rows)
! 
  -- should get FQSed because DISTINCT clause contains distkey
  select distinct val, val2 from tab1_modulo where val2 = 8;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select distinct val, val2 from tab1_modulo where val2 = 8;
!                                  QUERY PLAN                                  
! -----------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_modulo.val, tab1_modulo.val2
!    Remote query: SELECT DISTINCT val, val2 FROM tab1_modulo WHERE (val2 = 8)
!    ->  Unique
!          Output: val, val2
!          ->  Sort
!                Output: val, val2
!                Sort Key: tab1_modulo.val
!                ->  Seq Scan on public.tab1_modulo
!                      Output: val, val2
!                      Filter: (tab1_modulo.val2 = 8)
! (11 rows)
! 
  -- should get FQSed because GROUP BY clause uses distkey
  select val, val2 from tab1_modulo where val2 = 8 group by val, val2;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select val, val2 from tab1_modulo where val2 = 8 group by val, val2;
!                                       QUERY PLAN                                       
! ---------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_modulo.val, tab1_modulo.val2
!    Remote query: SELECT val, val2 FROM tab1_modulo WHERE (val2 = 8) GROUP BY val, val2
!    ->  Group
!          Output: val, val2
!          Group Key: tab1_modulo.val, tab1_modulo.val2
!          ->  Sort
!                Output: val, val2
!                Sort Key: tab1_modulo.val
!                ->  Seq Scan on public.tab1_modulo
!                      Output: val, val2
!                      Filter: (tab1_modulo.val2 = 8)
! (12 rows)
! 
  -- should not get FQSed because of HAVING clause
  select sum(val) from tab1_modulo where val2 = 2 group by val2 having sum(val) > 1;
!  sum 
! -----
!   10
! (1 row)
! 
  explain (verbose on, nodes off, costs off) select sum(val) from tab1_modulo where val2 = 2 group by val2 having sum(val) > 1;
!                         QUERY PLAN                        
! ----------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: sum(val), val2
!    ->  Finalize GroupAggregate
!          Output: sum(val), val2
!          Group Key: tab1_modulo.val2
!          Filter: (sum(tab1_modulo.val) > 1)
!          ->  Remote Subquery Scan on all
!                Output: val2, PARTIAL sum(val)
!                Distribute results by H: val2
!                ->  Partial GroupAggregate
!                      Output: val2, PARTIAL sum(val)
!                      Group Key: tab1_modulo.val2
!                      ->  Seq Scan on public.tab1_modulo
!                            Output: val, val2
!                            Filter: (tab1_modulo.val2 = 2)
! (15 rows)
! 
  -- tests for node reduction by application of quals. Having query FQSed because of
  -- existence of ORDER BY, implies that nodes got reduced.
  select * from tab1_modulo where val = 7;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = 7;
!                             QUERY PLAN                             
! -------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: tab1_modulo.val, tab1_modulo.val2
!    Remote query: SELECT val, val2 FROM tab1_modulo WHERE (val = 7)
!    ->  Seq Scan on public.tab1_modulo
!          Output: val, val2
!          Filter: (tab1_modulo.val = 7)
! (6 rows)
! 
  select * from tab1_modulo where val = 7 or val = 2 order by val;
!  val | val2 
! -----+------
!    2 |    4
!    7 |    8
! (2 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_modulo where val = 7 or val = 2 order by val;
!                                QUERY PLAN                               
! ------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    Sort Key: tab1_modulo.val
!    ->  Sort
!          Output: val, val2
!          Sort Key: tab1_modulo.val
!          ->  Seq Scan on public.tab1_modulo
!                Output: val, val2
!                Filter: ((tab1_modulo.val = 7) OR (tab1_modulo.val = 2))
! (9 rows)
! 
  select * from tab1_modulo where val = 7 and val2 = 8;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = 7 and val2 = 8;
!                                      QUERY PLAN                                     
! ------------------------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: tab1_modulo.val, tab1_modulo.val2
!    Remote query: SELECT val, val2 FROM tab1_modulo WHERE ((val = 7) AND (val2 = 8))
!    ->  Seq Scan on public.tab1_modulo
!          Output: val, val2
!          Filter: ((tab1_modulo.val = 7) AND (tab1_modulo.val2 = 8))
! (6 rows)
! 
  select * from tab1_modulo where val = 3 + 4 and val2 = 8;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = 3 + 4;
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: tab1_modulo.val, tab1_modulo.val2
!    Remote query: SELECT val, val2 FROM tab1_modulo WHERE (val = (3 + 4))
!    ->  Seq Scan on public.tab1_modulo
!          Output: val, val2
!          Filter: (tab1_modulo.val = 7)
! (6 rows)
! 
  select * from tab1_modulo where val = char_length('len')+4;
!  val | val2 
! -----+------
!    7 |    8
! (1 row)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = char_length('len')+4;
!                                            QUERY PLAN                                           
! ------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution (primary node count=0, node count=1)
!    Output: tab1_modulo.val, tab1_modulo.val2
!    Remote query: SELECT val, val2 FROM tab1_modulo WHERE (val = (char_length('len'::text) + 4))
!    ->  Seq Scan on public.tab1_modulo
!          Output: val, val2
!          Filter: (tab1_modulo.val = 7)
! (6 rows)
! 
  -- insert some more values 
  insert into tab1_modulo values (7, 2); 
  select avg(val) from tab1_modulo where val = 7;
!         avg         
! --------------------
!  7.0000000000000000
! (1 row)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select avg(val) from tab1_modulo where val = 7;
!                     QUERY PLAN                     
! ---------------------------------------------------
!  Finalize Aggregate
!    Output: avg(val)
!    ->  Remote Subquery Scan on all
!          Output: PARTIAL avg(val)
!          ->  Partial Aggregate
!                Output: PARTIAL avg(val)
!                ->  Seq Scan on public.tab1_modulo
!                      Output: val, val2
!                      Filter: (tab1_modulo.val = 7)
! (9 rows)
! 
  select val, val2 from tab1_modulo where val = 7 order by val2;
!  val | val2 
! -----+------
!    7 |    2
!    7 |    8
! (2 rows)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select val, val2 from tab1_modulo where val = 7 order by val2;
!                  QUERY PLAN                  
! ---------------------------------------------
!  Remote Subquery Scan on all
!    Output: val, val2
!    ->  Sort
!          Output: val, val2
!          Sort Key: tab1_modulo.val2
!          ->  Seq Scan on public.tab1_modulo
!                Output: val, val2
!                Filter: (tab1_modulo.val = 7)
! (8 rows)
! 
  select distinct val2 from tab1_modulo where val = 7;
!  val2 
! ------
!     2
!     8
! (2 rows)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select distinct val2 from tab1_modulo where val = 7;
!                     QUERY PLAN                     
! ---------------------------------------------------
!  Unique
!    Output: val2
!    ->  Remote Subquery Scan on all
!          Output: val2
!          ->  Sort
!                Output: val2
!                Sort Key: tab1_modulo.val2
!                ->  Seq Scan on public.tab1_modulo
!                      Output: val2
!                      Filter: (tab1_modulo.val = 7)
! (10 rows)
! 
  -- DMLs
  update tab1_modulo set val2 = 1000 where val = 7; 
  explain (verbose on, nodes off, costs off) update tab1_modulo set val2 = 1000 where val = 7; 
!                                            QUERY PLAN                                           
! ------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_modulo.val, 1000, tab1_modulo.xc_node_id, tab1_modulo.ctid, tab1_modulo.shardid
!    Remote query: UPDATE tab1_modulo SET val2 = 1000 WHERE (val = 7)
!    ->  Update on public.tab1_modulo
!          ->  Seq Scan on public.tab1_modulo
!                Output: val, 1000, ctid, shardid
!                Filter: (tab1_modulo.val = 7)
! (7 rows)
! 
  select * from tab1_modulo where val = 7;
!  val | val2 
! -----+------
!    7 | 1000
!    7 | 1000
! (2 rows)
! 
  delete from tab1_modulo where val = 7; 
  explain (verbose on, costs off) delete from tab1_modulo where val = 7; 
!                                         QUERY PLAN                                        
! ------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_modulo.xc_node_id, tab1_modulo.ctid, tab1_modulo.shardid, tab1_modulo.val
!    Node/s: datanode_2
!    Remote query: DELETE FROM tab1_modulo WHERE (val = 7)
!    ->  Delete on public.tab1_modulo
!          ->  Seq Scan on public.tab1_modulo
!                Output: ctid, shardid
!                Filter: (tab1_modulo.val = 7)
! (8 rows)
! 
  select * from tab1_modulo where val = 7;
!  val | val2 
! -----+------
! (0 rows)
! 
  -- Testset 4 for replicated tables, for replicated tables, unless the expression
  -- is itself unshippable, any query involving a single replicated table is shippable
  select cr_table('tab1_replicated(val int, val2 int)', '{1, 2, 3}'::int[], 'replication');
--- 41,666 ----
  -- a single table
  -- Testset 1 for distributed table (by roundrobin)
  select create_table_nodes('tab1_rr(val int, val2 int)', '{1, 2, 3}'::int[], 'roundrobin', NULL);
! ERROR:  Cannot support distribute type: RoundRobin
! CONTEXT:  SQL statement "CREATE TABLE tab1_rr(val int, val2 int) DISTRIBUTE BY roundrobin TO NODE (datanode_1, datanode_2, datanode_1)"
! PL/pgSQL function create_table_nodes(character varying,integer[],character varying,character varying) line 37 at EXECUTE
  insert into tab1_rr values (1, 2);
+ ERROR:  relation "tab1_rr" does not exist
+ LINE 1: insert into tab1_rr values (1, 2);
+                     ^
  insert into tab1_rr values (2, 4);
+ ERROR:  relation "tab1_rr" does not exist
+ LINE 1: insert into tab1_rr values (2, 4);
+                     ^
  insert into tab1_rr values (5, 3);
+ ERROR:  relation "tab1_rr" does not exist
+ LINE 1: insert into tab1_rr values (5, 3);
+                     ^
  insert into tab1_rr values (7, 8);
+ ERROR:  relation "tab1_rr" does not exist
+ LINE 1: insert into tab1_rr values (7, 8);
+                     ^
  insert into tab1_rr values (9, 2);
+ ERROR:  relation "tab1_rr" does not exist
+ LINE 1: insert into tab1_rr values (9, 2);
+                     ^
  explain (verbose on, nodes off, num_nodes on, costs off) insert into tab1_rr values (9, 2);
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ..., nodes off, num_nodes on, costs off) insert into tab1_rr va...
!                                                              ^
  -- simple select
  -- should get FQSed
  select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_rr where val2 = 4;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ...e same' else 'val and val2 are not same' end from tab1_rr wh...
!                                                              ^
  explain (verbose on, nodes off, costs off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_rr where val2 = 4;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ...e same' else 'val and val2 are not same' end from tab1_rr wh...
!                                                              ^
  -- should not get FQSed because of aggregates
  select sum(val), avg(val), count(*) from tab1_rr;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select sum(val), avg(val), count(*) from tab1_rr;
!                                                  ^
  explain (verbose on, nodes off, costs off) select sum(val), avg(val), count(*) from tab1_rr;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ...costs off) select sum(val), avg(val), count(*) from tab1_rr;
!                                                                ^
  -- should not get FQSed because of window functions
  select first_value(val) over (partition by val2 order by val) from tab1_rr;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ...lue(val) over (partition by val2 order by val) from tab1_rr;
!                                                                ^
  explain (verbose on, nodes off, costs off) select first_value(val) over (partition by val2 order by val) from tab1_rr;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ...lue(val) over (partition by val2 order by val) from tab1_rr;
!                                                                ^
  -- should not get FQSed because of LIMIT clause
  select * from tab1_rr where val2 = 3 limit 1;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select * from tab1_rr where val2 = 3 limit 1;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val2 = 3 limit 1;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_rr wh...
!                                                              ^
  -- should not FQSed because of OFFSET clause
  select * from tab1_rr where val2 = 4 offset 1;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select * from tab1_rr where val2 = 4 offset 1;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val2 = 4 offset 1;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_rr wh...
!                                                              ^
  -- should not get FQSed because of SORT clause
  select * from tab1_rr order by val;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select * from tab1_rr order by val;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_rr order by val;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_rr or...
!                                                              ^
  -- should not get FQSed because of DISTINCT clause
  select distinct val, val2 from tab1_rr where val2 = 8;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select distinct val, val2 from tab1_rr where val2 = 8;
!                                        ^
  explain (verbose on, nodes off, costs off) select distinct val, val2 from tab1_rr where val2 = 8;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ...es off, costs off) select distinct val, val2 from tab1_rr wh...
!                                                              ^
  -- should not get FQSed because of GROUP clause
  select val, val2 from tab1_rr where val2 = 8 group by val, val2;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select val, val2 from tab1_rr where val2 = 8 group by val, v...
!                               ^
  explain (verbose on, nodes off, costs off) select val, val2 from tab1_rr where val2 = 8 group by val, val2;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ...e on, nodes off, costs off) select val, val2 from tab1_rr wh...
!                                                              ^
  -- should not get FQSed because of HAVING clause
  select sum(val) from tab1_rr where val2 = 2 group by val2 having sum(val) > 1;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select sum(val) from tab1_rr where val2 = 2 group by val2 ha...
!                              ^
  explain (verbose on, nodes off, costs off) select sum(val) from tab1_rr where val2 = 2 group by val2 having sum(val) > 1;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ...se on, nodes off, costs off) select sum(val) from tab1_rr wh...
!                                                              ^
  -- tests for node reduction by application of quals, for roundrobin node
  -- reduction is not applicable. Having query not FQSed because of existence of ORDER BY,
  -- implies that nodes did not get reduced.
  select * from tab1_rr where val = 7;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select * from tab1_rr where val = 7;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 7;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_rr wh...
!                                                              ^
  select * from tab1_rr where val = 7 or val = 2 order by val;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select * from tab1_rr where val = 7 or val = 2 order by val;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 7 or val = 2 order by val;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_rr wh...
!                                                              ^
  select * from tab1_rr where val = 7 and val2 = 8;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select * from tab1_rr where val = 7 and val2 = 8;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 7 and val2 = 8 order by val;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_rr wh...
!                                                              ^
  select * from tab1_rr where val = 3 + 4 and val2 = 8 order by val;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select * from tab1_rr where val = 3 + 4 and val2 = 8 order b...
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val = 3 + 4 order by val;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_rr wh...
!                                                              ^
  select * from tab1_rr where val = char_length('len')+4 order by val;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select * from tab1_rr where val = char_length('len')+4 order...
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_rr where val = char_length('len')+4 order by val;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_rr wh...
!                                                              ^
  -- insert some more values 
  insert into tab1_rr values (7, 2); 
+ ERROR:  relation "tab1_rr" does not exist
+ LINE 1: insert into tab1_rr values (7, 2);
+                     ^
  select avg(val) from tab1_rr where val = 7;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select avg(val) from tab1_rr where val = 7;
!                              ^
  explain (verbose on, nodes off, costs off) select avg(val) from tab1_rr where val = 7;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ...se on, nodes off, costs off) select avg(val) from tab1_rr wh...
!                                                              ^
  select val, val2 from tab1_rr where val = 7 order by val2;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select val, val2 from tab1_rr where val = 7 order by val2;
!                               ^
  explain (verbose on, nodes off, costs off) select val, val2 from tab1_rr where val = 7 order by val2;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ...e on, nodes off, costs off) select val, val2 from tab1_rr wh...
!                                                              ^
  select distinct val2 from tab1_rr where val = 7 order by val2;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select distinct val2 from tab1_rr where val = 7 order by val...
!                                   ^
  explain (verbose on, nodes off, costs off) select distinct val2 from tab1_rr where val = 7 order by val2;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: ..., nodes off, costs off) select distinct val2 from tab1_rr wh...
!                                                              ^
  -- DMLs
  update tab1_rr set val2 = 1000 where val = 7; 
+ ERROR:  relation "tab1_rr" does not exist
+ LINE 1: update tab1_rr set val2 = 1000 where val = 7;
+                ^
  explain (verbose on, nodes off, costs off) update tab1_rr set val2 = 1000 where val = 7; 
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: explain (verbose on, nodes off, costs off) update tab1_rr se...
!                                                           ^
  select * from tab1_rr where val = 7;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select * from tab1_rr where val = 7;
!                       ^
  delete from tab1_rr where val = 7; 
+ ERROR:  relation "tab1_rr" does not exist
+ LINE 1: delete from tab1_rr where val = 7;
+                     ^
  explain (verbose on, costs off) delete from tab1_rr where val = 7; 
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: explain (verbose on, costs off) delete from tab1_rr where va...
!                                                     ^
  select * from tab1_rr where val = 7;
! ERROR:  relation "tab1_rr" does not exist
! LINE 1: select * from tab1_rr where val = 7;
!                       ^
  -- Testset 2 for distributed tables (by hash)
  select cr_table('tab1_hash(val int, val2 int)', '{1, 2, 3}'::int[], 'hash(val)');
! ERROR:  Cannot support distribute type: Hash
! CONTEXT:  SQL statement "CREATE TABLE tab1_hash(val int, val2 int) DISTRIBUTE BY hash(val) TO NODE (datanode_1, datanode_2, datanode_1)"
! PL/pgSQL function cr_table(character varying,integer[],character varying) line 35 at EXECUTE
  insert into tab1_hash values (1, 2);
+ ERROR:  relation "tab1_hash" does not exist
+ LINE 1: insert into tab1_hash values (1, 2);
+                     ^
  insert into tab1_hash values (2, 4);
+ ERROR:  relation "tab1_hash" does not exist
+ LINE 1: insert into tab1_hash values (2, 4);
+                     ^
  insert into tab1_hash values (5, 3);
+ ERROR:  relation "tab1_hash" does not exist
+ LINE 1: insert into tab1_hash values (5, 3);
+                     ^
  insert into tab1_hash values (7, 8);
+ ERROR:  relation "tab1_hash" does not exist
+ LINE 1: insert into tab1_hash values (7, 8);
+                     ^
  insert into tab1_hash values (9, 2);
+ ERROR:  relation "tab1_hash" does not exist
+ LINE 1: insert into tab1_hash values (9, 2);
+                     ^
  explain (verbose on, costs off) insert into tab1_hash values (9, 2);
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: explain (verbose on, costs off) insert into tab1_hash values...
!                                                     ^
  -- simple select
  -- should get FQSed
  select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_hash where val2 = 4;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...e same' else 'val and val2 are not same' end from tab1_hash ...
!                                                              ^
  explain (verbose on, nodes off, costs off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_hash where val2 = 2;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...e same' else 'val and val2 are not same' end from tab1_hash ...
!                                                              ^
  -- should not get FQSed because of aggregates
  select sum(val), avg(val), count(*) from tab1_hash;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select sum(val), avg(val), count(*) from tab1_hash;
!                                                  ^
  explain (verbose on, nodes off, costs off) select sum(val), avg(val), count(*) from tab1_hash;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...sts off) select sum(val), avg(val), count(*) from tab1_hash;
!                                                              ^
  -- should not get FQSed because of window functions
  select first_value(val) over (partition by val2 order by val) from tab1_hash;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...e(val) over (partition by val2 order by val) from tab1_hash;
!                                                              ^
  explain (verbose on, nodes off, costs off) select first_value(val) over (partition by val2 order by val) from tab1_hash;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...e(val) over (partition by val2 order by val) from tab1_hash;
!                                                              ^
  -- should not get FQSed because of LIMIT clause
  select * from tab1_hash where val2 = 3 limit 1;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select * from tab1_hash where val2 = 3 limit 1;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_hash where val2 = 3 limit 1;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_hash ...
!                                                              ^
  -- should not FQSed because of OFFSET clause
  select * from tab1_hash where val2 = 4 offset 1;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select * from tab1_hash where val2 = 4 offset 1;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_hash where val2 = 4 offset 1;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_hash ...
!                                                              ^
  -- should not get FQSed because of SORT clause
  select * from tab1_hash order by val;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select * from tab1_hash order by val;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_hash order by val;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_hash ...
!                                                              ^
  -- should get FQSed because DISTINCT clause contains distkey
  select distinct val, val2 from tab1_hash where val2 = 8;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select distinct val, val2 from tab1_hash where val2 = 8;
!                                        ^
  explain (verbose on, nodes off, costs off) select distinct val, val2 from tab1_hash where val2 = 8;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...es off, costs off) select distinct val, val2 from tab1_hash ...
!                                                              ^
  -- should get FQSed because GROUP BY clause uses distkey
  select val, val2 from tab1_hash where val2 = 8 group by val, val2;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select val, val2 from tab1_hash where val2 = 8 group by val,...
!                               ^
  explain (verbose on, nodes off, costs off) select val, val2 from tab1_hash where val2 = 8 group by val, val2;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...e on, nodes off, costs off) select val, val2 from tab1_hash ...
!                                                              ^
  -- should not get FQSed because of HAVING clause
  select sum(val) from tab1_hash where val2 = 2 group by val2 having sum(val) > 1;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select sum(val) from tab1_hash where val2 = 2 group by val2 ...
!                              ^
  explain (verbose on, nodes off, costs off) select sum(val) from tab1_hash where val2 = 2 group by val2 having sum(val) > 1;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...se on, nodes off, costs off) select sum(val) from tab1_hash ...
!                                                              ^
  -- tests for node reduction by application of quals. Having query FQSed because of
  -- existence of ORDER BY, implies that nodes got reduced.
  select * from tab1_hash where val = 7;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select * from tab1_hash where val = 7;
!                       ^
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = 7;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...nodes off, costs off, num_nodes on) select * from tab1_hash ...
!                                                              ^
  select * from tab1_hash where val = 7 or val = 2 order by val;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select * from tab1_hash where val = 7 or val = 2 order by va...
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_hash where val = 7 or val = 2 order by val;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_hash ...
!                                                              ^
  select * from tab1_hash where val = 7 and val2 = 8;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select * from tab1_hash where val = 7 and val2 = 8;
!                       ^
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = 7 and val2 = 8;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...nodes off, costs off, num_nodes on) select * from tab1_hash ...
!                                                              ^
  select * from tab1_hash where val = 3 + 4 and val2 = 8;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select * from tab1_hash where val = 3 + 4 and val2 = 8;
!                       ^
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = 3 + 4;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...nodes off, costs off, num_nodes on) select * from tab1_hash ...
!                                                              ^
  select * from tab1_hash where val = char_length('len')+4;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select * from tab1_hash where val = char_length('len')+4;
!                       ^
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_hash where val = char_length('len')+4;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...nodes off, costs off, num_nodes on) select * from tab1_hash ...
!                                                              ^
  -- insert some more values 
  insert into tab1_hash values (7, 2); 
+ ERROR:  relation "tab1_hash" does not exist
+ LINE 1: insert into tab1_hash values (7, 2);
+                     ^
  select avg(val) from tab1_hash where val = 7;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select avg(val) from tab1_hash where val = 7;
!                              ^
  explain (verbose on, nodes off, costs off, num_nodes on) select avg(val) from tab1_hash where val = 7;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...ff, costs off, num_nodes on) select avg(val) from tab1_hash ...
!                                                              ^
  select val, val2 from tab1_hash where val = 7 order by val2;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select val, val2 from tab1_hash where val = 7 order by val2;
!                               ^
  explain (verbose on, nodes off, costs off, num_nodes on) select val, val2 from tab1_hash where val = 7 order by val2;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...f, costs off, num_nodes on) select val, val2 from tab1_hash ...
!                                                              ^
  select distinct val2 from tab1_hash where val = 7 order by val2;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select distinct val2 from tab1_hash where val = 7 order by v...
!                                   ^
  explain (verbose on, nodes off, costs off, num_nodes on) select distinct val2 from tab1_hash where val = 7 order by val2;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: ...osts off, num_nodes on) select distinct val2 from tab1_hash ...
!                                                              ^
  -- DMLs
  update tab1_hash set val2 = 1000 where val = 7; 
+ ERROR:  relation "tab1_hash" does not exist
+ LINE 1: update tab1_hash set val2 = 1000 where val = 7;
+                ^
  explain (verbose on, nodes off, costs off) update tab1_hash set val2 = 1000 where val = 7; 
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: explain (verbose on, nodes off, costs off) update tab1_hash ...
!                                                           ^
  select * from tab1_hash where val = 7;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select * from tab1_hash where val = 7;
!                       ^
  delete from tab1_hash where val = 7; 
+ ERROR:  relation "tab1_hash" does not exist
+ LINE 1: delete from tab1_hash where val = 7;
+                     ^
  explain (verbose on, costs off) delete from tab1_hash where val = 7; 
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: explain (verbose on, costs off) delete from tab1_hash where ...
!                                                     ^
  select * from tab1_hash where val = 7;
! ERROR:  relation "tab1_hash" does not exist
! LINE 1: select * from tab1_hash where val = 7;
!                       ^
  -- Testset 3 for distributed tables (by modulo)
  select cr_table('tab1_modulo(val int, val2 int)', '{1, 2, 3}'::int[], 'modulo(val)');
! ERROR:  Cannot support distribute type: Hash
! CONTEXT:  SQL statement "CREATE TABLE tab1_modulo(val int, val2 int) DISTRIBUTE BY modulo(val) TO NODE (datanode_1, datanode_2, datanode_1)"
! PL/pgSQL function cr_table(character varying,integer[],character varying) line 35 at EXECUTE
  insert into tab1_modulo values (1, 2);
+ ERROR:  relation "tab1_modulo" does not exist
+ LINE 1: insert into tab1_modulo values (1, 2);
+                     ^
  insert into tab1_modulo values (2, 4);
+ ERROR:  relation "tab1_modulo" does not exist
+ LINE 1: insert into tab1_modulo values (2, 4);
+                     ^
  insert into tab1_modulo values (5, 3);
+ ERROR:  relation "tab1_modulo" does not exist
+ LINE 1: insert into tab1_modulo values (5, 3);
+                     ^
  insert into tab1_modulo values (7, 8);
+ ERROR:  relation "tab1_modulo" does not exist
+ LINE 1: insert into tab1_modulo values (7, 8);
+                     ^
  insert into tab1_modulo values (9, 2);
+ ERROR:  relation "tab1_modulo" does not exist
+ LINE 1: insert into tab1_modulo values (9, 2);
+                     ^
  explain (verbose on, costs off) insert into tab1_modulo values (9, 2);
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: explain (verbose on, costs off) insert into tab1_modulo valu...
!                                                     ^
  -- simple select
  -- should get FQSed
  select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_modulo where val2 = 4;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...e same' else 'val and val2 are not same' end from tab1_modul...
!                                                              ^
  explain (verbose on, nodes off, costs off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_modulo where val2 = 4;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...e same' else 'val and val2 are not same' end from tab1_modul...
!                                                              ^
  -- should not get FQSed because of aggregates
  select sum(val), avg(val), count(*) from tab1_modulo;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select sum(val), avg(val), count(*) from tab1_modulo;
!                                                  ^
  explain (verbose on, nodes off, costs off) select sum(val), avg(val), count(*) from tab1_modulo;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...sts off) select sum(val), avg(val), count(*) from tab1_modul...
!                                                              ^
  -- should not get FQSed because of window functions
  select first_value(val) over (partition by val2 order by val) from tab1_modulo;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...e(val) over (partition by val2 order by val) from tab1_modul...
!                                                              ^
  explain (verbose on, nodes off, costs off) select first_value(val) over (partition by val2 order by val) from tab1_modulo;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...e(val) over (partition by val2 order by val) from tab1_modul...
!                                                              ^
  -- should not get FQSed because of LIMIT clause
  select * from tab1_modulo where val2 = 3 limit 1;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select * from tab1_modulo where val2 = 3 limit 1;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_modulo where val2 = 3 limit 1;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_modul...
!                                                              ^
  -- should not FQSed because of OFFSET clause
  select * from tab1_modulo where val2 = 4 offset 1;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select * from tab1_modulo where val2 = 4 offset 1;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_modulo where val2 = 4 offset 1;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_modul...
!                                                              ^
  -- should not get FQSed because of SORT clause
  select * from tab1_modulo order by val;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select * from tab1_modulo order by val;
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_modulo order by val;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_modul...
!                                                              ^
  -- should get FQSed because DISTINCT clause contains distkey
  select distinct val, val2 from tab1_modulo where val2 = 8;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select distinct val, val2 from tab1_modulo where val2 = 8;
!                                        ^
  explain (verbose on, nodes off, costs off) select distinct val, val2 from tab1_modulo where val2 = 8;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...es off, costs off) select distinct val, val2 from tab1_modul...
!                                                              ^
  -- should get FQSed because GROUP BY clause uses distkey
  select val, val2 from tab1_modulo where val2 = 8 group by val, val2;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select val, val2 from tab1_modulo where val2 = 8 group by va...
!                               ^
  explain (verbose on, nodes off, costs off) select val, val2 from tab1_modulo where val2 = 8 group by val, val2;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...e on, nodes off, costs off) select val, val2 from tab1_modul...
!                                                              ^
  -- should not get FQSed because of HAVING clause
  select sum(val) from tab1_modulo where val2 = 2 group by val2 having sum(val) > 1;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select sum(val) from tab1_modulo where val2 = 2 group by val...
!                              ^
  explain (verbose on, nodes off, costs off) select sum(val) from tab1_modulo where val2 = 2 group by val2 having sum(val) > 1;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...se on, nodes off, costs off) select sum(val) from tab1_modul...
!                                                              ^
  -- tests for node reduction by application of quals. Having query FQSed because of
  -- existence of ORDER BY, implies that nodes got reduced.
  select * from tab1_modulo where val = 7;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select * from tab1_modulo where val = 7;
!                       ^
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = 7;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...nodes off, costs off, num_nodes on) select * from tab1_modul...
!                                                              ^
  select * from tab1_modulo where val = 7 or val = 2 order by val;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select * from tab1_modulo where val = 7 or val = 2 order by ...
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_modulo where val = 7 or val = 2 order by val;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_modul...
!                                                              ^
  select * from tab1_modulo where val = 7 and val2 = 8;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select * from tab1_modulo where val = 7 and val2 = 8;
!                       ^
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = 7 and val2 = 8;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...nodes off, costs off, num_nodes on) select * from tab1_modul...
!                                                              ^
  select * from tab1_modulo where val = 3 + 4 and val2 = 8;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select * from tab1_modulo where val = 3 + 4 and val2 = 8;
!                       ^
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = 3 + 4;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...nodes off, costs off, num_nodes on) select * from tab1_modul...
!                                                              ^
  select * from tab1_modulo where val = char_length('len')+4;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select * from tab1_modulo where val = char_length('len')+4;
!                       ^
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_modulo where val = char_length('len')+4;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...nodes off, costs off, num_nodes on) select * from tab1_modul...
!                                                              ^
  -- insert some more values 
  insert into tab1_modulo values (7, 2); 
+ ERROR:  relation "tab1_modulo" does not exist
+ LINE 1: insert into tab1_modulo values (7, 2);
+                     ^
  select avg(val) from tab1_modulo where val = 7;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select avg(val) from tab1_modulo where val = 7;
!                              ^
  explain (verbose on, nodes off, costs off, num_nodes on) select avg(val) from tab1_modulo where val = 7;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...ff, costs off, num_nodes on) select avg(val) from tab1_modul...
!                                                              ^
  select val, val2 from tab1_modulo where val = 7 order by val2;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select val, val2 from tab1_modulo where val = 7 order by val...
!                               ^
  explain (verbose on, nodes off, costs off, num_nodes on) select val, val2 from tab1_modulo where val = 7 order by val2;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...f, costs off, num_nodes on) select val, val2 from tab1_modul...
!                                                              ^
  select distinct val2 from tab1_modulo where val = 7;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select distinct val2 from tab1_modulo where val = 7;
!                                   ^
  explain (verbose on, nodes off, costs off, num_nodes on) select distinct val2 from tab1_modulo where val = 7;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: ...osts off, num_nodes on) select distinct val2 from tab1_modul...
!                                                              ^
  -- DMLs
  update tab1_modulo set val2 = 1000 where val = 7; 
+ ERROR:  relation "tab1_modulo" does not exist
+ LINE 1: update tab1_modulo set val2 = 1000 where val = 7;
+                ^
  explain (verbose on, nodes off, costs off) update tab1_modulo set val2 = 1000 where val = 7; 
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: explain (verbose on, nodes off, costs off) update tab1_modul...
!                                                           ^
  select * from tab1_modulo where val = 7;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select * from tab1_modulo where val = 7;
!                       ^
  delete from tab1_modulo where val = 7; 
+ ERROR:  relation "tab1_modulo" does not exist
+ LINE 1: delete from tab1_modulo where val = 7;
+                     ^
  explain (verbose on, costs off) delete from tab1_modulo where val = 7; 
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: explain (verbose on, costs off) delete from tab1_modulo wher...
!                                                     ^
  select * from tab1_modulo where val = 7;
! ERROR:  relation "tab1_modulo" does not exist
! LINE 1: select * from tab1_modulo where val = 7;
!                       ^
  -- Testset 4 for replicated tables, for replicated tables, unless the expression
  -- is itself unshippable, any query involving a single replicated table is shippable
  select cr_table('tab1_replicated(val int, val2 int)', '{1, 2, 3}'::int[], 'replication');
***************
*** 1609,1615 ****
  
  -- Constant subquery
  create table subquery_fqs(id int, a varchar, c int) distribute by shard(id);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into subquery_fqs values(1,'gd', 2);
  insert into subquery_fqs values(1,'zj', 2);
  insert into subquery_fqs values(1,'sz', 2);
--- 960,965 ----
***************
*** 1640,1647 ****
  
  -- Support subquery FQS only if subquery distributed on same DN with main query(only 1 DN node)
  explain  (num_nodes on, verbose on, nodes off, costs off) select * from subquery_fqs t1 where t1.id = 1 and t1.c IN (select c from subquery_fqs t2 where t2.id=1);
!                          QUERY PLAN                         
! ------------------------------------------------------------
   Remote Subquery Scan on all
     Output: t1.id, t1.a, t1.c
     ->  Nested Loop Semi Join
--- 990,997 ----
  
  -- Support subquery FQS only if subquery distributed on same DN with main query(only 1 DN node)
  explain  (num_nodes on, verbose on, nodes off, costs off) select * from subquery_fqs t1 where t1.id = 1 and t1.c IN (select c from subquery_fqs t2 where t2.id=1);
!                       QUERY PLAN                      
! ------------------------------------------------------
   Remote Subquery Scan on all
     Output: t1.id, t1.a, t1.c
     ->  Nested Loop Semi Join
***************
*** 1652,1663 ****
                 Filter: (t1.id = 1)
           ->  Materialize
                 Output: t2.c
!                ->  Remote Subquery Scan on all
                       Output: t2.c
!                      ->  Seq Scan on public.subquery_fqs t2
!                            Output: t2.c
!                            Filter: (t2.id = 1)
! (15 rows)
  
  select * from subquery_fqs t1 where t1.id = 1 and t1.c IN (select c from subquery_fqs t2 where t2.id=1);
   id | a  | c 
--- 1002,1011 ----
                 Filter: (t1.id = 1)
           ->  Materialize
                 Output: t2.c
!                ->  Seq Scan on public.subquery_fqs t2
                       Output: t2.c
!                      Filter: (t2.id = 1)
! (13 rows)
  
  select * from subquery_fqs t1 where t1.id = 1 and t1.c IN (select c from subquery_fqs t2 where t2.id=1);
   id | a  | c 
***************
*** 1824,1831 ****
--- 1172,1182 ----
  (6 rows)
  
  drop table tab1_rr;
+ ERROR:  table "tab1_rr" does not exist
  drop table tab1_hash;
+ ERROR:  table "tab1_hash" does not exist
  drop table tab1_modulo;
+ ERROR:  table "tab1_modulo" does not exist
  drop table tab1_replicated;
  drop table subquery_fqs;
  drop function cr_table(varchar, int[], varchar); 

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_FQS_join_1.out"	2025-07-31 16:07:15.007067787 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_FQS_join.out"	2025-07-31 16:40:50.215369934 +0800
***************
*** 68,90 ****
  (1 row)
  
  select cr_table('tab1_mod', '{1, 2, 3}'::int[], 'modulo(val)', 'as select * from tab1_rep');
!  cr_table 
! ----------
!  
! (1 row)
! 
  select cr_table('tab2_mod', '{2, 4}'::int[], 'modulo(val)', 'as select * from tab1_rep');
!  cr_table 
! ----------
!  
! (1 row)
! 
  select cr_table('tab3_mod', '{1, 2, 3}'::int[], 'modulo(val)', 'as select * from tab1_rep');
!  cr_table 
! ----------
!  
! (1 row)
! 
  -- Join involving replicated tables only, all of them should be shippable
  select * from tab1_rep, tab2_rep where tab1_rep.val = tab2_rep.val and
  										tab1_rep.val2 = tab2_rep.val2 and
--- 68,84 ----
  (1 row)
  
  select cr_table('tab1_mod', '{1, 2, 3}'::int[], 'modulo(val)', 'as select * from tab1_rep');
! ERROR:  Cannot support distribute type: Hash
! CONTEXT:  SQL statement "CREATE TABLE tab1_mod DISTRIBUTE BY modulo(val) TO NODE (datanode_1, datanode_2, datanode_1) as select * from tab1_rep"
! PL/pgSQL function cr_table(character varying,integer[],character varying,character varying) line 38 at EXECUTE
  select cr_table('tab2_mod', '{2, 4}'::int[], 'modulo(val)', 'as select * from tab1_rep');
! ERROR:  Cannot support distribute type: Hash
! CONTEXT:  SQL statement "CREATE TABLE tab2_mod DISTRIBUTE BY modulo(val) TO NODE (datanode_2, datanode_2) as select * from tab1_rep"
! PL/pgSQL function cr_table(character varying,integer[],character varying,character varying) line 38 at EXECUTE
  select cr_table('tab3_mod', '{1, 2, 3}'::int[], 'modulo(val)', 'as select * from tab1_rep');
! ERROR:  Cannot support distribute type: Hash
! CONTEXT:  SQL statement "CREATE TABLE tab3_mod DISTRIBUTE BY modulo(val) TO NODE (datanode_1, datanode_2, datanode_1) as select * from tab1_rep"
! PL/pgSQL function cr_table(character varying,integer[],character varying,character varying) line 38 at EXECUTE
  -- Join involving replicated tables only, all of them should be shippable
  select * from tab1_rep, tab2_rep where tab1_rep.val = tab2_rep.val and
  										tab1_rep.val2 = tab2_rep.val2 and
***************
*** 337,746 ****
  -- shippable
  select * from tab1_mod natural join tab1_rep
  			where tab1_mod.val > 2 and tab1_rep.val < 4;
!  val | val2 
! -----+------
!    3 |    1
!    3 |    2
!    3 |    3
!    3 |    4
!    3 |    5
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_mod natural join tab1_rep
  			where tab1_mod.val > 2 and tab1_rep.val < 4;
!                                                                       QUERY PLAN                                                                      
! ------------------------------------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_mod.val, tab1_mod.val2
!    Remote query: SELECT tab1_mod.val, tab1_mod.val2 FROM (tab1_mod JOIN tab1_rep USING (val, val2)) WHERE ((tab1_mod.val > 2) AND (tab1_rep.val < 4))
!    ->  Merge Join
!          Output: tab1_mod.val, tab1_mod.val2
!          Merge Cond: ((tab1_mod.val = tab1_rep.val) AND (tab1_mod.val2 = tab1_rep.val2))
!          ->  Sort
!                Output: tab1_mod.val, tab1_mod.val2
!                Sort Key: tab1_mod.val, tab1_mod.val2
!                ->  Seq Scan on public.tab1_mod
!                      Output: tab1_mod.val, tab1_mod.val2
!                      Filter: (tab1_mod.val > 2)
!          ->  Sort
!                Output: tab1_rep.val, tab1_rep.val2
!                Sort Key: tab1_rep.val, tab1_rep.val2
!                ->  Seq Scan on public.tab1_rep
!                      Output: tab1_rep.val, tab1_rep.val2
!                      Filter: (tab1_rep.val < 4)
! (18 rows)
! 
  -- Join involving one distributed and one replicated table, with replicated
  -- table existing on only some of the nodes where distributed table exists.
  -- should not be shippable
  select * from tab1_mod natural join tab4_rep
  			where tab1_mod.val > 2 and tab4_rep.val < 4;
!  val | val2 
! -----+------
!    3 |    1
!    3 |    2
!    3 |    3
!    3 |    4
!    3 |    5
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_mod natural join tab4_rep
  			where tab1_mod.val > 2 and tab4_rep.val < 4;
!                                     QUERY PLAN                                    
! ----------------------------------------------------------------------------------
!  Hash Join
!    Output: tab1_mod.val, tab1_mod.val2
!    Hash Cond: ((tab1_mod.val = tab4_rep.val) AND (tab1_mod.val2 = tab4_rep.val2))
!    ->  Remote Subquery Scan on all
!          Output: tab1_mod.val, tab1_mod.val2
!          ->  Seq Scan on public.tab1_mod
!                Output: tab1_mod.val, tab1_mod.val2
!                Filter: (tab1_mod.val > 2)
!    ->  Hash
!          Output: tab4_rep.val, tab4_rep.val2
!          ->  Remote Subquery Scan on all
!                Output: tab4_rep.val, tab4_rep.val2
!                ->  Seq Scan on public.tab4_rep
!                      Output: tab4_rep.val, tab4_rep.val2
!                      Filter: (tab4_rep.val < 4)
! (15 rows)
! 
  -- Join involving two distributed tables, never shipped
  select * from tab1_mod natural join tab2_mod
  			where tab1_mod.val > 2 and tab2_mod.val < 4;
!  val | val2 
! -----+------
!    3 |    1
!    3 |    2
!    3 |    3
!    3 |    4
!    3 |    5
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_mod natural join tab2_mod
  			where tab1_mod.val > 2 and tab2_mod.val < 4;
!                                        QUERY PLAN                                       
! ----------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: tab1_mod.val, tab1_mod.val2
!    ->  Hash Join
!          Output: tab1_mod.val, tab1_mod.val2
!          Hash Cond: ((tab1_mod.val = tab2_mod.val) AND (tab1_mod.val2 = tab2_mod.val2))
!          ->  Seq Scan on public.tab1_mod
!                Output: tab1_mod.val, tab1_mod.val2
!                Filter: (tab1_mod.val > 2)
!          ->  Hash
!                Output: tab2_mod.val, tab2_mod.val2
!                ->  Remote Subquery Scan on all
!                      Output: tab2_mod.val, tab2_mod.val2
!                      Distribute results by M: val
!                      ->  Seq Scan on public.tab2_mod
!                            Output: tab2_mod.val, tab2_mod.val2
!                            Filter: (tab2_mod.val < 4)
! (16 rows)
! 
  -- Join involving a distributed table and two replicated tables, such that the
  -- distributed table exists only on nodes common to replicated tables, try few
  -- permutations
  select * from tab2_rep natural join tab4_rep natural join tab2_mod
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
!  val | val2 
! -----+------
!    3 |    1
!    3 |    2
!    3 |    3
!    3 |    4
!    3 |    5
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab2_rep natural join tab4_rep natural join tab2_mod
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
!                                                                                        QUERY PLAN                                                                                       
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab2_rep.val, tab2_rep.val2
!    Remote query: SELECT tab2_rep.val, tab2_rep.val2 FROM ((tab2_rep JOIN tab4_rep USING (val, val2)) JOIN tab2_mod USING (val, val2)) WHERE ((tab2_rep.val > 2) AND (tab4_rep.val < 4))
!    ->  Hash Join
!          Output: tab2_rep.val, tab2_rep.val2
!          Hash Cond: ((tab2_mod.val = tab2_rep.val) AND (tab2_mod.val2 = tab2_rep.val2))
!          ->  Seq Scan on public.tab2_mod
!                Output: tab2_mod.val, tab2_mod.val2
!          ->  Hash
!                Output: tab2_rep.val, tab2_rep.val2, tab4_rep.val, tab4_rep.val2
!                ->  Merge Join
!                      Output: tab2_rep.val, tab2_rep.val2, tab4_rep.val, tab4_rep.val2
!                      Merge Cond: ((tab2_rep.val = tab4_rep.val) AND (tab2_rep.val2 = tab4_rep.val2))
!                      ->  Sort
!                            Output: tab2_rep.val, tab2_rep.val2
!                            Sort Key: tab2_rep.val, tab2_rep.val2
!                            ->  Seq Scan on public.tab2_rep
!                                  Output: tab2_rep.val, tab2_rep.val2
!                                  Filter: (tab2_rep.val > 2)
!                      ->  Sort
!                            Output: tab4_rep.val, tab4_rep.val2
!                            Sort Key: tab4_rep.val, tab4_rep.val2
!                            ->  Seq Scan on public.tab4_rep
!                                  Output: tab4_rep.val, tab4_rep.val2
!                                  Filter: (tab4_rep.val < 4)
! (25 rows)
! 
  select * from tab4_rep natural join tab2_rep natural join tab2_mod
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
!  val | val2 
! -----+------
!    3 |    1
!    3 |    2
!    3 |    3
!    3 |    4
!    3 |    5
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab4_rep natural join tab2_rep natural join tab2_mod
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
!                                                                                        QUERY PLAN                                                                                       
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab4_rep.val, tab4_rep.val2
!    Remote query: SELECT tab4_rep.val, tab4_rep.val2 FROM ((tab4_rep JOIN tab2_rep USING (val, val2)) JOIN tab2_mod USING (val, val2)) WHERE ((tab2_rep.val > 2) AND (tab4_rep.val < 4))
!    ->  Hash Join
!          Output: tab4_rep.val, tab4_rep.val2
!          Hash Cond: ((tab2_mod.val = tab4_rep.val) AND (tab2_mod.val2 = tab4_rep.val2))
!          ->  Seq Scan on public.tab2_mod
!                Output: tab2_mod.val, tab2_mod.val2
!          ->  Hash
!                Output: tab4_rep.val, tab4_rep.val2, tab2_rep.val, tab2_rep.val2
!                ->  Merge Join
!                      Output: tab4_rep.val, tab4_rep.val2, tab2_rep.val, tab2_rep.val2
!                      Merge Cond: ((tab4_rep.val = tab2_rep.val) AND (tab4_rep.val2 = tab2_rep.val2))
!                      ->  Sort
!                            Output: tab4_rep.val, tab4_rep.val2
!                            Sort Key: tab4_rep.val, tab4_rep.val2
!                            ->  Seq Scan on public.tab4_rep
!                                  Output: tab4_rep.val, tab4_rep.val2
!                                  Filter: (tab4_rep.val < 4)
!                      ->  Sort
!                            Output: tab2_rep.val, tab2_rep.val2
!                            Sort Key: tab2_rep.val, tab2_rep.val2
!                            ->  Seq Scan on public.tab2_rep
!                                  Output: tab2_rep.val, tab2_rep.val2
!                                  Filter: (tab2_rep.val > 2)
! (25 rows)
! 
  select * from tab2_rep natural join tab2_mod natural join tab4_rep
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
!  val | val2 
! -----+------
!    3 |    1
!    3 |    2
!    3 |    3
!    3 |    4
!    3 |    5
! (5 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab2_rep natural join tab2_mod natural join tab4_rep
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
!                                                                                        QUERY PLAN                                                                                       
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab2_rep.val, tab2_rep.val2
!    Remote query: SELECT tab2_rep.val, tab2_rep.val2 FROM ((tab2_rep JOIN tab2_mod USING (val, val2)) JOIN tab4_rep USING (val, val2)) WHERE ((tab2_rep.val > 2) AND (tab4_rep.val < 4))
!    ->  Hash Join
!          Output: tab2_rep.val, tab2_rep.val2
!          Hash Cond: ((tab2_mod.val = tab2_rep.val) AND (tab2_mod.val2 = tab2_rep.val2))
!          ->  Seq Scan on public.tab2_mod
!                Output: tab2_mod.val, tab2_mod.val2
!          ->  Hash
!                Output: tab2_rep.val, tab2_rep.val2, tab4_rep.val, tab4_rep.val2
!                ->  Merge Join
!                      Output: tab2_rep.val, tab2_rep.val2, tab4_rep.val, tab4_rep.val2
!                      Merge Cond: ((tab2_rep.val = tab4_rep.val) AND (tab2_rep.val2 = tab4_rep.val2))
!                      ->  Sort
!                            Output: tab2_rep.val, tab2_rep.val2
!                            Sort Key: tab2_rep.val, tab2_rep.val2
!                            ->  Seq Scan on public.tab2_rep
!                                  Output: tab2_rep.val, tab2_rep.val2
!                                  Filter: (tab2_rep.val > 2)
!                      ->  Sort
!                            Output: tab4_rep.val, tab4_rep.val2
!                            Sort Key: tab4_rep.val, tab4_rep.val2
!                            ->  Seq Scan on public.tab4_rep
!                                  Output: tab4_rep.val, tab4_rep.val2
!                                  Filter: (tab4_rep.val < 4)
! (25 rows)
! 
  -- qualifications on distributed tables
  -- In case of 2,3,4 datanodes following join should get shipped completely
  select * from tab1_mod natural join tab4_rep where tab1_mod.val = 1 order by tab1_mod.val2;
!  val | val2 
! -----+------
!    1 |    1
!    1 |    2
!    1 |    3
!    1 |    4
!    1 |    5
! (5 rows)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_mod natural join tab4_rep where tab1_mod.val = 1 order by tab1_mod.val2;
!                           QUERY PLAN                           
! ---------------------------------------------------------------
!  Sort
!    Output: tab1_mod.val, tab1_mod.val2, tab1_mod.val2
!    Sort Key: tab1_mod.val2
!    ->  Nested Loop
!          Output: tab1_mod.val, tab1_mod.val2, tab1_mod.val2
!          Join Filter: (tab1_mod.val2 = tab4_rep.val2)
!          ->  Remote Subquery Scan on all
!                Output: tab1_mod.val, tab1_mod.val2
!                ->  Seq Scan on public.tab1_mod
!                      Output: tab1_mod.val, tab1_mod.val2
!                      Filter: (tab1_mod.val = 1)
!          ->  Materialize
!                Output: tab4_rep.val, tab4_rep.val2
!                ->  Remote Subquery Scan on all
!                      Output: tab4_rep.val, tab4_rep.val2
!                      ->  Seq Scan on public.tab4_rep
!                            Output: tab4_rep.val, tab4_rep.val2
!                            Filter: (tab4_rep.val = 1)
! (18 rows)
! 
  -- following join between distributed tables should get FQSed because both of
  -- them reduce to a single node
  select * from tab1_mod join tab2_mod using (val2)
  		where tab1_mod.val = 1 and tab2_mod.val = 2 order by tab1_mod.val2;
!  val2 | val | val 
! ------+-----+-----
!     1 |   1 |   2
!     2 |   1 |   2
!     3 |   1 |   2
!     4 |   1 |   2
!     5 |   1 |   2
! (5 rows)
! 
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_mod join tab2_mod using (val2)
  		where tab1_mod.val = 1 and tab2_mod.val = 2 order by tab1_mod.val;
!                                QUERY PLAN                                
! -------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    Output: tab1_mod.val2, tab1_mod.val, tab2_mod.val, tab1_mod.val
!    ->  Nested Loop
!          Output: tab1_mod.val2, tab1_mod.val, tab2_mod.val, tab1_mod.val
!          Join Filter: (tab1_mod.val2 = tab2_mod.val2)
!          ->  Remote Subquery Scan on all
!                Output: tab1_mod.val2, tab1_mod.val
!                ->  Seq Scan on public.tab1_mod
!                      Output: tab1_mod.val2, tab1_mod.val
!                      Filter: (tab1_mod.val = 1)
!          ->  Materialize
!                Output: tab2_mod.val, tab2_mod.val2
!                ->  Seq Scan on public.tab2_mod
!                      Output: tab2_mod.val, tab2_mod.val2
!                      Filter: (tab2_mod.val = 2)
! (15 rows)
! 
  -- JOIN involving the distributed table with equi-JOIN on the distributed column
  -- with same kind of distribution on same nodes.
  select * from tab1_mod, tab3_mod where tab1_mod.val = tab3_mod.val and tab1_mod.val = 1;
!  val | val2 | val | val2 
! -----+------+-----+------
!    1 |    1 |   1 |    1
!    1 |    1 |   1 |    2
!    1 |    1 |   1 |    3
!    1 |    1 |   1 |    4
!    1 |    1 |   1 |    5
!    1 |    2 |   1 |    1
!    1 |    2 |   1 |    2
!    1 |    2 |   1 |    3
!    1 |    2 |   1 |    4
!    1 |    2 |   1 |    5
!    1 |    3 |   1 |    1
!    1 |    3 |   1 |    2
!    1 |    3 |   1 |    3
!    1 |    3 |   1 |    4
!    1 |    3 |   1 |    5
!    1 |    4 |   1 |    1
!    1 |    4 |   1 |    2
!    1 |    4 |   1 |    3
!    1 |    4 |   1 |    4
!    1 |    4 |   1 |    5
!    1 |    5 |   1 |    1
!    1 |    5 |   1 |    2
!    1 |    5 |   1 |    3
!    1 |    5 |   1 |    4
!    1 |    5 |   1 |    5
! (25 rows)
! 
  explain (verbose on, nodes off, costs off) select * from tab1_mod, tab3_mod
  			where tab1_mod.val = tab3_mod.val and tab1_mod.val = 1;
!                                                                               QUERY PLAN                                                                              
! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Remote Fast Query Execution
!    Output: tab1_mod.val, tab1_mod.val2, tab3_mod.val, tab3_mod.val2
!    Remote query: SELECT tab1_mod.val, tab1_mod.val2, tab3_mod.val, tab3_mod.val2 FROM tab1_mod, tab3_mod WHERE ((tab1_mod.val = tab3_mod.val) AND (tab1_mod.val = 1))
!    ->  Nested Loop
!          Output: tab1_mod.val, tab1_mod.val2, tab3_mod.val, tab3_mod.val2
!          ->  Seq Scan on public.tab1_mod
!                Output: tab1_mod.val, tab1_mod.val2
!                Filter: (tab1_mod.val = 1)
!          ->  Materialize
!                Output: tab3_mod.val, tab3_mod.val2
!                ->  Seq Scan on public.tab3_mod
!                      Output: tab3_mod.val, tab3_mod.val2
!                      Filter: (tab3_mod.val = 1)
! (13 rows)
! 
  -- DMLs involving JOINs are not FQSed
  explain (verbose on, nodes off, costs off) update tab1_mod set val2 = 1000 from tab2_mod 
  		where tab1_mod.val = tab2_mod.val and tab1_mod. val2 = tab2_mod.val2;
!                                                              QUERY PLAN                                                             
! ------------------------------------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Update on public.tab1_mod
!          ->  Merge Join
!                Output: tab1_mod.val, 1000, tab1_mod.xc_node_id, tab1_mod.ctid, tab1_mod.shardid, tab2_mod.ctid, tab2_mod.xc_node_id
!                Merge Cond: ((tab1_mod.val = tab2_mod.val) AND (tab1_mod.val2 = tab2_mod.val2))
!                ->  Sort
!                      Output: tab1_mod.val, tab1_mod.xc_node_id, tab1_mod.ctid, tab1_mod.shardid, tab1_mod.val2
!                      Sort Key: tab1_mod.val, tab1_mod.val2
!                      ->  Seq Scan on public.tab1_mod
!                            Output: tab1_mod.val, tab1_mod.xc_node_id, tab1_mod.ctid, tab1_mod.shardid, tab1_mod.val2
!                ->  Materialize
!                      Output: tab2_mod.ctid, tab2_mod.xc_node_id, tab2_mod.val, tab2_mod.val2
!                      ->  Remote Subquery Scan on all
!                            Output: tab2_mod.ctid, tab2_mod.xc_node_id, tab2_mod.val, tab2_mod.val2
!                            Distribute results by M: val
!                            ->  Sort
!                                  Output: tab2_mod.ctid, tab2_mod.xc_node_id, tab2_mod.val, tab2_mod.val2
!                                  Sort Key: tab2_mod.val, tab2_mod.val2
!                                  ->  Seq Scan on public.tab2_mod
!                                        Output: tab2_mod.ctid, tab2_mod.xc_node_id, tab2_mod.val, tab2_mod.val2
! (20 rows)
! 
  explain (verbose on, nodes off, costs off) delete from tab1_mod using tab2_mod
  		where tab1_mod.val = tab2_mod.val and tab1_mod.val2 = tab2_mod.val2;
!                                                           QUERY PLAN                                                          
! ------------------------------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Delete on public.tab1_mod
!          ->  Merge Join
!                Output: tab1_mod.xc_node_id, tab1_mod.ctid, tab1_mod.shardid, tab1_mod.val, tab2_mod.ctid, tab2_mod.xc_node_id
!                Merge Cond: ((tab1_mod.val = tab2_mod.val) AND (tab1_mod.val2 = tab2_mod.val2))
!                ->  Sort
!                      Output: tab1_mod.xc_node_id, tab1_mod.ctid, tab1_mod.shardid, tab1_mod.val, tab1_mod.val2
!                      Sort Key: tab1_mod.val, tab1_mod.val2
!                      ->  Seq Scan on public.tab1_mod
!                            Output: tab1_mod.xc_node_id, tab1_mod.ctid, tab1_mod.shardid, tab1_mod.val, tab1_mod.val2
!                ->  Materialize
!                      Output: tab2_mod.ctid, tab2_mod.xc_node_id, tab2_mod.val, tab2_mod.val2
!                      ->  Remote Subquery Scan on all
!                            Output: tab2_mod.ctid, tab2_mod.xc_node_id, tab2_mod.val, tab2_mod.val2
!                            Distribute results by M: val
!                            ->  Sort
!                                  Output: tab2_mod.ctid, tab2_mod.xc_node_id, tab2_mod.val, tab2_mod.val2
!                                  Sort Key: tab2_mod.val, tab2_mod.val2
!                                  ->  Seq Scan on public.tab2_mod
!                                        Output: tab2_mod.ctid, tab2_mod.xc_node_id, tab2_mod.val, tab2_mod.val2
! (20 rows)
! 
  explain (verbose on, nodes off, costs off) update tab1_rep set val2 = 1000 from tab2_rep
  		where tab1_rep.val = tab2_rep.val and tab1_rep.val2 = tab2_rep.val2;
                                                    QUERY PLAN                                                   
--- 331,445 ----
  -- shippable
  select * from tab1_mod natural join tab1_rep
  			where tab1_mod.val > 2 and tab1_rep.val < 4;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: select * from tab1_mod natural join tab1_rep
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_mod natural join tab1_rep
  			where tab1_mod.val > 2 and tab1_rep.val < 4;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_mod n...
!                                                              ^
  -- Join involving one distributed and one replicated table, with replicated
  -- table existing on only some of the nodes where distributed table exists.
  -- should not be shippable
  select * from tab1_mod natural join tab4_rep
  			where tab1_mod.val > 2 and tab4_rep.val < 4;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: select * from tab1_mod natural join tab4_rep
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_mod natural join tab4_rep
  			where tab1_mod.val > 2 and tab4_rep.val < 4;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_mod n...
!                                                              ^
  -- Join involving two distributed tables, never shipped
  select * from tab1_mod natural join tab2_mod
  			where tab1_mod.val > 2 and tab2_mod.val < 4;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: select * from tab1_mod natural join tab2_mod
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_mod natural join tab2_mod
  			where tab1_mod.val > 2 and tab2_mod.val < 4;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_mod n...
!                                                              ^
  -- Join involving a distributed table and two replicated tables, such that the
  -- distributed table exists only on nodes common to replicated tables, try few
  -- permutations
  select * from tab2_rep natural join tab4_rep natural join tab2_mod
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
! ERROR:  relation "tab2_mod" does not exist
! LINE 1: ... * from tab2_rep natural join tab4_rep natural join tab2_mod
!                                                                ^
  explain (verbose on, nodes off, costs off) select * from tab2_rep natural join tab4_rep natural join tab2_mod
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
! ERROR:  relation "tab2_mod" does not exist
! LINE 1: ... * from tab2_rep natural join tab4_rep natural join tab2_mod
!                                                                ^
  select * from tab4_rep natural join tab2_rep natural join tab2_mod
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
! ERROR:  relation "tab2_mod" does not exist
! LINE 1: ... * from tab4_rep natural join tab2_rep natural join tab2_mod
!                                                                ^
  explain (verbose on, nodes off, costs off) select * from tab4_rep natural join tab2_rep natural join tab2_mod
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
! ERROR:  relation "tab2_mod" does not exist
! LINE 1: ... * from tab4_rep natural join tab2_rep natural join tab2_mod
!                                                                ^
  select * from tab2_rep natural join tab2_mod natural join tab4_rep
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
! ERROR:  relation "tab2_mod" does not exist
! LINE 1: select * from tab2_rep natural join tab2_mod natural join ta...
!                                             ^
  explain (verbose on, nodes off, costs off) select * from tab2_rep natural join tab2_mod natural join tab4_rep
  			where tab2_rep.val > 2 and tab4_rep.val < 4;
! ERROR:  relation "tab2_mod" does not exist
! LINE 1: ...f, costs off) select * from tab2_rep natural join tab2_mod n...
!                                                              ^
  -- qualifications on distributed tables
  -- In case of 2,3,4 datanodes following join should get shipped completely
  select * from tab1_mod natural join tab4_rep where tab1_mod.val = 1 order by tab1_mod.val2;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: select * from tab1_mod natural join tab4_rep where tab1_mod....
!                       ^
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_mod natural join tab4_rep where tab1_mod.val = 1 order by tab1_mod.val2;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: ...nodes off, costs off, num_nodes on) select * from tab1_mod n...
!                                                              ^
  -- following join between distributed tables should get FQSed because both of
  -- them reduce to a single node
  select * from tab1_mod join tab2_mod using (val2)
  		where tab1_mod.val = 1 and tab2_mod.val = 2 order by tab1_mod.val2;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: select * from tab1_mod join tab2_mod using (val2)
!                       ^
  explain (verbose on, nodes off, costs off, num_nodes on) select * from tab1_mod join tab2_mod using (val2)
  		where tab1_mod.val = 1 and tab2_mod.val = 2 order by tab1_mod.val;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: ...nodes off, costs off, num_nodes on) select * from tab1_mod j...
!                                                              ^
  -- JOIN involving the distributed table with equi-JOIN on the distributed column
  -- with same kind of distribution on same nodes.
  select * from tab1_mod, tab3_mod where tab1_mod.val = tab3_mod.val and tab1_mod.val = 1;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: select * from tab1_mod, tab3_mod where tab1_mod.val = tab3_m...
!                       ^
  explain (verbose on, nodes off, costs off) select * from tab1_mod, tab3_mod
  			where tab1_mod.val = tab3_mod.val and tab1_mod.val = 1;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: ... (verbose on, nodes off, costs off) select * from tab1_mod, ...
!                                                              ^
  -- DMLs involving JOINs are not FQSed
  explain (verbose on, nodes off, costs off) update tab1_mod set val2 = 1000 from tab2_mod 
  		where tab1_mod.val = tab2_mod.val and tab1_mod. val2 = tab2_mod.val2;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: explain (verbose on, nodes off, costs off) update tab1_mod s...
!                                                           ^
  explain (verbose on, nodes off, costs off) delete from tab1_mod using tab2_mod
  		where tab1_mod.val = tab2_mod.val and tab1_mod.val2 = tab2_mod.val2;
! ERROR:  relation "tab1_mod" does not exist
! LINE 1: ...in (verbose on, nodes off, costs off) delete from tab1_mod u...
!                                                              ^
  explain (verbose on, nodes off, costs off) update tab1_rep set val2 = 1000 from tab2_rep
  		where tab1_rep.val = tab2_rep.val and tab1_rep.val2 = tab2_rep.val2;
                                                    QUERY PLAN                                                   
***************
*** 788,792 ****
--- 487,493 ----
  drop table tab3_rep;
  drop table tab4_rep;
  drop table tab1_mod;
+ ERROR:  table "tab1_mod" does not exist
  drop table tab2_mod;
+ ERROR:  table "tab2_mod" does not exist
  drop function cr_table(varchar, int[], varchar, varchar);

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_copy.out"	2025-07-31 16:37:23.179922049 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_copy.out"	2025-07-31 16:40:49.893376705 +0800
***************
*** 26,31 ****
  DROP TABLE "Xc_copy_2";
  -- Table with no locator data
  CREATE TABLE xc_copy_3 (c1 int) DISTRIBUTE BY HASH(c1);
  COPY (SELECT pclocatortype,pcattnum,pchashalgorithm,pchashbuckets FROM pgxc_class WHERE pgxc_class.pcrelid = 'xc_copy_3'::regclass) TO stdout;
! H	1	1	4096
  DROP TABLE xc_copy_3;
--- 26,35 ----
  DROP TABLE "Xc_copy_2";
  -- Table with no locator data
  CREATE TABLE xc_copy_3 (c1 int) DISTRIBUTE BY HASH(c1);
+ ERROR:  Cannot support distribute type: Hash
  COPY (SELECT pclocatortype,pcattnum,pchashalgorithm,pchashbuckets FROM pgxc_class WHERE pgxc_class.pcrelid = 'xc_copy_3'::regclass) TO stdout;
! ERROR:  relation "xc_copy_3" does not exist
! LINE 1: ...uckets FROM pgxc_class WHERE pgxc_class.pcrelid = 'xc_copy_3...
!                                                              ^
  DROP TABLE xc_copy_3;
+ ERROR:  table "xc_copy_3" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_for_update_1.out"	2025-07-31 16:07:15.008067771 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_for_update.out"	2025-07-31 16:41:07.930997942 +0800
***************
*** 221,227 ****
                 Merge Cond: (t1.val2 = t2.val2)
                 ->  Remote Subquery Scan on all
                       Output: t1.val, t1.val2
!                      Distribute results by H: val2
                       Sort Key: t1.val2
                       ->  Sort
                             Output: t1.val, t1.val2
--- 221,227 ----
                 Merge Cond: (t1.val2 = t2.val2)
                 ->  Remote Subquery Scan on all
                       Output: t1.val, t1.val2
!                      Distribute results by S: val2
                       Sort Key: t1.val2
                       ->  Sort
                             Output: t1.val, t1.val2
***************
*** 232,238 ****
                       Output: t2.val, t2.val2
                       ->  Remote Subquery Scan on all
                             Output: t2.val, t2.val2
!                            Distribute results by H: val2
                             Sort Key: t2.val2
                             ->  Sort
                                   Output: t2.val, t2.val2
--- 232,238 ----
                       Output: t2.val, t2.val2
                       ->  Remote Subquery Scan on all
                             Output: t2.val, t2.val2
!                            Distribute results by S: val2
                             Sort Key: t2.val2
                             ->  Sort
                                   Output: t2.val, t2.val2
***************
*** 243,249 ****
                 Output: t3.val, t3.val2
                 ->  Remote Subquery Scan on all
                       Output: t3.val, t3.val2
!                      Distribute results by H: val2
                       Sort Key: t3.val2
                       ->  Sort
                             Output: t3.val, t3.val2
--- 243,249 ----
                 Output: t3.val, t3.val2
                 ->  Remote Subquery Scan on all
                       Output: t3.val, t3.val2
!                      Distribute results by S: val2
                       Sort Key: t3.val2
                       ->  Sort
                             Output: t3.val, t3.val2
***************
*** 633,642 ****
  CREATE VIEW v1 as select * from mytab1 where val = 2;
  -- insert some rows
  insert into mytab1 values(1,11,1122),(2,11,3344);
!  val | val2 
! -----+------
! (0 rows)
! 
  -------------------------------------------
  -- Case 1 where we have a SELECT FOR UPDATE
  -------------------------------------------
--- 633,640 ----
  CREATE VIEW v1 as select * from mytab1 where val = 2;
  -- insert some rows
  insert into mytab1 values(1,11,1122),(2,11,3344);
! ERROR:  node:datanode_1, backend_pid:384356, nodename:datanode_1,backend_pid:384356,message:null value in column "val" violates not-null constraint
! DETAIL:  Failing row contains (null, null, null).
  -------------------------------------------
  -- Case 1 where we have a SELECT FOR UPDATE
  -------------------------------------------
***************
*** 646,660 ****
  fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
!    1 |   11 | 1122
! (1 row)
  
  declare c2 cursor for select * from mytab1 for share;
  fetch 1 from c2;
   val | val2 | val3 
  -----+------+------
!    1 |   11 | 1122
! (1 row)
  
  end;
  -- prepare a transaction that holds a ACCESS EXCLUSIVE (ROW SHARE) lock on a table
--- 644,656 ----
  fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
! (0 rows)
  
  declare c2 cursor for select * from mytab1 for share;
  fetch 1 from c2;
   val | val2 | val3 
  -----+------+------
! (0 rows)
  
  end;
  -- prepare a transaction that holds a ACCESS EXCLUSIVE (ROW SHARE) lock on a table
***************
*** 663,670 ****
  fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
!    1 |   11 | 1122
! (1 row)
  
  prepare transaction 'tbl_mytab1_locked';
  set statement_timeout to 1000;
--- 659,665 ----
  fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
! (0 rows)
  
  prepare transaction 'tbl_mytab1_locked';
  set statement_timeout to 1000;
***************
*** 674,682 ****
         select * from mytab1 order by 1;
   val | val2 | val3 
  -----+------+------
!    1 |   11 | 1122
!    2 |   11 | 3344
! (2 rows)
  
  --  2. insert a row (Should pass)
         insert into mytab1 values(123,456);
--- 669,675 ----
         select * from mytab1 order by 1;
   val | val2 | val3 
  -----+------+------
! (0 rows)
  
  --  2. insert a row (Should pass)
         insert into mytab1 values(123,456);
***************
*** 686,698 ****
  
  --  3. update a row (Should fail)
         update mytab1 set val2=33 where val = 1;
- ERROR:  canceling statement due to statement timeout
  --  4. delete a row
  --     Newly Inserted (Should pass)
         delete from mytab1 where val2=456;
  --     Previously Inserted (Should fail)
         delete from mytab1 where val=1;
- ERROR:  canceling statement due to statement timeout
  --  5. inherit form it (Should pass)
         create table chld_mytab1(d int, e int) inherits (mytab1);
  --  6. create a view on it (Should pass)
--- 679,689 ----
***************
*** 707,713 ****
  ERROR:  canceling statement due to statement timeout
  -- 10. vacuum it (Should pass)
         vacuum mytab1;
- ERROR:  canceling statement due to statement timeout
  -- 11. obtain any of these locks on it
  --     ACCESS SHARE (Should pass)
         begin;
--- 698,703 ----
***************
*** 747,759 ****
         begin;
           declare c1 cursor for select * from mytab1 for share nowait;
           fetch 1 from c1;
! ERROR:  could not obtain lock on row in relation "mytab1"
         end;
  -- 13. do a SELECT FOR UPDATE on it (Should fail)
         begin;
           declare c1 cursor for select * from mytab1 for update nowait;
           fetch 1 from c1;
! ERROR:  could not obtain lock on row in relation "mytab1"
         end;
  -- 14. alter already defined index on it (Should fail)
         ALTER INDEX test_idx RENAME TO mytab1_idx;
--- 737,755 ----
         begin;
           declare c1 cursor for select * from mytab1 for share nowait;
           fetch 1 from c1;
!  val | val2 | val3 
! -----+------+------
! (0 rows)
! 
         end;
  -- 13. do a SELECT FOR UPDATE on it (Should fail)
         begin;
           declare c1 cursor for select * from mytab1 for update nowait;
           fetch 1 from c1;
!  val | val2 | val3 
! -----+------+------
! (0 rows)
! 
         end;
  -- 14. alter already defined index on it (Should fail)
         ALTER INDEX test_idx RENAME TO mytab1_idx;
***************
*** 792,806 ****
  fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
!    1 |   11 | 1122
! (1 row)
  
  declare c2 cursor for select * from mytab1 for update;
  fetch 1 from c2;
   val | val2 | val3 
  -----+------+------
!    1 |   11 | 1122
! (1 row)
  
  end;
  -- prepare a transaction that holds a ACCESS SHARE (ROW SHARE) lock on a table
--- 788,800 ----
  fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
! (0 rows)
  
  declare c2 cursor for select * from mytab1 for update;
  fetch 1 from c2;
   val | val2 | val3 
  -----+------+------
! (0 rows)
  
  end;
  -- prepare a transaction that holds a ACCESS SHARE (ROW SHARE) lock on a table
***************
*** 809,816 ****
  fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
!    1 |   11 | 1122
! (1 row)
  
  prepare transaction 'tbl_mytab1_locked';
  set statement_timeout to 1000;
--- 803,809 ----
  fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
! (0 rows)
  
  prepare transaction 'tbl_mytab1_locked';
  set statement_timeout to 1000;
***************
*** 820,828 ****
         select * from mytab1 order by 1 ;
   val | val2 | val3 
  -----+------+------
!    1 |   11 | 1122
!    2 |   11 | 3344
! (2 rows)
  
  --  2. insert a row (Should pass)
         insert into mytab1 values(123,456);
--- 813,819 ----
         select * from mytab1 order by 1 ;
   val | val2 | val3 
  -----+------+------
! (0 rows)
  
  --  2. insert a row (Should pass)
         insert into mytab1 values(123,456);
***************
*** 893,900 ****
           fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
!    2 |   11 | 3344
! (1 row)
  
         end;
  -- 13. do a SELECT FOR UPDATE on it (Should fail)
--- 884,890 ----
           fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
! (0 rows)
  
         end;
  -- 13. do a SELECT FOR UPDATE on it (Should fail)
***************
*** 903,910 ****
           fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
!    2 |   11 | 3344
! (1 row)
  
         end;
  -- 14. alter already defined index on it (Should fail)
--- 893,899 ----
           fetch 1 from c1;
   val | val2 | val3 
  -----+------+------
! (0 rows)
  
         end;
  -- 14. alter already defined index on it (Should fail)

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_alter_table_1.out"	2025-07-31 16:07:15.007067787 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_alter_table.out"	2025-07-31 16:40:50.532363269 +0800
***************
*** 3,110 ****
  --
  -- Check on dropped columns
  CREATE TABLE xc_alter_table_1 (id serial, name varchar(80), code varchar(80)) DISTRIBUTE BY HASH(id);
  EXPLAIN (VERBOSE true, COSTS false, NODES false) INSERT INTO xc_alter_table_1(name) VALUES ('aaa'),('bbb'),('ccc');
!                                                       QUERY PLAN                                                       
! -----------------------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Insert on public.xc_alter_table_1
!          ->  Remote Subquery Scan on all
!                Output: nextval('xc_alter_table_1_id_seq'::regclass), "*VALUES*".column1, NULL::character varying
!                Distribute results by H: nextval('xc_alter_table_1_id_seq'::regclass)
!                ->  Values Scan on "*VALUES*"
!                      Output: nextval('xc_alter_table_1_id_seq'::regclass), "*VALUES*".column1, NULL::character varying
! (7 rows)
! 
  INSERT INTO xc_alter_table_1(name) VALUES ('aaa'),('bbb'),('ccc');
  SELECT id, name, code FROM xc_alter_table_1 ORDER BY 1;
!  id | name | code 
! ----+------+------
!   1 | aaa  | 
!   2 | bbb  | 
!   3 | ccc  | 
! (3 rows)
! 
  -- Cannot drop distribution column
  ALTER TABLE xc_alter_table_1 DROP COLUMN id;
! ERROR:  Distribution column cannot be dropped
  -- Drop 1st column
  ALTER TABLE xc_alter_table_1 DROP COLUMN code;
  -- Check for query generation of remote INSERT
  INSERT INTO xc_alter_table_1(name) VALUES('ddd'),('eee'),('fff');
  EXPLAIN (VERBOSE true, COSTS false, NODES false) INSERT INTO xc_alter_table_1(name) VALUES('ddd'),('eee'),('fff');
!                                                  QUERY PLAN                                                  
! -------------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Insert on public.xc_alter_table_1
!          ->  Remote Subquery Scan on all
!                Output: nextval('xc_alter_table_1_id_seq'::regclass), "*VALUES*".column1, NULL::integer
!                Distribute results by H: nextval('xc_alter_table_1_id_seq'::regclass)
!                ->  Values Scan on "*VALUES*"
!                      Output: nextval('xc_alter_table_1_id_seq'::regclass), "*VALUES*".column1, NULL::integer
! (7 rows)
! 
  SELECT id, name FROM xc_alter_table_1 ORDER BY 1;
!  id | name 
! ----+------
!   1 | aaa
!   2 | bbb
!   3 | ccc
!   4 | ddd
!   5 | eee
!   6 | fff
! (6 rows)
! 
  -- Check for query generation of remote INSERT SELECT
  INSERT INTO xc_alter_table_1(name) SELECT 'ggg';
  EXPLAIN (VERBOSE true, COSTS false, NODES false) INSERT INTO xc_alter_table_1(name) SELECT 'ggg';
!                                                       QUERY PLAN                                                       
! -----------------------------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Insert on public.xc_alter_table_1
!          ->  Remote Subquery Scan on all
!                Output: nextval('xc_alter_table_1_id_seq'::regclass), 'ggg'::character varying(80), NULL::integer
!                Distribute results by H: nextval('xc_alter_table_1_id_seq'::regclass)
!                ->  Result
!                      Output: nextval('xc_alter_table_1_id_seq'::regclass), 'ggg'::character varying(80), NULL::integer
! (7 rows)
! 
  SELECT id, name FROM xc_alter_table_1 ORDER BY 1;
!  id | name 
! ----+------
!   1 | aaa
!   2 | bbb
!   3 | ccc
!   4 | ddd
!   5 | eee
!   6 | fff
!   7 | ggg
! (7 rows)
! 
  -- Check for query generation of remote UPDATE
  EXPLAIN (VERBOSE true, COSTS false, NODES false) UPDATE xc_alter_table_1 SET name = 'zzz' WHERE id = currval('xc_alter_table_1_id_seq');
!                                             QUERY PLAN                                            
! --------------------------------------------------------------------------------------------------
!  Remote Subquery Scan on all
!    ->  Update on public.xc_alter_table_1
!          ->  Seq Scan on public.xc_alter_table_1
!                Output: id, 'zzz'::character varying(80), NULL::integer, xc_node_id, ctid, shardid
!                Filter: (xc_alter_table_1.id = currval('xc_alter_table_1_id_seq'::regclass))
! (5 rows)
! 
  UPDATE xc_alter_table_1 SET name = 'zzz' WHERE id = currval('xc_alter_table_1_id_seq');
  SELECT id, name FROM xc_alter_table_1 ORDER BY 1;
!  id | name 
! ----+------
!   1 | aaa
!   2 | bbb
!   3 | ccc
!   4 | ddd
!   5 | eee
!   6 | fff
!   7 | zzz
! (7 rows)
! 
  DROP TABLE xc_alter_table_1;
  -- Check for multiple columns dropped and created
  CREATE TABLE xc_alter_table_2 (a int, b varchar(20), c boolean, d text, e interval) distribute by replication;
  INSERT INTO xc_alter_table_2 VALUES (1, 'John', true, 'Master', '01:00:10');
--- 3,68 ----
  --
  -- Check on dropped columns
  CREATE TABLE xc_alter_table_1 (id serial, name varchar(80), code varchar(80)) DISTRIBUTE BY HASH(id);
+ ERROR:  Cannot support distribute type: Hash
  EXPLAIN (VERBOSE true, COSTS false, NODES false) INSERT INTO xc_alter_table_1(name) VALUES ('aaa'),('bbb'),('ccc');
! ERROR:  relation "xc_alter_table_1" does not exist
! LINE 1: ...RBOSE true, COSTS false, NODES false) INSERT INTO xc_alter_t...
!                                                              ^
  INSERT INTO xc_alter_table_1(name) VALUES ('aaa'),('bbb'),('ccc');
+ ERROR:  relation "xc_alter_table_1" does not exist
+ LINE 1: INSERT INTO xc_alter_table_1(name) VALUES ('aaa'),('bbb'),('...
+                     ^
  SELECT id, name, code FROM xc_alter_table_1 ORDER BY 1;
! ERROR:  relation "xc_alter_table_1" does not exist
! LINE 1: SELECT id, name, code FROM xc_alter_table_1 ORDER BY 1;
!                                    ^
  -- Cannot drop distribution column
  ALTER TABLE xc_alter_table_1 DROP COLUMN id;
! ERROR:  relation "xc_alter_table_1" does not exist
  -- Drop 1st column
  ALTER TABLE xc_alter_table_1 DROP COLUMN code;
+ ERROR:  relation "xc_alter_table_1" does not exist
  -- Check for query generation of remote INSERT
  INSERT INTO xc_alter_table_1(name) VALUES('ddd'),('eee'),('fff');
+ ERROR:  relation "xc_alter_table_1" does not exist
+ LINE 1: INSERT INTO xc_alter_table_1(name) VALUES('ddd'),('eee'),('f...
+                     ^
  EXPLAIN (VERBOSE true, COSTS false, NODES false) INSERT INTO xc_alter_table_1(name) VALUES('ddd'),('eee'),('fff');
! ERROR:  relation "xc_alter_table_1" does not exist
! LINE 1: ...RBOSE true, COSTS false, NODES false) INSERT INTO xc_alter_t...
!                                                              ^
  SELECT id, name FROM xc_alter_table_1 ORDER BY 1;
! ERROR:  relation "xc_alter_table_1" does not exist
! LINE 1: SELECT id, name FROM xc_alter_table_1 ORDER BY 1;
!                              ^
  -- Check for query generation of remote INSERT SELECT
  INSERT INTO xc_alter_table_1(name) SELECT 'ggg';
+ ERROR:  relation "xc_alter_table_1" does not exist
+ LINE 1: INSERT INTO xc_alter_table_1(name) SELECT 'ggg';
+                     ^
  EXPLAIN (VERBOSE true, COSTS false, NODES false) INSERT INTO xc_alter_table_1(name) SELECT 'ggg';
! ERROR:  relation "xc_alter_table_1" does not exist
! LINE 1: ...RBOSE true, COSTS false, NODES false) INSERT INTO xc_alter_t...
!                                                              ^
  SELECT id, name FROM xc_alter_table_1 ORDER BY 1;
! ERROR:  relation "xc_alter_table_1" does not exist
! LINE 1: SELECT id, name FROM xc_alter_table_1 ORDER BY 1;
!                              ^
  -- Check for query generation of remote UPDATE
  EXPLAIN (VERBOSE true, COSTS false, NODES false) UPDATE xc_alter_table_1 SET name = 'zzz' WHERE id = currval('xc_alter_table_1_id_seq');
! ERROR:  relation "xc_alter_table_1" does not exist
! LINE 1: ...N (VERBOSE true, COSTS false, NODES false) UPDATE xc_alter_t...
!                                                              ^
  UPDATE xc_alter_table_1 SET name = 'zzz' WHERE id = currval('xc_alter_table_1_id_seq');
+ ERROR:  relation "xc_alter_table_1" does not exist
+ LINE 1: UPDATE xc_alter_table_1 SET name = 'zzz' WHERE id = currval(...
+                ^
  SELECT id, name FROM xc_alter_table_1 ORDER BY 1;
! ERROR:  relation "xc_alter_table_1" does not exist
! LINE 1: SELECT id, name FROM xc_alter_table_1 ORDER BY 1;
!                              ^
  DROP TABLE xc_alter_table_1;
+ ERROR:  table "xc_alter_table_1" does not exist
  -- Check for multiple columns dropped and created
  CREATE TABLE xc_alter_table_2 (a int, b varchar(20), c boolean, d text, e interval) distribute by replication;
  INSERT INTO xc_alter_table_2 VALUES (1, 'John', true, 'Master', '01:00:10');
***************
*** 217,618 ****
  -- and effects of redistribution is checked on all the dependent objects
  -- Table with integers
  CREATE TABLE xc_alter_table_3 (a int, b varchar(10)) DISTRIBUTE BY HASH(a);
  INSERT INTO xc_alter_table_3 VALUES (0, NULL);
  INSERT INTO xc_alter_table_3 VALUES (1, 'a');
  INSERT INTO xc_alter_table_3 VALUES (2, 'aa');
  INSERT INTO xc_alter_table_3 VALUES (3, 'aaa');
  INSERT INTO xc_alter_table_3 VALUES (4, 'aaaa');
  INSERT INTO xc_alter_table_3 VALUES (5, 'aaaaa');
  INSERT INTO xc_alter_table_3 VALUES (6, 'aaaaaa');
  INSERT INTO xc_alter_table_3 VALUES (7, 'aaaaaaa');
  INSERT INTO xc_alter_table_3 VALUES (8, 'aaaaaaaa');
  INSERT INTO xc_alter_table_3 VALUES (9, 'aaaaaaaaa');
  INSERT INTO xc_alter_table_3 VALUES (10, 'aaaaaaaaaa');
  -- Create some objects to check the effect of redistribution
  CREATE VIEW xc_alter_table_3_v AS SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
  CREATE RULE xc_alter_table_3_insert AS ON UPDATE TO xc_alter_table_3 WHERE OLD.a = 11 DO INSERT INTO xc_alter_table_3 VALUES (OLD.a + 1, 'nnn');
  PREPARE xc_alter_table_insert AS INSERT INTO xc_alter_table_3 VALUES ($1, $2);
  PREPARE xc_alter_table_delete AS DELETE FROM xc_alter_table_3 WHERE a = $1;
  PREPARE xc_alter_table_update AS UPDATE xc_alter_table_3 SET b = $2 WHERE a = $1;
  -- Now begin the tests
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY HASH(a);
! ERROR:  this operation is not permitted
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  EXECUTE xc_alter_table_insert(11, 'b');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b 
! ---
!  b
! (1 row)
! 
  EXECUTE xc_alter_table_update(11, 'bb');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b  
! ----
!  bb
! (1 row)
! 
  EXECUTE xc_alter_table_delete(11);
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!   b  
! -----
!  nnn
! (1 row)
! 
  EXECUTE xc_alter_table_delete(12);
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY HASH(b);
! ERROR:  this operation is not permitted
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  EXECUTE xc_alter_table_insert(11, 'b');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b 
! ---
!  b
! (1 row)
! 
  EXECUTE xc_alter_table_update(11, 'bb');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b  
! ----
!  bb
! (1 row)
! 
  EXECUTE xc_alter_table_delete(11);
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!   b  
! -----
!  nnn
! (1 row)
! 
  EXECUTE xc_alter_table_delete(12);
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY ROUNDROBIN;
! ERROR:  this operation is not permitted
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  EXECUTE xc_alter_table_insert(11, 'b');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b 
! ---
!  b
! (1 row)
! 
  EXECUTE xc_alter_table_update(11, 'bb');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b  
! ----
!  bb
! (1 row)
! 
  EXECUTE xc_alter_table_delete(11);
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!   b  
! -----
!  nnn
! (1 row)
! 
  EXECUTE xc_alter_table_delete(12);
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY MODULO(a);
! ERROR:  this operation is not permitted
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  EXECUTE xc_alter_table_insert(11, 'b');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b 
! ---
!  b
! (1 row)
! 
  EXECUTE xc_alter_table_update(11, 'bb');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b  
! ----
!  bb
! (1 row)
! 
  EXECUTE xc_alter_table_delete(11);
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!   b  
! -----
!  nnn
! (1 row)
! 
  EXECUTE xc_alter_table_delete(12);
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY MODULO(b);
! ERROR:  this operation is not permitted
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  EXECUTE xc_alter_table_insert(11, 'b');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b 
! ---
!  b
! (1 row)
! 
  EXECUTE xc_alter_table_update(11, 'bb');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b  
! ----
!  bb
! (1 row)
! 
  EXECUTE xc_alter_table_delete(11);
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!   b  
! -----
!  nnn
! (1 row)
! 
  EXECUTE xc_alter_table_delete(12);
  -- Index and redistribution
  CREATE INDEX xc_alter_table_3_index ON xc_alter_table_3(a);
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY HASH(a);
! ERROR:  this operation is not permitted
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  EXECUTE xc_alter_table_insert(11, 'b');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b 
! ---
!  b
! (1 row)
! 
  EXECUTE xc_alter_table_update(11, 'bb');
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
!  b  
! ----
!  bb
! (1 row)
! 
  EXECUTE xc_alter_table_delete(11);
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!   b  
! -----
!  nnn
! (1 row)
! 
  EXECUTE xc_alter_table_delete(12);
  -- Add column on table
  ALTER TABLE xc_alter_table_3 ADD COLUMN c int DEFAULT 4;
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY REPLICATION;
! ERROR:  this operation is not permitted
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  -- Drop column on table
  ALTER TABLE xc_alter_table_3 DROP COLUMN b CASCADE;
! NOTICE:  drop cascades to rule xc_alter_table_3_insert on table xc_alter_table_3
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY HASH(a);
! ERROR:  this operation is not permitted
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  -- Remanipulate table once again and distribute on old column
  ALTER TABLE xc_alter_table_3 DROP COLUMN c;
  ALTER TABLE xc_alter_table_3 ADD COLUMN b varchar(3) default 'aaa';
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY HASH(a);
! ERROR:  this operation is not permitted
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  -- Change the node list
  SELECT alter_table_change_nodes('xc_alter_table_3', '{1}', 'to', NULL);
! ERROR:  this operation is not permitted
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 to NODE (datanode_1)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  -- Add some nodes on it
  SELECT alter_table_change_nodes('xc_alter_table_3', '{2,4,5}', 'add', NULL);
! ERROR:  this operation is not permitted
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 TO NODE (datanode_2, datanode_1)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check in tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  -- Remove some nodes on it
  SELECT alter_table_change_nodes('xc_alter_table_3', '{3}', 'add', NULL);
! ERROR:  this operation is not permitted
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 TO NODE (datanode_1)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT alter_table_change_nodes('xc_alter_table_3', '{2,3,5}', 'delete', NULL);
! ERROR:  this operation is not permitted
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 TO NODE (datanode_2, datanode_1)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  -- Multiple operations with replication
  SELECT alter_table_change_nodes('xc_alter_table_3', '{1,3,4,5}', 'to', 'replication');
! ERROR:  this operation is not permitted
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 TO NODE (datanode_1), DISTRIBUTE BY replication"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  -- Manipulate number of nodes to include and remove nodes on a replicated table
  -- On removed nodes data is deleted and on new nodes data is added
  SELECT alter_table_change_nodes('xc_alter_table_3', '{2,3,5}', 'to', NULL);
! ERROR:  this operation is not permitted
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 TO NODE (datanode_2, datanode_1)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  -- Re-do a double operation with hash this time
  SELECT alter_table_change_nodes('xc_alter_table_3', '{2}', 'delete', 'hash(a)');
! ERROR:  this operation is not permitted
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 delete NODE (datanode_2), DISTRIBUTE BY hash(a)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
! SELECT * FROM xc_alter_table_3_v;
!  count | sum |        avg         
! -------+-----+--------------------
!     11 |  55 | 5.0000000000000000
! (1 row)
! 
  -- Error checks
  ALTER TABLE xc_alter_table_3 ADD COLUMN b int, DISTRIBUTE BY HASH(a);
! ERROR:  this operation is not permitted
  -- Clean up
  DROP TABLE xc_alter_table_3 CASCADE;
! NOTICE:  drop cascades to view xc_alter_table_3_v
--- 175,555 ----
  -- and effects of redistribution is checked on all the dependent objects
  -- Table with integers
  CREATE TABLE xc_alter_table_3 (a int, b varchar(10)) DISTRIBUTE BY HASH(a);
+ ERROR:  Cannot support distribute type: Hash
  INSERT INTO xc_alter_table_3 VALUES (0, NULL);
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: INSERT INTO xc_alter_table_3 VALUES (0, NULL);
+                     ^
  INSERT INTO xc_alter_table_3 VALUES (1, 'a');
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: INSERT INTO xc_alter_table_3 VALUES (1, 'a');
+                     ^
  INSERT INTO xc_alter_table_3 VALUES (2, 'aa');
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: INSERT INTO xc_alter_table_3 VALUES (2, 'aa');
+                     ^
  INSERT INTO xc_alter_table_3 VALUES (3, 'aaa');
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: INSERT INTO xc_alter_table_3 VALUES (3, 'aaa');
+                     ^
  INSERT INTO xc_alter_table_3 VALUES (4, 'aaaa');
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: INSERT INTO xc_alter_table_3 VALUES (4, 'aaaa');
+                     ^
  INSERT INTO xc_alter_table_3 VALUES (5, 'aaaaa');
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: INSERT INTO xc_alter_table_3 VALUES (5, 'aaaaa');
+                     ^
  INSERT INTO xc_alter_table_3 VALUES (6, 'aaaaaa');
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: INSERT INTO xc_alter_table_3 VALUES (6, 'aaaaaa');
+                     ^
  INSERT INTO xc_alter_table_3 VALUES (7, 'aaaaaaa');
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: INSERT INTO xc_alter_table_3 VALUES (7, 'aaaaaaa');
+                     ^
  INSERT INTO xc_alter_table_3 VALUES (8, 'aaaaaaaa');
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: INSERT INTO xc_alter_table_3 VALUES (8, 'aaaaaaaa');
+                     ^
  INSERT INTO xc_alter_table_3 VALUES (9, 'aaaaaaaaa');
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: INSERT INTO xc_alter_table_3 VALUES (9, 'aaaaaaaaa');
+                     ^
  INSERT INTO xc_alter_table_3 VALUES (10, 'aaaaaaaaaa');
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: INSERT INTO xc_alter_table_3 VALUES (10, 'aaaaaaaaaa');
+                     ^
  -- Create some objects to check the effect of redistribution
  CREATE VIEW xc_alter_table_3_v AS SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: ...table_3_v AS SELECT count(*), sum(a), avg(a) FROM xc_alter_t...
+                                                              ^
  CREATE RULE xc_alter_table_3_insert AS ON UPDATE TO xc_alter_table_3 WHERE OLD.a = 11 DO INSERT INTO xc_alter_table_3 VALUES (OLD.a + 1, 'nnn');
+ ERROR:  relation "xc_alter_table_3" does not exist
  PREPARE xc_alter_table_insert AS INSERT INTO xc_alter_table_3 VALUES ($1, $2);
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: PREPARE xc_alter_table_insert AS INSERT INTO xc_alter_table_...
+                                                      ^
  PREPARE xc_alter_table_delete AS DELETE FROM xc_alter_table_3 WHERE a = $1;
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: PREPARE xc_alter_table_delete AS DELETE FROM xc_alter_table_...
+                                                      ^
  PREPARE xc_alter_table_update AS UPDATE xc_alter_table_3 SET b = $2 WHERE a = $1;
+ ERROR:  relation "xc_alter_table_3" does not exist
+ LINE 1: PREPARE xc_alter_table_update AS UPDATE xc_alter_table_3 SET...
+                                                 ^
  -- Now begin the tests
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY HASH(a);
! ERROR:  relation "xc_alter_table_3" does not exist
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  EXECUTE xc_alter_table_insert(11, 'b');
+ ERROR:  prepared statement "xc_alter_table_insert" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_update(11, 'bb');
+ ERROR:  prepared statement "xc_alter_table_update" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_delete(11);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!                       ^
  EXECUTE xc_alter_table_delete(12);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY HASH(b);
! ERROR:  relation "xc_alter_table_3" does not exist
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  EXECUTE xc_alter_table_insert(11, 'b');
+ ERROR:  prepared statement "xc_alter_table_insert" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_update(11, 'bb');
+ ERROR:  prepared statement "xc_alter_table_update" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_delete(11);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!                       ^
  EXECUTE xc_alter_table_delete(12);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY ROUNDROBIN;
! ERROR:  relation "xc_alter_table_3" does not exist
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  EXECUTE xc_alter_table_insert(11, 'b');
+ ERROR:  prepared statement "xc_alter_table_insert" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_update(11, 'bb');
+ ERROR:  prepared statement "xc_alter_table_update" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_delete(11);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!                       ^
  EXECUTE xc_alter_table_delete(12);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY MODULO(a);
! ERROR:  relation "xc_alter_table_3" does not exist
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  EXECUTE xc_alter_table_insert(11, 'b');
+ ERROR:  prepared statement "xc_alter_table_insert" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_update(11, 'bb');
+ ERROR:  prepared statement "xc_alter_table_update" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_delete(11);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!                       ^
  EXECUTE xc_alter_table_delete(12);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY MODULO(b);
! ERROR:  relation "xc_alter_table_3" does not exist
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  EXECUTE xc_alter_table_insert(11, 'b');
+ ERROR:  prepared statement "xc_alter_table_insert" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_update(11, 'bb');
+ ERROR:  prepared statement "xc_alter_table_update" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_delete(11);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!                       ^
  EXECUTE xc_alter_table_delete(12);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  -- Index and redistribution
  CREATE INDEX xc_alter_table_3_index ON xc_alter_table_3(a);
+ ERROR:  relation "xc_alter_table_3" does not exist
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY HASH(a);
! ERROR:  relation "xc_alter_table_3" does not exist
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  EXECUTE xc_alter_table_insert(11, 'b');
+ ERROR:  prepared statement "xc_alter_table_insert" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_update(11, 'bb');
+ ERROR:  prepared statement "xc_alter_table_update" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11;
!                       ^
  EXECUTE xc_alter_table_delete(11);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT b FROM xc_alter_table_3 WHERE a = 11 or a = 12;
!                       ^
  EXECUTE xc_alter_table_delete(12);
+ ERROR:  prepared statement "xc_alter_table_delete" does not exist
  -- Add column on table
  ALTER TABLE xc_alter_table_3 ADD COLUMN c int DEFAULT 4;
+ ERROR:  relation "xc_alter_table_3" does not exist
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY REPLICATION;
! ERROR:  relation "xc_alter_table_3" does not exist
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  -- Drop column on table
  ALTER TABLE xc_alter_table_3 DROP COLUMN b CASCADE;
! ERROR:  relation "xc_alter_table_3" does not exist
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY HASH(a);
! ERROR:  relation "xc_alter_table_3" does not exist
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  -- Remanipulate table once again and distribute on old column
  ALTER TABLE xc_alter_table_3 DROP COLUMN c;
+ ERROR:  relation "xc_alter_table_3" does not exist
  ALTER TABLE xc_alter_table_3 ADD COLUMN b varchar(3) default 'aaa';
+ ERROR:  relation "xc_alter_table_3" does not exist
  ALTER TABLE xc_alter_table_3 DISTRIBUTE BY HASH(a);
! ERROR:  relation "xc_alter_table_3" does not exist
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  -- Change the node list
  SELECT alter_table_change_nodes('xc_alter_table_3', '{1}', 'to', NULL);
! ERROR:  relation "xc_alter_table_3" does not exist
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 to NODE (datanode_1)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  -- Add some nodes on it
  SELECT alter_table_change_nodes('xc_alter_table_3', '{2,4,5}', 'add', NULL);
! ERROR:  relation "xc_alter_table_3" does not exist
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 TO NODE (datanode_2, datanode_1)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check in tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  -- Remove some nodes on it
  SELECT alter_table_change_nodes('xc_alter_table_3', '{3}', 'add', NULL);
! ERROR:  relation "xc_alter_table_3" does not exist
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 TO NODE (datanode_1)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT alter_table_change_nodes('xc_alter_table_3', '{2,3,5}', 'delete', NULL);
! ERROR:  relation "xc_alter_table_3" does not exist
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 TO NODE (datanode_2, datanode_1)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  -- Multiple operations with replication
  SELECT alter_table_change_nodes('xc_alter_table_3', '{1,3,4,5}', 'to', 'replication');
! ERROR:  relation "xc_alter_table_3" does not exist
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 TO NODE (datanode_1), DISTRIBUTE BY replication"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  -- Manipulate number of nodes to include and remove nodes on a replicated table
  -- On removed nodes data is deleted and on new nodes data is added
  SELECT alter_table_change_nodes('xc_alter_table_3', '{2,3,5}', 'to', NULL);
! ERROR:  relation "xc_alter_table_3" does not exist
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 TO NODE (datanode_2, datanode_1)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  -- Re-do a double operation with hash this time
  SELECT alter_table_change_nodes('xc_alter_table_3', '{2}', 'delete', 'hash(a)');
! ERROR:  relation "xc_alter_table_3" does not exist
  CONTEXT:  SQL statement "ALTER TABLE xc_alter_table_3 delete NODE (datanode_2), DISTRIBUTE BY hash(a)"
  PL/pgSQL function alter_table_change_nodes(character varying,integer[],character varying,character varying) line 79 at EXECUTE
  SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3; -- Check on tuple presence
! ERROR:  relation "xc_alter_table_3" does not exist
! LINE 1: SELECT count(*), sum(a), avg(a) FROM xc_alter_table_3;
!                                              ^
! SELECT * FROM xc_alter_table_3_v;
! ERROR:  relation "xc_alter_table_3_v" does not exist
! LINE 1: SELECT * FROM xc_alter_table_3_v;
!                       ^
  -- Error checks
  ALTER TABLE xc_alter_table_3 ADD COLUMN b int, DISTRIBUTE BY HASH(a);
! ERROR:  relation "xc_alter_table_3" does not exist
  -- Clean up
  DROP TABLE xc_alter_table_3 CASCADE;
! ERROR:  table "xc_alter_table_3" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_sequence.out"	2025-07-31 16:07:15.010067739 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_sequence.out"	2025-07-31 16:40:51.350346071 +0800
***************
*** 99,169 ****
  -- Columns with SERIAL
  -- Serial sequence is named xc_sequence_tab1_col2_seq
  CREATE TABLE xc_sequence_tab1 (col1 int, col2 serial) DISTRIBUTE BY ROUNDROBIN;
  -- Some data
  INSERT INTO xc_sequence_tab1 VALUES (1, DEFAULT);
  INSERT INTO xc_sequence_tab1 VALUES (2, DEFAULT);
  SELECT col1, col2 FROM xc_sequence_tab1 ORDER BY 1;
!  col1 | col2 
! ------+------
!     1 |    1
!     2 |    2
! (2 rows)
! 
  -- Rollback a SERIAL column drop
  BEGIN;
  ALTER TABLE xc_sequence_tab1 DROP COLUMN col2;
  INSERT INTO xc_sequence_tab1 VALUES (3);
  SELECT col1 FROM xc_sequence_tab1 ORDER BY 1;
!  col1 
! ------
!     1
!     2
!     3
! (3 rows)
! 
  ROLLBACK;
  SELECT nextval('xc_sequence_tab1_col2_seq'); -- ok
!  nextval 
! ---------
!        3
! (1 row)
! 
  -- Commit a SERIAL column drop
  BEGIN;
  ALTER TABLE xc_sequence_tab1 DROP COLUMN col2;
  INSERT INTO xc_sequence_tab1 VALUES (3);
  SELECT col1 FROM xc_sequence_tab1 ORDER BY 1;
!  col1 
! ------
!     1
!     2
!     3
! (3 rows)
! 
  COMMIT;
  DROP TABLE xc_sequence_tab1;
  -- Need to recreate here, serial column is no more
  CREATE TABLE xc_sequence_tab1 (col1 int, col2 serial) DISTRIBUTE BY ROUNDROBIN;
  INSERT INTO xc_sequence_tab1 VALUES (1234, DEFAULT);
  SELECT col1, col2 FROM xc_sequence_tab1 ORDER BY 1;
!  col1 | col2 
! ------+------
!  1234 |    1
! (1 row)
! 
  -- Rollback of a table with SERIAL
  BEGIN;
  DROP TABLE xc_sequence_tab1;
  ROLLBACK;
  SELECT nextval('xc_sequence_tab1_col2_seq'); -- ok
!  nextval 
! ---------
!        2
! (1 row)
! 
  -- Commit of a table with SERIAL
  BEGIN;
  DROP TABLE xc_sequence_tab1;
  COMMIT;
  -- Recreate a sequence with the same name as previous SERIAL one
  CREATE SEQUENCE xc_sequence_tab1_col2_seq START 2344;
--- 99,166 ----
  -- Columns with SERIAL
  -- Serial sequence is named xc_sequence_tab1_col2_seq
  CREATE TABLE xc_sequence_tab1 (col1 int, col2 serial) DISTRIBUTE BY ROUNDROBIN;
+ ERROR:  Cannot support distribute type: RoundRobin
  -- Some data
  INSERT INTO xc_sequence_tab1 VALUES (1, DEFAULT);
+ ERROR:  relation "xc_sequence_tab1" does not exist
+ LINE 1: INSERT INTO xc_sequence_tab1 VALUES (1, DEFAULT);
+                     ^
  INSERT INTO xc_sequence_tab1 VALUES (2, DEFAULT);
+ ERROR:  relation "xc_sequence_tab1" does not exist
+ LINE 1: INSERT INTO xc_sequence_tab1 VALUES (2, DEFAULT);
+                     ^
  SELECT col1, col2 FROM xc_sequence_tab1 ORDER BY 1;
! ERROR:  relation "xc_sequence_tab1" does not exist
! LINE 1: SELECT col1, col2 FROM xc_sequence_tab1 ORDER BY 1;
!                                ^
  -- Rollback a SERIAL column drop
  BEGIN;
  ALTER TABLE xc_sequence_tab1 DROP COLUMN col2;
+ ERROR:  relation "xc_sequence_tab1" does not exist
  INSERT INTO xc_sequence_tab1 VALUES (3);
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT col1 FROM xc_sequence_tab1 ORDER BY 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  SELECT nextval('xc_sequence_tab1_col2_seq'); -- ok
! ERROR:  relation "xc_sequence_tab1_col2_seq" does not exist
! LINE 1: SELECT nextval('xc_sequence_tab1_col2_seq');
!                        ^
  -- Commit a SERIAL column drop
  BEGIN;
  ALTER TABLE xc_sequence_tab1 DROP COLUMN col2;
+ ERROR:  relation "xc_sequence_tab1" does not exist
  INSERT INTO xc_sequence_tab1 VALUES (3);
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT col1 FROM xc_sequence_tab1 ORDER BY 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  COMMIT;
  DROP TABLE xc_sequence_tab1;
+ ERROR:  table "xc_sequence_tab1" does not exist
  -- Need to recreate here, serial column is no more
  CREATE TABLE xc_sequence_tab1 (col1 int, col2 serial) DISTRIBUTE BY ROUNDROBIN;
+ ERROR:  Cannot support distribute type: RoundRobin
  INSERT INTO xc_sequence_tab1 VALUES (1234, DEFAULT);
+ ERROR:  relation "xc_sequence_tab1" does not exist
+ LINE 1: INSERT INTO xc_sequence_tab1 VALUES (1234, DEFAULT);
+                     ^
  SELECT col1, col2 FROM xc_sequence_tab1 ORDER BY 1;
! ERROR:  relation "xc_sequence_tab1" does not exist
! LINE 1: SELECT col1, col2 FROM xc_sequence_tab1 ORDER BY 1;
!                                ^
  -- Rollback of a table with SERIAL
  BEGIN;
  DROP TABLE xc_sequence_tab1;
+ ERROR:  table "xc_sequence_tab1" does not exist
  ROLLBACK;
  SELECT nextval('xc_sequence_tab1_col2_seq'); -- ok
! ERROR:  relation "xc_sequence_tab1_col2_seq" does not exist
! LINE 1: SELECT nextval('xc_sequence_tab1_col2_seq');
!                        ^
  -- Commit of a table with SERIAL
  BEGIN;
  DROP TABLE xc_sequence_tab1;
+ ERROR:  table "xc_sequence_tab1" does not exist
  COMMIT;
  -- Recreate a sequence with the same name as previous SERIAL one
  CREATE SEQUENCE xc_sequence_tab1_col2_seq START 2344;
***************
*** 463,468 ****
  --------+---------+-----------+----------+---------------------------------------+---------+--------------+-------------
   a      | integer |           | not null | nextval('xl_testtab_a_seq'::regclass) | plain   |              | 
   b      | integer |           |          |                                       | plain   |              | 
! Distribute By: HASH(a)
  Location Nodes: ALL DATANODES
  
--- 460,465 ----
  --------+---------+-----------+----------+---------------------------------------+---------+--------------+-------------
   a      | integer |           | not null | nextval('xl_testtab_a_seq'::regclass) | plain   |              | 
   b      | integer |           |          |                                       | plain   |              | 
! Distribute By: SHARD(a)
  Location Nodes: ALL DATANODES
  

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_misc.out"	2025-07-31 16:07:15.010067739 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_misc.out"	2025-07-31 16:40:51.541342055 +0800
***************
*** 22,52 ****
  $$;
  -- Test the system column added by XC called xc_node_id, used to find which tuples belong to which data node
  select create_table_nodes('t1_misc(a int, b int)', '{1, 2}'::int[], 'modulo(a)', NULL);
!  create_table_nodes 
! --------------------
!  
! (1 row)
! 
  insert into t1_misc values(1,11),(2,11),(3,11),(4,22),(5,22),(6,33),(7,44),(8,44);
  select get_unified_node_name(xc_node_id),* from t1_misc order by a;
!  get_unified_node_name | a | b  
! -----------------------+---+----
!  NODE_2                | 1 | 11
!  NODE_1                | 2 | 11
!  NODE_2                | 3 | 11
!  NODE_1                | 4 | 22
!  NODE_2                | 5 | 22
!  NODE_1                | 6 | 33
!  NODE_2                | 7 | 44
!  NODE_1                | 8 | 44
! (8 rows)
! 
  --select get_unified_node_name(xc_node_id),* from t1_misc where xc_node_id > 0 order by a;
  create table t2_misc(a int , xc_node_id int) distribute by modulo(a);
! ERROR:  column name "xc_node_id" conflicts with a system column name
  create table t2_misc(a int , b int) distribute by modulo(xc_node_id);
! ERROR:  Invalid distribution column specified
  drop table t1_misc;
  -- Test an SQL function with multiple statements in it including a utility statement.
  create table my_tab1 (a int);
  insert into my_tab1 values(1);
--- 22,45 ----
  $$;
  -- Test the system column added by XC called xc_node_id, used to find which tuples belong to which data node
  select create_table_nodes('t1_misc(a int, b int)', '{1, 2}'::int[], 'modulo(a)', NULL);
! ERROR:  Cannot support distribute type: Hash
! CONTEXT:  SQL statement "CREATE TABLE t1_misc(a int, b int) DISTRIBUTE BY modulo(a) TO NODE (datanode_1, datanode_2)"
! PL/pgSQL function create_table_nodes(character varying,integer[],character varying,character varying) line 37 at EXECUTE
  insert into t1_misc values(1,11),(2,11),(3,11),(4,22),(5,22),(6,33),(7,44),(8,44);
+ ERROR:  relation "t1_misc" does not exist
+ LINE 1: insert into t1_misc values(1,11),(2,11),(3,11),(4,22),(5,22)...
+                     ^
  select get_unified_node_name(xc_node_id),* from t1_misc order by a;
! ERROR:  relation "t1_misc" does not exist
! LINE 1: select get_unified_node_name(xc_node_id),* from t1_misc orde...
!                                                         ^
  --select get_unified_node_name(xc_node_id),* from t1_misc where xc_node_id > 0 order by a;
  create table t2_misc(a int , xc_node_id int) distribute by modulo(a);
! ERROR:  Cannot support distribute type: Hash
  create table t2_misc(a int , b int) distribute by modulo(xc_node_id);
! ERROR:  Cannot support distribute type: Hash
  drop table t1_misc;
+ ERROR:  table "t1_misc" does not exist
  -- Test an SQL function with multiple statements in it including a utility statement.
  create table my_tab1 (a int);
  insert into my_tab1 values(1);
***************
*** 55,61 ****
  create function f1 () returns setof my_tab1 as $$ create table my_tab2 (a int); select * from my_tab1; $$ language sql;
  ERROR:  function "f1" already exists with same argument types
  select f1();
! ERROR:  Unexpected response from coordinator
  CONTEXT:  SQL function "f1" statement 1
  SET check_function_bodies = true;
  drop function f1();
--- 48,54 ----
  create function f1 () returns setof my_tab1 as $$ create table my_tab2 (a int); select * from my_tab1; $$ language sql;
  ERROR:  function "f1" already exists with same argument types
  select f1();
! ERROR:  Unexpected response from coord2 pid 383336
  CONTEXT:  SQL function "f1" statement 1
  SET check_function_bodies = true;
  drop function f1();

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_node_1.out"	2025-07-31 16:07:15.010067739 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_node.out"	2025-07-31 16:41:08.112932150 +0800
***************
*** 36,42 ****
--- 36,44 ----
  (2 rows)
  
  DROP NODE dummy_node_coordinator;
+ WARNING:  this node[32690] is not exist in any group.
  DROP NODE dummy_node_datanode;
+ WARNING:  this node[32691] is not exist in any group.
  -- Check for error messages
  CREATE NODE dummy_node WITH (TYPE = 'dummy'); -- fail
  ERROR:  type value is incorrect, specify 'coordinator or 'datanode' or 'gtm'
***************
*** 56,61 ****
--- 58,64 ----
  CREATE NODE dummy_node WITH (TYPE = 'datanode');
  ALTER NODE dummy_node WITH (TYPE = 'coordinator');
  DROP NODE dummy_node;
+ WARNING:  this node[32692] is not exist in any group.
  CREATE NODE dummy_node WITH (TYPE = 'coordinator');
  ALTER NODE dummy_node WITH (PREFERRED);
  ERROR:  PGXC node dummy_node: cannot be a preferred node, it has to be a Datanode
***************
*** 63,65 ****
--- 66,69 ----
  ERROR:  PGXC node dummy_node: cannot be a primary node, it has to be a Datanode or GTM
  ALTER NODE dummy_node WITH (TYPE = 'datanode');
  DROP NODE dummy_node;
+ WARNING:  this node[32693] is not exist in any group.

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xc_notrans_block.out"	2025-07-31 16:37:23.182096748 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xc_notrans_block.out"	2025-07-31 16:41:23.345675108 +0800
***************
*** 19,26 ****
  
  -- This should fail because we have one tablespace created on data node 1.
  CREATE TABLESPACE xc_testspace1 LOCATION '/home/wyx//opentenbase/src/test/regress/testtablespace';
! ERROR:  tablespace "xc_testspace1" already exists
! CONTEXT:  Error message received from nodes:
  -- Drop tablespace on data node 1.
  select exec_util_on_node('drop TABLESPACE xc_testspace1 ', 1);
   exec_util_on_node 
--- 19,26 ----
  
  -- This should fail because we have one tablespace created on data node 1.
  CREATE TABLESPACE xc_testspace1 LOCATION '/home/wyx//opentenbase/src/test/regress/testtablespace';
! ERROR:  node:datanode_1, backend_pid:386087, nodename:datanode_1,backend_pid:386087,message:tablespace "xc_testspace1" already exists
! CONTEXT:  Error message received from nodes: datanode#2 coordinator#2
  -- Drop tablespace on data node 1.
  select exec_util_on_node('drop TABLESPACE xc_testspace1 ', 1);
   exec_util_on_node 
***************
*** 46,53 ****
  
  -- This should not work because there is no tablespace on datanode1
  CREATE DATABASE xc_db tablespace xc_testspace1;
! ERROR:  tablespace "xc_testspace1" does not exist
! CONTEXT:  Error message received from nodes:
  select exec_util_on_node('CREATE TABLESPACE xc_testspace1 LOCATION $LOC$/home/wyx//opentenbase/src/test/regress/testtablespace$LOC$', 1);
   exec_util_on_node 
  -------------------
--- 46,53 ----
  
  -- This should not work because there is no tablespace on datanode1
  CREATE DATABASE xc_db tablespace xc_testspace1;
! ERROR:  node:datanode_1, backend_pid:386087, nodename:datanode_1,backend_pid:386087,message:tablespace "xc_testspace1" does not exist
! CONTEXT:  Error message received from nodes: datanode#2 coordinator#2
  select exec_util_on_node('CREATE TABLESPACE xc_testspace1 LOCATION $LOC$/home/wyx//opentenbase/src/test/regress/testtablespace$LOC$', 1);
   exec_util_on_node 
  -------------------
***************
*** 83,90 ****
  clean connection to all for database xc_db;
  -- This should error out, since we don't have tablespace on data node 1
  alter database xc_db set tablespace xc_testspace1;
! ERROR:  tablespace "xc_testspace1" does not exist
! CONTEXT:  Error message received from nodes:
  select exec_util_on_node('CREATE TABLESPACE xc_testspace1 LOCATION $LOC$/home/wyx//opentenbase/src/test/regress/testtablespace$LOC$', 1);
   exec_util_on_node 
  -------------------
--- 83,90 ----
  clean connection to all for database xc_db;
  -- This should error out, since we don't have tablespace on data node 1
  alter database xc_db set tablespace xc_testspace1;
! ERROR:  node:datanode_2, backend_pid:386116, nodename:datanode_1,backend_pid:386087,message:tablespace "xc_testspace1" does not exist
! CONTEXT:  Error message received from nodes: coordinator#2
  select exec_util_on_node('CREATE TABLESPACE xc_testspace1 LOCATION $LOC$/home/wyx//opentenbase/src/test/regress/testtablespace$LOC$', 1);
   exec_util_on_node 
  -------------------
***************
*** 93,98 ****
--- 93,101 ----
  
  -- Now this should work.
  alter database xc_db set tablespace xc_testspace1;
+ ERROR:  node:datanode_2, backend_pid:386116, nodename:datanode_1,backend_pid:386087,message:database "xc_db" is being accessed by other users
+ DETAIL:  There are 20 other sessions using the database.
+ CONTEXT:  Error message received from nodes: coordinator#2
  -- Verify data in the objects created earlier
  \c xc_db
  select * from xc_tab1 order by id;
***************
*** 154,157 ****
  clean connection to all for database xc_db;
  drop database xc_db;
  drop tablespace xc_testspace1;
- ERROR:  tablespace "xc_testspace1" is not empty
--- 157,159 ----

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xl_primary_key.out"	2025-07-31 16:07:15.011067723 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xl_primary_key.out"	2025-07-31 16:41:23.583132485 +0800
***************
*** 4,30 ****
  -- this condition (distribution by second column of PRIMARY KEY ) is not erroneous. It is supported.
   
  CREATE TABLE xl_pk_products ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid, product_no) ) DISTRIBUTE BY HASH(product_no);
  CREATE TABLE xl_pk_products1 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid, product_no) ) DISTRIBUTE BY HASH(product_uid);
  CREATE TABLE xl_pk_products2 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid) ) DISTRIBUTE BY HASH(product_no); 
  ERROR:  Unique index of partitioned table must contain the hash distribution column.
  CREATE TABLE xl_pk_products3 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_no, product_uid) ) DISTRIBUTE BY MODULO(product_no);
  CREATE TABLE xl_pk_products4 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid, product_no) ) DISTRIBUTE BY MODULO(product_no);
  CREATE TABLE xl_pk_products5 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid) ) DISTRIBUTE BY MODULO(product_no);
  ERROR:  Unique index of partitioned table must contain the hash distribution column.
  --For roundrobin distributed table, PRIMARY KEY or UNIQUE INDEX is not supported
  CREATE TABLE xl_pk_products6 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid) ) DISTRIBUTE BY ROUNDROBIN;
  ERROR:  Cannot locally enforce a unique index on round robin distributed table.
  CREATE TABLE xl_pk_products7 ( product_no integer, product_uid integer, name text, price numeric ) DISTRIBUTE BY ROUNDROBIN;
  CREATE UNIQUE INDEX product_uuid ON xl_pk_products7 (product_uid, product_no); 
! ERROR:  Cannot locally enforce a unique index on round robin distributed table.
  DROP TABLE xl_pk_products; 
  DROP TABLE xl_pk_products1; 
  DROP TABLE xl_pk_products2; 
  ERROR:  table "xl_pk_products2" does not exist
  DROP TABLE xl_pk_products3; 
  DROP TABLE xl_pk_products4; 
  DROP TABLE xl_pk_products5; 
  ERROR:  table "xl_pk_products5" does not exist
  DROP TABLE xl_pk_products6; 
  ERROR:  table "xl_pk_products6" does not exist
  DROP TABLE xl_pk_products7;
--- 4,40 ----
  -- this condition (distribution by second column of PRIMARY KEY ) is not erroneous. It is supported.
   
  CREATE TABLE xl_pk_products ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid, product_no) ) DISTRIBUTE BY HASH(product_no);
+ ERROR:  Cannot support distribute type: Hash
  CREATE TABLE xl_pk_products1 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid, product_no) ) DISTRIBUTE BY HASH(product_uid);
+ ERROR:  Cannot support distribute type: Hash
  CREATE TABLE xl_pk_products2 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid) ) DISTRIBUTE BY HASH(product_no); 
  ERROR:  Unique index of partitioned table must contain the hash distribution column.
  CREATE TABLE xl_pk_products3 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_no, product_uid) ) DISTRIBUTE BY MODULO(product_no);
+ ERROR:  Cannot support distribute type: Hash
  CREATE TABLE xl_pk_products4 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid, product_no) ) DISTRIBUTE BY MODULO(product_no);
+ ERROR:  Cannot support distribute type: Hash
  CREATE TABLE xl_pk_products5 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid) ) DISTRIBUTE BY MODULO(product_no);
  ERROR:  Unique index of partitioned table must contain the hash distribution column.
  --For roundrobin distributed table, PRIMARY KEY or UNIQUE INDEX is not supported
  CREATE TABLE xl_pk_products6 ( product_no integer, product_uid integer, name text, price numeric, primary key (product_uid) ) DISTRIBUTE BY ROUNDROBIN;
  ERROR:  Cannot locally enforce a unique index on round robin distributed table.
  CREATE TABLE xl_pk_products7 ( product_no integer, product_uid integer, name text, price numeric ) DISTRIBUTE BY ROUNDROBIN;
+ ERROR:  Cannot support distribute type: RoundRobin
  CREATE UNIQUE INDEX product_uuid ON xl_pk_products7 (product_uid, product_no); 
! ERROR:  relation "xl_pk_products7" does not exist
  DROP TABLE xl_pk_products; 
+ ERROR:  table "xl_pk_products" does not exist
  DROP TABLE xl_pk_products1; 
+ ERROR:  table "xl_pk_products1" does not exist
  DROP TABLE xl_pk_products2; 
  ERROR:  table "xl_pk_products2" does not exist
  DROP TABLE xl_pk_products3; 
+ ERROR:  table "xl_pk_products3" does not exist
  DROP TABLE xl_pk_products4; 
+ ERROR:  table "xl_pk_products4" does not exist
  DROP TABLE xl_pk_products5; 
  ERROR:  table "xl_pk_products5" does not exist
  DROP TABLE xl_pk_products6; 
  ERROR:  table "xl_pk_products6" does not exist
  DROP TABLE xl_pk_products7;
+ ERROR:  table "xl_pk_products7" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xl_foreign_key.out"	2025-07-31 16:07:15.011067723 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xl_foreign_key.out"	2025-07-31 16:41:23.880663917 +0800
***************
*** 20,36 ****
--- 20,39 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO(product_no);
+ ERROR:  Cannot support distribute type: Hash
  CREATE TABLE xl_fk_products11 (
      product_no integer ,
      product_id integer PRIMARY KEY,
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO(product_id);
+ ERROR:  Cannot support distribute type: Hash
  CREATE TABLE xl_fk_orders (
      order_id integer,
      product_no integer REFERENCES xl_fk_products (product_no),
      quantity integer
  ) DISTRIBUTE BY HASH(product_no);
+ ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  --pass
  CREATE TABLE xl_fk_orders01 (
      order_id integer,
***************
*** 44,49 ****
--- 47,53 ----
      product_no integer REFERENCES xl_fk_products1 (product_no),
      quantity integer
  ) DISTRIBUTE BY MODULO(product_no);
+ ERROR:  relation "xl_fk_products1" does not exist
  --pass - as source is also modulo distributed
  CREATE TABLE xl_fk_orders1 (
      order_id integer,
***************
*** 70,76 ****
      product_no integer REFERENCES xl_fk_products1 (product_id),
      quantity integer
  ) DISTRIBUTE BY MODULO(order_id); 
! ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  -- fail- as references is using a different column that primary key of referred table
  --This also implies that more than one FOREIGN KEY constraints cannot be specified
  CREATE TABLE xl_fk_orders5 (
--- 74,80 ----
      product_no integer REFERENCES xl_fk_products1 (product_id),
      quantity integer
  ) DISTRIBUTE BY MODULO(order_id); 
! ERROR:  relation "xl_fk_products1" does not exist
  -- fail- as references is using a different column that primary key of referred table
  --This also implies that more than one FOREIGN KEY constraints cannot be specified
  CREATE TABLE xl_fk_orders5 (
***************
*** 86,96 ****
      product_id integer REFERENCES xl_fk_products11 (product_id),
      quantity integer
  ) DISTRIBUTE BY MODULO(order_id); 
! ERROR:  Hash/Modulo distribution column does not refer to hash/modulo distribution column in referenced table.
  DROP TABLE xl_fk_orders;
  DROP TABLE xl_fk_orders01;
  ERROR:  table "xl_fk_orders01" does not exist
  DROP TABLE xl_fk_orders02;
  DROP TABLE xl_fk_orders1;
  ERROR:  table "xl_fk_orders1" does not exist
  DROP TABLE xl_fk_orders2;
--- 90,102 ----
      product_id integer REFERENCES xl_fk_products11 (product_id),
      quantity integer
  ) DISTRIBUTE BY MODULO(order_id); 
! ERROR:  relation "xl_fk_products1" does not exist
  DROP TABLE xl_fk_orders;
+ ERROR:  table "xl_fk_orders" does not exist
  DROP TABLE xl_fk_orders01;
  ERROR:  table "xl_fk_orders01" does not exist
  DROP TABLE xl_fk_orders02;
+ ERROR:  table "xl_fk_orders02" does not exist
  DROP TABLE xl_fk_orders1;
  ERROR:  table "xl_fk_orders1" does not exist
  DROP TABLE xl_fk_orders2;
***************
*** 106,109 ****
--- 112,117 ----
  DROP TABLE xl_fk_products;
  DROP TABLE xl_fk_products01;
  DROP TABLE xl_fk_products1;
+ ERROR:  table "xl_fk_products1" does not exist
  DROP TABLE xl_fk_products11;
+ ERROR:  table "xl_fk_products11" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xl_distribution_column_types_1.out"	2025-07-31 16:07:15.011067723 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xl_distribution_column_types.out"	2025-07-31 16:41:23.878663959 +0800
***************
*** 6,11 ****
--- 6,12 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (product_id);
+ ERROR:  Cannot support distribute type: Hash
  --INT2, 
  CREATE TABLE xl_dc1 (
      product_no integer,
***************
*** 13,18 ****
--- 14,20 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (product_id);
+ ERROR:  Cannot support distribute type: Hash
  --OID, 
  CREATE TABLE xl_dc2 (
      product_no integer,
***************
*** 20,25 ****
--- 22,28 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (product_id);
+ ERROR:  Cannot support distribute type: Hash
  --INT4, 
  CREATE TABLE xl_dc3 (
      product_no integer,
***************
*** 27,32 ****
--- 30,36 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (product_id);
+ ERROR:  Cannot support distribute type: Hash
  --BOOL, 
  CREATE TABLE xl_dc4 (
      product_no integer,
***************
*** 34,39 ****
--- 38,44 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (is_available);
+ ERROR:  Cannot support distribute type: Hash
  --OIDVECTOR, 
  CREATE TABLE xl_dc6 (
      product_no integer,
***************
*** 42,47 ****
--- 47,53 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (sub_product_ids);
+ ERROR:  Cannot support distribute type: Hash
  --CHAR, 
  CREATE TABLE xl_dc7 (
      product_no integer,
***************
*** 49,54 ****
--- 55,61 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (product_group);
+ ERROR:  Cannot support distribute type: Hash
  --NAME, 
  CREATE TABLE xl_dc8 (
      product_no integer,
***************
*** 56,61 ****
--- 63,69 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (product_name);
+ ERROR:  Cannot support distribute type: Hash
  --TEXT, 
  CREATE TABLE xl_dc9 (
      product_no integer,
***************
*** 63,68 ****
--- 71,77 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (product_name);
+ ERROR:  Cannot support distribute type: Hash
  --BPCHAR - blank padded char, 
  CREATE TABLE xl_dc10 (
      product_no integer,
***************
*** 70,75 ****
--- 79,85 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (product_group);
+ ERROR:  Cannot support distribute type: Hash
  --BYTEA - variable length binary string, 
  CREATE TABLE xl_dc11 (
      product_no integer,
***************
*** 77,82 ****
--- 87,93 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (product_group);
+ ERROR:  Cannot support distribute type: Hash
  --VARCHAR, 
  CREATE TABLE xl_dc12 (
      product_no integer,
***************
*** 84,89 ****
--- 95,101 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (product_group);
+ ERROR:  Cannot support distribute type: Hash
  --NUMERIC, 
  CREATE TABLE xl_dc15 (
      product_no integer,
***************
*** 91,96 ****
--- 103,109 ----
      name text,
      price numeric
  ) DISTRIBUTE BY HASH (product_id);
+ ERROR:  Cannot support distribute type: Hash
  --MONEY - String datatype, 
  CREATE TABLE xl_dc16 (
      product_no integer,
***************
*** 98,103 ****
--- 111,117 ----
      name MONEY PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY HASH (name);
+ ERROR:  Cannot support distribute type: Hash
  --ABSTIME, 
  CREATE TABLE xl_dc17 (
      product_no integer,
***************
*** 105,110 ****
--- 119,125 ----
      purchase_date ABSTIME PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY HASH (purchase_date);
+ ERROR:  Cannot support distribute type: Hash
  --RELTIME, 
  CREATE TABLE xl_dc18 (
      product_no integer,
***************
*** 113,118 ****
--- 128,134 ----
      purchase_date RELTIME PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY HASH (purchase_date);
+ ERROR:  Cannot support distribute type: Hash
  --DATE, 
  CREATE TABLE xl_dc19 (
      product_no integer,
***************
*** 121,126 ****
--- 137,143 ----
      purchase_date DATE PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY HASH (purchase_date);
+ ERROR:  Cannot support distribute type: Hash
  --TIME, 
  CREATE TABLE xl_dc20 (
      product_no integer,
***************
*** 129,134 ****
--- 146,152 ----
      purchase_date TIME PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY HASH (purchase_date);
+ ERROR:  Cannot support distribute type: Hash
  --TIMESTAMP,
  CREATE TABLE xl_dc21 (
      product_no integer,
***************
*** 137,142 ****
--- 155,161 ----
      purchase_date TIMESTAMP PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY HASH (purchase_date); 
+ ERROR:  Cannot support distribute type: Hash
  --TIMESTAMPTZ, 
  CREATE TABLE xl_dc22 (
      product_no integer,
***************
*** 145,150 ****
--- 164,170 ----
      purchase_date TIMESTAMPTZ PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY HASH (purchase_date); 
+ ERROR:  Cannot support distribute type: Hash
  --INTERVAL, 
  CREATE TABLE xl_dc23 (
      product_no integer,
***************
*** 153,158 ****
--- 173,179 ----
      purchase_date INTERVAL PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY HASH (purchase_date); 
+ ERROR:  Cannot support distribute type: Hash
  --and TIMETZ - time along with time zone
  CREATE TABLE xl_dc24 (
      product_no integer,
***************
*** 161,166 ****
--- 182,188 ----
      purchase_date TIMETZ PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY HASH (purchase_date); 
+ ERROR:  Cannot support distribute type: Hash
  --Distribution strategy can specify on a single column
  CREATE TABLE xl_dc25 (
      product_no integer,
***************
*** 170,176 ****
      price numeric,
      primary key(product_no, product_id)
  ) DISTRIBUTE BY HASH (product_no, product_id); --fail
! ERROR:  too many distributed keys for non-shard table, only one distributed key is allowed.
  -- Distribution column value cannot be updated
  -- default distributed on HASH by primary key column, i.e. city
  CREATE TABLE xl_dc_weather (
--- 192,198 ----
      price numeric,
      primary key(product_no, product_id)
  ) DISTRIBUTE BY HASH (product_no, product_id); --fail
! ERROR:  Cannot support distribute type: Hash
  -- Distribution column value cannot be updated
  -- default distributed on HASH by primary key column, i.e. city
  CREATE TABLE xl_dc_weather (
***************
*** 184,210 ****
--- 206,254 ----
  UPDATE xl_dc_weather SET city = 'SFO' where temp_lo=46 and temp_hi=50; -- fail
  ERROR:  Distributed column or partition column "city" can't be updated in current version
  DROP TABLE xl_dc;
+ ERROR:  table "xl_dc" does not exist
  DROP TABLE xl_dc1;
+ ERROR:  table "xl_dc1" does not exist
  DROP TABLE xl_dc2;
+ ERROR:  table "xl_dc2" does not exist
  DROP TABLE xl_dc3;
+ ERROR:  table "xl_dc3" does not exist
  DROP TABLE xl_dc4;
+ ERROR:  table "xl_dc4" does not exist
  DROP TABLE xl_dc6;
+ ERROR:  table "xl_dc6" does not exist
  DROP TABLE xl_dc7;
+ ERROR:  table "xl_dc7" does not exist
  DROP TABLE xl_dc8;
+ ERROR:  table "xl_dc8" does not exist
  DROP TABLE xl_dc9;
+ ERROR:  table "xl_dc9" does not exist
  DROP TABLE xl_dc10;
+ ERROR:  table "xl_dc10" does not exist
  DROP TABLE xl_dc11;
+ ERROR:  table "xl_dc11" does not exist
  DROP TABLE xl_dc12;
+ ERROR:  table "xl_dc12" does not exist
  DROP TABLE xl_dc15;
+ ERROR:  table "xl_dc15" does not exist
  DROP TABLE xl_dc16;
+ ERROR:  table "xl_dc16" does not exist
  DROP TABLE xl_dc17;
+ ERROR:  table "xl_dc17" does not exist
  DROP TABLE xl_dc18;
+ ERROR:  table "xl_dc18" does not exist
  DROP TABLE xl_dc19;
+ ERROR:  table "xl_dc19" does not exist
  DROP TABLE xl_dc20;
+ ERROR:  table "xl_dc20" does not exist
  DROP TABLE xl_dc21;
+ ERROR:  table "xl_dc21" does not exist
  DROP TABLE xl_dc22;
+ ERROR:  table "xl_dc22" does not exist
  DROP TABLE xl_dc23;
+ ERROR:  table "xl_dc23" does not exist
  DROP TABLE xl_dc24;
+ ERROR:  table "xl_dc24" does not exist
  DROP TABLE xl_dc25;
  ERROR:  table "xl_dc25" does not exist
  DROP TABLE xl_dc_weather;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xl_alter_table.out"	2025-07-31 16:07:15.010067739 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xl_alter_table.out"	2025-07-31 16:41:23.931430795 +0800
***************
*** 4,112 ****
      product_no integer,
      product_id integer PRIMARY KEY
  ) DISTRIBUTE BY HASH (product_id);
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE INT2;
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE INT4;
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE varchar(80);
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE INT8 USING product_id::bigint;
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE INT2;
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE INT4;
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE varchar(80);
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE INT8 USING product_no::bigint;
  INSERT into xl_at (product_no, product_id) VALUES (9223372036854775807, 9223372036854775807);
  -- Value is beyond limit for below smaller integer conversions - so these fail
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE integer;--fail
! ERROR:  integer out of range
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE INT2;--fail
! ERROR:  smallint out of range
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE INT4;--fail
! ERROR:  integer out of range
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE integer;--fail
! ERROR:  integer out of range
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE INT2;--fail
! ERROR:  smallint out of range
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE INT4;--fail
! ERROR:  integer out of range
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE varchar(80);
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE varchar(80);
  --INT8 - converting to varchar, to integer, 
  CREATE TABLE xl_at1 (
      product_no INT8,
      product_id INT8 PRIMARY KEY
  ) DISTRIBUTE BY HASH (product_id);
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE INT2 USING product_id::smallint;
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE INT4 USING product_id::integer;
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE varchar(80);
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE integer USING product_id::integer;
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE INT2 USING product_no::smallint;
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE INT4 USING product_no::integer;
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE varchar(80);
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE integer USING product_no::integer;
  INSERT into xl_at1 (product_no, product_id) VALUES (42, 42);
  -- Value is within limit for smaller integer conversions - so these pass
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE INT8;
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE INT2;
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE INT4;
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE INT8;
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE INT2;
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE INT4;
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE varchar(80);
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE varchar(80);
  -- HASH Distributed table:
  -- Distribution column cannot be dropped. 
  CREATE TABLE xl_at2h (
      product_no INT8,
      product_id INT2
  ) DISTRIBUTE BY HASH (product_id);
  ALTER TABLE xl_at2h DROP COLUMN product_id;--fail - distribution column cannot be dropped. 
! ERROR:  Distribution column cannot be dropped
  ALTER TABLE xl_at2h DISTRIBUTE BY MODULO(product_id);
  ALTER TABLE xl_at2h DISTRIBUTE BY HASH(product_id);
  ALTER TABLE xl_at2h DROP COLUMN product_no;
  ALTER TABLE xl_at2h ADD COLUMN product_no INT8;
  ALTER TABLE xl_at2h ALTER COLUMN product_no SET NOT NULL;
  ALTER TABLE xl_at2h ALTER COLUMN product_id SET NOT NULL;
  ALTER TABLE xl_at2h ALTER COLUMN product_no DROP NOT NULL;
  ALTER TABLE xl_at2h ALTER COLUMN product_id DROP NOT NULL; 
  ALTER TABLE xl_at2h ALTER COLUMN product_no SET DEFAULT 0;
  ALTER TABLE xl_at2h ALTER COLUMN product_id SET DEFAULT 0;
  ALTER TABLE xl_at2h ALTER COLUMN product_no DROP DEFAULT;
  ALTER TABLE xl_at2h ALTER COLUMN product_id DROP DEFAULT;
  ALTER TABLE xl_at2h RENAME COLUMN product_no TO product_number;
  ALTER TABLE xl_at2h RENAME COLUMN product_id TO product_identifier;
  ALTER TABLE xl_at2h RENAME TO xl_at3h;
  ALTER TABLE xl_at3h DELETE NODE (datanode_2);
  ALTER TABLE xl_at3h ADD NODE (datanode_2);
  ALTER TABLE xl_at3h DISTRIBUTE BY REPLICATION; 
  -- MODULO Distributed table:
  CREATE TABLE xl_at2m (
      product_no INT8,
      product_id INT2
  ) DISTRIBUTE BY MODULO (product_id); 
  ALTER TABLE xl_at2m DROP COLUMN product_id;--fail - distribution column cannot be dropped. 
! ERROR:  Distribution column cannot be dropped
  ALTER TABLE xl_at2m DISTRIBUTE BY HASH(product_id);
  ALTER TABLE xl_at2m DISTRIBUTE BY MODULO(product_id);
  ALTER TABLE xl_at2m DROP COLUMN product_no;
  ALTER TABLE xl_at2m ADD COLUMN product_no INT8;
  ALTER TABLE xl_at2m ALTER COLUMN product_no SET NOT NULL;
  ALTER TABLE xl_at2m ALTER COLUMN product_id SET NOT NULL;
  ALTER TABLE xl_at2m ALTER COLUMN product_no DROP NOT NULL;
  ALTER TABLE xl_at2m ALTER COLUMN product_id DROP NOT NULL;
  ALTER TABLE xl_at2m ALTER COLUMN product_no SET DEFAULT 0;
  ALTER TABLE xl_at2m ALTER COLUMN product_id SET DEFAULT 0;
  ALTER TABLE xl_at2m ALTER COLUMN product_no DROP DEFAULT;
  ALTER TABLE xl_at2m ALTER COLUMN product_id DROP DEFAULT;
  ALTER TABLE xl_at2m RENAME COLUMN product_no TO product_number;
  ALTER TABLE xl_at2m RENAME COLUMN product_id TO product_identifier;
  ALTER TABLE xl_at2m RENAME TO xl_at3m;
  ALTER TABLE xl_at3m DELETE NODE (datanode_2);
  ALTER TABLE xl_at3m ADD NODE (datanode_2);
  ALTER TABLE xl_at3m DISTRIBUTE BY REPLICATION;
  DROP TABLE xl_at;
  DROP TABLE xl_at1;
  DROP TABLE xl_at2h;
  ERROR:  table "xl_at2h" does not exist
  DROP TABLE xl_at3h;
  DROP TABLE xl_at2m;
  ERROR:  table "xl_at2m" does not exist
  DROP TABLE xl_at3m;
--- 4,188 ----
      product_no integer,
      product_id integer PRIMARY KEY
  ) DISTRIBUTE BY HASH (product_id);
+ ERROR:  Cannot support distribute type: Hash
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE INT2;
+ ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE INT4;
+ ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE varchar(80);
+ ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE INT8 USING product_id::bigint;
+ ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE INT2;
+ ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE INT4;
+ ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE varchar(80);
+ ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE INT8 USING product_no::bigint;
+ ERROR:  relation "xl_at" does not exist
  INSERT into xl_at (product_no, product_id) VALUES (9223372036854775807, 9223372036854775807);
+ ERROR:  relation "xl_at" does not exist
+ LINE 1: INSERT into xl_at (product_no, product_id) VALUES (922337203...
+                     ^
  -- Value is beyond limit for below smaller integer conversions - so these fail
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE integer;--fail
! ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE INT2;--fail
! ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE INT4;--fail
! ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE integer;--fail
! ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE INT2;--fail
! ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE INT4;--fail
! ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_id TYPE varchar(80);
+ ERROR:  relation "xl_at" does not exist
  ALTER TABLE xl_at ALTER COLUMN product_no TYPE varchar(80);
+ ERROR:  relation "xl_at" does not exist
  --INT8 - converting to varchar, to integer, 
  CREATE TABLE xl_at1 (
      product_no INT8,
      product_id INT8 PRIMARY KEY
  ) DISTRIBUTE BY HASH (product_id);
+ ERROR:  Cannot support distribute type: Hash
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE INT2 USING product_id::smallint;
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE INT4 USING product_id::integer;
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE varchar(80);
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE integer USING product_id::integer;
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE INT2 USING product_no::smallint;
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE INT4 USING product_no::integer;
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE varchar(80);
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE integer USING product_no::integer;
+ ERROR:  relation "xl_at1" does not exist
  INSERT into xl_at1 (product_no, product_id) VALUES (42, 42);
+ ERROR:  relation "xl_at1" does not exist
+ LINE 1: INSERT into xl_at1 (product_no, product_id) VALUES (42, 42);
+                     ^
  -- Value is within limit for smaller integer conversions - so these pass
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE INT8;
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE INT2;
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE INT4;
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE INT8;
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE INT2;
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE INT4;
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_id TYPE varchar(80);
+ ERROR:  relation "xl_at1" does not exist
  ALTER TABLE xl_at1 ALTER COLUMN product_no TYPE varchar(80);
+ ERROR:  relation "xl_at1" does not exist
  -- HASH Distributed table:
  -- Distribution column cannot be dropped. 
  CREATE TABLE xl_at2h (
      product_no INT8,
      product_id INT2
  ) DISTRIBUTE BY HASH (product_id);
+ ERROR:  Cannot support distribute type: Hash
  ALTER TABLE xl_at2h DROP COLUMN product_id;--fail - distribution column cannot be dropped. 
! ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h DISTRIBUTE BY MODULO(product_id);
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h DISTRIBUTE BY HASH(product_id);
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h DROP COLUMN product_no;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h ADD COLUMN product_no INT8;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h ALTER COLUMN product_no SET NOT NULL;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h ALTER COLUMN product_id SET NOT NULL;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h ALTER COLUMN product_no DROP NOT NULL;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h ALTER COLUMN product_id DROP NOT NULL; 
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h ALTER COLUMN product_no SET DEFAULT 0;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h ALTER COLUMN product_id SET DEFAULT 0;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h ALTER COLUMN product_no DROP DEFAULT;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h ALTER COLUMN product_id DROP DEFAULT;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h RENAME COLUMN product_no TO product_number;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h RENAME COLUMN product_id TO product_identifier;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at2h RENAME TO xl_at3h;
+ ERROR:  relation "xl_at2h" does not exist
  ALTER TABLE xl_at3h DELETE NODE (datanode_2);
+ ERROR:  relation "xl_at3h" does not exist
  ALTER TABLE xl_at3h ADD NODE (datanode_2);
+ ERROR:  relation "xl_at3h" does not exist
  ALTER TABLE xl_at3h DISTRIBUTE BY REPLICATION; 
+ ERROR:  relation "xl_at3h" does not exist
  -- MODULO Distributed table:
  CREATE TABLE xl_at2m (
      product_no INT8,
      product_id INT2
  ) DISTRIBUTE BY MODULO (product_id); 
+ ERROR:  Cannot support distribute type: Hash
  ALTER TABLE xl_at2m DROP COLUMN product_id;--fail - distribution column cannot be dropped. 
! ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m DISTRIBUTE BY HASH(product_id);
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m DISTRIBUTE BY MODULO(product_id);
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m DROP COLUMN product_no;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m ADD COLUMN product_no INT8;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m ALTER COLUMN product_no SET NOT NULL;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m ALTER COLUMN product_id SET NOT NULL;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m ALTER COLUMN product_no DROP NOT NULL;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m ALTER COLUMN product_id DROP NOT NULL;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m ALTER COLUMN product_no SET DEFAULT 0;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m ALTER COLUMN product_id SET DEFAULT 0;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m ALTER COLUMN product_no DROP DEFAULT;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m ALTER COLUMN product_id DROP DEFAULT;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m RENAME COLUMN product_no TO product_number;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m RENAME COLUMN product_id TO product_identifier;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at2m RENAME TO xl_at3m;
+ ERROR:  relation "xl_at2m" does not exist
  ALTER TABLE xl_at3m DELETE NODE (datanode_2);
+ ERROR:  relation "xl_at3m" does not exist
  ALTER TABLE xl_at3m ADD NODE (datanode_2);
+ ERROR:  relation "xl_at3m" does not exist
  ALTER TABLE xl_at3m DISTRIBUTE BY REPLICATION;
+ ERROR:  relation "xl_at3m" does not exist
  DROP TABLE xl_at;
+ ERROR:  table "xl_at" does not exist
  DROP TABLE xl_at1;
+ ERROR:  table "xl_at1" does not exist
  DROP TABLE xl_at2h;
  ERROR:  table "xl_at2h" does not exist
  DROP TABLE xl_at3h;
+ ERROR:  table "xl_at3h" does not exist
  DROP TABLE xl_at2m;
  ERROR:  table "xl_at2m" does not exist
  DROP TABLE xl_at3m;
+ ERROR:  table "xl_at3m" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xl_distribution_column_types_modulo_1.out"	2025-07-31 16:07:15.011067723 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xl_distribution_column_types_modulo.out"	2025-07-31 16:41:23.824665088 +0800
***************
*** 7,12 ****
--- 7,13 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_id);
+ ERROR:  Cannot support distribute type: Hash
  --integer
  CREATE TABLE xl_dcm0 (
      product_no integer,
***************
*** 14,19 ****
--- 15,21 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_id);
+ ERROR:  Cannot support distribute type: Hash
  --INT2, 
  CREATE TABLE xl_dcm1 (
      product_no integer,
***************
*** 21,26 ****
--- 23,29 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_id);
+ ERROR:  Cannot support distribute type: Hash
  --OID, 
  CREATE TABLE xl_dcm2 (
      product_no integer,
***************
*** 28,34 ****
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_id);
! ERROR:  Column product_id is not modulo distributable data type
  --INT4, 
  CREATE TABLE xl_dcm3 (
      product_no integer,
--- 31,37 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_id);
! ERROR:  Cannot support distribute type: Hash
  --INT4, 
  CREATE TABLE xl_dcm3 (
      product_no integer,
***************
*** 36,41 ****
--- 39,45 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_id);
+ ERROR:  Cannot support distribute type: Hash
  --BOOL, 
  CREATE TABLE xl_dcm4 (
      product_no integer,
***************
*** 43,48 ****
--- 47,53 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (is_available);
+ ERROR:  Cannot support distribute type: Hash
  --INT2VECTOR, 
  CREATE TABLE xl_dcm5 (
      product_no integer,
***************
*** 51,57 ****
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (sub_product_ids);
! ERROR:  Column sub_product_ids is not modulo distributable data type
  --OIDVECTOR, 
  CREATE TABLE xl_dcm6 (
      product_no integer,
--- 56,62 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (sub_product_ids);
! ERROR:  Cannot support distribute type: Hash
  --OIDVECTOR, 
  CREATE TABLE xl_dcm6 (
      product_no integer,
***************
*** 60,66 ****
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (sub_product_ids);
! ERROR:  Column sub_product_ids is not modulo distributable data type
  --CHAR, 
  CREATE TABLE xl_dcm7 (
      product_no integer,
--- 65,71 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (sub_product_ids);
! ERROR:  Cannot support distribute type: Hash
  --CHAR, 
  CREATE TABLE xl_dcm7 (
      product_no integer,
***************
*** 68,74 ****
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_group);
! ERROR:  Column product_group is not modulo distributable data type
  --NAME, 
  CREATE TABLE xl_dcm8 (
      product_no integer,
--- 73,79 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_group);
! ERROR:  Cannot support distribute type: Hash
  --NAME, 
  CREATE TABLE xl_dcm8 (
      product_no integer,
***************
*** 76,82 ****
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_name);
! ERROR:  Column product_name is not modulo distributable data type
  --TEXT, 
  CREATE TABLE xl_dcm9 (
      product_no integer,
--- 81,87 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_name);
! ERROR:  Cannot support distribute type: Hash
  --TEXT, 
  CREATE TABLE xl_dcm9 (
      product_no integer,
***************
*** 84,90 ****
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_name);
! ERROR:  Column product_name is not modulo distributable data type
  --BPCHAR - blank padded char, 
  CREATE TABLE xl_dcm10 (
      product_no integer,
--- 89,95 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_name);
! ERROR:  Cannot support distribute type: Hash
  --BPCHAR - blank padded char, 
  CREATE TABLE xl_dcm10 (
      product_no integer,
***************
*** 92,98 ****
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_group);
! ERROR:  Column product_group is not modulo distributable data type
  --BYTEA - variable length binary string, 
  CREATE TABLE xl_dcm11 (
      product_no integer,
--- 97,103 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_group);
! ERROR:  Cannot support distribute type: Hash
  --BYTEA - variable length binary string, 
  CREATE TABLE xl_dcm11 (
      product_no integer,
***************
*** 100,106 ****
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_group);
! ERROR:  Column product_group is not modulo distributable data type
  --VARCHAR, 
  CREATE TABLE xl_dcm12 (
      product_no integer,
--- 105,111 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_group);
! ERROR:  Cannot support distribute type: Hash
  --VARCHAR, 
  CREATE TABLE xl_dcm12 (
      product_no integer,
***************
*** 108,114 ****
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_group);
! ERROR:  Column product_group is not modulo distributable data type
  --NUMERIC, 
  CREATE TABLE xl_dcm15 (
      product_no integer,
--- 113,119 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_group);
! ERROR:  Cannot support distribute type: Hash
  --NUMERIC, 
  CREATE TABLE xl_dcm15 (
      product_no integer,
***************
*** 116,122 ****
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_id);
! ERROR:  Column product_id is not modulo distributable data type
  --MONEY - String datatype, 
  CREATE TABLE xl_dcm16 (
      product_no integer,
--- 121,127 ----
      name text,
      price numeric
  ) DISTRIBUTE BY MODULO (product_id);
! ERROR:  Cannot support distribute type: Hash
  --MONEY - String datatype, 
  CREATE TABLE xl_dcm16 (
      product_no integer,
***************
*** 124,130 ****
      name MONEY PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (name);
! ERROR:  Column name is not modulo distributable data type
  --ABSTIME, 
  CREATE TABLE xl_dcm17 (
      product_no integer,
--- 129,135 ----
      name MONEY PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (name);
! ERROR:  Cannot support distribute type: Hash
  --ABSTIME, 
  CREATE TABLE xl_dcm17 (
      product_no integer,
***************
*** 132,137 ****
--- 137,143 ----
      purchase_date ABSTIME PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date);
+ ERROR:  Cannot support distribute type: Hash
  --RELTIME, 
  CREATE TABLE xl_dcm18 (
      product_no integer,
***************
*** 140,145 ****
--- 146,152 ----
      purchase_date RELTIME PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date);
+ ERROR:  Cannot support distribute type: Hash
  --DATE, 
  CREATE TABLE xl_dcm19 (
      product_no integer,
***************
*** 148,153 ****
--- 155,161 ----
      purchase_date DATE PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date);
+ ERROR:  Cannot support distribute type: Hash
  --TIME, 
  CREATE TABLE xl_dcm20 (
      product_no integer,
***************
*** 156,162 ****
      purchase_date TIME PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date);
! ERROR:  Column purchase_date is not modulo distributable data type
  --TIMESTAMP,
  CREATE TABLE xl_dcm21 (
      product_no integer,
--- 164,170 ----
      purchase_date TIME PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date);
! ERROR:  Cannot support distribute type: Hash
  --TIMESTAMP,
  CREATE TABLE xl_dcm21 (
      product_no integer,
***************
*** 165,171 ****
      purchase_date TIMESTAMP PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date); 
! ERROR:  Column purchase_date is not modulo distributable data type
  --TIMESTAMPTZ, 
  CREATE TABLE xl_dcm22 (
      product_no integer,
--- 173,179 ----
      purchase_date TIMESTAMP PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date); 
! ERROR:  Cannot support distribute type: Hash
  --TIMESTAMPTZ, 
  CREATE TABLE xl_dcm22 (
      product_no integer,
***************
*** 174,180 ****
      purchase_date TIMESTAMPTZ PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date); 
! ERROR:  Column purchase_date is not modulo distributable data type
  --INTERVAL, 
  CREATE TABLE xl_dcm23 (
      product_no integer,
--- 182,188 ----
      purchase_date TIMESTAMPTZ PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date); 
! ERROR:  Cannot support distribute type: Hash
  --INTERVAL, 
  CREATE TABLE xl_dcm23 (
      product_no integer,
***************
*** 183,189 ****
      purchase_date INTERVAL PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date); 
! ERROR:  Column purchase_date is not modulo distributable data type
  --and TIMETZ - time along with time zone
  CREATE TABLE xl_dcm24 (
      product_no integer,
--- 191,197 ----
      purchase_date INTERVAL PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date); 
! ERROR:  Cannot support distribute type: Hash
  --and TIMETZ - time along with time zone
  CREATE TABLE xl_dcm24 (
      product_no integer,
***************
*** 192,198 ****
      purchase_date TIMETZ PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date); 
! ERROR:  Column purchase_date is not modulo distributable data type
  --Distribution strategy can specify on a single column
  CREATE TABLE xl_dcm25 (
      product_no integer,
--- 200,206 ----
      purchase_date TIMETZ PRIMARY KEY,
      price numeric
  ) DISTRIBUTE BY MODULO (purchase_date); 
! ERROR:  Cannot support distribute type: Hash
  --Distribution strategy can specify on a single column
  CREATE TABLE xl_dcm25 (
      product_no integer,
***************
*** 202,208 ****
      price numeric,
      primary key(product_no, product_id)
  ) DISTRIBUTE BY MODULO (product_no, product_id); --fail
! ERROR:  too many distributed keys for non-shard table, only one distributed key is allowed.
  -- Distribution column value cannot be updated
  -- default distributed on HASH by primary key column, i.e. city
  CREATE TABLE xl_dcm_weather (
--- 210,216 ----
      price numeric,
      primary key(product_no, product_id)
  ) DISTRIBUTE BY MODULO (product_no, product_id); --fail
! ERROR:  Cannot support distribute type: Hash
  -- Distribution column value cannot be updated
  -- default distributed on HASH by primary key column, i.e. city
  CREATE TABLE xl_dcm_weather (
***************
*** 212,226 ****
      prcp            real,          -- precipitation
      date            date
  ) DISTRIBUTE BY MODULO (city_no);
  INSERT INTO xl_dcm_weather VALUES (55, 46, 50, 0.25, '1994-11-27');
  UPDATE xl_dcm_weather SET city_no = 56 where temp_lo=46 and temp_hi=50; -- fail
! ERROR:  Distributed column or partition column "city_no" can't be updated in current version
  DROP TABLE xl_dcm;
  DROP TABLE xl_dcm1;
  DROP TABLE xl_dcm2;
  ERROR:  table "xl_dcm2" does not exist
  DROP TABLE xl_dcm3;
  DROP TABLE xl_dcm4;
  DROP TABLE xl_dcm5;
  ERROR:  table "xl_dcm5" does not exist
  DROP TABLE xl_dcm6;
--- 220,244 ----
      prcp            real,          -- precipitation
      date            date
  ) DISTRIBUTE BY MODULO (city_no);
+ ERROR:  Cannot support distribute type: Hash
  INSERT INTO xl_dcm_weather VALUES (55, 46, 50, 0.25, '1994-11-27');
+ ERROR:  relation "xl_dcm_weather" does not exist
+ LINE 1: INSERT INTO xl_dcm_weather VALUES (55, 46, 50, 0.25, '1994-1...
+                     ^
  UPDATE xl_dcm_weather SET city_no = 56 where temp_lo=46 and temp_hi=50; -- fail
! ERROR:  relation "xl_dcm_weather" does not exist
! LINE 1: UPDATE xl_dcm_weather SET city_no = 56 where temp_lo=46 and ...
!                ^
  DROP TABLE xl_dcm;
+ ERROR:  table "xl_dcm" does not exist
  DROP TABLE xl_dcm1;
+ ERROR:  table "xl_dcm1" does not exist
  DROP TABLE xl_dcm2;
  ERROR:  table "xl_dcm2" does not exist
  DROP TABLE xl_dcm3;
+ ERROR:  table "xl_dcm3" does not exist
  DROP TABLE xl_dcm4;
+ ERROR:  table "xl_dcm4" does not exist
  DROP TABLE xl_dcm5;
  ERROR:  table "xl_dcm5" does not exist
  DROP TABLE xl_dcm6;
***************
*** 242,249 ****
--- 260,270 ----
  DROP TABLE xl_dcm16;
  ERROR:  table "xl_dcm16" does not exist
  DROP TABLE xl_dcm17;
+ ERROR:  table "xl_dcm17" does not exist
  DROP TABLE xl_dcm18;
+ ERROR:  table "xl_dcm18" does not exist
  DROP TABLE xl_dcm19;
+ ERROR:  table "xl_dcm19" does not exist
  DROP TABLE xl_dcm20;
  ERROR:  table "xl_dcm20" does not exist
  DROP TABLE xl_dcm21;
***************
*** 257,259 ****
--- 278,281 ----
  DROP TABLE xl_dcm25;
  ERROR:  table "xl_dcm25" does not exist
  DROP TABLE xl_dcm_weather;
+ ERROR:  table "xl_dcm_weather" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xl_plan_pushdown.out"	2025-07-31 16:07:15.011067723 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xl_plan_pushdown.out"	2025-07-31 16:41:23.506671740 +0800
***************
*** 1,243 ****
  --ensure that the plans are being pushed to the right subset of nodes
  --Sometimes plans get pushed down to more nodes than they really need to.
  CREATE TABLE xl_pp (a bigint, b int) DISTRIBUTE BY HASH(a);
  INSERT INTO xl_pp SELECT generate_series(1,100), 20;
  EXPLAIN VERBOSE SELECT * FROM xl_pp WHERE a = 100;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: xl_pp.a, xl_pp.b
!    Node/s: datanode_2
!    Remote query: SELECT a, b FROM xl_pp WHERE (a = 100)
!    ->  Seq Scan on public.xl_pp  (cost=0.00..35.50 rows=10 width=12)
!          Output: a, b
!          Filter: (xl_pp.a = 100)
! (7 rows)
! 
  EXPLAIN VERBOSE SELECT * FROM xl_pp WHERE a = 100::bigint;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: xl_pp.a, xl_pp.b
!    Node/s: datanode_2
!    Remote query: SELECT a, b FROM xl_pp WHERE (a = (100)::bigint)
!    ->  Seq Scan on public.xl_pp  (cost=0.00..35.50 rows=10 width=12)
!          Output: a, b
!          Filter: (xl_pp.a = '100'::bigint)
! (7 rows)
! 
  EXPLAIN VERBOSE INSERT INTO xl_pp (a, b) VALUES (200, 1) ;
!                            QUERY PLAN                            
! -----------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: 200, 1
!    Node expr: 200
!    Remote query: INSERT INTO xl_pp (a, b) VALUES (200, 1)
!    ->  Insert on public.xl_pp  (cost=0.00..0.01 rows=1 width=12)
!          ->  Result  (cost=0.00..0.01 rows=1 width=12)
!                Output: '200'::bigint, 1
! (7 rows)
! 
  EXPLAIN VERBOSE INSERT INTO xl_pp (a, b) VALUES (201::bigint, 1) ;
!                              QUERY PLAN                             
! --------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: (201)::bigint, 1
!    Node expr: (201)::bigint
!    Remote query: INSERT INTO xl_pp (a, b) VALUES ((201)::bigint, 1)
!    ->  Insert on public.xl_pp  (cost=0.00..0.01 rows=1 width=12)
!          ->  Result  (cost=0.00..0.01 rows=1 width=12)
!                Output: '201'::bigint, 1
! (7 rows)
! 
  EXPLAIN VERBOSE UPDATE xl_pp SET b=2 where a=200;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: 2, xl_pp.xc_node_id, xl_pp.ctid
!    Node/s: datanode_1
!    Remote query: UPDATE xl_pp SET b = 2 WHERE (a = 200)
!    ->  Update on public.xl_pp  (cost=0.00..35.50 rows=10 width=18)
!          ->  Seq Scan on public.xl_pp  (cost=0.00..35.50 rows=10 width=18)
!                Output: a, 2, ctid
!                Filter: (xl_pp.a = 200)
! (8 rows)
! 
  EXPLAIN VERBOSE UPDATE xl_pp SET b=2 where a=200::bigint;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: 2, xl_pp.xc_node_id, xl_pp.ctid
!    Node/s: datanode_1
!    Remote query: UPDATE xl_pp SET b = 2 WHERE (a = (200)::bigint)
!    ->  Update on public.xl_pp  (cost=0.00..35.50 rows=10 width=18)
!          ->  Seq Scan on public.xl_pp  (cost=0.00..35.50 rows=10 width=18)
!                Output: a, 2, ctid
!                Filter: (xl_pp.a = '200'::bigint)
! (8 rows)
! 
  EXPLAIN VERBOSE DELETE FROM xl_pp where a=200;
!                                 QUERY PLAN                                
! --------------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: xl_pp.xc_node_id, xl_pp.ctid
!    Node/s: datanode_1
!    Remote query: DELETE FROM xl_pp WHERE (a = 200)
!    ->  Delete on public.xl_pp  (cost=0.00..35.50 rows=10 width=6)
!          ->  Seq Scan on public.xl_pp  (cost=0.00..35.50 rows=10 width=6)
!                Output: ctid
!                Filter: (xl_pp.a = 200)
! (8 rows)
! 
  SELECT * from xl_pp where a=200;
!  a | b 
! ---+---
! (0 rows)
! 
  SELECT * from xl_pp where a=200::bigint;
!  a | b 
! ---+---
! (0 rows)
! 
  EXPLAIN VERBOSE DELETE FROM xl_pp where a=200;
!                                 QUERY PLAN                                
! --------------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: xl_pp.xc_node_id, xl_pp.ctid
!    Node/s: datanode_1
!    Remote query: DELETE FROM xl_pp WHERE (a = 200)
!    ->  Delete on public.xl_pp  (cost=0.00..35.50 rows=10 width=6)
!          ->  Seq Scan on public.xl_pp  (cost=0.00..35.50 rows=10 width=6)
!                Output: ctid
!                Filter: (xl_pp.a = 200)
! (8 rows)
! 
  EXPLAIN VERBOSE DELETE FROM xl_pp where a=200::bigint;
!                                 QUERY PLAN                                
! --------------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: xl_pp.xc_node_id, xl_pp.ctid
!    Node/s: datanode_1
!    Remote query: DELETE FROM xl_pp WHERE (a = (200)::bigint)
!    ->  Delete on public.xl_pp  (cost=0.00..35.50 rows=10 width=6)
!          ->  Seq Scan on public.xl_pp  (cost=0.00..35.50 rows=10 width=6)
!                Output: ctid
!                Filter: (xl_pp.a = '200'::bigint)
! (8 rows)
! 
  --Testing with MODULO distribution
  CREATE TABLE xl_ppm (a INT2, b int) DISTRIBUTE BY MODULO(a);
  INSERT INTO xl_ppm SELECT generate_series(1,100), 20;
  EXPLAIN VERBOSE SELECT * FROM xl_ppm WHERE a = 100;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: xl_ppm.a, xl_ppm.b
!    Node/s: datanode_1
!    Remote query: SELECT a, b FROM xl_ppm WHERE (a = 100)
!    ->  Seq Scan on public.xl_ppm  (cost=0.00..40.00 rows=12 width=6)
!          Output: a, b
!          Filter: (xl_ppm.a = 100)
! (7 rows)
! 
  EXPLAIN VERBOSE SELECT * FROM xl_ppm WHERE a = 100::INT2;
!                              QUERY PLAN                              
! ---------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: xl_ppm.a, xl_ppm.b
!    Node/s: datanode_1
!    Remote query: SELECT a, b FROM xl_ppm WHERE (a = (100)::smallint)
!    ->  Seq Scan on public.xl_ppm  (cost=0.00..40.00 rows=12 width=6)
!          Output: a, b
!          Filter: (xl_ppm.a = '100'::smallint)
! (7 rows)
! 
  EXPLAIN VERBOSE INSERT INTO xl_ppm (a, b) VALUES (201::INT2, 1) ;
!                               QUERY PLAN                               
! -----------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: (201)::smallint, 1
!    Node expr: (201)::smallint
!    Remote query: INSERT INTO xl_ppm (a, b) VALUES ((201)::smallint, 1)
!    ->  Insert on public.xl_ppm  (cost=0.00..0.01 rows=1 width=6)
!          ->  Result  (cost=0.00..0.01 rows=1 width=6)
!                Output: '201'::smallint, 1
! (7 rows)
! 
  EXPLAIN VERBOSE UPDATE xl_ppm SET b=2 where a=200;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: 2, xl_ppm.xc_node_id, xl_ppm.ctid
!    Node/s: datanode_1
!    Remote query: UPDATE xl_ppm SET b = 2 WHERE (a = 200)
!    ->  Update on public.xl_ppm  (cost=0.00..40.00 rows=12 width=12)
!          ->  Seq Scan on public.xl_ppm  (cost=0.00..40.00 rows=12 width=12)
!                Output: a, 2, ctid
!                Filter: (xl_ppm.a = 200)
! (8 rows)
! 
  EXPLAIN VERBOSE UPDATE xl_ppm SET b=2 where a=200::INT2;
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: 2, xl_ppm.xc_node_id, xl_ppm.ctid
!    Node/s: datanode_1
!    Remote query: UPDATE xl_ppm SET b = 2 WHERE (a = (200)::smallint)
!    ->  Update on public.xl_ppm  (cost=0.00..40.00 rows=12 width=12)
!          ->  Seq Scan on public.xl_ppm  (cost=0.00..40.00 rows=12 width=12)
!                Output: a, 2, ctid
!                Filter: (xl_ppm.a = '200'::smallint)
! (8 rows)
! 
  EXPLAIN VERBOSE DELETE FROM xl_ppm where a=200;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: xl_ppm.xc_node_id, xl_ppm.ctid
!    Node/s: datanode_1
!    Remote query: DELETE FROM xl_ppm WHERE (a = 200)
!    ->  Delete on public.xl_ppm  (cost=0.00..40.00 rows=12 width=6)
!          ->  Seq Scan on public.xl_ppm  (cost=0.00..40.00 rows=12 width=6)
!                Output: ctid
!                Filter: (xl_ppm.a = 200)
! (8 rows)
! 
  SELECT * from xl_ppm where a=200;
!  a | b 
! ---+---
! (0 rows)
! 
  SELECT * from xl_ppm where a=200::INT2;
!  a | b 
! ---+---
! (0 rows)
! 
  EXPLAIN VERBOSE DELETE FROM xl_ppm where a=200;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: xl_ppm.xc_node_id, xl_ppm.ctid
!    Node/s: datanode_1
!    Remote query: DELETE FROM xl_ppm WHERE (a = 200)
!    ->  Delete on public.xl_ppm  (cost=0.00..40.00 rows=12 width=6)
!          ->  Seq Scan on public.xl_ppm  (cost=0.00..40.00 rows=12 width=6)
!                Output: ctid
!                Filter: (xl_ppm.a = 200)
! (8 rows)
! 
  EXPLAIN VERBOSE DELETE FROM xl_ppm where a=200::INT2;
!                                 QUERY PLAN                                 
! ---------------------------------------------------------------------------
!  Remote Fast Query Execution  (cost=0.00..0.00 rows=0 width=0)
!    Output: xl_ppm.xc_node_id, xl_ppm.ctid
!    Node/s: datanode_1
!    Remote query: DELETE FROM xl_ppm WHERE (a = (200)::smallint)
!    ->  Delete on public.xl_ppm  (cost=0.00..40.00 rows=12 width=6)
!          ->  Seq Scan on public.xl_ppm  (cost=0.00..40.00 rows=12 width=6)
!                Output: ctid
!                Filter: (xl_ppm.a = '200'::smallint)
! (8 rows)
! 
  DROP TABLE xl_pp;
  DROP TABLE xl_ppm;
--- 1,103 ----
  --ensure that the plans are being pushed to the right subset of nodes
  --Sometimes plans get pushed down to more nodes than they really need to.
  CREATE TABLE xl_pp (a bigint, b int) DISTRIBUTE BY HASH(a);
+ ERROR:  Cannot support distribute type: Hash
  INSERT INTO xl_pp SELECT generate_series(1,100), 20;
+ ERROR:  relation "xl_pp" does not exist
+ LINE 1: INSERT INTO xl_pp SELECT generate_series(1,100), 20;
+                     ^
  EXPLAIN VERBOSE SELECT * FROM xl_pp WHERE a = 100;
! ERROR:  relation "xl_pp" does not exist
! LINE 1: EXPLAIN VERBOSE SELECT * FROM xl_pp WHERE a = 100;
!                                       ^
  EXPLAIN VERBOSE SELECT * FROM xl_pp WHERE a = 100::bigint;
! ERROR:  relation "xl_pp" does not exist
! LINE 1: EXPLAIN VERBOSE SELECT * FROM xl_pp WHERE a = 100::bigint;
!                                       ^
  EXPLAIN VERBOSE INSERT INTO xl_pp (a, b) VALUES (200, 1) ;
! ERROR:  relation "xl_pp" does not exist
! LINE 1: EXPLAIN VERBOSE INSERT INTO xl_pp (a, b) VALUES (200, 1) ;
!                                     ^
  EXPLAIN VERBOSE INSERT INTO xl_pp (a, b) VALUES (201::bigint, 1) ;
! ERROR:  relation "xl_pp" does not exist
! LINE 1: EXPLAIN VERBOSE INSERT INTO xl_pp (a, b) VALUES (201::bigint...
!                                     ^
  EXPLAIN VERBOSE UPDATE xl_pp SET b=2 where a=200;
! ERROR:  relation "xl_pp" does not exist
! LINE 1: EXPLAIN VERBOSE UPDATE xl_pp SET b=2 where a=200;
!                                ^
  EXPLAIN VERBOSE UPDATE xl_pp SET b=2 where a=200::bigint;
! ERROR:  relation "xl_pp" does not exist
! LINE 1: EXPLAIN VERBOSE UPDATE xl_pp SET b=2 where a=200::bigint;
!                                ^
  EXPLAIN VERBOSE DELETE FROM xl_pp where a=200;
! ERROR:  relation "xl_pp" does not exist
! LINE 1: EXPLAIN VERBOSE DELETE FROM xl_pp where a=200;
!                                     ^
  SELECT * from xl_pp where a=200;
! ERROR:  relation "xl_pp" does not exist
! LINE 1: SELECT * from xl_pp where a=200;
!                       ^
  SELECT * from xl_pp where a=200::bigint;
! ERROR:  relation "xl_pp" does not exist
! LINE 1: SELECT * from xl_pp where a=200::bigint;
!                       ^
  EXPLAIN VERBOSE DELETE FROM xl_pp where a=200;
! ERROR:  relation "xl_pp" does not exist
! LINE 1: EXPLAIN VERBOSE DELETE FROM xl_pp where a=200;
!                                     ^
  EXPLAIN VERBOSE DELETE FROM xl_pp where a=200::bigint;
! ERROR:  relation "xl_pp" does not exist
! LINE 1: EXPLAIN VERBOSE DELETE FROM xl_pp where a=200::bigint;
!                                     ^
  --Testing with MODULO distribution
  CREATE TABLE xl_ppm (a INT2, b int) DISTRIBUTE BY MODULO(a);
+ ERROR:  Cannot support distribute type: Hash
  INSERT INTO xl_ppm SELECT generate_series(1,100), 20;
+ ERROR:  relation "xl_ppm" does not exist
+ LINE 1: INSERT INTO xl_ppm SELECT generate_series(1,100), 20;
+                     ^
  EXPLAIN VERBOSE SELECT * FROM xl_ppm WHERE a = 100;
! ERROR:  relation "xl_ppm" does not exist
! LINE 1: EXPLAIN VERBOSE SELECT * FROM xl_ppm WHERE a = 100;
!                                       ^
  EXPLAIN VERBOSE SELECT * FROM xl_ppm WHERE a = 100::INT2;
! ERROR:  relation "xl_ppm" does not exist
! LINE 1: EXPLAIN VERBOSE SELECT * FROM xl_ppm WHERE a = 100::INT2;
!                                       ^
  EXPLAIN VERBOSE INSERT INTO xl_ppm (a, b) VALUES (201::INT2, 1) ;
! ERROR:  relation "xl_ppm" does not exist
! LINE 1: EXPLAIN VERBOSE INSERT INTO xl_ppm (a, b) VALUES (201::INT2,...
!                                     ^
  EXPLAIN VERBOSE UPDATE xl_ppm SET b=2 where a=200;
! ERROR:  relation "xl_ppm" does not exist
! LINE 1: EXPLAIN VERBOSE UPDATE xl_ppm SET b=2 where a=200;
!                                ^
  EXPLAIN VERBOSE UPDATE xl_ppm SET b=2 where a=200::INT2;
! ERROR:  relation "xl_ppm" does not exist
! LINE 1: EXPLAIN VERBOSE UPDATE xl_ppm SET b=2 where a=200::INT2;
!                                ^
  EXPLAIN VERBOSE DELETE FROM xl_ppm where a=200;
! ERROR:  relation "xl_ppm" does not exist
! LINE 1: EXPLAIN VERBOSE DELETE FROM xl_ppm where a=200;
!                                     ^
  SELECT * from xl_ppm where a=200;
! ERROR:  relation "xl_ppm" does not exist
! LINE 1: SELECT * from xl_ppm where a=200;
!                       ^
  SELECT * from xl_ppm where a=200::INT2;
! ERROR:  relation "xl_ppm" does not exist
! LINE 1: SELECT * from xl_ppm where a=200::INT2;
!                       ^
  EXPLAIN VERBOSE DELETE FROM xl_ppm where a=200;
! ERROR:  relation "xl_ppm" does not exist
! LINE 1: EXPLAIN VERBOSE DELETE FROM xl_ppm where a=200;
!                                     ^
  EXPLAIN VERBOSE DELETE FROM xl_ppm where a=200::INT2;
! ERROR:  relation "xl_ppm" does not exist
! LINE 1: EXPLAIN VERBOSE DELETE FROM xl_ppm where a=200::INT2;
!                                     ^
  DROP TABLE xl_pp;
+ ERROR:  table "xl_pp" does not exist
  DROP TABLE xl_ppm;
+ ERROR:  table "xl_ppm" does not exist

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xl_functions_1.out"	2025-07-31 16:07:15.011067723 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xl_functions.out"	2025-07-31 16:41:23.815665276 +0800
***************
*** 10,24 ****
  	b integer,
  	c integer DEFAULT xl_add(10,12 )
  ) DISTRIBUTE BY HASH(a);
  INSERT INTO xl_funct2(a,b) VALUES (1,2);--c should be 22
  INSERT INTO xl_funct2(a,b,c) VALUES (3,4,5);-- c should be 5
  SELECT * from xl_funct2 order by 1;
!  a | b | c  
! ---+---+----
!  1 | 2 | 22
!  3 | 4 |  5
! (2 rows)
! 
  --STABLE functions
  -- checking STABLE function in DEFAULT of non-distribution column
  create function xl_nochange(text) returns text
--- 10,28 ----
  	b integer,
  	c integer DEFAULT xl_add(10,12 )
  ) DISTRIBUTE BY HASH(a);
+ ERROR:  Cannot support distribute type: Hash
  INSERT INTO xl_funct2(a,b) VALUES (1,2);--c should be 22
+ ERROR:  relation "xl_funct2" does not exist
+ LINE 1: INSERT INTO xl_funct2(a,b) VALUES (1,2);
+                     ^
  INSERT INTO xl_funct2(a,b,c) VALUES (3,4,5);-- c should be 5
+ ERROR:  relation "xl_funct2" does not exist
+ LINE 1: INSERT INTO xl_funct2(a,b,c) VALUES (3,4,5);
+                     ^
  SELECT * from xl_funct2 order by 1;
! ERROR:  relation "xl_funct2" does not exist
! LINE 1: SELECT * from xl_funct2 order by 1;
!                       ^
  --STABLE functions
  -- checking STABLE function in DEFAULT of non-distribution column
  create function xl_nochange(text) returns text
***************
*** 28,57 ****
  	b integer,
  	c text DEFAULT xl_nochange('hello')
  ) DISTRIBUTE BY HASH(a);
  INSERT INTO xl_funct3(a,b) VALUES (1,2);--c should be pallavi
  INSERT INTO xl_funct3(a,b,c) VALUES (3,4,'qwerty');-- c should be qwerty
  SELECT * from xl_funct3 order by 1;
!  a | b |   c    
! ---+---+--------
!  1 | 2 | hello
!  3 | 4 | qwerty
! (2 rows)
! 
  -- checking STABLE function in DEFAULT of distribution column
  CREATE TABLE xl_funct4(
  	a integer,
  	b integer,
  	c text DEFAULT xl_nochange('hello')
  ) DISTRIBUTE BY HASH(c);
  INSERT INTO xl_funct4(a,b) VALUES (1,2);--c should be pallavi
  INSERT INTO xl_funct4(a,b,c) VALUES (3,4,'qwerty');-- c should be qwerty
  SELECT * from xl_funct4 order by 1;
!  a | b |   c    
! ---+---+--------
!  1 | 2 | hello
!  3 | 4 | qwerty
! (2 rows)
! 
  --VOLATILE functions
  create or replace function xl_get_curr_decade() returns double precision as
  $$ SELECT EXTRACT(DECADE FROM NOW()); $$
--- 32,69 ----
  	b integer,
  	c text DEFAULT xl_nochange('hello')
  ) DISTRIBUTE BY HASH(a);
+ ERROR:  Cannot support distribute type: Hash
  INSERT INTO xl_funct3(a,b) VALUES (1,2);--c should be pallavi
+ ERROR:  relation "xl_funct3" does not exist
+ LINE 1: INSERT INTO xl_funct3(a,b) VALUES (1,2);
+                     ^
  INSERT INTO xl_funct3(a,b,c) VALUES (3,4,'qwerty');-- c should be qwerty
+ ERROR:  relation "xl_funct3" does not exist
+ LINE 1: INSERT INTO xl_funct3(a,b,c) VALUES (3,4,'qwerty');
+                     ^
  SELECT * from xl_funct3 order by 1;
! ERROR:  relation "xl_funct3" does not exist
! LINE 1: SELECT * from xl_funct3 order by 1;
!                       ^
  -- checking STABLE function in DEFAULT of distribution column
  CREATE TABLE xl_funct4(
  	a integer,
  	b integer,
  	c text DEFAULT xl_nochange('hello')
  ) DISTRIBUTE BY HASH(c);
+ ERROR:  Cannot support distribute type: Hash
  INSERT INTO xl_funct4(a,b) VALUES (1,2);--c should be pallavi
+ ERROR:  relation "xl_funct4" does not exist
+ LINE 1: INSERT INTO xl_funct4(a,b) VALUES (1,2);
+                     ^
  INSERT INTO xl_funct4(a,b,c) VALUES (3,4,'qwerty');-- c should be qwerty
+ ERROR:  relation "xl_funct4" does not exist
+ LINE 1: INSERT INTO xl_funct4(a,b,c) VALUES (3,4,'qwerty');
+                     ^
  SELECT * from xl_funct4 order by 1;
! ERROR:  relation "xl_funct4" does not exist
! LINE 1: SELECT * from xl_funct4 order by 1;
!                       ^
  --VOLATILE functions
  create or replace function xl_get_curr_decade() returns double precision as
  $$ SELECT EXTRACT(DECADE FROM NOW()); $$
***************
*** 61,75 ****
  	b integer,
  	c double precision DEFAULT xl_get_curr_decade()
  ) DISTRIBUTE BY HASH(a);
  INSERT INTO xl_funct5(a,b) VALUES (1,2);--c should be e.g. 201 for 2015
  INSERT INTO xl_funct5(a,b,c) VALUES (3,4,20);-- c should be 20
  SELECT * from xl_funct5 order by 1;
!  a | b |  c  
! ---+---+-----
!  1 | 2 | 202
!  3 | 4 |  20
! (2 rows)
! 
  --nextval check
  SET sequence_range = 1;
  CREATE SEQUENCE xl_INSERT_SEQ;
--- 73,91 ----
  	b integer,
  	c double precision DEFAULT xl_get_curr_decade()
  ) DISTRIBUTE BY HASH(a);
+ ERROR:  Cannot support distribute type: Hash
  INSERT INTO xl_funct5(a,b) VALUES (1,2);--c should be e.g. 201 for 2015
+ ERROR:  relation "xl_funct5" does not exist
+ LINE 1: INSERT INTO xl_funct5(a,b) VALUES (1,2);
+                     ^
  INSERT INTO xl_funct5(a,b,c) VALUES (3,4,20);-- c should be 20
+ ERROR:  relation "xl_funct5" does not exist
+ LINE 1: INSERT INTO xl_funct5(a,b,c) VALUES (3,4,20);
+                     ^
  SELECT * from xl_funct5 order by 1;
! ERROR:  relation "xl_funct5" does not exist
! LINE 1: SELECT * from xl_funct5 order by 1;
!                       ^
  --nextval check
  SET sequence_range = 1;
  CREATE SEQUENCE xl_INSERT_SEQ;
***************
*** 77,114 ****
  	a integer,
  	b INT DEFAULT nextval('xl_insert_seq')
  ) DISTRIBUTE BY HASH (a);
  INSERT INTO xl_funct (a) VALUES (1);
  INSERT INTO xl_funct (a) VALUES (2);
  INSERT INTO xl_funct (a) VALUES (3);
  SELECT * FROM xl_funct order by 1;
!  a | b 
! ---+---
!  1 | 1
!  2 | 2
!  3 | 3
! (3 rows)
! 
  CREATE TABLE xl_funct1 (
  	a integer DEFAULT nextval('xl_insert_seq'),
  	b INT 
  ) DISTRIBUTE BY HASH (a);
  INSERT INTO xl_funct1 (b) VALUES (1);
  INSERT INTO xl_funct1 (b) VALUES (2);
  INSERT INTO xl_funct1 (b) VALUES (3);
  SELECT * FROM xl_funct1 order by a;
!  a | b 
! ---+---
!  4 | 1
!  5 | 2
!  6 | 3
! (3 rows)
! 
  DROP TABLE xl_funct;
  DROP TABLE xl_funct1;
  DROP SEQUENCE xl_INSERT_SEQ;
  DROP TABLE xl_funct2;
  DROP TABLE xl_funct3;
  DROP TABLE xl_funct4;
  DROP FUNCTION xl_nochange(text);
  DROP TABLE xl_funct5;
  DROP FUNCTION xl_get_curr_decade();
--- 93,148 ----
  	a integer,
  	b INT DEFAULT nextval('xl_insert_seq')
  ) DISTRIBUTE BY HASH (a);
+ ERROR:  Cannot support distribute type: Hash
  INSERT INTO xl_funct (a) VALUES (1);
+ ERROR:  relation "xl_funct" does not exist
+ LINE 1: INSERT INTO xl_funct (a) VALUES (1);
+                     ^
  INSERT INTO xl_funct (a) VALUES (2);
+ ERROR:  relation "xl_funct" does not exist
+ LINE 1: INSERT INTO xl_funct (a) VALUES (2);
+                     ^
  INSERT INTO xl_funct (a) VALUES (3);
+ ERROR:  relation "xl_funct" does not exist
+ LINE 1: INSERT INTO xl_funct (a) VALUES (3);
+                     ^
  SELECT * FROM xl_funct order by 1;
! ERROR:  relation "xl_funct" does not exist
! LINE 1: SELECT * FROM xl_funct order by 1;
!                       ^
  CREATE TABLE xl_funct1 (
  	a integer DEFAULT nextval('xl_insert_seq'),
  	b INT 
  ) DISTRIBUTE BY HASH (a);
+ ERROR:  Cannot support distribute type: Hash
  INSERT INTO xl_funct1 (b) VALUES (1);
+ ERROR:  relation "xl_funct1" does not exist
+ LINE 1: INSERT INTO xl_funct1 (b) VALUES (1);
+                     ^
  INSERT INTO xl_funct1 (b) VALUES (2);
+ ERROR:  relation "xl_funct1" does not exist
+ LINE 1: INSERT INTO xl_funct1 (b) VALUES (2);
+                     ^
  INSERT INTO xl_funct1 (b) VALUES (3);
+ ERROR:  relation "xl_funct1" does not exist
+ LINE 1: INSERT INTO xl_funct1 (b) VALUES (3);
+                     ^
  SELECT * FROM xl_funct1 order by a;
! ERROR:  relation "xl_funct1" does not exist
! LINE 1: SELECT * FROM xl_funct1 order by a;
!                       ^
  DROP TABLE xl_funct;
+ ERROR:  table "xl_funct" does not exist
  DROP TABLE xl_funct1;
+ ERROR:  table "xl_funct1" does not exist
  DROP SEQUENCE xl_INSERT_SEQ;
  DROP TABLE xl_funct2;
+ ERROR:  table "xl_funct2" does not exist
  DROP TABLE xl_funct3;
+ ERROR:  table "xl_funct3" does not exist
  DROP TABLE xl_funct4;
+ ERROR:  table "xl_funct4" does not exist
  DROP FUNCTION xl_nochange(text);
  DROP TABLE xl_funct5;
+ ERROR:  table "xl_funct5" does not exist
  DROP FUNCTION xl_get_curr_decade();

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xl_limitations_1.out"	2025-07-31 16:07:15.011067723 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xl_limitations.out"	2025-07-31 16:41:25.077107899 +0800
***************
*** 44,55 ****
  --BEFORE/AFTER TRIGGERs are not supported in Postgres-XL - below would fail
  create trigger tg_room_bu before update
      on xl_Room for each row execute procedure xl_room_au();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  create trigger xl_room_au after update
      on xl_Room for each row execute procedure xl_room_au();
- ERROR:  Postgres-XL does not support TRIGGER yet
- DETAIL:  The feature is not currently supported
  --
  -- Test error trapping
  --
--- 44,51 ----
***************
*** 604,616 ****
--- 600,616 ----
      EXCLUDE USING gist (c WITH &&)
  );
  CREATE TABLE xl_cons_hash (a int, c circle, EXCLUDE USING gist (c WITH &&)) DISTRIBUTE BY HASH(a); 
+ ERROR:  Cannot support distribute type: Hash
  CREATE TABLE xl_cons_modulo (a int, c circle, EXCLUDE USING gist (c WITH &&)) DISTRIBUTE BY MODULO(a);  error
+ ERROR:  Cannot support distribute type: Hash
  CREATE TABLE xl_cons_rr (c circle, EXCLUDE USING gist (c WITH &&)) DISTRIBUTE BY ROUNDROBIN;
  ERROR:  syntax error at or near "error"
  LINE 1: error
          ^
  CREATE TABLE xl_cons_hash2 (a int, b int, c circle, EXCLUDE USING btree (a WITH = , b WITH =)) DISTRIBUTE BY HASH(a); 
+ ERROR:  Cannot support distribute type: Hash
  CREATE TABLE xl_cons_modulo2 (a int, b int, c circle, EXCLUDE USING btree (a WITH =, b WITH =)) DISTRIBUTE BY MODULO(a); 
+ ERROR:  Cannot support distribute type: Hash
  -- xl_test1 is distributed by default on HASH(a)
  CREATE TABLE xl_test1 (a int, b int);
  INSERT INTO xl_test1 VALUES (1,2);
***************
*** 637,662 ****
  CREATE TABLE xl_test (a int, b int, EXCLUDE USING btree (b WITH =));
  INSERT INTO xl_test VALUES (1,2);
  INSERT INTO xl_test VALUES (2,2);
! ERROR:  conflicting key value violates exclusion constraint "xl_test_b_excl"
  DETAIL:  Key (b)=(2) conflicts with existing key (b)=(2).
  INSERT INTO xl_test VALUES (3,2);
  INSERT INTO xl_test VALUES (4,2);
! ERROR:  conflicting key value violates exclusion constraint "xl_test_b_excl"
  DETAIL:  Key (b)=(2) conflicts with existing key (b)=(2).
  INSERT INTO xl_test VALUES (5,2);
! ERROR:  conflicting key value violates exclusion constraint "xl_test_b_excl"
  DETAIL:  Key (b)=(2) conflicts with existing key (b)=(2).
  INSERT INTO xl_test VALUES (6,2);
! ERROR:  conflicting key value violates exclusion constraint "xl_test_b_excl"
  DETAIL:  Key (b)=(2) conflicts with existing key (b)=(2).
  INSERT INTO xl_test VALUES (7,2);
! ERROR:  conflicting key value violates exclusion constraint "xl_test_b_excl"
  DETAIL:  Key (b)=(2) conflicts with existing key (b)=(2).
  --the constraint is enforced when both rows map to the same datanode, e.g. when a=1, a=2
  --But if they go into different datanodes, the constraint is not enforced, e.g. when a=3
  drop table xl_circles;
  drop table xl_cons_hash;
  drop table xl_cons_modulo;
  drop table xl_cons_rr;
  ERROR:  table "xl_cons_rr" does not exist
  drop table xl_test;
--- 637,664 ----
  CREATE TABLE xl_test (a int, b int, EXCLUDE USING btree (b WITH =));
  INSERT INTO xl_test VALUES (1,2);
  INSERT INTO xl_test VALUES (2,2);
! ERROR:  node:datanode_1, backend_pid:384356, nodename:datanode_1,backend_pid:384356,message:conflicting key value violates exclusion constraint "xl_test_b_excl"
  DETAIL:  Key (b)=(2) conflicts with existing key (b)=(2).
  INSERT INTO xl_test VALUES (3,2);
  INSERT INTO xl_test VALUES (4,2);
! ERROR:  node:datanode_2, backend_pid:384628, nodename:datanode_2,backend_pid:384628,message:conflicting key value violates exclusion constraint "xl_test_b_excl"
  DETAIL:  Key (b)=(2) conflicts with existing key (b)=(2).
  INSERT INTO xl_test VALUES (5,2);
! ERROR:  node:datanode_1, backend_pid:384356, nodename:datanode_1,backend_pid:384356,message:conflicting key value violates exclusion constraint "xl_test_b_excl"
  DETAIL:  Key (b)=(2) conflicts with existing key (b)=(2).
  INSERT INTO xl_test VALUES (6,2);
! ERROR:  node:datanode_1, backend_pid:384356, nodename:datanode_1,backend_pid:384356,message:conflicting key value violates exclusion constraint "xl_test_b_excl"
  DETAIL:  Key (b)=(2) conflicts with existing key (b)=(2).
  INSERT INTO xl_test VALUES (7,2);
! ERROR:  node:datanode_2, backend_pid:384628, nodename:datanode_2,backend_pid:384628,message:conflicting key value violates exclusion constraint "xl_test_b_excl"
  DETAIL:  Key (b)=(2) conflicts with existing key (b)=(2).
  --the constraint is enforced when both rows map to the same datanode, e.g. when a=1, a=2
  --But if they go into different datanodes, the constraint is not enforced, e.g. when a=3
  drop table xl_circles;
  drop table xl_cons_hash;
+ ERROR:  table "xl_cons_hash" does not exist
  drop table xl_cons_modulo;
+ ERROR:  table "xl_cons_modulo" does not exist
  drop table xl_cons_rr;
  ERROR:  table "xl_cons_rr" does not exist
  drop table xl_test;
***************
*** 673,687 ****
  CREATE TABLE xl_concur_heap (f1 text, f2 text);
  -- empty table
  CREATE INDEX CONCURRENTLY xl_concur_index1 ON xl_concur_heap(f2,f1);
- ERROR:  PGXC does not support concurrent INDEX yet
- DETAIL:  The feature is not currently supported
  CREATE INDEX CONCURRENTLY IF NOT EXISTS xl_concur_index1 ON xl_concur_heap(f2,f1);
! ERROR:  PGXC does not support concurrent INDEX yet
! DETAIL:  The feature is not currently supported
  INSERT INTO xl_concur_heap VALUES  ('a','b');
  INSERT INTO xl_concur_heap VALUES  ('b','b');
  drop index concurrently xl_concur_index1;
! ERROR:  index "xl_concur_index1" does not exist
  drop table xl_concur_heap;
  --Large objects are not supported
  CREATE TABLE lotest_stash_values (loid oid, junk integer, fd integer);
--- 675,687 ----
  CREATE TABLE xl_concur_heap (f1 text, f2 text);
  -- empty table
  CREATE INDEX CONCURRENTLY xl_concur_index1 ON xl_concur_heap(f2,f1);
  CREATE INDEX CONCURRENTLY IF NOT EXISTS xl_concur_index1 ON xl_concur_heap(f2,f1);
! NOTICE:  relation "xl_concur_index1" already exists, skipping
! WARNING:  snapshot 0x58271fc9b0f8 still active
  INSERT INTO xl_concur_heap VALUES  ('a','b');
  INSERT INTO xl_concur_heap VALUES  ('b','b');
  drop index concurrently xl_concur_index1;
! ERROR:  node:coord2, backend_pid:387203, nodename:coord2,backend_pid:387203,message:DROP INDEX CONCURRENTLY cannot run inside a transaction block
  drop table xl_concur_heap;
  --Large objects are not supported
  CREATE TABLE lotest_stash_values (loid oid, junk integer, fd integer);
***************
*** 732,738 ****
  CREATE FOREIGN DATA WRAPPER xl_foo; -- ERROR
  RESET ROLE;
  CREATE FOREIGN DATA WRAPPER xl_foo VALIDATOR postgresql_fdw_validator;
! ERROR:  foreign-data wrapper "xl_foo" already exists
  --LISTEN/NOTIFY is not supported. Looks like they are supported now. 
  --We would obviously have issues with LISTEN/NOTIFY if clients are connected to different coordinators. Need to test that manually as it is difficult via regression.
  --LISTEN notify_async1; 
--- 732,738 ----
  CREATE FOREIGN DATA WRAPPER xl_foo; -- ERROR
  RESET ROLE;
  CREATE FOREIGN DATA WRAPPER xl_foo VALIDATOR postgresql_fdw_validator;
! ERROR:  node:datanode_2, backend_pid:384628, nodename:coord2,backend_pid:387203,message:foreign-data wrapper "xl_foo" already exists
  --LISTEN/NOTIFY is not supported. Looks like they are supported now. 
  --We would obviously have issues with LISTEN/NOTIFY if clients are connected to different coordinators. Need to test that manually as it is difficult via regression.
  --LISTEN notify_async1; 
***************
*** 782,787 ****
--- 782,788 ----
  drop function xl_nodename_from_id(integer);
  -- TRUNCATE ... RESTART IDENTITY
  CREATE SEQUENCE truncate_a_id1 START WITH 33;
+ ERROR:  relation "truncate_a_id1" already exists
  CREATE TABLE truncate_a (id serial,
                           id1 integer default nextval('truncate_a_id1'));
  ALTER SEQUENCE truncate_a_id1 OWNED BY truncate_a.id1;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xl_join.out"	2025-07-31 16:07:15.011067723 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xl_join.out"	2025-07-31 16:41:23.853664482 +0800
***************
*** 16,22 ****
           ->  Merge Join
                 Merge Cond: (xl_join_t2.val2 = xl_join_t1.val1)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by H: val2
                       ->  Sort
                             Sort Key: xl_join_t2.val2
                             ->  Seq Scan on xl_join_t2
--- 16,22 ----
           ->  Merge Join
                 Merge Cond: (xl_join_t2.val2 = xl_join_t1.val1)
                 ->  Remote Subquery Scan on all (datanode_1,datanode_2)
!                      Distribute results by S: val2
                       ->  Sort
                             Sort Key: xl_join_t2.val2
                             ->  Seq Scan on xl_join_t2

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/xl_distributed_xact.out"	2025-07-31 16:07:15.010067739 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/xl_distributed_xact.out"	2025-07-31 16:41:25.172830765 +0800
***************
*** 9,32 ****
  -- information, leading to many problems
  BEGIN;
  INSERT INTO testlr_x14 SELECT * FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
  TRUNCATE testr_x14;
  INSERT INTO testr_x14 SELECT * FROM testl_x14;
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;
!  count 
! -------
!      0
! (1 row)
! 
  TRUNCATE testlr_x14;
  INSERT INTO testlr_x14 SELECT * FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;
!  count 
! -------
!  10000
! (1 row)
! 
  ROLLBACK;
  INSERT INTO testlr_x14 SELECT * FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
  TRUNCATE testr_x14;
  INSERT INTO testr_x14 SELECT * FROM testl_x14;
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;
--- 9,32 ----
  -- information, leading to many problems
  BEGIN;
  INSERT INTO testlr_x14 SELECT * FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
+ ERROR:  node:datanode_2, backend_pid:387207, nodename:datanode_1,backend_pid:386087,message:null value in column "al" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, 1, 1).
  TRUNCATE testr_x14;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  INSERT INTO testr_x14 SELECT * FROM testl_x14;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  TRUNCATE testlr_x14;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  INSERT INTO testlr_x14 SELECT * FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  INSERT INTO testlr_x14 SELECT * FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
+ ERROR:  node:datanode_2, backend_pid:385393, nodename:datanode_1,backend_pid:384790,message:null value in column "al" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, 1, 1).
  TRUNCATE testr_x14;
  INSERT INTO testr_x14 SELECT * FROM testl_x14;
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;
***************
*** 50,73 ****
  CREATE TABLE testlr_x14 (al int, bl int, ar int, br int);
  BEGIN;
  INSERT INTO testlr_x14 SELECT * FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
  ALTER TABLE testr_x14 ALTER COLUMN b SET DATA TYPE text;
  INSERT INTO testr_x14 SELECT * FROM testl_x14;
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;
!  count 
! -------
!      0
! (1 row)
! 
  TRUNCATE testlr_x14;
  INSERT INTO testlr_x14 SELECT testr_x14.a, testr_x14.b::integer, testl_x14.* FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;
!  count 
! -------
!  10000
! (1 row)
! 
  ROLLBACK;
  INSERT INTO testlr_x14 SELECT * FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
  ALTER TABLE testr_x14 ALTER COLUMN b SET DATA TYPE text;
  INSERT INTO testr_x14 SELECT * FROM testl_x14;
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;
--- 50,73 ----
  CREATE TABLE testlr_x14 (al int, bl int, ar int, br int);
  BEGIN;
  INSERT INTO testlr_x14 SELECT * FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
+ ERROR:  node:datanode_2, backend_pid:385393, nodename:datanode_1,backend_pid:384356,message:null value in column "al" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, 1, 1).
  ALTER TABLE testr_x14 ALTER COLUMN b SET DATA TYPE text;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  INSERT INTO testr_x14 SELECT * FROM testl_x14;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  TRUNCATE testlr_x14;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  INSERT INTO testlr_x14 SELECT testr_x14.a, testr_x14.b::integer, testl_x14.* FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  INSERT INTO testlr_x14 SELECT * FROM testr_x14 RIGHT OUTER JOIN testl_x14 ON testr_x14.a = testl_x14.b;
+ ERROR:  node:datanode_2, backend_pid:385393, nodename:datanode_1,backend_pid:384356,message:null value in column "al" violates not-null constraint
+ DETAIL:  Failing row contains (null, null, 1, 1).
  ALTER TABLE testr_x14 ALTER COLUMN b SET DATA TYPE text;
  INSERT INTO testr_x14 SELECT * FROM testl_x14;
  SELECT count(*) FROM testlr_x14 WHERE al IS NOT NULL;

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/opentenbase_explain.out"	2025-07-31 16:07:14.993068009 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/opentenbase_explain.out"	2025-07-31 16:41:25.509228034 +0800
***************
*** 41,47 ****
                 DN (actual rows=99..99 loops=1..1)
                 - datanode_1 (actual rows=99 loops=1)
                 Output: 2, generate_series(2, 100), 'b'::text
!                Distribute results by H: 2
                 ->  ProjectSet
                       DN (actual rows=99..99 loops=1..1)
                       - datanode_1 (actual rows=99 loops=1)
--- 41,47 ----
                 DN (actual rows=99..99 loops=1..1)
                 - datanode_1 (actual rows=99 loops=1)
                 Output: 2, generate_series(2, 100), 'b'::text
!                Distribute results by S: 2
                 ->  ProjectSet
                       DN (actual rows=99..99 loops=1..1)
                       - datanode_1 (actual rows=99 loops=1)
***************
*** 63,69 ****
                 DN (actual rows=100..100 loops=1..1)
                 - datanode_2 (actual rows=100 loops=1)
                 Output: 3, generate_series(1, 100), 'c'::text
!                Distribute results by H: 3
                 ->  ProjectSet
                       DN (actual rows=100..100 loops=1..1)
                       - datanode_2 (actual rows=100 loops=1)
--- 63,69 ----
                 DN (actual rows=100..100 loops=1..1)
                 - datanode_2 (actual rows=100 loops=1)
                 Output: 3, generate_series(1, 100), 'c'::text
!                Distribute results by S: 3
                 ->  ProjectSet
                       DN (actual rows=100..100 loops=1..1)
                       - datanode_2 (actual rows=100 loops=1)
***************
*** 124,130 ****
           - datanode_2 (actual rows=58 loops=1)
           Output: num, (count(*))
           Sort Key: (count(*))
!          Sort Method: quicksort  Memory: 28kB
           ->  Finalize HashAggregate
                 DN (actual rows=42..58 loops=1..1)
                 - datanode_1 (actual rows=42 loops=1)
--- 124,130 ----
           - datanode_2 (actual rows=58 loops=1)
           Output: num, (count(*))
           Sort Key: (count(*))
!          Sort Method: quicksort  Memory: 27kB
           ->  Finalize HashAggregate
                 DN (actual rows=42..58 loops=1..1)
                 - datanode_1 (actual rows=42 loops=1)
***************
*** 136,142 ****
                       - datanode_1 (actual rows=84 loops=1)
                       - datanode_2 (actual rows=116 loops=1)
                       Output: num, PARTIAL count(*)
!                      Distribute results by H: num
                       ->  Partial HashAggregate
                             DN (actual rows=100..100 loops=1..1)
                             - datanode_1 (actual rows=100 loops=1)
--- 136,142 ----
                       - datanode_1 (actual rows=84 loops=1)
                       - datanode_2 (actual rows=116 loops=1)
                       Output: num, PARTIAL count(*)
!                      Distribute results by S: num
                       ->  Partial HashAggregate
                             DN (actual rows=100..100 loops=1..1)
                             - datanode_1 (actual rows=100 loops=1)
***************
*** 167,173 ****
                 - datanode_1 (actual rows=126 loops=1)
                 - datanode_2 (actual rows=174 loops=1)
                 Output: a1.id, a1.num, a1.name
!                Distribute results by H: num
                 ->  Seq Scan on public.a1
                       DN (actual rows=100..200 loops=1..1)
                       - datanode_1 (actual rows=200 loops=1)
--- 167,173 ----
                 - datanode_1 (actual rows=126 loops=1)
                 - datanode_2 (actual rows=174 loops=1)
                 Output: a1.id, a1.num, a1.name
!                Distribute results by S: num
                 ->  Seq Scan on public.a1
                       DN (actual rows=100..200 loops=1..1)
                       - datanode_1 (actual rows=200 loops=1)
***************
*** 184,190 ****
                       - datanode_1 (actual rows=126 loops=1)
                       - datanode_2 (actual rows=174 loops=1)
                       Output: a2.id, a2.num, a2.name
!                      Distribute results by H: num
                       ->  Seq Scan on public.a2
                             DN (actual rows=100..200 loops=1..1)
                             - datanode_1 (actual rows=200 loops=1)
--- 184,190 ----
                       - datanode_1 (actual rows=126 loops=1)
                       - datanode_2 (actual rows=174 loops=1)
                       Output: a2.id, a2.num, a2.name
!                      Distribute results by S: num
                       ->  Seq Scan on public.a2
                             DN (actual rows=100..200 loops=1..1)
                             - datanode_1 (actual rows=200 loops=1)
***************
*** 377,389 ****
     ->  Remote Subquery Scan on all (datanode_1,datanode_2) (actual rows=1 loops=1)
           Output: a1.id, a1.num, a1.name
           ->  Limit
!                DN (never executed)
                 Output: a1.id, a1.num, a1.name
                 ->  Seq Scan on public.a1
!                      DN (never executed)
                       Output: a1.id, a1.num, a1.name
                       Filter: (a1.num >= $0)
! (27 rows)
  
  explain (costs off,timing off,summary off,analyze,verbose)
  select count(*) from a1 group by name having count(*) = (select count(*) from a2 where name='a');
--- 377,391 ----
     ->  Remote Subquery Scan on all (datanode_1,datanode_2) (actual rows=1 loops=1)
           Output: a1.id, a1.num, a1.name
           ->  Limit
!                DN (actual rows=1..1 loops=1..1)
!                - datanode_2 (actual rows=1 loops=1)
                 Output: a1.id, a1.num, a1.name
                 ->  Seq Scan on public.a1
!                      DN (actual rows=1..1 loops=1..1)
!                      - datanode_2 (actual rows=1 loops=1)
                       Output: a1.id, a1.num, a1.name
                       Filter: (a1.num >= $0)
! (29 rows)
  
  explain (costs off,timing off,summary off,analyze,verbose)
  select count(*) from a1 group by name having count(*) = (select count(*) from a2 where name='a');
***************
*** 425,431 ****
                 - datanode_1 (actual rows=2 loops=1)
                 - datanode_2 (actual rows=1 loops=1)
                 Output: a1.name, PARTIAL count(*)
!                Distribute results by H: name
                 ->  Partial HashAggregate
                       DN (actual rows=1..2 loops=1..1)
                       - datanode_1 (actual rows=2 loops=1)
--- 427,433 ----
                 - datanode_1 (actual rows=2 loops=1)
                 - datanode_2 (actual rows=1 loops=1)
                 Output: a1.name, PARTIAL count(*)
!                Distribute results by S: name
                 ->  Partial HashAggregate
                       DN (actual rows=1..2 loops=1..1)
                       - datanode_1 (actual rows=2 loops=1)

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/redistribute_custom_types.out"	2025-07-31 16:07:14.998067930 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/redistribute_custom_types.out"	2025-07-31 16:41:25.914621383 +0800
***************
*** 8,14 ****
  NOTICE:  type "enumtype" does not exist, skipping
  create type enumtype AS enum ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun');
  create table enum_test(a int, b enumtype) distribute by shard(a);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into enum_test(a,b) values(1,'Mon');
  insert into enum_test(a,b) values(2,'Tue');
  insert into enum_test(a,b) values(3,'Wed');
--- 8,13 ----
***************
*** 49,55 ****
  NOTICE:  type "comptype" does not exist, skipping
  create type comptype as (f1 int, f2 int);
  create table comptype_test(a int, b comptype) distribute by shard(a);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into comptype_test(a,b) values(1,(1,2));
  insert into comptype_test(a,b) values(2,(2,3));
  insert into comptype_test(a,b) values(3,(3,4));
--- 48,53 ----
***************
*** 92,98 ****
  NOTICE:  type "domaintype" does not exist, skipping
  create domain domaintype as int check(value < 100);
  create table domaintype_test(a int, b domaintype) distribute by shard(a);
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  insert into domaintype_test(a,b) values(1,1);
  insert into domaintype_test(a,b) values(2,2);
  insert into domaintype_test(a,b) values(3,3);
--- 90,95 ----

======================================================================

*** "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/expected/pl_bugs.out"	2025-07-31 16:07:14.995067978 +0800
--- "/home/wyx/\346\241\214\351\235\242/opentenbase/src/test/regress/results/pl_bugs.out"	2025-07-31 16:41:26.168616072 +0800
***************
*** 404,410 ****
      load_date timestamp(0) without time zone
  )
  DISTRIBUTE BY SHARD (c_fundcode) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Name: b03_ts_remetrade_bak; Type: TABLE; Schema: sync; Owner: gregsun
  --
--- 404,409 ----
***************
*** 427,433 ****
      load_date timestamp(0) without time zone
  )
  DISTRIBUTE BY SHARD (c_fundcode) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Name: ks0_fund_base_26; Type: TABLE; Schema: sync; Owner: gregsun
  --
--- 426,431 ----
***************
*** 440,446 ****
      pcol character varying(50)
  )
  DISTRIBUTE BY SHARD (id1) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Name: p; Type: TABLE; Schema: sync; Owner: gregsun
  --
--- 438,443 ----
***************
*** 449,454 ****
--- 446,452 ----
      p2 text
  )
  DISTRIBUTE BY HASH (p1);
+ ERROR:  Cannot support distribute type: Hash
  --
  -- Name: s017_taccoinfo; Type: TABLE; Schema: sync; Owner: gregsun
  --
***************
*** 473,479 ****
      work_date timestamp(0) without time zone
  )
  DISTRIBUTE BY SHARD (c_custno) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Name: s017_tacconet; Type: TABLE; Schema: sync; Owner: gregsun
  --
--- 471,476 ----
***************
*** 500,506 ****
      load_date timestamp(0) without time zone
  )
  DISTRIBUTE BY SHARD (c_fundacco) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Name: s017_tagencyinfo; Type: TABLE; Schema: sync; Owner: gregsun
  --
--- 497,502 ----
***************
*** 584,590 ****
      load_date timestamp(0) without time zone
  )
  DISTRIBUTE BY SHARD (c_agencyno) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Name: s017_tconfirm_all; Type: TABLE; Schema: sync; Owner: gregsun
  --
--- 580,585 ----
***************
*** 755,761 ****
      c_businname character varying(100)
  )
  DISTRIBUTE BY SHARD (c_businflag) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Name: s017_tdividenddetail; Type: TABLE; Schema: sync; Owner: gregsun
  --
--- 750,755 ----
***************
*** 813,819 ****
      f_remainshares numeric(16,2)
  )
  DISTRIBUTE BY SHARD (d_cdate) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Name: s017_tfundday; Type: TABLE; Schema: sync; Owner: gregsun
  --
--- 807,812 ----
***************
*** 866,871 ****
--- 859,865 ----
      load_date timestamp(0) without time zone DEFAULT orcl_sysdate()
  )
  DISTRIBUTE BY HASH (d_date);
+ ERROR:  Cannot support distribute type: Hash
  --
  -- Name: s017_tfundinfo; Type: TABLE; Schema: sync; Owner: gregsun
  --
***************
*** 1478,1484 ****
      c_islocalmoneytypecollect character varying(1)
  )
  DISTRIBUTE BY SHARD (c_fundcode) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Name: s017_tsharecurrents_all; Type: TABLE; Schema: sync; Owner: gregsun
  --
--- 1472,1477 ----
***************
*** 1514,1520 ****
      work_date timestamp(0) without time zone
  )
  DISTRIBUTE BY SHARD (d_cdate) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Name: s017_ttrustclientinfo_all; Type: TABLE; Schema: sync; Owner: gregsun
  --
--- 1507,1512 ----
***************
*** 1703,1709 ****
      work_date timestamp(0) without time zone
  )
  DISTRIBUTE BY SHARD (c_custno) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Name: sys_stat_error_log; Type: TABLE; Schema: sync; Owner: gregsun
  --
--- 1695,1700 ----
***************
*** 1722,1728 ****
      sql_errm varchar2(500)
  )
  DISTRIBUTE BY SHARD (proc_name) to GROUP default_group;
- NOTICE:  Replica identity is needed for shard table, please add to this table through "alter table" command.
  --
  -- Data for Name: b03_ts_remetrade; Type: TABLE DATA; Schema: sync; Owner: gregsun
  --
--- 1713,1718 ----
***************
*** 1739,1748 ****
--- 1729,1749 ----
  -- Data for Name: p; Type: TABLE DATA; Schema: sync; Owner: gregsun
  --
  COPY p (p1, p2) FROM stdin;
+ ERROR:  relation "p" does not exist
+ 2021-12-12	2021-12-12
+ 2021-12-13	2021-12-12
+ 2020-12-13	2021-12-12
+ \.
+ invalid command \.
  --
  -- Data for Name: s017_taccoinfo; Type: TABLE DATA; Schema: sync; Owner: gregsun
  --
  COPY s017_taccoinfo (c_custno, c_accounttype, c_fundacco, c_agencyno, c_netno, c_childnetno, d_opendate, d_lastmodify, c_accostatus, c_freezecause, d_backdate, l_changetime, d_firstinvest, c_password, c_bourseflag, c_operator, jy_custid, work_date) FROM stdin;
+ ERROR:  syntax error at or near "2021"
+ LINE 1: 2021-12-12 2021-12-12
+         ^
+ \.
+ invalid command \.
  --
  -- Data for Name: s017_tacconet; Type: TABLE DATA; Schema: sync; Owner: gregsun
  --
***************
*** 1763,1768 ****
--- 1764,1772 ----
  -- Data for Name: s017_tfundday; Type: TABLE DATA; Schema: sync; Owner: gregsun
  --
  COPY s017_tfundday (d_date, d_cdate, c_fundcode, c_todaystatus, c_status, f_netvalue, f_lastshares, f_lastasset, f_asucceed, f_rsucceed, c_vastflag, f_encashratio, f_changeratio, c_excessflag, f_subscriberatio, c_inputpersonnel, c_checkpersonnel, f_income, f_incomeratio, f_unassign, f_incomeunit, f_totalnetvalue, f_servicefare, f_assign, f_growthrate, c_netvalueflag, f_managefare, d_exportdate, c_flag, f_advisorfee, d_auditdate, f_extendnetvalue, f_extendtotalnetvalue, jy_fundcode, f_yearincomeratio, f_riskcapital, f_totalincome, f_agencyexpyearincomeration, f_agencyexpincomeunit, f_agencyexpincomeration, f_agencyexpincome, c_isspecflag, c_isasync, sys_id, work_date, load_date) FROM stdin;
+ ERROR:  relation "s017_tfundday" does not exist
+ \.
+ invalid command \.
  --
  -- Data for Name: s017_tfundinfo; Type: TABLE DATA; Schema: sync; Owner: gregsun
  --
***************
*** 1924,1944 ****
         AND A.C_FUNDACCO = B.C_FUNDACCO
         AND TO_DATE(A.D_CDATE, 'YYYY-MM-DD') = B.D_CDATE
         AND A.C_CSERIALNO = B.C_CSERIALNO*/;
  DROP SCHEMA sync cascade;
! NOTICE:  drop cascades to 16 other objects
  DETAIL:  drop cascades to function func_getlastnetvalue(varchar2,date)
  drop cascades to table b03_ts_remetrade
  drop cascades to table b03_ts_remetrade_bak
  drop cascades to table ks0_fund_base_26
- drop cascades to table p
  drop cascades to table s017_taccoinfo
  drop cascades to table s017_tacconet
  drop cascades to table s017_tagencyinfo
  drop cascades to table s017_tconfirm_all
  drop cascades to table s017_tdividenddetail
- drop cascades to table s017_tfundday
  drop cascades to table s017_tfundinfo
  drop cascades to table s017_tsharecurrents_all
  drop cascades to table s017_ttrustclientinfo_all
  drop cascades to table sys_stat_error_log
- drop cascades to table newtab
--- 1928,1946 ----
         AND A.C_FUNDACCO = B.C_FUNDACCO
         AND TO_DATE(A.D_CDATE, 'YYYY-MM-DD') = B.D_CDATE
         AND A.C_CSERIALNO = B.C_CSERIALNO*/;
+ ERROR:  node:datanode_1, backend_pid:384790, nodename:datanode_1,backend_pid:384790,message:node:datanode_1, backend_pid:387142, nodename:datanode_1,backend_pid:387142,message:relation "p" does not exist
  DROP SCHEMA sync cascade;
! NOTICE:  drop cascades to 13 other objects
  DETAIL:  drop cascades to function func_getlastnetvalue(varchar2,date)
  drop cascades to table b03_ts_remetrade
  drop cascades to table b03_ts_remetrade_bak
  drop cascades to table ks0_fund_base_26
  drop cascades to table s017_taccoinfo
  drop cascades to table s017_tacconet
  drop cascades to table s017_tagencyinfo
  drop cascades to table s017_tconfirm_all
  drop cascades to table s017_tdividenddetail
  drop cascades to table s017_tfundinfo
  drop cascades to table s017_tsharecurrents_all
  drop cascades to table s017_ttrustclientinfo_all
  drop cascades to table sys_stat_error_log

======================================================================

