Parsed test spec with 2 sessions

starting permutation: b1 m1 s1 c1 b2 m2 s2 c2
step b1: BEGIN ISOLATION LEVEL READ COMMITTED;
step m1: MERGE INTO tgt USING src ON tgt.id = src.id
             WHEN MATCHED THEN UPDATE SET val = src.val
             WHEN NOT MATCHED THEN INSERT VALUES (src.id, src.val);
step s1: SELECT * FROM tgt order by 1;
id|val
--+---
 1| 10
 2| 20
 3| 30
(3 rows)

step c1: COMMIT;
step b2: BEGIN ISOLATION LEVEL READ COMMITTED;
step m2: MERGE INTO tgt USING src ON tgt.id = src.id
             WHEN MATCHED THEN UPDATE SET val = src.val
             WHEN NOT MATCHED THEN INSERT VALUES (src.id, src.val);
step s2: SELECT * FROM tgt order by 1;
id|val
--+---
 1| 10
 2| 20
 3| 30
(3 rows)

step c2: COMMIT;

starting permutation: b1 b2 m1 hj ex m2 c1 c2 s1
step b1: BEGIN ISOLATION LEVEL READ COMMITTED;
step b2: BEGIN ISOLATION LEVEL READ COMMITTED;
step m1: MERGE INTO tgt USING src ON tgt.id = src.id
             WHEN MATCHED THEN UPDATE SET val = src.val
             WHEN NOT MATCHED THEN INSERT VALUES (src.id, src.val);
step hj: SET LOCAL enable_mergejoin = off; SET LOCAL enable_nestloop = off;
step ex: EXPLAIN (verbose, costs off)
           MERGE INTO tgt USING src ON tgt.id = src.id
             WHEN MATCHED THEN UPDATE SET val = src.val
             WHEN NOT MATCHED THEN INSERT VALUES (src.id, src.val);
QUERY PLAN                                                                                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------
Remote Merge                                                                                                                                     
  Insert Statement : INSERT INTO public.tgt (id, val) VALUES ($1, $2) RETURNING tgt.ctid, tgt.shardid, tgt.tableoid                              
  Action 1 Type: Insert                                                                                                                          
    Insert: src.id, src.val                                                                                                                      
  ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)                                                                                     
        ->  Merge on public.tgt                                                                                                                  
              ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)                                                                         
                    Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id            
                    Distribute results by S: id                                                                                                  
                    ->  MergeQualProj                                                                                                            
                          Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id      
                          Action 1 Type: Update                                                                                                  
                          Action 2 Type: Insert                                                                                                  
                            Insert: src.id, src.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id    
                          ->  Hash Left Join                                                                                                     
                                Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id
                                Inner Unique: true                                                                                               
                                Hash Cond: (src.id = tgt.id)                                                                                     
                                ->  Seq Scan on public.src                                                                                       
                                      Output: src.id, src.val, src.ctid, src.xc_node_id                                                          
                                ->  Hash                                                                                                         
                                      Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid                                             
                                      ->  Seq Scan on public.tgt                                                                                 
                                            Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid                                       
(24 rows)

step m2: MERGE INTO tgt USING src ON tgt.id = src.id
             WHEN MATCHED THEN UPDATE SET val = src.val
             WHEN NOT MATCHED THEN INSERT VALUES (src.id, src.val); <waiting ...>
step c1: COMMIT;
step m2: <... completed>
ERROR:  ExecRemoteFragment not support remote epq now.
step c2: COMMIT;
step s1: SELECT * FROM tgt order by 1;
id|val
--+---
 1| 10
 2| 20
 3| 30
(3 rows)


starting permutation: b1 b2 m1 mj ex m2 c1 c2 s1
step b1: BEGIN ISOLATION LEVEL READ COMMITTED;
step b2: BEGIN ISOLATION LEVEL READ COMMITTED;
step m1: MERGE INTO tgt USING src ON tgt.id = src.id
             WHEN MATCHED THEN UPDATE SET val = src.val
             WHEN NOT MATCHED THEN INSERT VALUES (src.id, src.val);
step mj: SET LOCAL enable_hashjoin = off; SET LOCAL enable_nestloop = off;
step ex: EXPLAIN (verbose, costs off)
           MERGE INTO tgt USING src ON tgt.id = src.id
             WHEN MATCHED THEN UPDATE SET val = src.val
             WHEN NOT MATCHED THEN INSERT VALUES (src.id, src.val);
QUERY PLAN                                                                                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------
Remote Merge                                                                                                                                     
  Insert Statement : INSERT INTO public.tgt (id, val) VALUES ($1, $2) RETURNING tgt.ctid, tgt.shardid, tgt.tableoid                              
  Action 1 Type: Insert                                                                                                                          
    Insert: src.id, src.val                                                                                                                      
  ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)                                                                                     
        ->  Merge on public.tgt                                                                                                                  
              ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)                                                                         
                    Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id            
                    Distribute results by S: id                                                                                                  
                    ->  MergeQualProj                                                                                                            
                          Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id      
                          Action 1 Type: Update                                                                                                  
                          Action 2 Type: Insert                                                                                                  
                            Insert: src.id, src.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id    
                          ->  Merge Left Join                                                                                                    
                                Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id
                                Inner Unique: true                                                                                               
                                Merge Cond: (src.id = tgt.id)                                                                                    
                                ->  Index Scan using src_pkey on public.src                                                                      
                                      Output: src.id, src.val, src.ctid, src.xc_node_id                                                          
                                ->  Index Scan using tgt_pkey on public.tgt                                                                      
                                      Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid                                             
(22 rows)

step m2: MERGE INTO tgt USING src ON tgt.id = src.id
             WHEN MATCHED THEN UPDATE SET val = src.val
             WHEN NOT MATCHED THEN INSERT VALUES (src.id, src.val); <waiting ...>
step c1: COMMIT;
step m2: <... completed>
ERROR:  ExecRemoteFragment not support remote epq now.
step c2: COMMIT;
step s1: SELECT * FROM tgt order by 1;
id|val
--+---
 1| 10
 2| 20
 3| 30
(3 rows)


starting permutation: b1 b2 m1 nl ex m2 c1 c2 s1
step b1: BEGIN ISOLATION LEVEL READ COMMITTED;
step b2: BEGIN ISOLATION LEVEL READ COMMITTED;
step m1: MERGE INTO tgt USING src ON tgt.id = src.id
             WHEN MATCHED THEN UPDATE SET val = src.val
             WHEN NOT MATCHED THEN INSERT VALUES (src.id, src.val);
step nl: SET LOCAL enable_hashjoin = off; SET LOCAL enable_mergejoin = off;
step ex: EXPLAIN (verbose, costs off)
           MERGE INTO tgt USING src ON tgt.id = src.id
             WHEN MATCHED THEN UPDATE SET val = src.val
             WHEN NOT MATCHED THEN INSERT VALUES (src.id, src.val);
QUERY PLAN                                                                                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------
Remote Merge                                                                                                                                     
  Insert Statement : INSERT INTO public.tgt (id, val) VALUES ($1, $2) RETURNING tgt.ctid, tgt.shardid, tgt.tableoid                              
  Action 1 Type: Insert                                                                                                                          
    Insert: src.id, src.val                                                                                                                      
  ->  Remote Subquery Scan[1] on all (datanode_1,datanode_2)                                                                                     
        ->  Merge on public.tgt                                                                                                                  
              ->  Remote Subquery Scan[2] on all (datanode_1,datanode_2)                                                                         
                    Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id            
                    Distribute results by S: id                                                                                                  
                    ->  MergeQualProj                                                                                                            
                          Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id      
                          Action 1 Type: Update                                                                                                  
                          Action 2 Type: Insert                                                                                                  
                            Insert: src.id, src.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id    
                          ->  Nested Loop Left Join                                                                                              
                                Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid, src.id, src.val, tgt.id, src.ctid, src.xc_node_id
                                Inner Unique: true                                                                                               
                                ->  Seq Scan on public.src                                                                                       
                                      Output: src.id, src.val, src.ctid, src.xc_node_id                                                          
                                ->  Index Scan using tgt_pkey on public.tgt                                                                      
                                      Output: tgt.id, tgt.val, tgt.xc_node_id, tgt.shardid, tgt.ctid                                             
                                      Index Cond: (tgt.id = src.id)                                                                              
(22 rows)

step m2: MERGE INTO tgt USING src ON tgt.id = src.id
             WHEN MATCHED THEN UPDATE SET val = src.val
             WHEN NOT MATCHED THEN INSERT VALUES (src.id, src.val); <waiting ...>
step c1: COMMIT;
step m2: <... completed>
ERROR:  ExecRemoteFragment not support remote epq now.
step c2: COMMIT;
step s1: SELECT * FROM tgt order by 1;
id|val
--+---
 1| 10
 2| 20
 3| 30
(3 rows)

