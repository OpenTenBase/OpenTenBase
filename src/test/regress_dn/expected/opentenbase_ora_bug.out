\c regression_ora
-- START TAPD: 887262065
-- case: table 
create table tbl_20230920_1(id int, name varchar2(20));
insert into tbl_20230920_1 values(1, 'xxx');
insert into tbl_20230920_1 values(2, 'yyy');
insert into tbl_20230920_1 values(0, 'mmm');
select 1+2 as col1, 'kkk' as col2, id, name from tbl_20230920_1 order by to_number(col1), 3;
 COL1 | COL2 | ID | NAME 
------+------+----+------
    3 | kkk  |  0 | mmm
    3 | kkk  |  1 | xxx
    3 | kkk  |  2 | yyy
(3 rows)

select 1+2 as col1, 'kkk' as col2, id, name from tbl_20230920_1 order by to_number(col1) || id, 3;
 COL1 | COL2 | ID | NAME 
------+------+----+------
    3 | kkk  |  0 | mmm
    3 | kkk  |  1 | xxx
    3 | kkk  |  2 | yyy
(3 rows)

select 1+2 as col1, 'kkk' as col2, id, name from tbl_20230920_1 order by to_number(col1) + 1, 3;
 COL1 | COL2 | ID | NAME 
------+------+----+------
    3 | kkk  |  0 | mmm
    3 | kkk  |  1 | xxx
    3 | kkk  |  2 | yyy
(3 rows)

select 1+2 as col1, 'kkk' as col2, id, name from tbl_20230920_1 order by col1 + 1, 3;
 COL1 | COL2 | ID | NAME 
------+------+----+------
    3 | kkk  |  0 | mmm
    3 | kkk  |  1 | xxx
    3 | kkk  |  2 | yyy
(3 rows)

select 1+2 as col1, to_number('333.44') as col2, id, name from tbl_20230920_1 order by to_number(col1), to_number(col2) || id, 3;
 COL1 |  COL2  | ID | NAME 
------+--------+----+------
    3 | 333.44 |  0 | mmm
    3 | 333.44 |  1 | xxx
    3 | 333.44 |  2 | yyy
(3 rows)

select (select 1 from dual) as col1 from dual order by (select id from tbl_20230920_1) || col1;
ERROR:  more than one row returned by a subquery used as an expression
select id + 1 as col1 from tbl_20230920_1 order by (select max(id) from tbl_20230920_1) || col1;
 COL1 
------
    1
    2
    3
(3 rows)

-- expected error
select (select 1 from dual) as col1 from dual order by (select col1 from dual);
ERROR:  column "COL1" does not exist
LINE 1: ...t 1 from dual) as col1 from dual order by (select col1 from ...
                                                             ^
select (select 1 from dual) as col1 from dual order by (select to_number(col1) from dual);
ERROR:  column "COL1" does not exist
LINE 1: ...ual) as col1 from dual order by (select to_number(col1) from...
                                                             ^
select (select 1 from dual) as col1 from dual order by (select id from tbl_20230920_1 order by col1);
ERROR:  column "COL1" does not exist
LINE 1: ...dual order by (select id from tbl_20230920_1 order by col1);
                                                                 ^
select 1+2 as col1, name || '_x' as col2 from tbl_20230920_1 where col1 = 3;
ERROR:  column "COL1" does not exist
LINE 1: ...l1, name || '_x' as col2 from tbl_20230920_1 where col1 = 3;
                                                              ^
-- case: sublink
select (select 1 from dual) as col1 from dual order by to_number(col1);
 COL1 
------
    1
(1 row)

select (select 1 from dual) as col1 from dual order by to_number(col1), to_number(col1);
 COL1 
------
    1
(1 row)

select (select 1 from dual) as col1, (select 'aaa' from dual) as col2 from dual order by to_number(col1), to_char(col2);
 COL1 | COL2 
------+------
    1 | aaa
(1 row)

select 'xxxx' as col1, '123' as col2 from dual order by to_number(col1), col2;
ERROR:  invalid input syntax for type numeric: "xxxx"
-- case: view
create view v_orderby_20230920 as select (select 1 from dual) as col1, (select 'aaa' from dual) as col2 from dual order by to_number(col1), to_char(col2);
select * from v_orderby_20230920;
 COL1 | COL2 
------+------
    1 | aaa
(1 row)

select * from v_orderby_20230920 order by to_number(col1);
 COL1 | COL2 
------+------
    1 | aaa
(1 row)

drop view v_orderby_20230920;
drop table tbl_20230920_1;
-- END TAPD: 887262065
set skip_check_same_relname to on;
-- TEST TAPD: 887132191 
create table a0413(a1 int, a2 int, a3 int);
create table b0413(b1 int, b2 int, b3 int);
create table c0413(c1 int, c2 int, c3 int);
insert into a0413 values(1,null,111);
insert into a0413 values(1,11,111);
insert into a0413 values(1,99,111);
insert into a0413 values(2,null,222);
insert into a0413 values(2,22,222);
insert into a0413 values(2,88,222);
insert into b0413 values(1,null,111);
insert into b0413 values(1,88,111);
insert into b0413 values(2,null,222);
insert into b0413 values(2,11,222);
insert into c0413 values(1,null,111);
insert into c0413 values(1,88,111);
insert into c0413 values(2,null,222);
insert into c0413 values(2,11,222);
-- same rels
explain (costs off, verbose) select 1 from a0413 s, b0413 s where  s.b1 = 1;
                 QUERY PLAN                 
--------------------------------------------
 Nested Loop
   Output: 1
   ->  Seq Scan on "public".A0413 S
         Output: S.A1, S.A2, S.A3
   ->  Materialize
         ->  Seq Scan on "public".B0413 S_1
               Filter: (S_1.B1 = 1)
(7 rows)

create table tb1_20230906(a int);
create table tb2_20230906(b int);
create table tb3_20230906(a int);
select * from tb1_20230906, tb2_20230906, tb3_20230906;
 A | B | A 
---+---+---
(0 rows)

select t.a from tb1_20230906 t, tb2_20230906 t;
 A 
---
(0 rows)

select t.b from tb1_20230906 t, tb2_20230906 t;
 B 
---
(0 rows)

select t.a from tb1_20230906 t, tb3_20230906 t;
ERROR:  column reference "A" is ambiguous
LINE 1: select t.a from tb1_20230906 t, tb3_20230906 t;
               ^
select a from tb1_20230906 t, tb2_20230906 t;
 A 
---
(0 rows)

select b from tb1_20230906 t, tb2_20230906 t;
 B 
---
(0 rows)

select a from tb1_20230906 t, tb3_20230906 t;
ERROR:  column reference "A" is ambiguous
LINE 1: select a from tb1_20230906 t, tb3_20230906 t;
               ^
select t.* from tb1_20230906 t, tb2_20230906 t; -- error
ERROR:  table reference "T" is ambiguous
LINE 1: select t.* from tb1_20230906 t, tb2_20230906 t;
               ^
drop table a0413;
drop table b0413;
drop table c0413;
drop table tb1_20230906;
drop table tb2_20230906;
drop table tb3_20230906;
reset skip_check_same_relname;
--END TEST 887132191
-- tapd:114400655
create schema s1;
create function s1.func1() return void as
begin
    raise notice '%', 'schema_s1_func1';
end;
/
select s1.func1();
NOTICE:  schema_s1_func1
 FUNC1 
-------
 
(1 row)

create public synonym synonym1 for s1;
--expect error
select synonym1.func1();
ERROR:  schema "SYNONYM1" does not exist
LINE 1: select synonym1.func1();
               ^
create package s1 AS
end s1;
/
--expect error
select synonym1.func1();
ERROR:  schema "SYNONYM1" does not exist
LINE 1: select synonym1.func1();
               ^
create or replace function s1(a int) return int is
begin return a; end;
/
--expect error
select synonym1.func1();
ERROR:  schema "SYNONYM1" does not exist
LINE 1: select synonym1.func1();
               ^
drop package s1;
--expect error
select synonym1.func1();
ERROR:  schema "SYNONYM1" does not exist
LINE 1: select synonym1.func1();
               ^
drop schema s1 cascade;
NOTICE:  drop cascades to function S1.FUNC1()
drop function s1;
--end tapd:114400655
--tapd: 115860571
create table tbl_20240110(a int, b int);
select count(a.*) from dual;
ERROR:  missing FROM-clause entry for table "A"
LINE 1: select count(a.*) from dual;
                     ^
select count(a.*) from tbl_20240110;
ERROR:  missing FROM-clause entry for table "A"
LINE 1: select count(a.*) from tbl_20240110;
                     ^
select count(b.*) from tbl_20240110;
ERROR:  missing FROM-clause entry for table "B"
LINE 1: select count(b.*) from tbl_20240110;
                     ^
select count(a.b) from tbl_20240110;
ERROR:  missing FROM-clause entry for table "A"
LINE 1: select count(a.b) from tbl_20240110;
                     ^
drop table tbl_20240110;
-- end tapd:115860571
-- begin: 119236711
create role r_allow_unmatched_block_comments_tester;
set session role r_allow_unmatched_block_comments_tester;
show allow_unmatched_block_comments;
 allow_unmatched_block_comments 
--------------------------------
 off
(1 row)

select name,setting,context from pg_settings where name = 'allow_unmatched_block_comments';
              NAME              | SETTING | CONTEXT 
--------------------------------+---------+---------
 allow_unmatched_block_comments | off     | user
(1 row)

set allow_unmatched_block_comments to off;
select /* aaa */ /* a */ 'unmatch example' AS test;			-- ok
      TEST       
-----------------
 unmatch example
(1 row)

select /* /* aaa */ */ /* a */ 'unmatch example' AS test;	-- nested block comment ok
      TEST       
-----------------
 unmatch example
(1 row)

select /* /* /* a */ 'unmatch example' AS test;				-- failed
ERROR:  unterminated /* comment at or near "/* /* /* a */ 'unmatch example' AS test;"
LINE 1: select /* /* /* a */ 'unmatch example' AS test;
               ^
set allow_unmatched_block_comments to on;
select /* /* /* a */ 'unmatch example' AS test;				-- ok
      TEST       
-----------------
 unmatch example
(1 row)

select /* /* aaa */ /* a */ 'unmatch example' AS test;		-- ok
      TEST       
-----------------
 unmatch example
(1 row)

select /* aaa */ /* a */ 'unmatch example' AS test;			-- ok
      TEST       
-----------------
 unmatch example
(1 row)

select /* /* aaa */ */ /* a */ 'unmatch example' AS test;	-- nested block comment failed
ERROR:  operator does not exist: */ UNKNOWN
LINE 1: select /* /* aaa */ */ /* a */ 'unmatch example' AS test;
                            ^
HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
\c -
drop role r_allow_unmatched_block_comments_tester;
-- end: 119236711
-- bug: 119377019
CREATE TABLE bug_tbl_20240124(
c0 int,
c1 int,
c2 int,
c3 varchar(20),
c4 varchar(20),
c5 date,
c6 date,
c7 numeric,
c8 varchar(20),
c9 date)    PARTITION BY hash( c3) distribute by replication;
create TABLE bug_tbl_20240124_p0 partition of bug_tbl_20240124 for values with(modulus 4,remainder 0);
create TABLE bug_tbl_20240124_p1 partition of bug_tbl_20240124 for values with(modulus 4,remainder 1);
create TABLE bug_tbl_20240124_p2 partition of bug_tbl_20240124 for values with(modulus 4,remainder 2);
create TABLE bug_tbl_20240124_p3 partition of bug_tbl_20240124 for values with(modulus 4,remainder 3);
alter table bug_tbl_20240124 alter column c0 drop not null;
INSERT INTO bug_tbl_20240124 VALUES
(2, 1, 4, 'bar', 'bar', '1988-05-23', '1979-12-16', NULL, 'd', '2006-05-20 16:59:20') , 
(5, 3, 5, 'sx', 'bar', '2031-02-01', '2021-10-28', 9, 'bar', '1991-09-12 07:43:01') ,
(3, 4, 2, 'xtclceqc', 'bar', '1974-01-13', '1995-01-26 19:59:45', NULL, 'tclceqcjcu', '2021-11-12 23:54:13') ,
(2, 1, 2, 'clceqcjcug', 'lce', '2031-08-20', '1973-05-05 10:10:26', 6, 'ceqcjcu', '2003-06-16') ,
(4, 3, 5, 'eqc', 'qcjcugfmha', '2010-11-27', '2033-08-23 10:37:20', 1, 'bar', '1986-08-10');
CREATE OR REPLACE FUNCTION INSERT_RETURN_20231205() RETURNS INT AS
$$ DECLARE 
n INT;
BEGIN
UPDATE bug_tbl_20240124 SET c7 = 1086 % -2692 WHERE c1 = 1 RETURNING c0 INTO n ;
RETURN 1;
END; $$;
ALTER FUNCTION INSERT_RETURN_20231205 PUSHDOWN;
SELECT INSERT_RETURN_20231205();
ERROR:  query returned more than one row
CONTEXT:  PL/pgSQL function INSERT_RETURN_20231205() line 4 at SQL statement
CREATE OR REPLACE FUNCTION INSERT_RETURN_20231205_1() RETURNS INT AS
$$ DECLARE 
n INT;
BEGIN
UPDATE bug_tbl_20240124 SET c7 = 1086 % -2692 WHERE c1 = 4 RETURNING c0 INTO n ;
raise notice 'n: %', n;
RETURN 1;
END; $$;
ALTER FUNCTION INSERT_RETURN_20231205_1 PUSHDOWN;
SELECT INSERT_RETURN_20231205_1();
NOTICE:  n: 3
 INSERT_RETURN_20231205_1 
--------------------------
                        1
(1 row)

DROP FUNCTION INSERT_RETURN_20231205;
DROP FUNCTION INSERT_RETURN_20231205_1;
DROP TABLE bug_tbl_20240124;
-- end bug: 119377019
-- start bug: 122976613
CREATE TABLE IF NOT EXISTS "bug122976613"(
    "ID" NUMERIC(10,2) NOT NULL,
    "1" BIGINT,
    "EXT_COL_1" BIGINT,
    "ext_col_2" BIGINT,
    "EXT_COL_3" BIGINT,
    "EXT_COL_4" NUMERIC(10,2),
    "ext_col_5" NUMERIC(10,2),
    CONSTRAINT "SHARD_TABLE_PKEY" PRIMARY KEY ("ID")
) WITH (OIDS = FALSE) DISTRIBUTE BY SHARD("ID");
-- OPENTENBASE_ORA converts all objects without double quotes to uppercase
ALTER TABLE "bug122976613" ALTER COLUMN "ext_col_5" TYPE "NUMERIC"(10, 3);
ALTER TABLE "bug122976613" ALTER COLUMN ext_col_4 TYPE "NUMERIC"(10, 3);
ALTER TABLE "bug122976613" ALTER COLUMN "EXT_COL_4" TYPE "NUMERIC"(10, 2);
ALTER TABLE "bug122976613" ALTER COLUMN EXT_COL_1 TYPE INT;
-- ERROR
ALTER TABLE bug122976613 ALTER COLUMN "ext_col_2" TYPE INT;
ERROR:  relation "BUG122976613" does not exist
ALTER TABLE "bug122976613" ALTER COLUMN "ext_col_3" TYPE INT;
ERROR:  column "ext_col_3" of relation "bug122976613" does not exist
ALTER TABLE "bug122976613" ALTER COLUMN ext_col_5 TYPE "NUMERIC"(10, 4);
ERROR:  column "EXT_COL_5" of relation "bug122976613" does not exist
DROP TABLE "bug122976613";
-- end bug: 122976613
-- position for update clause and order by clause in query can swap each other.
drop table if exists test_position_swap;
NOTICE:  table "TEST_POSITION_SWAP" does not exist, skipping
-- 1. simple select
create table test_position_swap(a int, b int);
select * from test_position_swap for update order by a; --ok
 A | B 
---+---
(0 rows)

select * from test_position_swap order by a for update; --ok
 A | B 
---+---
(0 rows)

select * from test_position_swap for update; --ok
 A | B 
---+---
(0 rows)

select * from test_position_swap order by a for update order by b; -- error
ERROR:  SQL command not properly ended
-- 2. with clause
with cte1 as (select * from test_position_swap) select * from cte1 for update; -- ok
 A | B 
---+---
(0 rows)

with cte1 as (select * from test_position_swap) select * from cte1 order by a; -- ok
 A | B 
---+---
(0 rows)

with cte1 as (select * from test_position_swap) select * from cte1 for update order by a; -- ok
 A | B 
---+---
(0 rows)

with cte1 as (select * from test_position_swap) select * from cte1 order by a for update; -- ok
 A | B 
---+---
(0 rows)

with cte1 as (select * from test_position_swap) select * from cte1 order by a for update order by a; -- error
ERROR:  SQL command not properly ended
