--
-- Test partitioning planner code
--
set datestyle = 'ISO, YMD';
create table lp (a char) partition by list (a);
create table lp_default partition of lp default;
create table lp_ef partition of lp for values in ('e', 'f');
create table lp_ad partition of lp for values in ('a', 'd');
create table lp_bc partition of lp for values in ('b', 'c');
create table lp_g partition of lp for values in ('g');
create table lp_null partition of lp for values in (null);
explain (costs off, verbose on) select * from lp;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_ad  public.lp_bc  public.lp_ef  public.lp_g  public.lp_null  public.lp_default
         Output: lp.a
(5 rows)

explain (costs off, verbose on) select * from lp where a > 'a' and a < 'd';
                           QUERY PLAN                            
-----------------------------------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_bc  public.lp_default
         Output: lp.a
         Filter: ((lp.a > 'a'::bpchar) AND (lp.a < 'd'::bpchar))
(6 rows)

explain (costs off, verbose on) select * from lp where a > 'a' and a <= 'd';
                              QUERY PLAN                               
-----------------------------------------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_ad  public.lp_bc  public.lp_default
         Output: lp.a
         Filter: ((lp.a > 'a'::bpchar) AND (lp.a <= 'd'::bpchar))
(6 rows)

explain (costs off, verbose on) select * from lp where a = 'a';
              QUERY PLAN              
--------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_ad
         Output: lp.a
         Filter: (lp.a = 'a'::bpchar)
(6 rows)

explain (costs off, verbose on) select * from lp where 'a' = a;	/* commuted */
              QUERY PLAN              
--------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_ad
         Output: lp.a
         Filter: ('a'::bpchar = lp.a)
(6 rows)

explain (costs off, verbose on) select * from lp where a is not null;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_ad  public.lp_bc  public.lp_ef  public.lp_g  public.lp_default
         Output: lp.a
         Filter: (lp.a IS NOT NULL)
(6 rows)

explain (costs off, verbose on) select * from lp where a is null;
               QUERY PLAN               
----------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_null
         Output: lp.a
         Filter: (lp.a IS NULL)
(6 rows)

explain (costs off, verbose on) select * from lp where a = 'a' or a = 'c';
                           QUERY PLAN                           
----------------------------------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_ad  public.lp_bc
         Output: lp.a
         Filter: ((lp.a = 'a'::bpchar) OR (lp.a = 'c'::bpchar))
(6 rows)

explain (costs off, verbose on) select * from lp where a is not null and (a = 'a' or a = 'c');
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_ad  public.lp_bc
         Output: lp.a
         Filter: ((lp.a IS NOT NULL) AND ((lp.a = 'a'::bpchar) OR (lp.a = 'c'::bpchar)))
(6 rows)

explain (costs off, verbose on) select * from lp where a <> 'g';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_ad  public.lp_bc  public.lp_ef  public.lp_default
         Output: lp.a
         Filter: (lp.a <> 'g'::bpchar)
(6 rows)

explain (costs off, verbose on) select * from lp where a <> 'a' and a <> 'd';
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_bc  public.lp_ef  public.lp_g  public.lp_default
         Output: lp.a
         Filter: ((lp.a <> 'a'::bpchar) AND (lp.a <> 'd'::bpchar))
(6 rows)

explain (costs off, verbose on) select * from lp where a not in ('a', 'd');
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_bc  public.lp_ef  public.lp_g  public.lp_default
         Output: lp.a
         Filter: (lp.a <> ALL ('{a,d}'::bpchar[]))
(6 rows)

-- collation matches the partitioning collation, pruning works
create table coll_pruning (a text collate "C") partition by list (a);
create table coll_pruning_a partition of coll_pruning for values in ('a');
create table coll_pruning_b partition of coll_pruning for values in ('b');
create table coll_pruning_def partition of coll_pruning default;
explain (costs off, verbose on) select * from coll_pruning where a collate "C" = 'a' collate "C";
                        QUERY PLAN                        
----------------------------------------------------------
 PartIterator
   Output: coll_pruning.a
   ->  Seq Scan on public.coll_pruning
         Part Iterator:  public.coll_pruning_a
         Output: coll_pruning.a
         Filter: (coll_pruning.a = 'a'::text COLLATE "C")
(6 rows)

-- collation doesn't match the partitioning collation, no pruning occurs
explain (costs off, verbose on) select * from coll_pruning where a collate "POSIX" = 'a' collate "POSIX";
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 PartIterator
   Output: coll_pruning.a
   ->  Seq Scan on public.coll_pruning
         Part Iterator:  public.coll_pruning_a  public.coll_pruning_b  public.coll_pruning_def
         Output: coll_pruning.a
         Filter: ((coll_pruning.a)::text = 'a'::text COLLATE "POSIX")
(6 rows)

create table rlp (a int, b varchar) partition by range (a);
create table rlp_default partition of rlp default partition by list (a);
create table rlp_default_default partition of rlp_default default;
create table rlp_default_10 partition of rlp_default for values in (10);
create table rlp_default_30 partition of rlp_default for values in (30);
create table rlp_default_null partition of rlp_default for values in (null);
create table rlp1 partition of rlp for values from (minvalue) to (1);
create table rlp2 partition of rlp for values from (1) to (10);
create table rlp3 (a int, b varchar) partition by list (b varchar_ops);
create table rlp3_default partition of rlp3 default;
create table rlp3abcd partition of rlp3 for values in ('ab', 'cd');
create table rlp3efgh partition of rlp3 for values in ('ef', 'gh');
create table rlp3nullxy partition of rlp3 for values in (null, 'xy');
alter table rlp attach partition rlp3 for values from (15) to (20);
create table rlp4 partition of rlp for values from (20) to (30) partition by range (a);
create table rlp4_default partition of rlp4 default;
create table rlp4_1 partition of rlp4 for values from (20) to (25);
create table rlp4_2 partition of rlp4 for values from (25) to (29);
create table rlp5 partition of rlp for values from (31) to (maxvalue) partition by range (a);
create table rlp5_default partition of rlp5 default;
create table rlp5_1 partition of rlp5 for values from (31) to (40);
explain (costs off, verbose on) select * from rlp where a < 1;
             QUERY PLAN              
-------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp1
         Output: rlp.a, rlp.b
         Filter: (rlp.a < 1)
(6 rows)

explain (costs off, verbose on) select * from rlp where 1 > a;	/* commuted */
             QUERY PLAN              
-------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp1
         Output: rlp.a, rlp.b
         Filter: (1 > rlp.a)
(6 rows)

explain (costs off, verbose on) select * from rlp where a <= 1;
                    QUERY PLAN                    
--------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp1  public.rlp2
         Output: rlp.a, rlp.b
         Filter: (rlp.a <= 1)
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 1;
             QUERY PLAN              
-------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp2
         Output: rlp.a, rlp.b
         Filter: (rlp.a = 1)
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 1::bigint;		/* same as above */
              QUERY PLAN               
---------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp2
         Output: rlp.a, rlp.b
         Filter: (rlp.a = '1'::bigint)
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 1::numeric;	/* no pruning */
                                                                                                                                                      QUERY PLAN                                                                                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp1  public.rlp2  public.rlp3abcd  public.rlp3efgh  public.rlp3nullxy  public.rlp3_default  public.rlp4_1  public.rlp4_2  public.rlp4_default  public.rlp5_1  public.rlp5_default  public.rlp_default_10  public.rlp_default_30  public.rlp_default_null  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: ((rlp.a)::numeric = '1'::numeric)
(6 rows)

explain (costs off, verbose on) select * from rlp where a <= 10;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp1  public.rlp2  public.rlp_default_10  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: (rlp.a <= 10)
(6 rows)

explain (costs off, verbose on) select * from rlp where a > 10;
                                                                                                                 QUERY PLAN                                                                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp3abcd  public.rlp3efgh  public.rlp3nullxy  public.rlp3_default  public.rlp4_1  public.rlp4_2  public.rlp4_default  public.rlp5_1  public.rlp5_default  public.rlp_default_30  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: (rlp.a > 10)
(6 rows)

explain (costs off, verbose on) select * from rlp where a < 15;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp1  public.rlp2  public.rlp_default_10  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: (rlp.a < 15)
(6 rows)

explain (costs off, verbose on) select * from rlp where a <= 15;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp1  public.rlp2  public.rlp3abcd  public.rlp3efgh  public.rlp3nullxy  public.rlp3_default  public.rlp_default_10  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: (rlp.a <= 15)
(6 rows)

explain (costs off, verbose on) select * from rlp where a > 15 and b = 'ab';
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp3abcd  public.rlp4_1  public.rlp4_2  public.rlp4_default  public.rlp5_1  public.rlp5_default  public.rlp_default_30  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: ((rlp.a > 15) AND ((rlp.b)::text = 'ab'::text))
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 16;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp3abcd  public.rlp3efgh  public.rlp3nullxy  public.rlp3_default
         Output: rlp.a, rlp.b
         Filter: (rlp.a = 16)
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 16 and b in ('not', 'in', 'here');
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp3_default
         Output: rlp.a, rlp.b
         Filter: ((rlp.a = 16) AND ((rlp.b)::text = ANY ('{not,in,here}'::text[])))
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 16 and b < 'ab';
                           QUERY PLAN                            
-----------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp3_default
         Output: rlp.a, rlp.b
         Filter: (((rlp.b)::text < 'ab'::text) AND (rlp.a = 16))
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 16 and b <= 'ab';
                            QUERY PLAN                            
------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp3abcd  public.rlp3_default
         Output: rlp.a, rlp.b
         Filter: (((rlp.b)::text <= 'ab'::text) AND (rlp.a = 16))
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 16 and b is null;
                     QUERY PLAN                     
----------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp3nullxy
         Output: rlp.a, rlp.b
         Filter: ((rlp.b IS NULL) AND (rlp.a = 16))
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 16 and b is not null;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp3abcd  public.rlp3efgh  public.rlp3nullxy  public.rlp3_default
         Output: rlp.a, rlp.b
         Filter: ((rlp.b IS NOT NULL) AND (rlp.a = 16))
(6 rows)

explain (costs off, verbose on) select * from rlp where a is null;
                   QUERY PLAN                    
-------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp_default_null
         Output: rlp.a, rlp.b
         Filter: (rlp.a IS NULL)
(6 rows)

explain (costs off, verbose on) select * from rlp where a is not null;
                                                                                                                                         QUERY PLAN                                                                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp1  public.rlp2  public.rlp3abcd  public.rlp3efgh  public.rlp3nullxy  public.rlp3_default  public.rlp4_1  public.rlp4_2  public.rlp4_default  public.rlp5_1  public.rlp5_default  public.rlp_default_10  public.rlp_default_30  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: (rlp.a IS NOT NULL)
(6 rows)

explain (costs off, verbose on) select * from rlp where a > 30;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp5_1  public.rlp5_default  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: (rlp.a > 30)
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 30;	/* only default is scanned */
                  QUERY PLAN                   
-----------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp_default_30
         Output: rlp.a, rlp.b
         Filter: (rlp.a = 30)
(6 rows)

explain (costs off, verbose on) select * from rlp where a <= 31;
                                                                                                                               QUERY PLAN                                                                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp1  public.rlp2  public.rlp3abcd  public.rlp3efgh  public.rlp3nullxy  public.rlp3_default  public.rlp4_1  public.rlp4_2  public.rlp4_default  public.rlp5_1  public.rlp_default_10  public.rlp_default_30  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: (rlp.a <= 31)
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 1 or a = 7;
                  QUERY PLAN                  
----------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp2
         Output: rlp.a, rlp.b
         Filter: ((rlp.a = 1) OR (rlp.a = 7))
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 1 or b = 'ab';
                                                                                                                         QUERY PLAN                                                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp1  public.rlp2  public.rlp3abcd  public.rlp4_1  public.rlp4_2  public.rlp4_default  public.rlp5_1  public.rlp5_default  public.rlp_default_10  public.rlp_default_30  public.rlp_default_null  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: ((rlp.a = 1) OR ((rlp.b)::text = 'ab'::text))
(6 rows)

explain (costs off, verbose on) select * from rlp where a > 20 and a < 27;
                      QUERY PLAN                      
------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp4_1  public.rlp4_2
         Output: rlp.a, rlp.b
         Filter: ((rlp.a > 20) AND (rlp.a < 27))
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 29;
                 QUERY PLAN                  
---------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp4_default
         Output: rlp.a, rlp.b
         Filter: (rlp.a = 29)
(6 rows)

explain (costs off, verbose on) select * from rlp where a >= 29;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp4_default  public.rlp5_1  public.rlp5_default  public.rlp_default_30  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: (rlp.a >= 29)
(6 rows)

explain (costs off, verbose on) select * from rlp where a < 1 or (a > 20 and a < 25);
                            QUERY PLAN                            
------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp1  public.rlp4_1
         Output: rlp.a, rlp.b
         Filter: ((rlp.a < 1) OR ((rlp.a > 20) AND (rlp.a < 25)))
(6 rows)

-- redundant clauses are eliminated
explain (costs off, verbose on) select * from rlp where a > 1 and a = 10;	/* only default */
                   QUERY PLAN                   
------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp_default_10
         Output: rlp.a, rlp.b
         Filter: ((rlp.a > 1) AND (rlp.a = 10))
(6 rows)

explain (costs off, verbose on) select * from rlp where a > 1 and a >=15;	/* rlp3 onwards, including default */
                                                                                                                 QUERY PLAN                                                                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp3abcd  public.rlp3efgh  public.rlp3nullxy  public.rlp3_default  public.rlp4_1  public.rlp4_2  public.rlp4_default  public.rlp5_1  public.rlp5_default  public.rlp_default_30  public.rlp_default_default
         Output: rlp.a, rlp.b
         Filter: ((rlp.a > 1) AND (rlp.a >= 15))
(6 rows)

explain (costs off, verbose on) select * from rlp where a = 1 and a = 3;	/* empty */
        QUERY PLAN        
--------------------------
 Result
   Output: a, b
   One-Time Filter: false
(3 rows)

explain (costs off, verbose on) select * from rlp where (a = 1 and a = 3) or (a > 1 and a = 15);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp2  public.rlp3abcd  public.rlp3efgh  public.rlp3nullxy  public.rlp3_default
         Output: rlp.a, rlp.b
         Filter: (((rlp.a = 1) AND (rlp.a = 3)) OR ((rlp.a > 1) AND (rlp.a = 15)))
(6 rows)

-- multi-column keys
create table mc3p (a int, b int, c int) partition by range (a, abs(b), c);
create table mc3p_default partition of mc3p default;
create table mc3p0 partition of mc3p for values from (minvalue, minvalue, minvalue) to (1, 1, 1);
create table mc3p1 partition of mc3p for values from (1, 1, 1) to (10, 5, 10);
create table mc3p2 partition of mc3p for values from (10, 5, 10) to (10, 10, 10);
create table mc3p3 partition of mc3p for values from (10, 10, 10) to (10, 10, 20);
create table mc3p4 partition of mc3p for values from (10, 10, 20) to (10, maxvalue, maxvalue);
create table mc3p5 partition of mc3p for values from (11, 1, 1) to (20, 10, 10);
create table mc3p6 partition of mc3p for values from (20, 10, 10) to (20, 20, 20);
create table mc3p7 partition of mc3p for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue);
explain (costs off, verbose on) select * from mc3p where a = 1;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p0  public.mc3p1  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: (mc3p.a = 1)
(6 rows)

explain (costs off, verbose on) select * from mc3p where a = 1 and abs(b) < 1;
                        QUERY PLAN                         
-----------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p0  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: ((mc3p.a = 1) AND (abs(mc3p.b) < 1))
(6 rows)

explain (costs off, verbose on) select * from mc3p where a = 1 and abs(b) = 1;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p0  public.mc3p1  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: ((mc3p.a = 1) AND (abs(mc3p.b) = 1))
(6 rows)

explain (costs off, verbose on) select * from mc3p where a = 1 and abs(b) = 1 and c < 8;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p0  public.mc3p1
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: ((mc3p.c < 8) AND (mc3p.a = 1) AND (abs(mc3p.b) = 1))
(6 rows)

explain (costs off, verbose on) select * from mc3p where a = 10 and abs(b) between 5 and 35;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p1  public.mc3p2  public.mc3p3  public.mc3p4  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: ((mc3p.a = 10) AND (abs(mc3p.b) >= 5) AND (abs(mc3p.b) <= 35))
(6 rows)

explain (costs off, verbose on) select * from mc3p where a > 10;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p5  public.mc3p6  public.mc3p7  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: (mc3p.a > 10)
(6 rows)

explain (costs off, verbose on) select * from mc3p where a >= 10;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p1  public.mc3p2  public.mc3p3  public.mc3p4  public.mc3p5  public.mc3p6  public.mc3p7  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: (mc3p.a >= 10)
(6 rows)

explain (costs off, verbose on) select * from mc3p where a < 10;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p0  public.mc3p1  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: (mc3p.a < 10)
(6 rows)

explain (costs off, verbose on) select * from mc3p where a <= 10 and abs(b) < 10;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p0  public.mc3p1  public.mc3p2  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: ((mc3p.a <= 10) AND (abs(mc3p.b) < 10))
(6 rows)

explain (costs off, verbose on) select * from mc3p where a = 11 and abs(b) = 0;
                      QUERY PLAN                       
-------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: ((mc3p.a = 11) AND (abs(mc3p.b) = 0))
(6 rows)

explain (costs off, verbose on) select * from mc3p where a = 20 and abs(b) = 10 and c = 100;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p6
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: ((mc3p.a = 20) AND (mc3p.c = 100) AND (abs(mc3p.b) = 10))
(6 rows)

explain (costs off, verbose on) select * from mc3p where a > 20;
                        QUERY PLAN                         
-----------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p7  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: (mc3p.a > 20)
(6 rows)

explain (costs off, verbose on) select * from mc3p where a >= 20;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p5  public.mc3p6  public.mc3p7  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: (mc3p.a >= 20)
(6 rows)

explain (costs off, verbose on) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20);
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p1  public.mc3p2  public.mc3p5  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: (((mc3p.a = 1) AND (abs(mc3p.b) = 1) AND (mc3p.c = 1)) OR ((mc3p.a = 10) AND (abs(mc3p.b) = 5) AND (mc3p.c = 10)) OR ((mc3p.a > 11) AND (mc3p.a < 20)))
(6 rows)

explain (costs off, verbose on) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20) or a < 1;
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p0  public.mc3p1  public.mc3p2  public.mc3p5  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: (((mc3p.a = 1) AND (abs(mc3p.b) = 1) AND (mc3p.c = 1)) OR ((mc3p.a = 10) AND (abs(mc3p.b) = 5) AND (mc3p.c = 10)) OR ((mc3p.a > 11) AND (mc3p.a < 20)) OR (mc3p.a < 1))
(6 rows)

explain (costs off, verbose on) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20) or a < 1 or a = 1;
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p0  public.mc3p1  public.mc3p2  public.mc3p5  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: (((mc3p.a = 1) AND (abs(mc3p.b) = 1) AND (mc3p.c = 1)) OR ((mc3p.a = 10) AND (abs(mc3p.b) = 5) AND (mc3p.c = 10)) OR ((mc3p.a > 11) AND (mc3p.a < 20)) OR (mc3p.a < 1) OR (mc3p.a = 1))
(6 rows)

explain (costs off, verbose on) select * from mc3p where a = 1 or abs(b) = 1 or c = 1;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p0  public.mc3p1  public.mc3p2  public.mc3p3  public.mc3p4  public.mc3p5  public.mc3p6  public.mc3p7  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: ((mc3p.a = 1) OR (abs(mc3p.b) = 1) OR (mc3p.c = 1))
(6 rows)

explain (costs off, verbose on) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 and abs(b) = 10);
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p0  public.mc3p1  public.mc3p2  public.mc3p3  public.mc3p4  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: (((mc3p.a = 1) AND (abs(mc3p.b) = 1)) OR ((mc3p.a = 10) AND (abs(mc3p.b) = 10)))
(6 rows)

explain (costs off, verbose on) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 and abs(b) = 9);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 PartIterator
   Output: mc3p.a, mc3p.b, mc3p.c
   ->  Seq Scan on public.mc3p
         Part Iterator:  public.mc3p0  public.mc3p1  public.mc3p2  public.mc3p_default
         Output: mc3p.a, mc3p.b, mc3p.c
         Filter: (((mc3p.a = 1) AND (abs(mc3p.b) = 1)) OR ((mc3p.a = 10) AND (abs(mc3p.b) = 9)))
(6 rows)

-- a simpler multi-column keys case
create table mc2p (a int, b int) partition by range (a, b);
create table mc2p_default partition of mc2p default;
create table mc2p0 partition of mc2p for values from (minvalue, minvalue) to (1, minvalue);
create table mc2p1 partition of mc2p for values from (1, minvalue) to (1, 1);
create table mc2p2 partition of mc2p for values from (1, 1) to (2, minvalue);
create table mc2p3 partition of mc2p for values from (2, minvalue) to (2, 1);
create table mc2p4 partition of mc2p for values from (2, 1) to (2, maxvalue);
create table mc2p5 partition of mc2p for values from (2, maxvalue) to (maxvalue, maxvalue);
explain (costs off, verbose on) select * from mc2p where a < 2;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 PartIterator
   Output: mc2p.a, mc2p.b
   ->  Seq Scan on public.mc2p
         Part Iterator:  public.mc2p0  public.mc2p1  public.mc2p2  public.mc2p_default
         Output: mc2p.a, mc2p.b
         Filter: (mc2p.a < 2)
(6 rows)

explain (costs off, verbose on) select * from mc2p where a = 2 and b < 1;
                   QUERY PLAN                    
-------------------------------------------------
 PartIterator
   Output: mc2p.a, mc2p.b
   ->  Seq Scan on public.mc2p
         Part Iterator:  public.mc2p3
         Output: mc2p.a, mc2p.b
         Filter: ((mc2p.b < 1) AND (mc2p.a = 2))
(6 rows)

explain (costs off, verbose on) select * from mc2p where a > 1;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 PartIterator
   Output: mc2p.a, mc2p.b
   ->  Seq Scan on public.mc2p
         Part Iterator:  public.mc2p2  public.mc2p3  public.mc2p4  public.mc2p5  public.mc2p_default
         Output: mc2p.a, mc2p.b
         Filter: (mc2p.a > 1)
(6 rows)

explain (costs off, verbose on) select * from mc2p where a = 1 and b > 1;
                   QUERY PLAN                    
-------------------------------------------------
 PartIterator
   Output: mc2p.a, mc2p.b
   ->  Seq Scan on public.mc2p
         Part Iterator:  public.mc2p2
         Output: mc2p.a, mc2p.b
         Filter: ((mc2p.b > 1) AND (mc2p.a = 1))
(6 rows)

-- all partitions but the default one should be pruned
explain (costs off, verbose on) select * from mc2p where a = 1 and b is null;
                     QUERY PLAN                      
-----------------------------------------------------
 PartIterator
   Output: mc2p.a, mc2p.b
   ->  Seq Scan on public.mc2p
         Part Iterator:  public.mc2p_default
         Output: mc2p.a, mc2p.b
         Filter: ((mc2p.b IS NULL) AND (mc2p.a = 1))
(6 rows)

explain (costs off, verbose on) select * from mc2p where a is null and b is null;
                       QUERY PLAN                        
---------------------------------------------------------
 PartIterator
   Output: mc2p.a, mc2p.b
   ->  Seq Scan on public.mc2p
         Part Iterator:  public.mc2p_default
         Output: mc2p.a, mc2p.b
         Filter: ((mc2p.a IS NULL) AND (mc2p.b IS NULL))
(6 rows)

explain (costs off, verbose on) select * from mc2p where a is null and b = 1;
                     QUERY PLAN                      
-----------------------------------------------------
 PartIterator
   Output: mc2p.a, mc2p.b
   ->  Seq Scan on public.mc2p
         Part Iterator:  public.mc2p_default
         Output: mc2p.a, mc2p.b
         Filter: ((mc2p.a IS NULL) AND (mc2p.b = 1))
(6 rows)

explain (costs off, verbose on) select * from mc2p where a is null;
                 QUERY PLAN                  
---------------------------------------------
 PartIterator
   Output: mc2p.a, mc2p.b
   ->  Seq Scan on public.mc2p
         Part Iterator:  public.mc2p_default
         Output: mc2p.a, mc2p.b
         Filter: (mc2p.a IS NULL)
(6 rows)

explain (costs off, verbose on) select * from mc2p where b is null;
                 QUERY PLAN                  
---------------------------------------------
 PartIterator
   Output: mc2p.a, mc2p.b
   ->  Seq Scan on public.mc2p
         Part Iterator:  public.mc2p_default
         Output: mc2p.a, mc2p.b
         Filter: (mc2p.b IS NULL)
(6 rows)

-- boolean partitioning
create table boolpart (a bool) partition by list (a);
create table boolpart_default partition of boolpart default;
create table boolpart_t partition of boolpart for values in ('true');
create table boolpart_f partition of boolpart for values in ('false');
explain (costs off, verbose on) select * from boolpart where a in (true, false);
                          QUERY PLAN                          
--------------------------------------------------------------
 PartIterator
   Output: boolpart.a
   ->  Seq Scan on public.boolpart
         Part Iterator:  public.boolpart_f  public.boolpart_t
         Output: boolpart.a
         Filter: (boolpart.a = ANY ('{t,f}'::boolean[]))
(6 rows)

explain (costs off, verbose on) select * from boolpart where a = false;
                QUERY PLAN                 
-------------------------------------------
 PartIterator
   Output: boolpart.a
   ->  Seq Scan on public.boolpart
         Part Iterator:  public.boolpart_f
         Output: boolpart.a
         Filter: (NOT boolpart.a)
(6 rows)

explain (costs off, verbose on) select * from boolpart where not a = false;
                QUERY PLAN                 
-------------------------------------------
 PartIterator
   Output: boolpart.a
   ->  Seq Scan on public.boolpart
         Part Iterator:  public.boolpart_t
         Output: boolpart.a
         Filter: boolpart.a
(6 rows)

explain (costs off, verbose on) select * from boolpart where a is true or a is not true;
                             QUERY PLAN                             
--------------------------------------------------------------------
 PartIterator
   Output: boolpart.a
   ->  Seq Scan on public.boolpart
         Part Iterator:  public.boolpart_f  public.boolpart_t
         Output: boolpart.a
         Filter: ((boolpart.a IS TRUE) OR (boolpart.a IS NOT TRUE))
(6 rows)

explain (costs off, verbose on) select * from boolpart where a is not true;
                QUERY PLAN                 
-------------------------------------------
 PartIterator
   Output: boolpart.a
   ->  Seq Scan on public.boolpart
         Part Iterator:  public.boolpart_f
         Output: boolpart.a
         Filter: (boolpart.a IS NOT TRUE)
(6 rows)

explain (costs off, verbose on) select * from boolpart where a is not true and a is not false;
        QUERY PLAN        
--------------------------
 Result
   Output: a
   One-Time Filter: false
(3 rows)

explain (costs off, verbose on) select * from boolpart where a is unknown;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 PartIterator
   Output: boolpart.a
   ->  Seq Scan on public.boolpart
         Part Iterator:  public.boolpart_f  public.boolpart_t  public.boolpart_default
         Output: boolpart.a
         Filter: (boolpart.a IS UNKNOWN)
(6 rows)

explain (costs off, verbose on) select * from boolpart where a is not unknown;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 PartIterator
   Output: boolpart.a
   ->  Seq Scan on public.boolpart
         Part Iterator:  public.boolpart_f  public.boolpart_t  public.boolpart_default
         Output: boolpart.a
         Filter: (boolpart.a IS NOT UNKNOWN)
(6 rows)

create table boolrangep (a bool, b bool, c int) partition by range (a,b,c);
create table boolrangep_tf partition of boolrangep for values from ('true', 'false', 0) to ('true', 'false', 100);
create table boolrangep_ft partition of boolrangep for values from ('false', 'true', 0) to ('false', 'true', 100);
create table boolrangep_ff1 partition of boolrangep for values from ('false', 'false', 0) to ('false', 'false', 50);
create table boolrangep_ff2 partition of boolrangep for values from ('false', 'false', 50) to ('false', 'false', 100);
-- try a more complex case that's been known to trip up pruning in the past
explain (costs off, verbose on)  select * from boolrangep where not a and not b and c = 25;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 PartIterator
   Output: boolrangep.a, boolrangep.b, boolrangep.c
   ->  Seq Scan on public.boolrangep
         Part Iterator:  public.boolrangep_ff1
         Output: boolrangep.a, boolrangep.b, boolrangep.c
         Filter: ((NOT boolrangep.a) AND (NOT boolrangep.b) AND (boolrangep.c = 25))
(6 rows)

-- test scalar-to-array operators
create table coercepart (a varchar) partition by list (a);
create table coercepart_ab partition of coercepart for values in ('ab');
create table coercepart_bc partition of coercepart for values in ('bc');
create table coercepart_cd partition of coercepart for values in ('cd');
explain (costs off, verbose on) select * from coercepart where a in ('ab', to_char(125, '999'));
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: coercepart.a
   ->  Seq Scan on public.coercepart
         Part Iterator:  public.coercepart_ab
         Part Removed: 2
         Part Removed Detail:  public.coercepart_bc public.coercepart_cd
         Output: coercepart.a
         Filter: ((coercepart.a)::text = ANY ((ARRAY['ab'::character varying, (to_char(125, '999'::text))::character varying])::text[]))
(8 rows)

explain (costs off, verbose on) select * from coercepart where a ~ any ('{ab}');
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 PartIterator
   Output: coercepart.a
   ->  Seq Scan on public.coercepart
         Part Iterator:  public.coercepart_ab  public.coercepart_bc  public.coercepart_cd
         Output: coercepart.a
         Filter: ((coercepart.a)::text ~ ANY ('{ab}'::text[]))
(6 rows)

explain (costs off, verbose on) select * from coercepart where a !~ all ('{ab}');
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 PartIterator
   Output: coercepart.a
   ->  Seq Scan on public.coercepart
         Part Iterator:  public.coercepart_ab  public.coercepart_bc  public.coercepart_cd
         Output: coercepart.a
         Filter: ((coercepart.a)::text !~ ALL ('{ab}'::text[]))
(6 rows)

explain (costs off, verbose on) select * from coercepart where a ~ any ('{ab,bc}');
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 PartIterator
   Output: coercepart.a
   ->  Seq Scan on public.coercepart
         Part Iterator:  public.coercepart_ab  public.coercepart_bc  public.coercepart_cd
         Output: coercepart.a
         Filter: ((coercepart.a)::text ~ ANY ('{ab,bc}'::text[]))
(6 rows)

explain (costs off, verbose on) select * from coercepart where a !~ all ('{ab,bc}');
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 PartIterator
   Output: coercepart.a
   ->  Seq Scan on public.coercepart
         Part Iterator:  public.coercepart_ab  public.coercepart_bc  public.coercepart_cd
         Output: coercepart.a
         Filter: ((coercepart.a)::text !~ ALL ('{ab,bc}'::text[]))
(6 rows)

drop table coercepart;
CREATE TABLE part (a INT, b INT) PARTITION BY LIST (a);
CREATE TABLE part_p1 PARTITION OF part FOR VALUES IN (-2,-1,0,1,2);
CREATE TABLE part_p2 PARTITION OF part DEFAULT PARTITION BY RANGE(a);
CREATE TABLE part_p2_p1 PARTITION OF part_p2 DEFAULT;
INSERT INTO part VALUES (-1,-1), (1,1), (2,NULL), (NULL,-2),(NULL,NULL);
explain (costs off, verbose on) SELECT tableoid::regclass as part, a, b FROM part WHERE a IS NULL ORDER BY 1, 2, 3;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Sort
   Output: ((part.tableoid)::regclass), part.a, part.b
   Sort Key: ((part.tableoid)::regclass), part.a, part.b
   ->  PartIterator
         Output: ((part.tableoid)::regclass), part.a, part.b
         ->  Seq Scan on public.part
               Part Iterator:  public.part_p2_p1
               Output: (part.tableoid)::regclass, part.a, part.b
               Filter: (part.a IS NULL)
(9 rows)

--
-- some more cases
--
--
-- pruning for partitioned table appearing inside a sub-query
--
-- pruning won't work for mc3p, because some keys are Params
explain (costs off, verbose on) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.a = t1.b and abs(t2.b) = 1 and t2.c = 1) s where t1.a = 1;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: t1.a, t1.b, (count(*))
   ->  PartIterator
         Output: t1.a, t1.b
         ->  Seq Scan on public.mc2p t1
               Part Iterator:  public.mc2p1  public.mc2p2  public.mc2p_default
               Output: t1.a, t1.b
               Filter: (t1.a = 1)
   ->  Aggregate
         Output: count(*)
         ->  PartIterator
               ->  Seq Scan on public.mc3p t2
                     Part Iterator:  public.mc3p0  public.mc3p1  public.mc3p2  public.mc3p3  public.mc3p4  public.mc3p5  public.mc3p6  public.mc3p7  public.mc3p_default
                     Filter: ((t2.a = t1.b) AND (t2.c = 1) AND (abs(t2.b) = 1))
(14 rows)

-- pruning should work fine, because values for a prefix of keys (a, b) are
-- available
explain (costs off, verbose on) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.c = t1.b and abs(t2.b) = 1 and t2.a = 1) s where t1.a = 1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Nested Loop
   Output: t1.a, t1.b, (count(*))
   ->  PartIterator
         Output: t1.a, t1.b
         ->  Seq Scan on public.mc2p t1
               Part Iterator:  public.mc2p1  public.mc2p2  public.mc2p_default
               Output: t1.a, t1.b
               Filter: (t1.a = 1)
   ->  Aggregate
         Output: count(*)
         ->  PartIterator
               ->  Seq Scan on public.mc3p t2
                     Part Iterator:  public.mc3p0  public.mc3p1  public.mc3p_default
                     Filter: ((t2.c = t1.b) AND (t2.a = 1) AND (abs(t2.b) = 1))
(14 rows)

-- also here, because values for all keys are provided
explain (costs off, verbose on) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.a = 1 and abs(t2.b) = 1 and t2.c = 1) s where t1.a = 1;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Nested Loop
   Output: t1.a, t1.b, (count(*))
   ->  Aggregate
         Output: count(*)
         ->  PartIterator
               ->  Seq Scan on public.mc3p t2
                     Part Iterator:  public.mc3p1
                     Filter: ((t2.a = 1) AND (t2.c = 1) AND (abs(t2.b) = 1))
   ->  PartIterator
         Output: t1.a, t1.b
         ->  Seq Scan on public.mc2p t1
               Part Iterator:  public.mc2p1  public.mc2p2  public.mc2p_default
               Output: t1.a, t1.b
               Filter: (t1.a = 1)
(14 rows)

--
-- pruning with clauses containing <> operator
--
-- doesn't prune range partitions
create table rp (a int) partition by range (a);
create table rp0 partition of rp for values from (minvalue) to (1);
create table rp1 partition of rp for values from (1) to (2);
create table rp2 partition of rp for values from (2) to (maxvalue);
explain (costs off, verbose on) select * from rp where a <> 1;
                         QUERY PLAN                         
------------------------------------------------------------
 PartIterator
   Output: rp.a
   ->  Seq Scan on public.rp
         Part Iterator:  public.rp0  public.rp1  public.rp2
         Output: rp.a
         Filter: (rp.a <> 1)
(6 rows)

explain (costs off, verbose on) select * from rp where a <> 1 and a <> 2;
                         QUERY PLAN                         
------------------------------------------------------------
 PartIterator
   Output: rp.a
   ->  Seq Scan on public.rp
         Part Iterator:  public.rp0  public.rp1  public.rp2
         Output: rp.a
         Filter: ((rp.a <> 1) AND (rp.a <> 2))
(6 rows)

-- null partition should be eliminated due to strict <> clause.
explain (costs off, verbose on) select * from lp where a <> 'a';
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_ad  public.lp_bc  public.lp_ef  public.lp_g  public.lp_default
         Output: lp.a
         Filter: (lp.a <> 'a'::bpchar)
(6 rows)

-- ensure we detect contradictions in clauses; a can't be NULL and NOT NULL.
explain (costs off, verbose on) select * from lp where a <> 'a' and a is null;
        QUERY PLAN        
--------------------------
 Result
   Output: a
   One-Time Filter: false
(3 rows)

explain (costs off, verbose on) select * from lp where (a <> 'a' and a <> 'd') or a is null;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 PartIterator
   Output: lp.a
   ->  Seq Scan on public.lp
         Part Iterator:  public.lp_bc  public.lp_ef  public.lp_g  public.lp_null  public.lp_default
         Output: lp.a
         Filter: (((lp.a <> 'a'::bpchar) AND (lp.a <> 'd'::bpchar)) OR (lp.a IS NULL))
(6 rows)

-- check that it also works for a partitioned table that's not root,
-- which in this case are partitions of rlp that are themselves
-- list-partitioned on b
explain (costs off, verbose on) select * from rlp where a = 15 and b <> 'ab' and b <> 'cd' and b <> 'xy' and b is not null;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: rlp.a, rlp.b
   ->  Seq Scan on public.rlp
         Part Iterator:  public.rlp3efgh  public.rlp3_default
         Output: rlp.a, rlp.b
         Filter: ((rlp.b IS NOT NULL) AND ((rlp.b)::text <> 'ab'::text) AND ((rlp.b)::text <> 'cd'::text) AND ((rlp.b)::text <> 'xy'::text) AND (rlp.a = 15))
(6 rows)

--
-- different collations for different keys with same expression
--
create table coll_pruning_multi (a text) partition by range (substr(a, 1) collate "POSIX", substr(a, 1) collate "C");
create table coll_pruning_multi1 partition of coll_pruning_multi for values from ('a', 'a') to ('a', 'e');
create table coll_pruning_multi2 partition of coll_pruning_multi for values from ('a', 'e') to ('a', 'z');
create table coll_pruning_multi3 partition of coll_pruning_multi for values from ('b', 'a') to ('b', 'e');
-- no pruning, because no value for the leading key
explain (costs off, verbose on) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C";
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: coll_pruning_multi.a
   ->  Seq Scan on public.coll_pruning_multi
         Part Iterator:  public.coll_pruning_multi1  public.coll_pruning_multi2  public.coll_pruning_multi3
         Output: coll_pruning_multi.a
         Filter: (substr(coll_pruning_multi.a, 1) = 'e'::text COLLATE "C")
(6 rows)

-- pruning, with a value provided for the leading key
explain (costs off, verbose on) select * from coll_pruning_multi where substr(a, 1) = 'a' collate "POSIX";
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 PartIterator
   Output: coll_pruning_multi.a
   ->  Seq Scan on public.coll_pruning_multi
         Part Iterator:  public.coll_pruning_multi1  public.coll_pruning_multi2
         Output: coll_pruning_multi.a
         Filter: (substr(coll_pruning_multi.a, 1) = 'a'::text COLLATE "POSIX")
(6 rows)

-- pruning, with values provided for both keys
explain (costs off, verbose on) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C" and substr(a, 1) = 'a' collate "POSIX";
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   Output: coll_pruning_multi.a
   ->  Seq Scan on public.coll_pruning_multi
         Part Iterator:  public.coll_pruning_multi2
         Output: coll_pruning_multi.a
         Filter: ((substr(coll_pruning_multi.a, 1) = 'e'::text COLLATE "C") AND (substr(coll_pruning_multi.a, 1) = 'a'::text COLLATE "POSIX"))
(6 rows)

--
-- LIKE operators don't prune
--
create table like_op_noprune (a text) partition by list (a);
create table like_op_noprune1 partition of like_op_noprune for values in ('ABC');
create table like_op_noprune2 partition of like_op_noprune for values in ('BCD');
explain (costs off, verbose on) select * from like_op_noprune where a like '%BC';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 PartIterator
   Output: like_op_noprune.a
   ->  Seq Scan on public.like_op_noprune
         Part Iterator:  public.like_op_noprune1  public.like_op_noprune2
         Output: like_op_noprune.a
         Filter: (like_op_noprune.a ~~ '%BC'::text)
(6 rows)

--
-- tests wherein clause value requires a cross-type comparison function
--
create table lparted_by_int2 (a smallint) partition by list (a);
create table lparted_by_int2_1 partition of lparted_by_int2 for values in (1);
create table lparted_by_int2_16384 partition of lparted_by_int2 for values in (16384);
explain (costs off, verbose on) select * from lparted_by_int2 where a = 100000000000000;
        QUERY PLAN        
--------------------------
 Result
   Output: a
   One-Time Filter: false
(3 rows)

create table rparted_by_int2 (a smallint) partition by range (a);
create table rparted_by_int2_1 partition of rparted_by_int2 for values from (1) to (10);
create table rparted_by_int2_16384 partition of rparted_by_int2 for values from (10) to (16384);
-- all partitions pruned
explain (costs off, verbose on) select * from rparted_by_int2 where a > 100000000000000;
        QUERY PLAN        
--------------------------
 Result
   Output: a
   One-Time Filter: false
(3 rows)

create table rparted_by_int2_maxvalue partition of rparted_by_int2 for values from (16384) to (maxvalue);
-- all partitions but rparted_by_int2_maxvalue pruned
explain (costs off, verbose on) select * from rparted_by_int2 where a > 100000000000000;
                           QUERY PLAN                            
-----------------------------------------------------------------
 PartIterator
   Output: rparted_by_int2.a
   ->  Seq Scan on public.rparted_by_int2
         Part Iterator:  public.rparted_by_int2_maxvalue
         Output: rparted_by_int2.a
         Filter: (rparted_by_int2.a > '100000000000000'::bigint)
(6 rows)

drop table lp, coll_pruning, rlp, mc3p, mc2p, boolpart, boolrangep, rp, coll_pruning_multi, like_op_noprune, lparted_by_int2, rparted_by_int2;
--
-- Test Partition pruning for HASH partitioning
--
-- Use hand-rolled hash functions and operator classes to get predictable
-- result on different machines.  See the definitions of
-- part_part_test_int4_ops and part_test_text_ops in insert.sql.
--
create or replace function part_hashint4_noop(value int4, seed int8)
returns int8 as $$
select value + seed;
$$ language sql immutable;
create operator class part_test_int4_ops
for type int4
using hash as
operator 1 =,
function 2 part_hashint4_noop(int4, int8);
create or replace function part_hashtext_length(value text, seed int8)
RETURNS int8 AS $$
select length(coalesce(value, ''))::int8
$$ language sql immutable;
create operator class part_test_text_ops
for type text
using hash as
operator 1 =,
function 2 part_hashtext_length(text, int8);
create table hp (a int, b text, c int)
  partition by hash (a part_test_int4_ops, b part_test_text_ops);
create table hp0 partition of hp for values with (modulus 4, remainder 0);
create table hp3 partition of hp for values with (modulus 4, remainder 3);
create table hp1 partition of hp for values with (modulus 4, remainder 1);
create table hp2 partition of hp for values with (modulus 4, remainder 2);
insert into hp values (null, null, 0);
insert into hp values (1, null, 1);
insert into hp values (1, 'xxx', 2);
insert into hp values (null, 'xxx', 3);
insert into hp values (2, 'xxx', 4);
insert into hp values (1, 'abcde', 5);
select tableoid::regclass, * from hp order by c;
 tableoid | a |   b   | c 
----------+---+-------+---
 hp0      |   |       | 0
 hp1      | 1 |       | 1
 hp0      | 1 | xxx   | 2
 hp2      |   | xxx   | 3
 hp3      | 2 | xxx   | 4
 hp2      | 1 | abcde | 5
(6 rows)

-- test pruning when not all the partitions exist
drop table hp1;
drop table hp3;
explain (costs off) select * from hp where a = 1 and b = 'abcde';
                    QUERY PLAN                     
---------------------------------------------------
 PartIterator
   ->  Seq Scan on hp
         Filter: ((a = 1) AND (b = 'abcde'::text))
(3 rows)

select * from hp where a = 1 and b = 'abcde';
 a |   b   | c 
---+-------+---
 1 | abcde | 5
(1 row)

explain (costs off) select * from hp where a = 1 and b = 'abcde' and
  (c = 2 or c = 3);
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 PartIterator
   ->  Seq Scan on hp
         Filter: ((a = 1) AND (b = 'abcde'::text) AND ((c = 2) OR (c = 3)))
(3 rows)

select * from hp where a = 1 and b = 'abcde' and
  (c = 2 or c = 3);
 a | b | c 
---+---+---
(0 rows)

drop table hp2;
explain (costs off) select * from hp where a = 1 and b = 'abcde' and
  (c = 2 or c = 3);
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

select * from hp where a = 1 and b = 'abcde' and
  (c = 2 or c = 3);
 a | b | c 
---+---+---
(0 rows)

select tableoid::regclass, * from hp order by c;
 tableoid | a |  b  | c 
----------+---+-----+---
 hp0      |   |     | 0
 hp0      | 1 | xxx | 2
(2 rows)

drop table hp;
drop function part_hashtext_length CASCADE;
NOTICE:  drop cascades to operator class part_test_text_ops for access method hash
drop function part_hashint4_noop CASCADE;
NOTICE:  drop cascades to operator class part_test_int4_ops for access method hash
show enable_fast_query_shipping;
 enable_fast_query_shipping 
----------------------------
 on
(1 row)

set enable_fast_query_shipping to off;
--
-- Test runtime partition pruning
--
create table ab (a int not null, b int not null) partition by list (a);
create table ab_a2 partition of ab for values in(2) partition by list (b);
create table ab_a2_b1 partition of ab_a2 for values in (1);
create table ab_a2_b2 partition of ab_a2 for values in (2);
create table ab_a2_b3 partition of ab_a2 for values in (3);
create table ab_a1 partition of ab for values in(1) partition by list (b);
create table ab_a1_b1 partition of ab_a1 for values in (1);
create table ab_a1_b2 partition of ab_a1 for values in (2);
create table ab_a1_b3 partition of ab_a1 for values in (3);
create table ab_a3 partition of ab for values in(3) partition by list (b);
create table ab_a3_b1 partition of ab_a3 for values in (1);
create table ab_a3_b2 partition of ab_a3 for values in (2);
create table ab_a3_b3 partition of ab_a3 for values in (3);
prepare ab_q1 (int, int, int) as
select * from ab where a between $1 and $2 and b <= $3;
-- Execute query 5 times to allow choose_custom_plan
-- to start considering a generic plan.
execute ab_q1 (1, 8, 3);
 a | b 
---+---
(0 rows)

execute ab_q1 (1, 8, 3);
 a | b 
---+---
(0 rows)

execute ab_q1 (1, 8, 3);
 a | b 
---+---
(0 rows)

execute ab_q1 (1, 8, 3);
 a | b 
---+---
(0 rows)

execute ab_q1 (1, 8, 3);
 a | b 
---+---
(0 rows)

explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q1 (2, 2, 3);
                       QUERY PLAN                        
---------------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   ->  Seq Scan on ab (actual rows=0 loops=3)
         Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))
(3 rows)

explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q1 (1, 2, 3);
                       QUERY PLAN                        
---------------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   ->  Seq Scan on ab (actual rows=0 loops=6)
         Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))
(3 rows)

deallocate ab_q1;
-- Runtime pruning after optimizer pruning
prepare ab_q1 (int, int) as
select a from ab where a between $1 and $2 and b < 3;
-- Execute query 5 times to allow choose_custom_plan
-- to start considering a generic plan.
execute ab_q1 (1, 8);
 a 
---
(0 rows)

execute ab_q1 (1, 8);
 a 
---
(0 rows)

execute ab_q1 (1, 8);
 a 
---
(0 rows)

execute ab_q1 (1, 8);
 a 
---
(0 rows)

execute ab_q1 (1, 8);
 a 
---
(0 rows)

explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q1 (2, 2);
                      QUERY PLAN                       
-------------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   ->  Seq Scan on ab (actual rows=0 loops=2)
         Filter: ((a >= $1) AND (a <= $2) AND (b < 3))
(3 rows)

explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q1 (2, 4);
                      QUERY PLAN                       
-------------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   ->  Seq Scan on ab (actual rows=0 loops=4)
         Filter: ((a >= $1) AND (a <= $2) AND (b < 3))
(3 rows)

-- Ensure a mix of external and exec params work together at different
-- levels of partitioning.
prepare ab_q2 (int, int) as
select a from ab where a between $1 and $2 and b < (select 3);
execute ab_q2 (1, 8);
 a 
---
(0 rows)

execute ab_q2 (1, 8);
 a 
---
(0 rows)

execute ab_q2 (1, 8);
 a 
---
(0 rows)

execute ab_q2 (1, 8);
 a 
---
(0 rows)

execute ab_q2 (1, 8);
 a 
---
(0 rows)

explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q2 (2, 2);
                       QUERY PLAN                       
--------------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   InitPlan 1 (returns $0)
     ->  Result (never executed)
   ->  Seq Scan on ab (actual rows=0 loops=3)
         Filter: ((a >= $1) AND (a <= $2) AND (b < $0))
(5 rows)

-- As above, but with swap the exec param to the first partition level
prepare ab_q3 (int, int) as
select a from ab where b between $1 and $2 and a < (select 3);
execute ab_q3 (1, 8);
 a 
---
(0 rows)

execute ab_q3 (1, 8);
 a 
---
(0 rows)

execute ab_q3 (1, 8);
 a 
---
(0 rows)

execute ab_q3 (1, 8);
 a 
---
(0 rows)

execute ab_q3 (1, 8);
 a 
---
(0 rows)

explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q3 (2, 2);
                       QUERY PLAN                       
--------------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   InitPlan 1 (returns $0)
     ->  Result (never executed)
   ->  Seq Scan on ab (actual rows=0 loops=3)
         Filter: ((b >= $1) AND (b <= $2) AND (a < $0))
(5 rows)

-- Test a backwards Append scan
create table list_part (a int) partition by list (a);
create table list_part1 partition of list_part for values in (1);
create table list_part2 partition of list_part for values in (2);
create table list_part3 partition of list_part for values in (3);
create table list_part4 partition of list_part for values in (4);
insert into list_part select generate_series(1,4);
begin;
-- Don't select an actual value out of the table as the order of the Append's
-- subnodes may not be stable.
declare cur SCROLL CURSOR for select 1 from list_part where a > (select 1) and a < (select 4);
-- move beyond the final row
move 3 from cur;
-- Ensure we get two rows.
fetch backward all from cur;
 ?column? 
----------
        1
        1
(2 rows)

commit;
drop table list_part;
-- Parallel append
prepare ab_q4 (int, int) as
select avg(a) from ab where a between $1 and $2 and b < 4;
-- Encourage use of parallel plans
set parallel_setup_cost = 0;
set parallel_tuple_cost = 0;
set min_parallel_table_scan_size = 0;
set max_parallel_workers_per_gather = 2;
-- Execute query 5 times to allow choose_custom_plan
-- to start considering a generic plan.
execute ab_q4 (1, 8);
 avg 
-----
    
(1 row)

execute ab_q4 (1, 8);
 avg 
-----
    
(1 row)

execute ab_q4 (1, 8);
 avg 
-----
    
(1 row)

execute ab_q4 (1, 8);
 avg 
-----
    
(1 row)

execute ab_q4 (1, 8);
 avg 
-----
    
(1 row)

explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q4 (2, 2);
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Finalize Aggregate (actual rows=1 loops=1)
   ->  Gather (actual rows=2 loops=1)
         Workers Planned: 2
         Workers Launched: 2
         ->  Partial Aggregate (actual rows=1 loops=2)
               ->  Parallel PartIterator (actual rows=0 loops=2)
                     ->  Parallel Seq Scan on ab (actual rows=0 loops=3)
                           Filter: ((a >= $1) AND (a <= $2) AND (b < 4))
(8 rows)

-- Test run-time pruning with IN lists.
prepare ab_q5 (int, int, int) as
select avg(a) from ab where a in($1,$2,$3) and b < 4;
-- Execute query 5 times to allow choose_custom_plan
-- to start considering a generic plan.
execute ab_q5 (1, 2, 3);
 avg 
-----
    
(1 row)

execute ab_q5 (1, 2, 3);
 avg 
-----
    
(1 row)

execute ab_q5 (1, 2, 3);
 avg 
-----
    
(1 row)

execute ab_q5 (1, 2, 3);
 avg 
-----
    
(1 row)

execute ab_q5 (1, 2, 3);
 avg 
-----
    
(1 row)

explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q5 (1, 1, 1);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate (actual rows=1 loops=1)
   ->  Gather (actual rows=2 loops=1)
         Workers Planned: 2
         Workers Launched: 2
         ->  Partial Aggregate (actual rows=1 loops=2)
               ->  Parallel PartIterator (actual rows=0 loops=2)
                     ->  Parallel Seq Scan on ab (actual rows=0 loops=3)
                           Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
(8 rows)

explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q5 (2, 3, 3);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate (actual rows=1 loops=1)
   ->  Gather (actual rows=2 loops=1)
         Workers Planned: 2
         Workers Launched: 2
         ->  Partial Aggregate (actual rows=1 loops=2)
               ->  Parallel PartIterator (actual rows=0 loops=2)
                     ->  Parallel Seq Scan on ab (actual rows=0 loops=6)
                           Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
(8 rows)

-- Test parallel Append with IN list and parameterized nested loops
create table lprt_a (a int not null);
-- Insert some values we won't find in ab
insert into lprt_a select 0 from generate_series(1,100);
-- and insert some values that we should find.
insert into lprt_a values(1),(1);
analyze lprt_a;
create index ab_a2_b1_a_idx on ab_a2_b1 (a);
create index ab_a2_b2_a_idx on ab_a2_b2 (a);
create index ab_a2_b3_a_idx on ab_a2_b3 (a);
create index ab_a1_b1_a_idx on ab_a1_b1 (a);
create index ab_a1_b2_a_idx on ab_a1_b2 (a);
create index ab_a1_b3_a_idx on ab_a1_b3 (a);
create index ab_a3_b1_a_idx on ab_a3_b1 (a);
create index ab_a3_b2_a_idx on ab_a3_b2 (a);
create index ab_a3_b3_a_idx on ab_a3_b3 (a);
set enable_hashjoin = 0;
set enable_mergejoin = 0;
prepare ab_q6 (int, int, int) as
select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in($1,$2,$3);
execute ab_q6 (1, 2, 3);
 avg 
-----
    
(1 row)

execute ab_q6 (1, 2, 3);
 avg 
-----
    
(1 row)

execute ab_q6 (1, 2, 3);
 avg 
-----
    
(1 row)

execute ab_q6 (1, 2, 3);
 avg 
-----
    
(1 row)

execute ab_q6 (1, 2, 3);
 avg 
-----
    
(1 row)

explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q6 (0, 0, 1);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate (actual rows=1 loops=1)
   ->  Gather (actual rows=2 loops=1)
         Workers Planned: 2
         Workers Launched: 2
         ->  Partial Aggregate (actual rows=1 loops=2)
               ->  Nested Loop (actual rows=0 loops=2)
                     Join Filter: (ab.a = a.a)
                     ->  Parallel PartIterator (actual rows=0 loops=2)
                           ->  Parallel Seq Scan on ab (actual rows=0 loops=9)
                     ->  Materialize (never executed)
                           ->  Seq Scan on lprt_a a (never executed)
                                 Filter: (a = ANY ('{0,0,1}'::integer[]))
(12 rows)

insert into lprt_a values(3),(3);
explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q6 (1, 0, 3);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate (actual rows=1 loops=1)
   ->  Gather (actual rows=2 loops=1)
         Workers Planned: 2
         Workers Launched: 2
         ->  Partial Aggregate (actual rows=1 loops=2)
               ->  Nested Loop (actual rows=0 loops=2)
                     Join Filter: (ab.a = a.a)
                     ->  Parallel PartIterator (actual rows=0 loops=2)
                           ->  Parallel Seq Scan on ab (actual rows=0 loops=9)
                     ->  Materialize (never executed)
                           ->  Seq Scan on lprt_a a (never executed)
                                 Filter: (a = ANY ('{1,0,3}'::integer[]))
(12 rows)

explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q6 (1, 0, 0);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate (actual rows=1 loops=1)
   ->  Gather (actual rows=2 loops=1)
         Workers Planned: 2
         Workers Launched: 2
         ->  Partial Aggregate (actual rows=1 loops=2)
               ->  Nested Loop (actual rows=0 loops=2)
                     Join Filter: (ab.a = a.a)
                     ->  Parallel PartIterator (actual rows=0 loops=2)
                           ->  Parallel Seq Scan on ab (actual rows=0 loops=9)
                     ->  Materialize (never executed)
                           ->  Seq Scan on lprt_a a (never executed)
                                 Filter: (a = ANY ('{1,0,0}'::integer[]))
(12 rows)

delete from lprt_a where a = 1;
explain (analyze, costs off, summary off, timing off, nodes off) execute ab_q6 (1, 0, 0);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Finalize Aggregate (actual rows=1 loops=1)
   ->  Gather (actual rows=2 loops=1)
         Workers Planned: 2
         Workers Launched: 2
         ->  Partial Aggregate (actual rows=1 loops=2)
               ->  Nested Loop (actual rows=0 loops=2)
                     Join Filter: (ab.a = a.a)
                     ->  Parallel PartIterator (actual rows=0 loops=2)
                           ->  Parallel Seq Scan on ab (actual rows=0 loops=9)
                     ->  Materialize (never executed)
                           ->  Seq Scan on lprt_a a (never executed)
                                 Filter: (a = ANY ('{1,0,0}'::integer[]))
(12 rows)

reset enable_hashjoin;
reset enable_mergejoin;
reset parallel_setup_cost;
reset parallel_tuple_cost;
reset min_parallel_table_scan_size;
reset max_parallel_workers_per_gather;
-- Test run-time partition pruning with an initplan
explain (analyze, costs off, summary off, timing off, nodes off)
select * from ab where a = (select max(a) from lprt_a) and b = (select max(a)-1 from lprt_a);
                         QUERY PLAN                         
------------------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   InitPlan 1 (returns $0)
     ->  Aggregate (never executed)
           ->  Seq Scan on lprt_a (never executed)
   InitPlan 2 (returns $1)
     ->  Aggregate (never executed)
           ->  Seq Scan on lprt_a lprt_a_1 (never executed)
   ->  Seq Scan on ab (actual rows=0 loops=9)
         Filter: ((a = $0) AND (b = $1))
(9 rows)

-- A case containing a UNION ALL with a non-partitioned child.
explain (analyze, costs off, summary off, timing off)
select * from (select * from ab where a = 1 union all (values(10,5)) union all select * from ab) ab where b = (select 1);
                       QUERY PLAN                        
---------------------------------------------------------
 Append (actual rows=0 loops=1)
   InitPlan 1 (returns $0)
     ->  Result (actual rows=1 loops=1)
   ->  PartIterator (actual rows=0 loops=1)
         ->  Seq Scan on ab ab_1 (actual rows=0 loops=3)
               Filter: ((a = 1) AND (b = $0))
   ->  Result (actual rows=0 loops=1)
         One-Time Filter: (5 = $0)
   ->  PartIterator (actual rows=0 loops=1)
         ->  Seq Scan on ab (actual rows=0 loops=9)
               Filter: (b = $0)
(11 rows)

deallocate ab_q1;
deallocate ab_q2;
deallocate ab_q3;
deallocate ab_q4;
deallocate ab_q5;
deallocate ab_q6;
-- UPDATE on a partition subtree has been seen to have problems.
insert into ab values (1,2);
explain (analyze, costs off, summary off, timing off)
update ab_a1 set b = 3 from ab where ab.a = 1 and ab.a = ab_a1.a;
                           QUERY PLAN                           
----------------------------------------------------------------
 Update on ab_a1 (actual rows=0 loops=1)
   Update on ab_a1_b1 ab_a1
   Update on ab_a1_b2 ab_a1
   Update on ab_a1_b3 ab_a1
   ->  Nested Loop (actual rows=1 loops=1)
         ->  PartIterator (actual rows=1 loops=1)
               ->  Seq Scan on ab_a1 (actual rows=0 loops=3)
                     Filter: (a = 1)
         ->  Materialize (actual rows=1 loops=1)
               ->  PartIterator (actual rows=1 loops=1)
                     ->  Seq Scan on ab (actual rows=0 loops=3)
                           Filter: (a = 1)
(12 rows)

table ab;
 a | b 
---+---
 1 | 3
(1 row)

-- Test UPDATE where source relation has run-time pruning enabled
truncate ab;
insert into ab values (1, 1), (1, 2), (1, 3), (2, 1);
explain (analyze, costs off, summary off, timing off)
update ab_a1 set b = 3 from ab_a2 where ab_a2.b = (select 1);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Update on ab_a1 (actual rows=0 loops=1)
   Update on ab_a1_b1 ab_a1
   Update on ab_a1_b2 ab_a1
   Update on ab_a1_b3 ab_a1
   InitPlan 1 (returns $0)
     ->  Result (actual rows=1 loops=1)
   ->  Nested Loop (actual rows=3 loops=1)
         ->  PartIterator (actual rows=3 loops=1)
               ->  Seq Scan on ab_a1 (actual rows=1 loops=3)
         ->  Materialize (actual rows=1 loops=3)
               ->  PartIterator (actual rows=1 loops=1)
                     ->  Seq Scan on ab_a2 (actual rows=0 loops=3)
                           Filter: (b = $0)
(13 rows)

select tableoid::regclass, * from ab order by a;
 tableoid | a | b 
----------+---+---
 ab_a1_b3 | 1 | 3
 ab_a1_b3 | 1 | 3
 ab_a1_b3 | 1 | 3
 ab_a2_b1 | 2 | 1
(4 rows)

drop table ab, lprt_a;
-- Join
create table tbl1(col1 int);
insert into tbl1 values (501), (505);
-- Basic table
create table tprt (col1 int) partition by range (col1);
create table tprt_1 partition of tprt for values from (1) to (501);
create table tprt_2 partition of tprt for values from (501) to (1001);
create table tprt_3 partition of tprt for values from (1001) to (2001);
create table tprt_4 partition of tprt for values from (2001) to (3001);
create table tprt_5 partition of tprt for values from (3001) to (4001);
create table tprt_6 partition of tprt for values from (4001) to (5001);
create index tprt1_idx on tprt_1 (col1);
create index tprt2_idx on tprt_2 (col1);
create index tprt3_idx on tprt_3 (col1);
create index tprt4_idx on tprt_4 (col1);
create index tprt5_idx on tprt_5 (col1);
create index tprt6_idx on tprt_6 (col1);
insert into tprt values (10), (20), (501), (502), (505), (1001), (4500);
set enable_hashjoin = off;
set enable_mergejoin = off;
select explain_filter('explain (analyze, costs off, summary off, timing off, nodes off)
select * from tbl1 join tprt on tbl1.col1 > tprt.col1;');
                    explain_filter                    
------------------------------------------------------
 Nested Loop (actual rows=N loops=N)
   Join Filter: (tbl1.col1 > tprt.col1)
   Rows Removed by Join Filter: N
   ->  PartIterator (actual rows=N loops=N)
         ->  Seq Scan on tprt (actual rows=N loops=N)
   ->  Materialize (actual rows=N loops=N)
         ->  Seq Scan on tbl1 (actual rows=N loops=N)
(7 rows)

select explain_filter('explain (analyze, costs off, summary off, timing off, nodes off)
select * from tbl1 join tprt on tbl1.col1 = tprt.col1;');
                           explain_filter                            
---------------------------------------------------------------------
 Gather (actual rows=N loops=N)
   Workers Planned: N
   Workers Launched: N
   ->  Nested Loop (actual rows=N loops=N)
         Join Filter: (tbl1.col1 = tprt.col1)
         Rows Removed by Join Filter: N
         ->  Parallel PartIterator (actual rows=N loops=N)
               ->  Parallel Seq Scan on tprt (actual rows=N loops=N)
         ->  Materialize (actual rows=N loops=N)
               ->  Seq Scan on tbl1 (actual rows=N loops=N)
(10 rows)

select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 > tprt.col1
order by tbl1.col1, tprt.col1;
 col1 | col1 
------+------
  501 |   10
  501 |   20
  505 |   10
  505 |   20
  505 |  501
  505 |  502
(6 rows)

select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 = tprt.col1
order by tbl1.col1, tprt.col1;
 col1 | col1 
------+------
  501 |  501
  505 |  505
(2 rows)

-- Multiple partitions
insert into tbl1 values (1001), (1010), (1011);
select explain_filter('explain (analyze, costs off, summary off, timing off, nodes off)
select * from tbl1 inner join tprt on tbl1.col1 > tprt.col1;');
                    explain_filter                    
------------------------------------------------------
 Nested Loop (actual rows=N loops=N)
   Join Filter: (tbl1.col1 > tprt.col1)
   Rows Removed by Join Filter: N
   ->  PartIterator (actual rows=N loops=N)
         ->  Seq Scan on tprt (actual rows=N loops=N)
   ->  Materialize (actual rows=N loops=N)
         ->  Seq Scan on tbl1 (actual rows=N loops=N)
(7 rows)

select explain_filter('explain (analyze, costs off, summary off, timing off, nodes off)
select * from tbl1 inner join tprt on tbl1.col1 = tprt.col1;');
                           explain_filter                            
---------------------------------------------------------------------
 Gather (actual rows=N loops=N)
   Workers Planned: N
   Workers Launched: N
   ->  Nested Loop (actual rows=N loops=N)
         Join Filter: (tbl1.col1 = tprt.col1)
         Rows Removed by Join Filter: N
         ->  Parallel PartIterator (actual rows=N loops=N)
               ->  Parallel Seq Scan on tprt (actual rows=N loops=N)
         ->  Materialize (actual rows=N loops=N)
               ->  Seq Scan on tbl1 (actual rows=N loops=N)
(10 rows)

select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 > tprt.col1
order by tbl1.col1, tprt.col1;
 col1 | col1 
------+------
  501 |   10
  501 |   20
  505 |   10
  505 |   20
  505 |  501
  505 |  502
 1001 |   10
 1001 |   20
 1001 |  501
 1001 |  502
 1001 |  505
 1010 |   10
 1010 |   20
 1010 |  501
 1010 |  502
 1010 |  505
 1010 | 1001
 1011 |   10
 1011 |   20
 1011 |  501
 1011 |  502
 1011 |  505
 1011 | 1001
(23 rows)

select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 = tprt.col1
order by tbl1.col1, tprt.col1;
 col1 | col1 
------+------
  501 |  501
  505 |  505
 1001 | 1001
(3 rows)

-- Last partition
delete from tbl1;
insert into tbl1 values (4400);
select explain_filter('explain (analyze, costs off, summary off, timing off, nodes off)
select * from tbl1 join tprt on tbl1.col1 < tprt.col1;');
                    explain_filter                    
------------------------------------------------------
 Nested Loop (actual rows=N loops=N)
   Join Filter: (tbl1.col1 < tprt.col1)
   Rows Removed by Join Filter: N
   ->  PartIterator (actual rows=N loops=N)
         ->  Seq Scan on tprt (actual rows=N loops=N)
   ->  Materialize (actual rows=N loops=N)
         ->  Seq Scan on tbl1 (actual rows=N loops=N)
(7 rows)

select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 < tprt.col1
order by tbl1.col1, tprt.col1;
 col1 | col1 
------+------
 4400 | 4500
(1 row)

-- No matching partition
delete from tbl1;
insert into tbl1 values (10000);
select explain_filter('explain (analyze, costs off, summary off, timing off, nodes off)
select * from tbl1 join tprt on tbl1.col1 = tprt.col1;');
                           explain_filter                            
---------------------------------------------------------------------
 Gather (actual rows=N loops=N)
   Workers Planned: N
   Workers Launched: N
   ->  Nested Loop (actual rows=N loops=N)
         Join Filter: (tbl1.col1 = tprt.col1)
         Rows Removed by Join Filter: N
         ->  Parallel PartIterator (actual rows=N loops=N)
               ->  Parallel Seq Scan on tprt (actual rows=N loops=N)
         ->  Materialize (actual rows=N loops=N)
               ->  Seq Scan on tbl1 (actual rows=N loops=N)
(10 rows)

select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 = tprt.col1
order by tbl1.col1, tprt.col1;
 col1 | col1 
------+------
(0 rows)

drop table tbl1, tprt;
-- Test with columns defined in varying orders between each level
create table part_abc (a int not null, b int not null, c int not null) partition by list (a);
create table part_bac (b int not null, a int not null, c int not null) partition by list (b);
create table part_cab (c int not null, a int not null, b int not null) partition by list (c);
create table part_abc_p1 (a int not null, b int not null, c int not null);
alter table part_abc attach partition part_bac for values in(1);
ERROR:  table "part_bac" contains column "a" at position 2, but parent "part_abc" has it at position 1
DETAIL:  Postgres-XL requires attribute positions to match
HINT:  Check for column ordering and dropped columns, if any
alter table part_bac attach partition part_cab for values in(2);
ERROR:  table "part_cab" contains column "b" at position 3, but parent "part_bac" has it at position 1
DETAIL:  Postgres-XL requires attribute positions to match
HINT:  Check for column ordering and dropped columns, if any
alter table part_cab attach partition part_abc_p1 for values in(3);
ERROR:  table "part_abc_p1" contains column "c" at position 3, but parent "part_cab" has it at position 1
DETAIL:  Postgres-XL requires attribute positions to match
HINT:  Check for column ordering and dropped columns, if any
prepare part_abc_q1 (int, int, int) as
select * from part_abc where a = $1 and b = $2 and c = $3;
-- Execute query 5 times to allow choose_custom_plan
-- to start considering a generic plan.
execute part_abc_q1 (1, 2, 3);
 a | b | c 
---+---+---
(0 rows)

execute part_abc_q1 (1, 2, 3);
 a | b | c 
---+---+---
(0 rows)

execute part_abc_q1 (1, 2, 3);
 a | b | c 
---+---+---
(0 rows)

execute part_abc_q1 (1, 2, 3);
 a | b | c 
---+---+---
(0 rows)

execute part_abc_q1 (1, 2, 3);
 a | b | c 
---+---+---
(0 rows)

-- Single partition should be scanned.
explain (analyze, costs off, summary off, timing off, nodes off) execute part_abc_q1 (1, 2, 3);
           QUERY PLAN           
--------------------------------
 Result (actual rows=0 loops=1)
   One-Time Filter: false
(2 rows)

deallocate part_abc_q1;
drop table part_abc;
-- Ensure that an Append node properly handles a sub-partitioned table
-- matching without any of its leaf partitions matching the clause.
create table listp (a int, b int) partition by list (a);
create table listp_1 partition of listp for values in(1) partition by list (b);
create table listp_1_1 partition of listp_1 for values in(1);
create table listp_2 partition of listp for values in(2) partition by list (b);
create table listp_2_1 partition of listp_2 for values in(2);
select * from listp where b = 1;
 a | b 
---+---
(0 rows)

-- Ensure that an Append node properly can handle selection of all first level
-- partitions before finally detecting the correct set of 2nd level partitions
-- which match the given parameter.
prepare q1 (int,int) as select * from listp where b in ($1,$2);
execute q1 (1,2);
 a | b 
---+---
(0 rows)

execute q1 (1,2);
 a | b 
---+---
(0 rows)

execute q1 (1,2);
 a | b 
---+---
(0 rows)

execute q1 (1,2);
 a | b 
---+---
(0 rows)

execute q1 (1,2);
 a | b 
---+---
(0 rows)

explain (analyze, costs off, summary off, timing off, nodes off)  execute q1 (1,1);
                   QUERY PLAN                    
-------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   ->  Seq Scan on listp (actual rows=0 loops=1)
         Filter: (b = ANY (ARRAY[$1, $2]))
(3 rows)

explain (analyze, costs off, summary off, timing off, nodes off)  execute q1 (2,2);
                   QUERY PLAN                    
-------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   ->  Seq Scan on listp (actual rows=0 loops=1)
         Filter: (b = ANY (ARRAY[$1, $2]))
(3 rows)

-- Try with no matching partitions. One subplan should remain in this case,
-- but it shouldn't be executed.
explain (analyze, costs off, summary off, timing off, nodes off)  execute q1 (0,0);
                QUERY PLAN                 
-------------------------------------------
 PartIterator (actual rows=0 loops=1)
   ->  Seq Scan on listp (never executed)
         Filter: (b = ANY (ARRAY[$1, $2]))
(3 rows)

deallocate q1;
-- Test more complex cases where a not-equal condition further eliminates partitions.
prepare q1 (int,int,int,int) as select * from listp where b in($1,$2) and $3 <> b and $4 <> b;
execute q1 (1,2,3,4);
 a | b 
---+---
(0 rows)

execute q1 (1,2,3,4);
 a | b 
---+---
(0 rows)

execute q1 (1,2,3,4);
 a | b 
---+---
(0 rows)

execute q1 (1,2,3,4);
 a | b 
---+---
(0 rows)

execute q1 (1,2,3,4);
 a | b 
---+---
(0 rows)

-- Both partitions allowed by IN clause, but one disallowed by <> clause
explain (analyze, costs off, summary off, timing off, nodes off)  execute q1 (1,2,2,0);
                               QUERY PLAN                                
-------------------------------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   ->  Seq Scan on listp (actual rows=0 loops=1)
         Filter: ((b = ANY (ARRAY[$1, $2])) AND ($3 <> b) AND ($4 <> b))
(3 rows)

-- Both partitions allowed by IN clause, then both excluded again by <> clauses.
-- One subplan will remain in this case, but it should not be executed.
explain (analyze, costs off, summary off, timing off, nodes off)  execute q1 (1,2,2,1);
                               QUERY PLAN                                
-------------------------------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   ->  Seq Scan on listp (never executed)
         Filter: ((b = ANY (ARRAY[$1, $2])) AND ($3 <> b) AND ($4 <> b))
(3 rows)

-- Ensure Params that evaluate to NULL properly prune away all partitions
explain (analyze, costs off, summary off, timing off)
select * from listp where a = (select null::int);
                   QUERY PLAN                    
-------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   InitPlan 1 (returns $0)
     ->  Result (never executed)
   ->  Seq Scan on listp (actual rows=0 loops=2)
         Filter: (a = $0)
(5 rows)

drop table listp;
--
-- Check that pruning with composite range partitioning works correctly when
-- it must ignore clauses for trailing keys once it has seen a clause with
-- non-inclusive operator for an earlier key
--
create table mc3p (a int, b int, c int) partition by range (a, abs(b), c);
create table mc3p0 partition of mc3p
  for values from (0, 0, 0) to (0, maxvalue, maxvalue);
create table mc3p1 partition of mc3p
  for values from (1, 1, 1) to (2, minvalue, minvalue);
create table mc3p2 partition of mc3p
  for values from (2, minvalue, minvalue) to (3, maxvalue, maxvalue);
insert into mc3p values (0, 1, 1), (1, 1, 1), (2, 1, 1);
explain (analyze, costs off, summary off, timing off)
select * from mc3p where a < 3 and abs(b) = 1;
                   QUERY PLAN                   
------------------------------------------------
 PartIterator (actual rows=3 loops=1)
   ->  Seq Scan on mc3p (actual rows=1 loops=3)
         Filter: ((a < 3) AND (abs(b) = 1))
(3 rows)

drop table mc3p;
-- Ensure runtime pruning works with initplans params with boolean types
create table boolvalues (value bool not null);
insert into boolvalues values('t'),('f');
create table boolp (a bool) partition by list (a);
create table boolp_t partition of boolp for values in('t');
create table boolp_f partition of boolp for values in('f');
explain (analyze, costs off, summary off, timing off, nodes off)
select * from boolp where a = (select value from boolvalues where value);
                   QUERY PLAN                    
-------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   InitPlan 1 (returns $0)
     ->  Seq Scan on boolvalues (never executed)
           Filter: value
   ->  Seq Scan on boolp (actual rows=0 loops=2)
         Filter: (a = $0)
(6 rows)

explain (analyze, costs off, summary off, timing off, nodes off)
select * from boolp where a = (select value from boolvalues where not value);
                   QUERY PLAN                    
-------------------------------------------------
 PartIterator (actual rows=0 loops=1)
   InitPlan 1 (returns $0)
     ->  Seq Scan on boolvalues (never executed)
           Filter: (NOT value)
   ->  Seq Scan on boolp (actual rows=0 loops=2)
         Filter: (a = $0)
(6 rows)

drop table boolp;
reset enable_fast_query_shipping;
--
-- check that pruning works properly when the partition key is of a
-- pseudotype
--
-- array type list partition key
create table pp_arrpart (a int[]) partition by list (a);
create table pp_arrpart1 partition of pp_arrpart for values in ('{1}');
create table pp_arrpart2 partition of pp_arrpart for values in ('{2, 3}', '{4, 5}');
explain (costs off, nodes off) select * from pp_arrpart where a = '{1}';
               QUERY PLAN               
----------------------------------------
 PartIterator
   ->  Seq Scan on pp_arrpart
         Filter: (a = '{1}'::integer[])
(3 rows)

explain (costs off, nodes off) select * from pp_arrpart where a = '{1, 2}';
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

explain (costs off, nodes off) select * from pp_arrpart where a in ('{4, 5}', '{1}');
                              QUERY PLAN                              
----------------------------------------------------------------------
 PartIterator
   ->  Seq Scan on pp_arrpart
         Filter: ((a = '{4,5}'::integer[]) OR (a = '{1}'::integer[]))
(3 rows)

drop table pp_arrpart;
-- array type hash partition key
create table pph_arrpart (a int[]) partition by hash (a);
create table pph_arrpart1 partition of pph_arrpart for values with (modulus 2, remainder 0);
create table pph_arrpart2 partition of pph_arrpart for values with (modulus 2, remainder 1);
insert into pph_arrpart values ('{1}'), ('{1, 2}'), ('{4, 5}');
select tableoid::regclass, * from pph_arrpart order by 1;
   tableoid   |   a   
--------------+-------
 pph_arrpart1 | {1,2}
 pph_arrpart1 | {4,5}
 pph_arrpart2 | {1}
(3 rows)

explain (costs off, nodes off) select * from pph_arrpart where a = '{1}';
               QUERY PLAN               
----------------------------------------
 PartIterator
   ->  Seq Scan on pph_arrpart
         Filter: (a = '{1}'::integer[])
(3 rows)

explain (costs off, nodes off) select * from pph_arrpart where a = '{1, 2}';
                QUERY PLAN                
------------------------------------------
 PartIterator
   ->  Seq Scan on pph_arrpart
         Filter: (a = '{1,2}'::integer[])
(3 rows)

explain (costs off, nodes off) select * from pph_arrpart where a in ('{4, 5}', '{1}');
                              QUERY PLAN                              
----------------------------------------------------------------------
 PartIterator
   ->  Seq Scan on pph_arrpart
         Filter: ((a = '{4,5}'::integer[]) OR (a = '{1}'::integer[]))
(3 rows)

drop table pph_arrpart;
-- enum type list partition key
create type pp_colors as enum ('green', 'blue', 'black');
create table pp_enumpart (a pp_colors) partition by list (a);
create table pp_enumpart_green partition of pp_enumpart for values in ('green');
create table pp_enumpart_blue partition of pp_enumpart for values in ('blue');
explain (costs off, nodes off) select * from pp_enumpart where a = 'blue';
               QUERY PLAN                
-----------------------------------------
 PartIterator
   ->  Seq Scan on pp_enumpart
         Filter: (a = 'blue'::pp_colors)
(3 rows)

explain (costs off, nodes off) select * from pp_enumpart where a = 'black';
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

drop table pp_enumpart;
drop type pp_colors;
-- record type as partition key
create type pp_rectype as (a int, b int);
create table pp_recpart (a pp_rectype) partition by list (a);
create table pp_recpart_11 partition of pp_recpart for values in ('(1,1)');
create table pp_recpart_23 partition of pp_recpart for values in ('(2,3)');
explain (costs off, nodes off) select * from pp_recpart where a = '(1,1)'::pp_rectype;
                QUERY PLAN                 
-------------------------------------------
 PartIterator
   ->  Seq Scan on pp_recpart
         Filter: (a = '(1,1)'::pp_rectype)
(3 rows)

explain (costs off, nodes off) select * from pp_recpart where a = '(1,2)'::pp_rectype;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

drop table pp_recpart;
drop type pp_rectype;
-- range type partition key
create table pp_intrangepart (a int4range) partition by list (a);
create table pp_intrangepart12 partition of pp_intrangepart for values in ('[1,2]');
create table pp_intrangepart2inf partition of pp_intrangepart for values in ('[2,)');
explain (costs off, nodes off) select * from pp_intrangepart where a = '[1,2]'::int4range;
                QUERY PLAN                
------------------------------------------
 PartIterator
   ->  Seq Scan on pp_intrangepart
         Filter: (a = '[1,3)'::int4range)
(3 rows)

explain (costs off, nodes off) select * from pp_intrangepart where a = '(1,2)'::int4range;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

drop table pp_intrangepart;
--
-- Ensure the enable_partition_prune GUC properly disables partition pruning.
--
create table pp_lp (a int, value int) partition by list (a);
create table pp_lp1 partition of pp_lp for values in(1);
create table pp_lp2 partition of pp_lp for values in(2);
explain (costs off, verbose on) select * from pp_lp where a = 1;
              QUERY PLAN               
---------------------------------------
 PartIterator
   Output: pp_lp.a, pp_lp.value
   ->  Seq Scan on public.pp_lp
         Part Iterator:  public.pp_lp1
         Output: pp_lp.a, pp_lp.value
         Filter: (pp_lp.a = 1)
(6 rows)

explain (costs off, verbose on) update pp_lp set value = 10 where a = 1;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Update on public.pp_lp
   Update on public.pp_lp1 pp_lp
   ->  PartIterator
         Output: 10, pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
         ->  Seq Scan on public.pp_lp
               Part Iterator:  public.pp_lp1
               Output: 10, pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
               Filter: (pp_lp.a = 1)
(8 rows)

explain (costs off, verbose on) delete from pp_lp where a = 1;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Delete on public.pp_lp
   Delete on public.pp_lp1 pp_lp
   ->  PartIterator
         Output: pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
         ->  Seq Scan on public.pp_lp
               Part Iterator:  public.pp_lp1
               Output: pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
               Filter: (pp_lp.a = 1)
(8 rows)

set enable_partition_pruning = off;
set constraint_exclusion = 'partition'; -- this should not affect the result.
explain (costs off, verbose on) select * from pp_lp where a = 1;
                      QUERY PLAN                      
------------------------------------------------------
 PartIterator
   Output: pp_lp.a, pp_lp.value
   ->  Seq Scan on public.pp_lp
         Part Iterator:  public.pp_lp1  public.pp_lp2
         Output: pp_lp.a, pp_lp.value
         Filter: (pp_lp.a = 1)
(6 rows)

explain (costs off, verbose on) update pp_lp set value = 10 where a = 1;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Update on public.pp_lp
   Update on public.pp_lp1 pp_lp
   Update on public.pp_lp2 pp_lp
   ->  PartIterator
         Output: 10, pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
         ->  Seq Scan on public.pp_lp
               Part Iterator:  public.pp_lp1  public.pp_lp2
               Output: 10, pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
               Filter: (pp_lp.a = 1)
(9 rows)

explain (costs off, verbose on) delete from pp_lp where a = 1;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Delete on public.pp_lp
   Delete on public.pp_lp1 pp_lp
   Delete on public.pp_lp2 pp_lp
   ->  PartIterator
         Output: pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
         ->  Seq Scan on public.pp_lp
               Part Iterator:  public.pp_lp1  public.pp_lp2
               Output: pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
               Filter: (pp_lp.a = 1)
(9 rows)

set constraint_exclusion = 'off'; -- this should not affect the result.
explain (costs off, verbose on) select * from pp_lp where a = 1;
                      QUERY PLAN                      
------------------------------------------------------
 PartIterator
   Output: pp_lp.a, pp_lp.value
   ->  Seq Scan on public.pp_lp
         Part Iterator:  public.pp_lp1  public.pp_lp2
         Output: pp_lp.a, pp_lp.value
         Filter: (pp_lp.a = 1)
(6 rows)

explain (costs off, verbose on) update pp_lp set value = 10 where a = 1;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Update on public.pp_lp
   Update on public.pp_lp1 pp_lp
   Update on public.pp_lp2 pp_lp
   ->  PartIterator
         Output: 10, pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
         ->  Seq Scan on public.pp_lp
               Part Iterator:  public.pp_lp1  public.pp_lp2
               Output: 10, pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
               Filter: (pp_lp.a = 1)
(9 rows)

explain (costs off, verbose on) delete from pp_lp where a = 1;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Delete on public.pp_lp
   Delete on public.pp_lp1 pp_lp
   Delete on public.pp_lp2 pp_lp
   ->  PartIterator
         Output: pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
         ->  Seq Scan on public.pp_lp
               Part Iterator:  public.pp_lp1  public.pp_lp2
               Output: pp_lp.tableoid, pp_lp.shardid, pp_lp.ctid
               Filter: (pp_lp.a = 1)
(9 rows)

drop table pp_lp;
-- Ensure enable_partition_prune does not affect non-partitioned tables.
create table inh_lp (a int, value int);
create table inh_lp1 (a int, value int, check(a = 1)) inherits (inh_lp);
NOTICE:  merging column "a" with inherited definition
NOTICE:  merging column "value" with inherited definition
create table inh_lp2 (a int, value int, check(a = 2)) inherits (inh_lp);
NOTICE:  merging column "a" with inherited definition
NOTICE:  merging column "value" with inherited definition
set constraint_exclusion = 'partition';
-- inh_lp2 should be removed in the following 3 cases.
explain (costs off, verbose on) select * from inh_lp where a = 1;
                QUERY PLAN                
------------------------------------------
 Append
   ->  Seq Scan on public.inh_lp
         Output: inh_lp.a, inh_lp.value
         Filter: (inh_lp.a = 1)
   ->  Seq Scan on public.inh_lp1
         Output: inh_lp1.a, inh_lp1.value
         Filter: (inh_lp1.a = 1)
(7 rows)

explain (costs off, verbose on) update inh_lp set value = 10 where a = 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Update on public.inh_lp
   Update on public.inh_lp inh_lp_1
   Update on public.inh_lp1
   ->  Result
         Output: 10, inh_lp_1.tableoid, inh_lp_1.shardid, inh_lp_1.ctid
         ->  Append
               ->  Seq Scan on public.inh_lp inh_lp_1
                     Output: inh_lp_1.tableoid, inh_lp_1.shardid, inh_lp_1.ctid
                     Filter: (inh_lp_1.a = 1)
               ->  Seq Scan on public.inh_lp1
                     Output: inh_lp1.tableoid, inh_lp1.shardid, inh_lp1.ctid
                     Filter: (inh_lp1.a = 1)
(12 rows)

explain (costs off, verbose on) delete from inh_lp where a = 1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Delete on public.inh_lp
   Delete on public.inh_lp inh_lp_1
   Delete on public.inh_lp1
   ->  Append
         ->  Seq Scan on public.inh_lp inh_lp_1
               Output: inh_lp_1.tableoid, inh_lp_1.shardid, inh_lp_1.ctid
               Filter: (inh_lp_1.a = 1)
         ->  Seq Scan on public.inh_lp1
               Output: inh_lp1.tableoid, inh_lp1.shardid, inh_lp1.ctid
               Filter: (inh_lp1.a = 1)
(10 rows)

-- Ensure we don't exclude normal relations when we only expect to exclude
-- inheritance children
explain (costs off, verbose on) update inh_lp1 set value = 10 where a = 2;
            QUERY PLAN             
-----------------------------------
 Update on public.inh_lp1
   ->  Seq Scan on public.inh_lp1
         Output: 10, shardid, ctid
         Filter: (inh_lp1.a = 2)
(4 rows)

\set VERBOSITY terse	\\ -- suppress cascade details
drop table inh_lp cascade;
NOTICE:  drop cascades to 2 other objects
\set VERBOSITY default
reset enable_partition_pruning;
reset constraint_exclusion;
-- Check pruning for a partition tree containing only temporary relations
create temp table pp_temp_parent (a int) partition by list (a);
create temp table pp_temp_part_1 partition of pp_temp_parent for values in (1);
create temp table pp_temp_part_def partition of pp_temp_parent default;
explain (costs off) select * from pp_temp_parent where true;
            QUERY PLAN            
----------------------------------
 PartIterator
   ->  Seq Scan on pp_temp_parent
(2 rows)

explain (costs off) select * from pp_temp_parent where a = 2;
            QUERY PLAN            
----------------------------------
 PartIterator
   ->  Seq Scan on pp_temp_parent
         Filter: (a = 2)
(3 rows)

drop table pp_temp_parent;
-- Stress run-time partition pruning a bit more, per bug reports
create temp table p (a int, b int, c int) partition by list (a);
create temp table p1 partition of p for values in (1);
create temp table p2 partition of p for values in (2);
create temp table q (a int, b int, c int) partition by list (a);
create temp table q1 partition of q for values in (1) partition by list (b);
create temp table q11 partition of q1 for values in (1) partition by list (c);
create temp table q111 partition of q11 for values in (1);
create temp table q2 partition of q for values in (2) partition by list (b);
create temp table q21 partition of q2 for values in (1);
create temp table q22 partition of q2 for values in (2);
insert into q22 values (2, 2, 3);
explain (costs off)
select *
from (
      select * from p
      union all
      select * from q1
      union all
      select 1, 1, 1
     ) s(a, b, c)
where s.a = 1 and s.b = 1 and s.c = (select 1);
                        QUERY PLAN                        
----------------------------------------------------------
 Append
   InitPlan 1 (returns $0)
     ->  Result
   ->  PartIterator
         ->  Seq Scan on p
               Filter: ((a = 1) AND (b = 1) AND (c = $0))
   ->  PartIterator
         ->  Seq Scan on q1
               Filter: ((a = 1) AND (b = 1) AND (c = $0))
   ->  Result
         One-Time Filter: (1 = $0)
(11 rows)

select *
from (
      select * from p
      union all
      select * from q1
      union all
      select 1, 1, 1
     ) s(a, b, c)
where s.a = 1 and s.b = 1 and s.c = (select 1);
 a | b | c 
---+---+---
 1 | 1 | 1
(1 row)

prepare q (int, int) as
select *
from (
      select * from p
      union all
      select * from q1
      union all
      select 1, 1, 1
     ) s(a, b, c)
where s.a = $1 and s.b = $2 and s.c = (select 1);
explain (costs off) execute q (1, 1);
                        QUERY PLAN                        
----------------------------------------------------------
 Append
   InitPlan 1 (returns $0)
     ->  Result
   ->  PartIterator
         ->  Seq Scan on p
               Filter: ((a = 1) AND (b = 1) AND (c = $0))
   ->  PartIterator
         ->  Seq Scan on q1
               Filter: ((a = 1) AND (b = 1) AND (c = $0))
   ->  Result
         One-Time Filter: (1 = $0)
(11 rows)

execute q (1, 1);
 a | b | c 
---+---+---
 1 | 1 | 1
(1 row)

drop table p, q;
-- Ensure run-time pruning works correctly when we match a partitioned table
-- on the first level but find no matching partitions on the second level.
create table listp (a int, b int) partition by list (a);
create table listp1 partition of listp for values in(1);
create table listp2 partition of listp for values in(2) partition by list(b);
create table listp2_10 partition of listp2 for values in (10);
explain (costs off, summary off, timing off)
select * from listp where a = (select 2) and b <> 10;
                QUERY PLAN                
------------------------------------------
 PartIterator
   InitPlan 1 (returns $0)
     ->  Result
   ->  Seq Scan on listp
         Filter: ((b <> 10) AND (a = $0))
(5 rows)

select * from listp where a = (select 2) and b <> 10;
 a | b 
---+---
(0 rows)

--
-- check that a partition directly accessed in a query is excluded with
-- constraint_exclusion = on
--
-- turn off partition pruning, so that it doesn't interfere
set enable_partition_pruning to off;
-- setting constraint_exclusion to 'partition' disables exclusion
set constraint_exclusion to 'partition';
explain (costs off, verbose on) select * from listp1 where a = 2;
        QUERY PLAN         
---------------------------
 Seq Scan on public.listp1
   Output: a, b
   Filter: (listp1.a = 2)
(3 rows)

explain (costs off, verbose on) update listp1 set a = 1 where a = 2;
            QUERY PLAN            
----------------------------------
 Update on public.listp1
   ->  Seq Scan on public.listp1
         Output: 1, shardid, ctid
         Filter: (listp1.a = 2)
(4 rows)

-- constraint exclusion enabled
set constraint_exclusion to 'on';
explain (costs off, verbose on) select * from listp1 where a = 2;
        QUERY PLAN        
--------------------------
 Result
   Output: a, b
   One-Time Filter: false
(3 rows)

explain (costs off, verbose on) update listp1 set a = 1 where a = 2;
            QUERY PLAN            
----------------------------------
 Update on public.listp1
   ->  Result
         Output: 1, shardid, ctid
         One-Time Filter: false
(4 rows)

reset constraint_exclusion;
reset enable_partition_pruning;
drop table listp;
-- support multi partition tables
create table T_TA_CONFIRM
(
  busi_date            varchar(8),
  custno               numeric(10),
  d_cdate              varchar(8)
) partition by range (d_cdate) 
;
create table P_TACONFIRM_2006 partition of T_TA_CONFIRM for values from ('20000101') to ('20070101');
create table T_LOF_CONFIRM
(
  busi_date            varchar(8),
  custno               numeric(10),
  d_cdate              varchar(8)
) partition by range (d_cdate) 
;
create table P_LOFCONFIRM_2014 partition of T_LOF_CONFIRM for values from ('20010101') to ('20150101');
create table T_LOF_CONFIRM1
(
  busi_date            varchar(8),
  custno               numeric(10),
  d_cdate              varchar(8)
) 
;
create or replace view v_dc_confirm
as
select * from t_ta_confirm a
union all
select * from t_lof_confirm b
union all
select * from t_lof_confirm1 c;
select * from v_dc_confirm where custno=123;
 busi_date | custno | d_cdate 
-----------+--------+---------
(0 rows)

select * from (
    select * from t_ta_confirm a
    union all
    select * from t_lof_confirm b
    union all
    select * from t_lof_confirm1 c
) a where a.custno=123;
 busi_date | custno | d_cdate 
-----------+--------+---------
(0 rows)

drop table T_TA_CONFIRM cascade;
NOTICE:  drop cascades to view v_dc_confirm
drop table T_LOF_CONFIRM cascade;
drop table T_LOF_CONFIRM1 cascade;
-- Partition table union to fix the plan distribution error
drop table if exists t_ab, t_cd;
NOTICE:  table "t_ab" does not exist, skipping
NOTICE:  table "t_cd" does not exist, skipping
create table t_cd (a int not null, b int not null) partition by list (a);
create table t_cd_a2 partition of t_cd for values in(2) partition by list (b);
create table t_cd_a2_b1 partition of t_cd_a2 for values in (1);
create table t_cd_a2_b2 partition of t_cd_a2 for values in (2);
create table t_cd_a2_b3 partition of t_cd_a2 for values in (3);
create table t_cd_a1 partition of t_cd for values in(1) partition by list (b);
create table t_cd_a1_b1 partition of t_cd_a1 for values in (1);
create table t_cd_a1_b2 partition of t_cd_a1 for values in (2);
create table t_cd_a1_b3 partition of t_cd_a1 for values in (3);
create table t_cd_a3 partition of t_cd for values in(3) partition by list (b);
create table t_cd_a3_b1 partition of t_cd_a3 for values in (1);
create table t_cd_a3_b2 partition of t_cd_a3 for values in (2);
create table t_cd_a3_b3 partition of t_cd_a3 for values in (3);
insert into t_cd values (1, 1), (1, 2), (1, 3), (2, 1), (3,1);
create table t_ab (a int not null, b int not null) partition by list (a);
create table t_ab_a2 partition of t_ab for values in(2) partition by list (b);
create table t_ab_a2_b1 partition of t_ab_a2 for values in (1);
create table t_ab_a2_b2 partition of t_ab_a2 for values in (2);
create table t_ab_a2_b3 partition of t_ab_a2 for values in (3);
create table t_ab_a1 partition of t_ab for values in(1) partition by list (b);
create table t_ab_a1_b1 partition of t_ab_a1 for values in (1);
create table t_ab_a1_b2 partition of t_ab_a1 for values in (2);
create table t_ab_a1_b3 partition of t_ab_a1 for values in (3);
create table t_ab_a3 partition of t_ab for values in(3) partition by list (b);
create table t_ab_a3_b1 partition of t_ab_a3 for values in (1);
create table t_ab_a3_b2 partition of t_ab_a3 for values in (2);
create table t_ab_a3_b3 partition of t_ab_a3 for values in (3);
insert into t_ab values (1, 1), (1, 2), (1, 3), (2, 1), (3,1);
explain (costs off) 
select * from t_ab where a = 1  union all select * from t_cd;
          QUERY PLAN           
-------------------------------
 Append
   ->  PartIterator
         ->  Seq Scan on t_ab
               Filter: (a = 1)
   ->  PartIterator
         ->  Seq Scan on t_cd
(6 rows)

select * from t_ab where a = 1  union all select * from t_cd order by 1,2;
 a | b 
---+---
 1 | 1
 1 | 1
 1 | 2
 1 | 2
 1 | 3
 1 | 3
 2 | 1
 3 | 1
(8 rows)

explain (costs off) 
select * from t_cd union all select * from t_ab where a = 1;
          QUERY PLAN           
-------------------------------
 Append
   ->  PartIterator
         ->  Seq Scan on t_cd
   ->  PartIterator
         ->  Seq Scan on t_ab
               Filter: (a = 1)
(6 rows)

select * from t_cd union all select * from t_ab where a = 1 order by 1,2;
 a | b 
---+---
 1 | 1
 1 | 1
 1 | 2
 1 | 2
 1 | 3
 1 | 3
 2 | 1
 3 | 1
(8 rows)

drop table t_ab, t_cd;
-- OPENTENBASE
-- Improve run-time partition pruning to handle any stable expression.
drop table if exists part_range_t2 cascade;
NOTICE:  table "part_range_t2" does not exist, skipping
create table public.part_range_t2                                                                                   
(
f1 int not null,
f2 date not null default now(),
f3 varchar(50),
f4 integer) 
partition by range (f2);
--
create table part_range_t2_part_0 partition of public.part_range_t2 for values from ('2020-06-01') to ('2020-07-01');
create table part_range_t2_part_1 partition of part_range_t2 for values from ('2020-07-01') to ('2020-08-01');
create table part_range_t2_part_2 partition of part_range_t2 for values from ('2020-08-01') to ('2020-09-01');
insert into part_range_t2(f1,f2,f3,f4) values(1,'2020-06-01','one',2);
insert into part_range_t2(f1,f2,f3,f4) values(2,'2020-07-01','two',3);
insert into part_range_t2(f1,f2,f3,f4) values(3,'2020-08-01','three',4);
insert into part_range_t2(f1,f2,f3,f4) values(4,'2020-08-21','four',4);
explain(costs off, summary off, timing off, nodes off)
select * from part_range_t2 where f2 > to_date('2020-07-02','yyyy-mm-dd')+1 and f2 < to_date('2020-07-28','yyyy-mm-dd');
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   ->  Seq Scan on part_range_t2
         Filter: ((f2 < to_date('2020-07-28'::text, 'yyyy-mm-dd'::text)) AND (f2 > (to_date('2020-07-02'::text, 'yyyy-mm-dd'::text) + 1)))
(3 rows)

select * from part_range_t2 where f2 > to_date('2020-07-02','yyyy-mm-dd')+1 and f2 < to_date('2020-07-28','yyyy-mm-dd');
 f1 | f2 | f3 | f4 
----+----+----+----
(0 rows)

explain(costs off, summary off, timing off, nodes off)
select * from part_range_t2 where f2 > to_date('2020-08-02','yyyy-mm-dd')+1 and f2 < to_date('2020-09-28','yyyy-mm-dd');
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 PartIterator
   ->  Seq Scan on part_range_t2
         Filter: ((f2 < to_date('2020-09-28'::text, 'yyyy-mm-dd'::text)) AND (f2 > (to_date('2020-08-02'::text, 'yyyy-mm-dd'::text) + 1)))
(3 rows)

select * from part_range_t2 where f2 > to_date('2020-08-02','yyyy-mm-dd')+1 and f2 < to_date('2020-09-28','yyyy-mm-dd');
 f1 |     f2     |  f3  | f4 
----+------------+------+----
  4 | 2020-08-21 | four |  4
(1 row)

drop table part_range_t2 cascade;
-- Parttion table with null array
drop table if exists t_stable_qual_pruning_20221219 cascade;
NOTICE:  table "t_stable_qual_pruning_20221219" does not exist, skipping
create table t_stable_qual_pruning_20221219 (a int, b varchar(20)) partition by range (a);
create table t_stable_qual_pruning_20221219_1 partition of t_stable_qual_pruning_20221219
 for values from (1) to (10);
create table t_stable_qual_pruning_20221219_2 partition of t_stable_qual_pruning_20221219
 for values from (11) to (20);
create table t_stable_qual_pruning_20221219_3 partition of t_stable_qual_pruning_20221219
 for values from (21) to (30);
insert into t_stable_qual_pruning_20221219 values(2,'part1');
insert into t_stable_qual_pruning_20221219 values(12,'part2');
insert into t_stable_qual_pruning_20221219 values(22,'part3');
select * from t_stable_qual_pruning_20221219 where a = any(null::int[]);
 a | b 
---+---
(0 rows)

select * from t_stable_qual_pruning_20221219 where a = some(null::int[]);
 a | b 
---+---
(0 rows)

select * from t_stable_qual_pruning_20221219 where a = some(null::int[]) or b='part2';
 a  |   b   
----+-------
 12 | part2
(1 row)

select * from t_stable_qual_pruning_20221219 where a = some('{1,2,3}'::int[]);
 a |   b   
---+-------
 2 | part1
(1 row)

drop table t_stable_qual_pruning_20221219;
