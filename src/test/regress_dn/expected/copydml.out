--
-- Test cases for COPY (INSERT/UPDATE/DELETE) TO
--
create table copydml_test (id serial, t text);
insert into copydml_test (t) values ('a');
insert into copydml_test (t) values ('b');
insert into copydml_test (t) values ('c');
insert into copydml_test (t) values ('d');
insert into copydml_test (t) values ('e');
--
-- Test COPY (insert/update/delete ...)
--
copy (insert into copydml_test (t) values ('f') returning id) to stdout;
6
copy (update copydml_test set t = 'g' where t = 'f' returning id) to stdout;
6
copy (delete from copydml_test where t = 'g' returning id) to stdout;
6
--
-- Test \copy (insert/update/delete ...)
--
\copy (insert into copydml_test (t) values ('f') returning id) to stdout;
7
\copy (update copydml_test set t = 'g' where t = 'f' returning id) to stdout;
7
\copy (delete from copydml_test where t = 'g' returning id) to stdout;
7
-- Error cases
copy (insert into copydml_test default values) to stdout;
ERROR:  COPY query must have a RETURNING clause
copy (update copydml_test set t = 'g') to stdout;
ERROR:  COPY query must have a RETURNING clause
copy (delete from copydml_test) to stdout;
ERROR:  COPY query must have a RETURNING clause
create rule qqq as on insert to copydml_test do instead nothing;
copy (insert into copydml_test default values) to stdout;
ERROR:  DO INSTEAD NOTHING rules are not supported for COPY
drop rule qqq on copydml_test;
create rule qqq as on insert to copydml_test do also delete from copydml_test;
copy (insert into copydml_test default values) to stdout;
ERROR:  DO ALSO rules are not supported for the COPY
drop rule qqq on copydml_test;
create rule qqq as on insert to copydml_test do instead (delete from copydml_test; delete from copydml_test);
copy (insert into copydml_test default values) to stdout;
ERROR:  multi-statement DO INSTEAD rules are not supported for COPY
drop rule qqq on copydml_test;
create rule qqq as on insert to copydml_test where new.t <> 'f' do instead delete from copydml_test;
copy (insert into copydml_test default values) to stdout;
ERROR:  conditional DO INSTEAD rules are not supported for COPY
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test do instead nothing;
copy (update copydml_test set t = 'f') to stdout;
ERROR:  DO INSTEAD NOTHING rules are not supported for COPY
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test do also delete from copydml_test;
copy (update copydml_test set t = 'f') to stdout;
ERROR:  DO ALSO rules are not supported for the COPY
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test do instead (delete from copydml_test; delete from copydml_test);
copy (update copydml_test set t = 'f') to stdout;
ERROR:  multi-statement DO INSTEAD rules are not supported for COPY
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test where new.t <> 'f' do instead delete from copydml_test;
copy (update copydml_test set t = 'f') to stdout;
ERROR:  conditional DO INSTEAD rules are not supported for COPY
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test do instead nothing;
copy (delete from copydml_test) to stdout;
ERROR:  DO INSTEAD NOTHING rules are not supported for COPY
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test do also insert into copydml_test default values;
copy (delete from copydml_test) to stdout;
ERROR:  DO ALSO rules are not supported for the COPY
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test do instead (insert into copydml_test default values; insert into copydml_test default values);
copy (delete from copydml_test) to stdout;
ERROR:  multi-statement DO INSTEAD rules are not supported for COPY
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test where old.t <> 'f' do instead insert into copydml_test default values;
copy (delete from copydml_test) to stdout;
ERROR:  conditional DO INSTEAD rules are not supported for COPY
drop rule qqq on copydml_test;
-- triggers
create function qqq_trig() returns trigger as $$
begin
if tg_op in ('INSERT', 'UPDATE') then
    raise notice '% %', tg_op, new.id;
    return new;
else
    raise notice '% %', tg_op, old.id;
    return old;
end if;
end
$$ language plpgsql;
create trigger qqqbef before insert or update or delete on copydml_test
    for each row execute procedure qqq_trig();
ERROR:  Postgres-XL does not support TRIGGER yet
DETAIL:  The feature is not currently supported
create trigger qqqaf after insert or update or delete on copydml_test
    for each row execute procedure qqq_trig();
ERROR:  Postgres-XL does not support TRIGGER yet
DETAIL:  The feature is not currently supported
copy (insert into copydml_test (t) values ('f') returning id) to stdout;
8
copy (update copydml_test set t = 'g' where t = 'f' returning id) to stdout;
8
copy (delete from copydml_test where t = 'g' returning id) to stdout;
8
drop table copydml_test;
drop function qqq_trig();
\c regression_ora
set transform_insert_to_copy TO on;
drop table if exists t_insert_success;
NOTICE:  table "T_INSERT_SUCCESS" does not exist, skipping
CREATE TABLE t_insert_success (
    col1 integer,
    col2 integer,
    col3 varchar2(3),
    col4 int,
    col5 date
) distribute by shard(col1);
delete from t_insert_success;
prepare p1_3(int)  as insert into t_insert_success  values(1,2,'a',1,'2011-01-01'),(2,2,2,3,'2020-11-01'),(3,3,3,3,'2022-11-01') ;
execute p1_3(1);
select * from t_insert_success order by 1,2,3,4,5;
 COL1 | COL2 | COL3 | COL4 |    COL5    
------+------+------+------+------------
    1 |    2 | a    |    1 | 01-01-2011
    2 |    2 | 2    |    3 | 11-01-2020
    3 |    3 | 3    |    3 | 11-01-2022
(3 rows)

select count(*) from t_insert_success;
 COUNT 
-------
     3
(1 row)

drop table if exists t_insert_success;
reset transform_insert_to_copy;
